<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>C语言自制编译器 | Fu Jinlong's Blog</title><meta name="author" content="ICEFJL"><meta name="copyright" content="ICEFJL"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="来源低レイヤを知りたい人のためのCコンパイラ作成入門 (sigbus.info) 介绍这本书的内容太多了，无法包含在一本书中。在本书中，我们将创建一个将 C 语言编写的源代码转换为汇编语言的程序，即 C 编译器。编译器本身也是使用 C 开发的。直接目标是能够自托管，即使用自制编译器编译自己的源代码。 在本书中，我决定在整本书中以渐进的方式解释各个主题，以免使编译器的解释变得过于困难。原因如下： 编">
<meta property="og:type" content="article">
<meta property="og:title" content="C语言自制编译器">
<meta property="og:url" content="http://icefjl.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/C%E8%AF%AD%E8%A8%80%E8%87%AA%E5%88%B6%E7%BC%96%E8%AF%91%E5%99%A8.html">
<meta property="og:site_name" content="Fu Jinlong&#39;s Blog">
<meta property="og:description" content="来源低レイヤを知りたい人のためのCコンパイラ作成入門 (sigbus.info) 介绍这本书的内容太多了，无法包含在一本书中。在本书中，我们将创建一个将 C 语言编写的源代码转换为汇编语言的程序，即 C 编译器。编译器本身也是使用 C 开发的。直接目标是能够自托管，即使用自制编译器编译自己的源代码。 在本书中，我决定在整本书中以渐进的方式解释各个主题，以免使编译器的解释变得过于困难。原因如下： 编">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://icefjl.github.io/img/web/post1.jpeg">
<meta property="article:published_time" content="2023-10-16T08:26:08.000Z">
<meta property="article:modified_time" content="2024-04-11T09:30:33.000Z">
<meta property="article:author" content="ICEFJL">
<meta property="article:tag" content="计算机&#x2F;计算机基础">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://icefjl.github.io/img/web/post1.jpeg"><link rel="shortcut icon" href="/img/web/logo.png"><link rel="canonical" href="http://icefjl.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/C%E8%AF%AD%E8%A8%80%E8%87%AA%E5%88%B6%E7%BC%96%E8%AF%91%E5%99%A8.html"><link rel="preconnect" href="//fastly.jsdelivr.net"/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="/" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?025b5b66546875a0e89a0f8ac8d27dce";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://fastly.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://fastly.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'C语言自制编译器',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-04-11 17:30:33'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/all.min.css"><link rel="stylesheet" href="/css/my.css"><meta name="generator" content="Hexo 6.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>const preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',()=> { preloader.endLoading() })

if (false) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/web/avatar.jpg" onerror="onerror=null;src='/img/web/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">68</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">21</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">20</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fas fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/web/post1.jpeg')"><nav id="nav"><span id="blog-info"><a href="/" title="Fu Jinlong's Blog"></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fas fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">C语言自制编译器</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-10-16T08:26:08.000Z" title="发表于 2023-10-16 16:26:08">2023-10-16</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-04-11T09:30:33.000Z" title="更新于 2024-04-11 17:30:33">2024-04-11</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/">计算机基础</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="C语言自制编译器"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h1><p><a target="_blank" rel="noopener" href="https://www.sigbus.info/compilerbook">低レイヤを知りたい人のためのCコンパイラ作成入門 (sigbus.info)</a></p>
<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a><a href="#%E3%81%AF%E3%81%98%E3%82%81%E3%81%AB">介绍</a></h1><p>这本书的内容太多了，无法包含在一本书中。在本书中，我们将创建一个将 C 语言编写的源代码转换为汇编语言的程序，即 C 编译器。编译器本身也是使用 C 开发的。直接目标是能够自托管，即使用自制编译器编译自己的源代码。</p>
<p>在本书中，我决定在整本书中以渐进的方式解释各个主题，以免使编译器的解释变得过于困难。原因如下：</p>
<p>编译器在概念上可以分为多个阶段：解析、中间传递和代码生成。常见的教科书方法是在章节中解释每个主题，但采用这种方法的书籍往往会变得过于狭窄和深入，使读者难以理解。</p>
<p>另外，采用创建每个阶段的开发方法，直到所有阶段都完成后才能运行编译器，因此在整个阶段开始工作之前很难注意到您的理解或代码是否存在明确的错误。缺点是你不能。首先，在您自己创建之前，您并不真正知道下一阶段的输入预计是什么，因此您并不真正知道上一阶段要输出什么。另一个问题是很难保持积极性，因为在代码完成之前你根本无法编译任何代码。</p>
<p>在本书中，我决定采取不同的方法来避免这个陷阱。在本书的前面，您将使用非常简单的语言规范来实现 “ 专有语言 “。该语言非常简单，您无需了解如何编写编译器即可实现它。之后，读者将通过本书不断为 “ 专有语言 “ 添加功能，最终将其发展成与 C 语言一致的东西。</p>
<p>在这种增量开发方法中，您逐步创建编译器，进行少量提交。通过这种开发方法，编译器在每次提交时总是在某种意义上 “ 完整 “。在一个阶段，它可能只能做一个计算器级别的事情，在另一个阶段，它可能是 C 的一个非常有限的子集，在另一个阶段，它可能是一种几乎可以称为 C 的语言。关键是，在每个阶段，我们的目标都是建立一种具有合理规范的语言，以匹配当时的完成水平。在开发过程中，我们不会只强调某些功能，使其看起来像 C 语言。</p>
<p>我们还会根据发展阶段分阶段讲解数据结构、算法、计算机科学知识。</p>
<p>增量开发实现的目标是，在阅读本书的任何时间点，读者都对如何在该级别创建合理的语言有统一的了解。这比只对编译器创建的某些主题进行极其详细的状态要好得多。当您读完本书时，您将精通所有主题。</p>
<p>本书还解释了如何从头开始编写大型程序。创建大型程序的技能是一种不同于学习数据结构和算法的独特技能，但我认为解释此类事情的书籍并不多。而且，即使有人向你解释，除非你亲自体验，否则你也不会真正知道一种开发方法是好是坏。本书旨在使您在将自己的语言开发为 C 语言的过程中，能够给您带来良好开发方法的实践经验。</p>
<p>如果作者的计划成功的话，通过阅读本书，读者不仅会学到创建编译器和 CPU 指令集的技术，还会学到如何将大程序分解成小步骤，一点一点地创建。学习测试技术、版本控制技术，甚至如何为一个雄心勃勃的项目（如编写编译器）做准备。</p>
<p>本书的目标读者是普通的 C 程序员。您不需要是一个非常了解 C 语言规范的超级 C 程序员。了解指针和数组就足够了，并且至少可以花一些时间阅读别人编写的小型 C 程序。</p>
<p>在写这本书时，我不仅试图解释语言规范和 CPU 规范，而且还尽可能多地解释为什么选择这样的设计。我们还穿插了有关编译器、CPU、计算机行业及其历史的专栏，这些专栏会引起读者的兴趣，使其读起来令人愉快。</p>
<h2 id="本书假设的开发环境"><a href="#本书假设的开发环境" class="headerlink" title="本书假设的开发环境"></a><a href="#%E6%9C%AC%E6%9B%B8%E3%81%AE%E6%83%B3%E5%AE%9A%E3%81%99%E3%82%8B%E9%96%8B%E7%99%BA%E7%92%B0%E5%A2%83">本书假设的开发环境</a></h2><p>本书假设 64 位 Linux 环境运行在所谓的普通 PC（例如 Intel 或 AMD）上。请根据您使用的发行版提前安装 gcc 等开发工具并 make。如果您使用的是 Ubuntu，则可以通过运行以下命令来安装本书中使用的命令。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt update</span><br><span class="line">$ sudo apt install -y gcc make git binutils libc6-dev</span><br></pre></td></tr></table></figure>

<p>尽管 macOS 在程序集源代码级别与 Linux 相当兼容，但它并不完全兼容（具体来说，不支持称为 “ 静态链接 “ 的功能）。尽管可以使用本书中的信息为 macOS 创建 C 编译器，但如果您尝试这样做，您可能会遇到一些小的不兼容问题。不建议同时学习创建 C 编译器的技术以及 macOS 和 Linux 之间的差异。当某件事不起作用时，很难知道哪种理解是错误的。</p>
<p>因此，本书不涉及 macOS。在 macOS 上，请使用某种虚拟环境来准备 Linux 环境。如果您是第一次准备 Linux 虚拟环境，请参阅附录，其中总结了如何使用 Docker 创建开发环境。</p>
<p>Windows 在汇编源代码级别与 Linux 不兼容。然而，在 Windows 10 中，可以像一个应​​用程序一样在 Windows 上运行 Linux，并且通过使用它，您可以在 Windows 上继续开发。名为 Windows Subsystem for Linux (WSL) 的应用程序就是 Linux 兼容环境。在 Windows 上实现本书内容时，请安装 WSL 并在其中进行开发。</p>
<p>コラム:  专栏：在线编译器</p>
<p>查看 C 代码及其编译结果是学习汇编语言的好方法，但是一遍又一遍地编辑和编译源代码，然后检查汇编输出可能会令人惊讶地乏味。有一个非常好的网站可以为您省去麻烦。那就是 Compiler Explorer（俗称 godbolt）。当您在 Compiler Explorer 屏幕左半边的文本框中输入代码时，相应的汇编输出会实时显示在屏幕的右半边。当您想要检查 C 代码被转换成何种类型的汇编时，该网站是一个不错的选择。</p>
<hr>
<h1 id="创建计算器级语言"><a href="#创建计算器级语言" class="headerlink" title="创建计算器级语言"></a><a href="#%E9%9B%BB%E5%8D%93%E3%83%AC%E3%83%99%E3%83%AB%E3%81%AE%E8%A8%80%E8%AA%9E%E3%81%AE%E4%BD%9C%E6%88%90">创建计算器级语言</a></h1><p>在本章中，编写 C 编译器的第一步是支持算术运算和其他算术运算符，以便您可以编译如下表达式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">30 + (4 - 2) * -5</span><br></pre></td></tr></table></figure>

<p>这看似一个简单的目标，但实际上相当困难。数学公式的结构是括号内的表达式优先，或者乘法优先于加法，除非您以某种方式理解这一点，否则您将无法正确执行计算。但是，作为输入给出的公式只是一个平面字符串，而不是结构化数据。为了正确评估表达式，有必要分析字符序列并成功导出隐藏结构。</p>
<p>本章介绍最常见的解析算法之一，递归下降解析。您日常使用的 C&#x2F;C++ 编译器，例如 GCC 和 Clang，也使用递归下降解析。</p>
<p>编程时经常需要读取具有某种结构的文本，而不仅仅是编译器。您在本章中学到的技术可以直接用于解决此类问题。可以毫不夸张地说，您将在本章中学到的语法分析技术是受用一生的技术。阅读本章以了解算法并将解析技能添加到程序员的工具箱中。</p>
<h2 id="第-1-步：创建一种编译整数的语言"><a href="#第-1-步：创建一种编译整数的语言" class="headerlink" title="第 1 步：创建一种编译整数的语言"></a><a href="#%E3%82%B9%E3%83%86%E3%83%83%E3%83%971%E6%95%B4%E6%95%B01%E5%80%8B%E3%82%92%E3%82%B3%E3%83%B3%E3%83%91%E3%82%A4%E3%83%AB%E3%81%99%E3%82%8B%E8%A8%80%E8%AA%9E%E3%81%AE%E4%BD%9C%E6%88%90">第 1 步：创建一种编译整数的语言</a></h2><p>考虑 C 语言最简单的子集。你想象中的语言是什么样的？ <code>main</code> 它是一种只有函数的语言吗？或者也许是一种仅由一种表达方式组成的语言？最终，我认为可以公平地说，仅由一个整数组成的语言是可以想象的最简单的子集。</p>
<p>在这一步中，我们首先实现最简单的语言。</p>
<p>您在此步骤中创建的程序是一个编译器，它从输入中读取数字并输出一个程序集，该程序集以该数字作为程序的退出代码退出。因此，输入只是一个像 <code>42</code> 这样的字符串，当它读取它时，它会创建一个编译器，输出如下所示的程序集：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.intel_syntax noprefix</span><br><span class="line">.globl main</span><br><span class="line"></span><br><span class="line">main:</span><br><span class="line">        mov rax, 42</span><br><span class="line">        ret</span><br></pre></td></tr></table></figure>

<p><code>.intel_syntax noprefix</code> 是一个汇编命令，它在多种汇编编写方法中选择本书中使用的 Intel 表示法。请务必在您这次创建的编译器的开头包含此行。其他行如前一章所述。</p>
<p>此时，读者可能会想，” 这个程序不能称为编译器。” 老实说我也这么认为。然而，该程序接受由单个数字组成的语言作为输入并输出与该数字相对应的代码，因此根据定义，它是一个很好的编译器。即使像这样简单的程序如果修改它也会很快变得非常复杂，所以让我们先完成这一步。</p>
<p>从整个开发流程来看，这一步其实非常重要。这是因为我们将使用这一步中创建的内容作为未来开发的骨架。在这一步中，除了创建编译器本身之外，我们还创建构建文件（Makefile）、自动化测试并设置 git 存储库。让我们逐一查看这些任务。</p>
<p>コラム:  专栏：Intel 表示法和 AT&amp;T 表示法</p>
<p>除了本书中使用的 Intel 表示法之外，一种称为 AT&amp;T 表示法的汇编表示法也被广泛使用，主要在 Unix 中。默认情况下，gcc 和 objdump 使用 AT&amp;T 表示法输出程序集。</p>
<p>在 AT&amp;T 表示法中，结果寄存器是第二个参数。因此，在双参数命令中，参数以相反的顺序写入。使用 <code>%</code> 前缀写入寄存器名称，例如 <code>%rax</code> 。使用 <code>$</code> 前缀写入数字，例如 <code>$42</code> 。</p>
<p>另外，在引用内存时，请使用 <code>()</code> 而不是 <code>[]</code> 以独特的表示法编写表达式。下面举一些例子来进行比较。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mov rbp, rsp   // Intel</span><br><span class="line">mov %rsp, %rbp // AT&amp;T</span><br><span class="line">mov rax, 8     // Intel</span><br><span class="line">mov $8, %rax   // AT&amp;T</span><br><span class="line">mov [rbp + rcx * 4 - 8], rax // Intel</span><br><span class="line">mov %rax, -8(rbp, rcx, 4)    // AT&amp;T</span><br></pre></td></tr></table></figure>

<p>在我这次创建的编译器中，为了可读性，我决定使用 Intel 表示法。 Intel 的指令集手册使用 Intel 表示法，其优点是可以将手册的描述直接写成代码。 AT&amp;T 表示法和 Intel 表示法的表达能力是相同的。无论使用哪种表示法，生成的机器语言指令序列都是相同的。</p>
<h3 id="创建编译器主体"><a href="#创建编译器主体" class="headerlink" title="创建编译器主体"></a><a href="#%E3%82%B3%E3%83%B3%E3%83%91%E3%82%A4%E3%83%A9%E6%9C%AC%E4%BD%93%E3%81%AE%E4%BD%9C%E6%88%90">创建编译器主体</a></h3><p>通常我们将输入作为文件提供给编译器，但由于我们不想打开和读取该文件，因此我们将直接将代码作为命令的第一个参数提供。将第一个参数作为数字读取并将其嵌入到固定短语的汇编中的 C 程序可以轻松编写如下。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;参数数量不正确\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;.intel_syntax noprefix\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;.globl main\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;main:\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;  mov rax, %d\n&quot;</span>, atoi(argv[<span class="number">1</span>]));</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;  ret\n&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建一个名为 <code>9cc</code> 的空目录，并在其中创建一个名为 <code>9cc.c</code> 的文件，其中包含上述内容。然后，如下所示运行 9cc 并检查操作。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cc -o 9cc 9cc.c</span><br><span class="line">$ ./9cc 123 &gt; tmp.s</span><br></pre></td></tr></table></figure>

<p>第一行编译 <code>9cc.c</code> 并创建一个名为 <code>9cc</code> 的可执行文件。第二行将输入 <code>123</code> 传递给 9cc 以生成程序集并将其写入文件 <code>tmp.s</code> 。我们来检查一下 <code>tmp.s</code> 的内容。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ cat tmp.s</span><br><span class="line">.intel_syntax noprefix</span><br><span class="line">.globl main</span><br><span class="line">main:</span><br><span class="line">  mov rax, 123</span><br><span class="line">  ret</span><br></pre></td></tr></table></figure>

<p>如您所见，它生成得很好。您可以通过将以此方式创建的汇编文件传递给汇编器来创建可执行文件。</p>
<p>在 Unix 中， <code>cc</code> （或 <code>gcc</code> ）是许多语言的前端，而不仅仅是 C 和 C++，根据确定启动编译器或汇编器。因此，就像编译 9cc 时一样，可以通过将扩展名为 <code>.s</code> 的汇编器文件传递给 <code>cc</code> 来进行汇编。下面是编译并运行生成的可执行文件的示例。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ cc -o tmp tmp.s</span><br><span class="line">$ ./tmp</span><br><span class="line">$ echo $?</span><br><span class="line">123</span><br></pre></td></tr></table></figure>

<p>在 shell 中，可以在名为 <code>$?</code> 的变量中访问上一个命令的退出代码。在上面的示例中，显示数字 123，这与 9cc 的参数相同。这意味着它工作正常。尝试给出 0 到 255 范围内 123 以外的数字（Unix 进程退出代码应该是 0 到 255），看看 9cc 是否真的有效。</p>
<h3 id="创建自动化测试"><a href="#创建自动化测试" class="headerlink" title="创建自动化测试"></a><a href="#%E8%87%AA%E5%8B%95%E3%83%86%E3%82%B9%E3%83%88%E3%81%AE%E4%BD%9C%E6%88%90">创建自动化测试</a></h3><p>许多读者可能从未为爱好编程编写过测试，但在本书中，我们将在每次扩展编译器时编写代码来测试新代码。编写测试一开始可能看起来很乏味，但您很快就会开始欣赏它们。如果不写测试代码，最后每次都得手工运行相同的测试来检查操作，但是手工做就麻烦多了。</p>
<p>我认为编写测试很乏味的印象很大程度上来自于测试框架被夸大以及测试哲学有时很教条这一事实。例如，像 JUnit 这样的测试框架有多种有用的功能，但安装和学习如何使用它们需要时间。因此，本章不介绍此类测试框架。相反，我将在 shell 脚本中编写一个非常简单的手写 “ 测试框架 “，并用它来编写我的测试。</p>
<p>下面是用于测试的 shell 脚本 <code>test.sh</code> 。 shell 函数 <code>assert</code> 接收两个参数，输入的值和期望输出的值，并实际组装 9cc 结果并将实际结果与期望值进行比较，我们说的就做。在 shell 脚本中，定义 <code>assert</code> 函数后，我们用它来确保 0 和 42 都能正确编译。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="function"><span class="title">assert</span></span>() &#123;</span><br><span class="line">  expected=<span class="string">&quot;<span class="variable">$1</span>&quot;</span></span><br><span class="line">  input=<span class="string">&quot;<span class="variable">$2</span>&quot;</span></span><br><span class="line"></span><br><span class="line">  ./9cc <span class="string">&quot;<span class="variable">$input</span>&quot;</span> &gt; tmp.s</span><br><span class="line">  cc -o tmp tmp.s</span><br><span class="line">  ./tmp</span><br><span class="line">  actual=<span class="string">&quot;$?&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$actual</span>&quot;</span> = <span class="string">&quot;<span class="variable">$expected</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$input</span> =&gt; <span class="variable">$actual</span>&quot;</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$input</span> =&gt; <span class="variable">$expected</span> expected, but got <span class="variable">$actual</span>&quot;</span></span><br><span class="line">    <span class="built_in">exit</span> 1</span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">assert 0 0</span><br><span class="line">assert 42 42</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> OK</span><br></pre></td></tr></table></figure>

<p>使用上述内容创建 <code>test.sh</code> 并运行 <code>chmod a+x test.sh</code> 使其可执行。让我们实际运行 <code>test.sh</code> 。如果没有发生错误， <code>test.sh</code> 将显示 <code>OK</code> 并退出，如下所示。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ ./test.sh</span><br><span class="line">0 =&gt; 0</span><br><span class="line">42 =&gt; 42</span><br><span class="line">OK</span><br></pre></td></tr></table></figure>

<p>如果发生错误， <code>test.sh</code> 将不会显示 <code>OK</code> 。相反， <code>test.sh</code> 显示失败测试的预期值和实际值，如下所示。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ./test.sh</span><br><span class="line">0 =&gt; 0</span><br><span class="line">42 expected, but got 123</span><br></pre></td></tr></table></figure>

<p>如果要调试测试脚本，请在 bash 中使用 <code>-x</code> 选项运行该脚本。使用 <code>-x</code> 选项，bash 显示执行跟踪，如下所示。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">$ bash -x test.sh</span><br><span class="line">+ assert 0 0</span><br><span class="line">+ expected=0</span><br><span class="line">+ input=0</span><br><span class="line">+ cc -o 9cc 9cc.c</span><br><span class="line">+ ./9cc 0</span><br><span class="line">+ cc -o tmp tmp.s</span><br><span class="line">+ ./tmp</span><br><span class="line">+ actual=0</span><br><span class="line">+ &#x27;[&#x27; 0 &#x27;!=&#x27; 0 &#x27;]&#x27;</span><br><span class="line">+ assert 42 42</span><br><span class="line">+ expected=42</span><br><span class="line">+ input=42</span><br><span class="line">+ cc -o 9cc 9cc.c</span><br><span class="line">+ ./9cc 42</span><br><span class="line">+ cc -o tmp tmp.s</span><br><span class="line">+ ./tmp</span><br><span class="line">+ actual=42</span><br><span class="line">+ &#x27;[&#x27; 42 &#x27;!=&#x27; 42 &#x27;]&#x27;</span><br><span class="line">+ echo OK</span><br><span class="line">OK</span><br></pre></td></tr></table></figure>

<p>我们在本书中使用的 “ 测试框架 “ 只是一个像上面那样的 shell 脚本。与 JUnit 等成熟的测试框架相比，这个脚本可能看起来太简单了，但是这个 shell 脚本的简单性与 9cc 本身的简单性得到了平衡，所以这是更可取的。自动化测试基本上只是一次性运行您编写的代码并机械地比较结果，因此首先测试它而不是考虑太多非常重要。</p>
<h3 id="使用-make-构建"><a href="#使用-make-构建" class="headerlink" title="使用 make 构建"></a><a href="#make%E3%81%AB%E3%82%88%E3%82%8B%E3%83%93%E3%83%AB%E3%83%89">使用 make 构建</a></h3><p>在本书中，您将构建 9cc 数百次甚至数千次。创建 9cc 可执行文件然后运行测试脚本的工作每次都是一样的，所以交给工具就方便了。 <code>make</code> 命令通常用于此目的。</p>
<p>运行时，make 读取当前目录中名为 <code>Makefile</code> 的文件并执行其中写入的命令。 <code>Makefile</code> 由一个以冒号结尾的规则和该规则的一系列命令组成。以下 <code>Makefile</code> 用于自动执行您要在此步骤中运行的命令。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">CFLAGS=-std=c11 -g -static</span><br><span class="line"></span><br><span class="line">9cc: 9cc.c</span><br><span class="line"></span><br><span class="line">test: 9cc</span><br><span class="line">        ./test.sh</span><br><span class="line"></span><br><span class="line">clean:</span><br><span class="line">        rm -f 9cc *.o *~ tmp*</span><br><span class="line"></span><br><span class="line">.PHONY: test clean</span><br></pre></td></tr></table></figure>

<p>在 <code>9cc.c</code> 所在的同一目录中创建文件名为 <code>Makefile</code> 的上述文件。然后，您可以运行 <code>make</code> 来创建 9cc，并运行 <code>make test</code> 来运行测试。由于 make 可以理解文件依赖关系，因此无需在更改 <code>9cc.c</code> 之后和运行 <code>make test</code> 之前运行 <code>make</code> 。仅当可执行文件 9cc 早于 9cc.c 时，make 才会在运行测试之前构建 9cc。</p>
<p><code>make clean</code> 是删除临时文件的规则。临时文件可以手动 <code>rm</code> ，但是如果你不小心删除了不想删除的文件，那就很麻烦了，所以你也可以使用 <code>Makefile</code> 中这样的实用程序我正打算写呢。</p>
<p>注意，编写 <code>Makefile</code> 时， <code>Makefile</code> 的缩进必须是制表符。 4 或 8 个空格将导致错误。这只是糟糕的语法，但 make 是 20 世纪 70 年代开发的旧工具，传统上就是这样。</p>
<p>请务必将选项 <code>-static</code> 传递给 <code>cc</code> 。该选项在 “ 动态链接 “ 一章中进行了解释。您现在不需要考虑太多这个选项的含义。</p>
<h3 id="使用-git-进行版本控制"><a href="#使用-git-进行版本控制" class="headerlink" title="使用 git 进行版本控制"></a><a href="#git%E3%81%AB%E3%82%88%E3%82%8B%E3%83%90%E3%83%BC%E3%82%B8%E3%83%A7%E3%83%B3%E7%AE%A1%E7%90%86">使用 git 进行版本控制</a></h3><p>本书使用 git 作为版本控制系统。在本书中，我们将逐步创建一个编译器，并且对于每一步，请创建一个 git 提交并编写提交消息。提交消息可以是日语，因此请确保包含实际更改内容的一行摘要。如果要写多行详细说明，请在第一行后留一个空行，然后再写说明。</p>
<p>Git 仅对您手动生成的文件执行版本控制。运行 9cc 生成的文件可以通过执行相同的命令再次生成，因此不需要将它们纳入版本控制。事实上，包含此类文件会使每次提交的更改不必要地变长，因此应将它们从版本控制中删除，并且不包含在存储库中。</p>
<p>在 git 中，您可以在名为 <code>.gitignore</code> 的文件中编写要从版本控制中排除的文件的模式。在与 <code>9cc.c</code> 相同的目录中创建 <code>.gitignore</code> 并添加以下内容，并设置 git 忽略临时文件、编辑器备份文件等。让我们开始吧。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">*~</span><br><span class="line">*.o</span><br><span class="line">tmp*</span><br><span class="line">a.out</span><br><span class="line">9cc</span><br></pre></td></tr></table></figure>

<p>如果这是您第一次使用 Git，请告诉 Git 您的姓名和电子邮件地址。你在这里告诉 git 的姓名和电子邮件地址将被记录在提交日志中。下面是设置作者姓名和电子邮件地址的示例。读者，请输入您的姓名和电子邮件地址。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.name &quot;Rui Ueyama&quot;</span><br><span class="line">$ git config --global user.email &quot;ruiu@cs.stanford.edu&quot;</span><br></pre></td></tr></table></figure>

<p>要使用 git 创建提交，首先需要使用 <code>git add</code> 添加已更改的文件。由于这是您的第一次提交，因此首先使用 <code>git init</code> 创建一个 git 存储库，然后使用 <code>git add</code> 添加迄今为止创建的所有文件。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git init</span><br><span class="line">Initialized empty Git repository in /home/ruiu/9cc</span><br><span class="line">$ git add 9cc.c test.sh Makefile .gitignore</span><br></pre></td></tr></table></figure>

<p> 然后使用 <code>git commit</code> 提交。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -m &quot;整数1つをコンパイルするコンパイラを作成&quot;</span><br></pre></td></tr></table></figure>

<p><code>-m</code> （可选）指定提交消息。如果没有 <code>-m</code> 选项，则 <code>git</code> 启动编辑器。您可以通过运行 <code>git log -p</code> 来确认提交是否成功，如下所示。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ git log -p</span><br><span class="line">commit 0942e68a98a048503eadfee46add3b8b9c7ae8b1 (HEAD -&gt; master)</span><br><span class="line">Author: Rui Ueyama &lt;ruiu@cs.stanford.edu&gt;</span><br><span class="line">Date:   Sat Aug 4 23:12:31 2018 +0000    整数1つをコンパイルするコンパイラを作成diff --git a/9cc.c b/9cc.c</span><br><span class="line">new file mode 100644</span><br><span class="line">index 0000000..e6e4599</span><br><span class="line">--- /dev/null</span><br><span class="line">+++ b/9cc.c</span><br><span class="line">@@ -0,0 +1,16 @@</span><br><span class="line">+#include &lt;stdio.h&gt;</span><br><span class="line">+#include &lt;stdlib.h&gt;</span><br><span class="line">+</span><br><span class="line">+int main(int argc, char **argv) &#123;</span><br><span class="line">+  if (argc != 2) &#123;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>最后，让我们将目前创建的 git 存储库上传到 GitHub。没有特别的理由上传到 GitHub，但也没有理由不上传，并且 GitHub 作为代码的备份非常有用。要上传到 GitHub，请创建一个新存储库（在本示例中，我们使用用户 <code>rui314</code> 创建了一个名为 <code>9cc</code> 的存储库），然后使用以下命令创建新存储库。添加存储库作为远程存储库。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git remote add origin git@github.com:rui314/9cc.git</span><br></pre></td></tr></table></figure>

<p>然后，运行 <code>git push</code> 会将存储库的内容推送到 GitHub。运行 <code>git push</code> 后，尝试在浏览器中打开 GitHub 并验证您的源代码是否已上传。</p>
<p>这样就完成了创建编译器的第一步。这一步中的编译器太简单了，不能称为编译器，但它是一个很好的程序，包含了编译器所需的所有元素。从现在开始，我们将继续增强这个编译器的功能，尽管可能令人难以置信，但我们将把它开发成一个优秀的 C 编译器。享受第一步的完成。</p>
<p> 参考实现</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/rui314/chibicc/commit/f722daaaae0606115df4ace5a852da23c1a5b0f3">f722daaaae060611</a></li>
</ul>
<h2 id="第2步：创建一个可以加减法的编译器"><a href="#第2步：创建一个可以加减法的编译器" class="headerlink" title="第2步：创建一个可以加减法的编译器"></a><a href="#%E3%82%B9%E3%83%86%E3%83%83%E3%83%972%E5%8A%A0%E6%B8%9B%E7%AE%97%E3%81%AE%E3%81%A7%E3%81%8D%E3%82%8B%E3%82%B3%E3%83%B3%E3%83%91%E3%82%A4%E3%83%A9%E3%81%AE%E4%BD%9C%E6%88%90">第2步：创建一个可以加减法的编译器</a></h2><p>在这一步中，我们扩展了上一步中创建的编译器，使其不仅包含 <code>42</code> 等值，还包含 <code>2+11</code> 和 <code>5+20-4</code> 等加法和减法&gt; 允许您接收表情。</p>
<p>像 <code>5+20-4</code> 这样的表达式可以在编译时计算，并且结果数字（在本例中为 <code>21</code> ）可以嵌入到程序集中，但这会导致编译器就像解释器一样，因此您需要输出在运行时执行加法和减法的程序集。加法和减法的汇编指令是 <code>add</code> 和 <code>sub</code> 。 <code>add</code> 采用两个寄存器，将它们的内容相加，然后将结果写入其第一个参数的寄存器。 <code>sub</code> 与 <code>add</code> 相同，但有减法。使用这些指令， <code>5+20-4</code> 可以编译如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.intel_syntax noprefix</span><br><span class="line">.globl main</span><br><span class="line"></span><br><span class="line">main:</span><br><span class="line">        mov rax, 5</span><br><span class="line">        add rax, 20</span><br><span class="line">        sub rax, 4</span><br><span class="line">        ret</span><br></pre></td></tr></table></figure>

<p>在上面的程序集中， <code>mov</code> 将 RAX 设置为 5，然后将 20 添加到 RAX 并减去 4。执行 <code>ret</code> 时 RAX 的值应该是 <code>5+20-4</code> 或 21。让我们运行一下并检查一下。将上面的文件保存在 <code>tmp.s</code> 中，组装它，然后尝试运行它。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ cc -o tmp tmp.s</span><br><span class="line">$ ./tmp</span><br><span class="line">$ echo $?</span><br><span class="line">21</span><br></pre></td></tr></table></figure>

<p> 21 已正确显示，如上所示。</p>
<p>现在，我应该如何创建这个程序集文件？如果我们将这种涉及加法和减法的表达式视为一种 “ 语言 “，那么这种语言可以定义如下。</p>
<ul>
<li>开头有一个数字</li>
<li>后面跟着零个或多个 “ 术语 “</li>
<li>术语可以是 <code>+</code> 后跟一个数字，也可以是 <code>-</code> 后跟一个数字。</li>
</ul>
<p>如果将此定义翻译成 C 代码，您将得到如下所示的程序：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;参数数量不正确\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">char</span> *p = argv[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;.intel_syntax noprefix\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;.globl main\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;main:\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;  mov rax, %ld\n&quot;</span>, strtol(p, &amp;p, <span class="number">10</span>));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (*p) &#123;</span><br><span class="line">    <span class="keyword">if</span> (*p == <span class="string">&#x27;+&#x27;</span>) &#123;</span><br><span class="line">      p++;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;  add rax, %ld\n&quot;</span>, strtol(p, &amp;p, <span class="number">10</span>));</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (*p == <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">      p++;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;  sub rax, %ld\n&quot;</span>, strtol(p, &amp;p, <span class="number">10</span>));</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;意外的字符: &#x27;%c&#x27;\n&quot;</span>, *p);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;  ret\n&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序有点长，但前半部分和 <code>ret</code> 行与以前相同。中间添加了阅读术语的代码。这次，程序不仅仅是读取单个数字，所以读取一个数字后，我们需要知道它读了多远。由于 <code>atoi</code> 不返回读取的字符数，因此 <code>atoi</code> 不知道从哪里开始阅读下一部分。因此，我们使用了 C 标准库中的 <code>strtol</code> 函数。</p>
<p><code>strtol</code> 读取数字后，它会更新第二个参数中的指针，以指向读取的最后一个字符之后的字符。因此，读取一个数字后，如果下一个字符是 <code>+</code> 或 <code>-</code> ，则 <code>p</code> 应指向该字符。上面的程序利用了这一事实，在 <code>while</code> 循环中逐个读取术语，并在每次读取一个术语时输出一行汇编。</p>
<p>现在，让我们运行这个编译器的修改版本。更新 <code>9cc.c</code> 文件后，您只需运行 <code>make</code> 即可创建新的 9cc 文件。执行示例如下所示。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ make</span><br><span class="line">$ ./9cc &#x27;5+20-4&#x27;</span><br><span class="line">.intel_syntax noprefix</span><br><span class="line">.globl main</span><br><span class="line">main:</span><br><span class="line">  mov rax, 5</span><br><span class="line">  add rax, 20</span><br><span class="line">  sub rax, 4</span><br><span class="line">  ret</span><br></pre></td></tr></table></figure>

<p>看起来程序集已成功输出。为了测试这个新功能，我们向 <code>test.sh</code> 添加一条测试行，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">assert 21 &quot;5+20-4&quot;</span><br></pre></td></tr></table></figure>

<p>完成此操作后，将更改提交到 git。为此，请运行以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git add test.sh 9cc.c</span><br><span class="line">$ git commit</span><br></pre></td></tr></table></figure>

<p>当您运行 <code>git commit</code> 时，编辑器将启动，因此编写 “ 添加加法和减法 “，保存并退出编辑器。尝试使用 <code>git log -p</code> 命令来验证提交是否按预期工作。最后，运行 <code>git push</code> 将提交推送到 GitHub，这一步就完成了！</p>
<p> 参考实现</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/rui314/chibicc/commit/afc9e8f05faddf051aa3a578520d6484ab451282">afc9e8f05faddf05</a></li>
</ul>
<h2 id="第-3-步：引入分词器"><a href="#第-3-步：引入分词器" class="headerlink" title="第 3 步：引入分词器"></a><a href="#%E3%82%B9%E3%83%86%E3%83%83%E3%83%973%E3%83%88%E3%83%BC%E3%82%AF%E3%83%8A%E3%82%A4%E3%82%B6%E3%82%92%E5%B0%8E%E5%85%A5">第 3 步：引入分词器</a></h2><p>上一步中创建的编译器有一个缺点。如果输入包含空白字符，则会出现错误。例如，如果如下所示给字符串 <code>5 - 3</code> 加上空格，则在尝试读取 <code>+</code> 或 <code>-</code> 时会发现空格字符。这将导致编译失败。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ./9cc &#x27;5 - 3&#x27; &gt; tmp.s</span><br><span class="line">予期しない文字です: &#x27; &#x27;</span><br></pre></td></tr></table></figure>

<p>有多种方法可以解决此问题。一种明显的方法是在尝试读取 <code>+</code> 或 <code>-</code> 之前跳过空格。这种方法没有什么特别的错误，但在这一步中我们将采用不同的方法来解决问题。方法是在读取表达式之前将输入拆分为单词。</p>
<p>就像日语和英语一样，数学公式和编程语言可以被认为是由单词序列组成的。例如， <code>5+20-4</code> 变为 <code>5</code> 、 <code>+</code> 、 <code>20</code> 、 <code>-</code> 、 <code>4</code> 5 您可以将其视为由两个单词组成。这个 “ 词 “ 被称为 “ 令牌 “。标记之间的空白仅用于分隔标记，而不是单词的一部分。因此，在将字符串拆分为标记序列时，删除空格字符是很自然的。将字符串划分为标记字符串称为 “ 标记化 “。</p>
<p>将字符串分成标记序列还有其他好处。当表达式被划分为标记时，可以对标记进行分类并指定类型。例如， <code>+</code> 和 <code>-</code> 是如您所见的 <code>+</code> 和 <code>-</code> 等符号，而 <code>123</code> 这个字符串表示数字 123。在进行词法分析时，不仅要将输入拆分为简单的字符串，还需要解释每个单独的令牌，在消耗令牌序列时需要考虑更少的事情。</p>
<p>在当前允许加法和减法的表达式语法中，存在三种类型的标记： <code>+</code> 、 <code>-</code> 和数字。此外，出于编译器实现的原因，最好定义一种特殊类型来表示标记字符串的结尾（相当于以 <code>&#39;\0&#39;</code> 结尾的字符串）。让我们将标记做成一个由指针连接的链表，以便我们可以处理任意长度的输入。</p>
<p>虽然有点长，但我将在下面发布引入分词器的编译器的改进版本。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 令牌的类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">  TK_RESERVED, <span class="comment">// 符号</span></span><br><span class="line">  TK_NUM,      <span class="comment">// 整数令牌</span></span><br><span class="line">  TK_EOF,      <span class="comment">// 表示输入结束的令牌</span></span><br><span class="line">&#125; TokenKind;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Token</span> <span class="title">Token</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 令牌结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Token</span> &#123;</span></span><br><span class="line">  TokenKind kind; <span class="comment">// 令牌类型</span></span><br><span class="line">  Token *next;    <span class="comment">// 下一个输入令牌</span></span><br><span class="line">  <span class="type">int</span> val;        <span class="comment">// 如果kind为TK_NUM，则为其数值</span></span><br><span class="line">  <span class="type">char</span> *str;      <span class="comment">// 令牌字符串</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前关注的令牌</span></span><br><span class="line">Token *token;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于报告错误的函数</span></span><br><span class="line"><span class="comment">// 与printf相同的参数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">error</span><span class="params">(<span class="type">char</span> *fmt, …)</span> &#123;</span><br><span class="line">  va_list ap;</span><br><span class="line">  va_start(ap, fmt);</span><br><span class="line">  <span class="built_in">vfprintf</span>(<span class="built_in">stderr</span>, fmt, ap);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果下一个令牌是期望的符号，则读取并返回true。</span></span><br><span class="line"><span class="comment">// 否则返回false。</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">consume</span><span class="params">(<span class="type">char</span> op)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (token-&gt;kind != TK_RESERVED || token-&gt;str[<span class="number">0</span>] != op)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  token = token-&gt;next;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果下一个令牌是期望的符号，则读取它。</span></span><br><span class="line"><span class="comment">// 否则报告错误。</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">expect</span><span class="params">(<span class="type">char</span> op)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (token-&gt;kind != TK_RESERVED || token-&gt;str[<span class="number">0</span>] != op)</span><br><span class="line">    error(<span class="string">&quot;&#x27;%c&#x27;不是预期的符号&quot;</span>, op);</span><br><span class="line">  token = token-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果下一个令牌是数字，则读取令牌并返回其数值。</span></span><br><span class="line"><span class="comment">// 否则报告错误。</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">expect_number</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (token-&gt;kind != TK_NUM)</span><br><span class="line">    error(<span class="string">&quot;不是数字&quot;</span>);</span><br><span class="line">  <span class="type">int</span> val = token-&gt;val;</span><br><span class="line">  token = token-&gt;next;</span><br><span class="line">  <span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">at_eof</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> token-&gt;kind == TK_EOF;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建新的令牌并连接到cur</span></span><br><span class="line">Token *<span class="title function_">new_token</span><span class="params">(TokenKind kind, Token *cur, <span class="type">char</span> *str)</span> &#123;</span><br><span class="line">  Token *tok = <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="keyword">sizeof</span>(Token));</span><br><span class="line">  tok-&gt;kind = kind;</span><br><span class="line">  tok-&gt;str = str;</span><br><span class="line">  cur-&gt;next = tok;</span><br><span class="line">  <span class="keyword">return</span> tok;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对输入字符串p进行令牌化并返回其令牌</span></span><br><span class="line">Token *<span class="title function_">tokenize</span><span class="params">(<span class="type">char</span> *p)</span> &#123;</span><br><span class="line">  Token head;</span><br><span class="line">  head.next = <span class="literal">NULL</span>;</span><br><span class="line">  Token *cur = &amp;head;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (*p) &#123;</span><br><span class="line">    <span class="comment">// 跳过空白字符</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isspace</span>(*p)) &#123;</span><br><span class="line">      p++;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (*p == <span class="string">&#x27;+&#x27;</span> || *p == <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">      cur = new_token(TK_RESERVED, cur, p++);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isdigit</span>(*p)) &#123;</span><br><span class="line">      cur = new_token(TK_NUM, cur, p);</span><br><span class="line">      cur-&gt;val = strtol(p, &amp;p, <span class="number">10</span>);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    error(<span class="string">&quot;无法进行令牌化&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  new_token(TK_EOF, cur, p);</span><br><span class="line">  <span class="keyword">return</span> head.next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">    error(<span class="string">&quot;参数数量不正确&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 进行令牌化</span></span><br><span class="line">  token = tokenize(argv[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 输出汇编的前半部分</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;.intel_syntax noprefix\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;.globl main\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;main:\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 表达式的开头必须是一个数字，检查它并输出第一条mov指令</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;  mov rax, %d\n&quot;</span>, expect_number());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 消耗`+ &lt;数&gt;`或`- &lt;数&gt;`的令牌序列并输出汇编</span></span><br><span class="line">  <span class="keyword">while</span> (!at_eof()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (consume(<span class="string">&#x27;+&#x27;</span>)) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;  add rax, %d\n&quot;</span>, expect_number());</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    expect(<span class="string">&#x27;-&#x27;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;  sub rax, %d\n&quot;</span>, expect_number());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;  ret\n&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码不是很短，大约 150 行，但它没有做任何太棘手的事情，所以你应该能够通过从顶部阅读来阅读它。</p>
<p>让我解释一下上面代码中使用的一些编程技术。</p>
<ul>
<li>我决定使用全局变量 <code>token</code> 来表示解析器读取的标记序列。解析器通过 <code>token</code> 的链接列表读取输入。这种使用全局变量的编程风格可能看起来不太干净。然而，在实践中，通过将输入标记序列视为像标准输入一样的流，通常更容易读取解析器代码，就像我们在这里所做的那样。因此，我们这里采用了这样的风格。</li>
<li>直接接触 <code>token</code> 的代码应该分成 <code>consume</code> 和 <code>expect</code> 等函数，其他函数不应该直接接触 <code>token</code> 。做好了。</li>
<li><code>tokenize</code> 函数正在构建一个链表。构建链表时，您可以通过创建一个虚拟 <code>head</code> 元素、将新元素连接到它并在末尾返回 <code>head-&gt;next</code> 来简化代码。这种方法浪费了分配给 <code>head</code> 元素的大部分内存，但分配局部变量的成本几乎为零，因此您无需担心。</li>
<li><code>calloc</code> 是一个分配内存的函数，就像 <code>malloc</code> 一样。与 <code>malloc</code> 不同， <code>calloc</code> 将分配的内存清零。我决定在这里使用 <code>calloc</code> 来节省将元素归零的工作。</li>
</ul>
<p>这个改进的版本现在应该能够跳过空格，所以让我们将以下测试添加到单行 <code>test.sh</code> 中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">assert 41 &quot; 12 + 34 - 5 &quot;</span><br></pre></td></tr></table></figure>

<p>Unix 进程的退出代码是 0 到 255 之间的数字，因此在编写测试时，请确保整个表达式的结果落在 0 到 255 的范围内。</p>
<p>将测试文件添加到 git 存储库即可完成此步骤。</p>
<p> 参考实现</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/rui314/chibicc/commit/ef6d1791eb2a5ef3af913945ca577ea76d4ff97e">ef6d1791eb2a5ef3</a></li>
</ul>
<h2 id="第-4-步：改进错误消息"><a href="#第-4-步：改进错误消息" class="headerlink" title="第 4 步：改进错误消息"></a><a href="#%E3%82%B9%E3%83%86%E3%83%83%E3%83%974%E3%82%A8%E3%83%A9%E3%83%BC%E3%83%A1%E3%83%83%E3%82%BB%E3%83%BC%E3%82%B8%E3%82%92%E6%94%B9%E8%89%AF">第 4 步：改进错误消息</a></h2><p>使用到目前为止我们创建的编译器，如果输入在语法上不正确，我们唯一可以判断的是某个地方有错误。让我们尝试在这一步中改进这个问题。具体来说，我们将能够显示如下所示的直观错误消息。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ ./9cc &quot;1+3++&quot; &gt; tmp.s</span><br><span class="line">1+3++</span><br><span class="line">    ^ 不是数字</span><br><span class="line">$ ./9cc &quot;1 + foo + 5&quot; &gt; tmp.s</span><br><span class="line">1 + foo + 5</span><br><span class="line">    ^ 无法进行令牌化</span><br></pre></td></tr></table></figure>

<p>为了显示这样的错误消息，我们需要能够知道错误发生在输入的哪个字节。为此，我们将整个程序字符串保存在名为 <code>user_input</code> 的变量中，并定义一个新的错误显示函数，该函数接收指向字符串中间的指针。代码如下所示。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用户输入程序</span></span><br><span class="line"><span class="type">char</span> *user_input;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报告错误位置</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">error_at</span><span class="params">(<span class="type">char</span> *loc, <span class="type">char</span> *fmt, …)</span> &#123;</span><br><span class="line">  va_list ap;</span><br><span class="line">  va_start(ap, fmt);</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> pos = loc - user_input;</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;%s\n&quot;</span>, user_input);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;%*s&quot;</span>, pos, <span class="string">&quot; &quot;</span>); <span class="comment">// 输出pos个空格</span></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;^ &quot;</span>);</span><br><span class="line">  <span class="built_in">vfprintf</span>(<span class="built_in">stderr</span>, fmt, ap);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>error_at</code> 接收的指针是指向代表整个输入的字符串中间的指针。通过获取该指针和指向输入开头的指针之间的差异，您可以知道错误位于输入的哪个字节，因此可以使用 <code>^</code> 显着地标记该位置。</p>
<p>通过将 <code>argv[1]</code> 保存到 <code>user_input</code> 并将 <code>error(&quot;数ではありません&quot;)</code> 等代码更新为 <code>error_at(token-&gt;str, &quot;数ではありません&quot;)</code> 等代码来完成此步骤。</p>
<p>实用级别的编译器也应该为输入有错误时的行为编写测试，但目前错误消息只是输出以帮助调试，在这个阶段没有必要编写测试。你没有。</p>
<p> 参考实现</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/rui314/chibicc/commit/c6ff1d98a1419e69c31902447e2caa85af4e9844">c6ff1d98a1419e69</a></li>
</ul>
<h2 id="语法描述方法与递归下降解析"><a href="#语法描述方法与递归下降解析" class="headerlink" title="语法描述方法与递归下降解析"></a><a href="#%E6%96%87%E6%B3%95%E3%81%AE%E8%A8%98%E8%BF%B0%E6%96%B9%E6%B3%95%E3%81%A8%E5%86%8D%E5%B8%B0%E4%B8%8B%E9%99%8D%E6%A7%8B%E6%96%87%E8%A7%A3%E6%9E%90">语法描述方法与递归下降解析</a></h2><p>现在，接下来我想在语言中添加用于乘法、除法和优先级的括号，即 <code>*</code> 、 <code>/</code> 、 <code>()</code> 。这是一个重大的技术挑战。这是因为有一个规则，在表达式中必须先计算乘法和除法。例如，表达式 <code>1+2*3</code> 必须解释为 <code>1+(2*3)</code> ，而不是 <code>(1+2)*3</code> 。运算符首先 “ 粘在一起 “ 的规则称为 “ 运算符优先级 “。</p>
<p>我们应该如何处理运算符优先级？到目前为止，我们创建的编译器只是从头开始读取标记序列并输出程序集，因此如果您只是扩展它并添加 <code>*</code> 和 <code>/</code> 、 <code>1+2*3</code> 将被编译为 <code>(1+2)*3</code> 。</p>
<p>现有的编译器自然擅长处理运算符优先级。编译器的解析非常强大，只要遵循语法就可以正确解释任何复杂的代码。这个编译器的行为可能给人的印象是它具有超越人类的智力，但实际上，计算机不具备像人类一样阅读文本的能力，因此解析只是通过某种机械机制来执行 。它到底是如何运作的？</p>
<p>在本章中，让我们暂时放下编码，学习一些解析技术。本章按以下顺序描述解析技术：</p>
<ol>
<li><p>首先通过了解解析器输出的数据结构来了解最终目标。</p>
</li>
<li><p> 了解定义语法规则的规则</p>
</li>
<li><p>学习根据定义语法规则的规则编写解析器的技术</p>
</li>
</ol>
<h3 id="递归降序解析"><a href="#递归降序解析" class="headerlink" title="递归降序解析"></a><a href="#%E5%86%8D%E5%B8%B0%E4%B8%8B%E9%99%8D%E6%A7%8B%E6%96%87%E8%A7%A3%E6%9E%90">递归降序解析</a></h3><p>如果给定 C 语言的产生式规则，通过将它们逐一展开，就可以机械地生成任何从产生式规则来看是正确的 C 程序。但我们想要用 9cc 做的事情实际上是相反的。我从外部源获得一个作为字符串的 C 程序，我想知道展开时产生输入字符串的展开过程，或者产生与以下字符串相同的语法树的结构输入。</p>
<p>事实上，对于某些类型的产生式规则，如果给定一个规则，就可以机械地编写代码来找到与该规则生成的句子相匹配的语法树。这里描述的 “ 递归下降解析方法 “ 就是这样一种技术。</p>
<p>作为示例，让我们考虑四种算术运算的语法。我将重新发布四种算术运算的语法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">expr    = mul (&quot;+&quot; mul | &quot;-&quot; mul)*</span><br><span class="line">mul     = primary (&quot;*&quot; primary | &quot;/&quot; primary)*</span><br><span class="line">primary = num | &quot;(&quot; expr &quot;)&quot;</span><br></pre></td></tr></table></figure>

<p>使用递归下降解析编写解析器时的基本策略是将每个非终结符直接映射到每个函数。因此解析器将具有三个函数： <code>expr</code> 、 <code>mul</code> 和 <code>primary</code> 。正如其名称所示，每个函数都会解析一系列标记。</p>
<p>让我们具体地考虑一下。传递给解析器的输入是一系列标记。由于我们想要从解析器创建并返回一个抽象语法树，因此让我们定义抽象语法树中的节点类型。节点类型如下所示。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象语法树的节点类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">  ND_ADD, <span class="comment">// +</span></span><br><span class="line">  ND_SUB, <span class="comment">// -</span></span><br><span class="line">  ND_MUL, <span class="comment">// *</span></span><br><span class="line">  ND_DIV, <span class="comment">// /</span></span><br><span class="line">  ND_NUM, <span class="comment">// 整数</span></span><br><span class="line">&#125; NodeKind;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> <span class="title">Node</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象语法树的节点类型</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">  NodeKind kind; <span class="comment">// 节点类型</span></span><br><span class="line">  Node *lhs;     <span class="comment">// 左侧</span></span><br><span class="line">  Node *rhs;     <span class="comment">// 右侧</span></span><br><span class="line">  <span class="type">int</span> val;       <span class="comment">// 仅在kind为ND_NUM时使用</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>lhs</code> 和 <code>rhs</code> 分别表示左侧和右侧。</p>
<p>我们还定义一个函数来创建新节点。该语法中有两种类型的算术运算：接受左侧和右侧的二元运算符以及数字，因此我们将为这两种类型分别准备两个函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Node *<span class="title function_">new_node</span><span class="params">(NodeKind kind, Node *lhs, Node *rhs)</span> &#123;</span><br><span class="line">  Node *node = <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="keyword">sizeof</span>(Node));</span><br><span class="line">  node-&gt;kind = kind;</span><br><span class="line">  node-&gt;lhs = lhs;</span><br><span class="line">  node-&gt;rhs = rhs;</span><br><span class="line">  <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Node *<span class="title function_">new_node_num</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">  Node *node = <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="keyword">sizeof</span>(Node));</span><br><span class="line">  node-&gt;kind = ND_NUM;</span><br><span class="line">  node-&gt;val = val;</span><br><span class="line">  <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在，让我们使用这些函数和数据类型编写一个解析器。 <code>+</code> 和 <code>-</code> 是左结合运算符。解析左结合运算符的函数被编写为如下模式：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Node *<span class="title function_">expr</span><span class="params">()</span> &#123;</span><br><span class="line">  Node *node = mul();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    <span class="keyword">if</span> (consume(<span class="string">&#x27;+&#x27;</span>))</span><br><span class="line">      node = new_node(ND_ADD, node, mul());</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (consume(<span class="string">&#x27;-&#x27;</span>))</span><br><span class="line">      node = new_node(ND_SUB, node, mul());</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="keyword">return</span> node;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>consume</code> 是上一步中定义的函数，它向前读取输入中的一个标记，如果输入流中的下一个标记与参数匹配，则返回 true。</p>
<p><code>expr</code> 请仔细阅读该函数。您可以看到产生式 <code>expr = mul (&quot;+&quot; mul | &quot;-&quot; mul)*</code> 直接映射到函数调用和循环。在上面 <code>expr</code> 函数返回的抽象语法树中，运算符是左关联的，这意味着返回节点左侧的分支更深。</p>
<p>我们还定义 <code>expr</code> 函数使用的 <code>mul</code> 函数。 <code>*</code> 和 <code>/</code> 也是左结合运算符，因此可以使用相同的模式编写它们。该函数如下所示。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Node *<span class="title function_">mul</span><span class="params">()</span> &#123;</span><br><span class="line">  Node *node = primary();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    <span class="keyword">if</span> (consume(<span class="string">&#x27;*&#x27;</span>))</span><br><span class="line">      node = new_node(ND_MUL, node, primary());</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (consume(<span class="string">&#x27;/&#x27;</span>))</span><br><span class="line">      node = new_node(ND_DIV, node, primary());</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="keyword">return</span> node;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中的函数调用关系直接对应于 <code>mul = primary (&quot;*&quot; primary | &quot;/&quot; primary)*</code> 产生式规则。</p>
<p>最后，让我们定义 <code>primary</code> 函数。 <code>primary</code> 不会读取左结合运算符，因此上面的代码并不遵循上面的模式，但是可以按原样使用产生式规则 <code>primary = &quot;(&quot; expr &quot;)&quot; | num</code> 来对应于函数调用。, <code>primary</code> 函数可以写成如下。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Node *<span class="title function_">primary</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="comment">// 如果下一个令牌是&quot;(&quot;，那么应该是&quot;(&quot; expr &quot;)&quot;的结构</span></span><br><span class="line">  <span class="keyword">if</span> (consume(<span class="string">&#x27;(&#x27;</span>)) &#123;</span><br><span class="line">    Node *node = expr();</span><br><span class="line">    expect(<span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 否则应该是一个数字</span></span><br><span class="line">  <span class="keyword">return</span> new_node_num(expect_number());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在我们已经有了所有的功能，我们真的可以解析令牌字符串吗？尽管乍一看可能并不明显，但您可以使用这组函数来正确解析令牌序列。例如，考虑表达式 <code>1+2*3</code> 。</p>
<p>第一个调用的是 <code>expr</code> 。它开始读取输入，假设整个表达式为 <code>expr</code> （在本例中确实如此）。然后，函数调用如下： <code>expr</code> → <code>mul</code> → <code>primary</code> ，读取令牌 <code>1</code> ，并读取令牌&lt; b6 &gt; 返回一个语法树，表示 1 作为返回值。</p>
<p>接下来， <code>expr</code> 中的表达式 <code>consume(&#39;+&#39;)</code> 变为 true，因此令牌 <code>+</code> 被消耗并返回 <code>mul</code> 将被调用。此阶段剩余的输入是 <code>2*3</code> 。</p>
<p>从 <code>mul</code> 开始，和之前一样调用了 <code>primary</code> ，并且读取了令牌 <code>2</code> ，但是这次 <code>mul</code> 是不会立即返回的。 <code>mul</code> 中的表达式 <code>consume(&#39;*&#39;)</code> 变为 true，因此 <code>mul</code> 再次调用 <code>primary</code> 并 <code>3</code> 将返回表示 <code>2*3</code> 的语法树。</p>
<p>在返回的目的地 <code>expr</code> 处，将表示 1 的语法树和表示 <code>2*3</code> 的语法树组合起来，构造表示 <code>1+2*3</code> 的语法树，即为返回 <code>expr</code> 的值。换句话说， <code>1+2*3</code> 被正确解析。</p>
<p>下图展示了函数调用关系以及每个函数读取的 token。下图中，整个 <code>1+2*3</code> 有一层 <code>expr</code> ，它代表对读取整个输入的 <code>expr</code> 的调用。 <code>expr</code> 上方有两个 <code>mul</code> ，但它们还有另一个 <code>mul</code> &gt; 表示调用。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../../img/blog/ed3375792da2e2a04ad0dd81b3bb1500_MD5.svg"></p>
<p>解析 <code>1+2*3</code> 时的函数调用关系</p>
<p>下面显示了一个稍微复杂的示例。下图展示了解析 <code>1*2+(3+4)</code> 时的函数调用关系。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../../img/blog/3c90870f3dae5e03d8aa63ce050caba4_MD5.svg"></p>
<p>解析 <code>1*2+(3+4)</code> 时的函数调用关系</p>
<p>对于不熟悉递归的程序员来说，像上面这样的递归函数可能会让人感到困惑。老实说，即使对于我这个应该非常熟悉递归的人来说，这种代码的工作也感觉像是一种魔法。即使您知道递归代码是如何工作的，它还是有一些奇怪的地方，而这可能就是它的本质。尝试一遍又一遍地在脑海中跟踪代码，以确保其正常工作。</p>
<p>如上所述将一个产生式规则映射到一个函数的解析方法称为 “ 递归降序解析 “。在上面的解析器中，只预读一个标记来决定调用或返回哪个函数。 (1) 称为解析器。另外，可以由 LL(1) 解析器编写的语法称为 LL(1) 语法。</p>
<h2 id="堆叠机"><a href="#堆叠机" class="headerlink" title="堆叠机"></a><a href="#%E3%82%B9%E3%82%BF%E3%83%83%E3%82%AF%E3%83%9E%E3%82%B7%E3%83%B3">堆叠机</a></h2><p>在上一章中，我们解释了将标记序列转换为抽象语法树的算法。通过选择考虑运算符优先级的语法， <code>*</code> 和 <code>/</code> 比 <code>+</code> 和 <code>-</code> 更好。现在我们可以创建一个抽象语法树的分支总是在树的顶部，但是我们如何将这棵树转换为汇编呢？本章解释了如何进行。</p>
<p>首先我们考虑一下为什么不能像加减法一样转换为汇编。可以执行加法和减法的编译器使用 RAX 作为结果寄存器并在那里执行加法和减法。也就是说，编译后的程序只保留了一个中间计算结果。</p>
<p>但涉及乘法和除法时，不保证中间计算结果只有一个。以 2_3+4_5 为例。为了进行加法，两边都必须计算，所以 2_3 和 4_5 必须在加法之前计算。换句话说，在这种情况下，除非能够存储两个中间计算结果，否则无法执行整个计算。</p>
<p>称为 “ 堆栈机 “ 的计算机可以轻松地执行这样的计算。让我们远离解析器创建的抽象语法树并了解堆栈机。</p>
<h3 id="编译到堆栈机"><a href="#编译到堆栈机" class="headerlink" title="编译到堆栈机"></a><a href="#%E3%82%B9%E3%82%BF%E3%83%83%E3%82%AF%E3%83%9E%E3%82%B7%E3%83%B3%E3%81%B8%E3%81%AE%E3%82%B3%E3%83%B3%E3%83%91%E3%82%A4%E3%83%AB">编译到堆栈机</a></h3><p>本节介绍如何将抽象语法树转换为堆栈机器码。如果你能做到这一点，你将能够解析由四个算术运算组成的表达式，组装抽象语法树，使用 x86-64 指令将其编译成堆栈机，并执行它。换句话说，将有可能编写一个可执行四种算术运算的编译器。</p>
<p>在堆栈机中，当计算子表达式时，结果的一个值（无论它是什么）都保留在堆栈顶部。例如，考虑下面的树。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../../img/blog/b5a50cee05b8bcf8a30d76f472634ed2_MD5.svg"></p>
<p> 表示加法的抽象语法树</p>
<p><code>A</code> 和 <code>B</code> 是子树的抽象表示，实际上表示某种类型的节点。然而，在编译整个树时，树的具体类型或形状并不重要。要编译此树，请执行以下操作：</p>
<ol>
<li><p> 编译左子树</p>
</li>
<li><p> 编译右子树</p>
</li>
<li><p>输出将堆栈上的两个值替换为将它们相加的结果的代码</p>
</li>
</ol>
<p>执行完#1 中的代码后，无论具体代码是什么，栈顶都应该有一个值代表左子树的结果。类似地，运行 2 中的代码后，堆栈顶部应该有一个代表右子树结果的值。因此，为了计算整棵树的值，我们只需要将这两个值替换为它们的总值即可。</p>
<p>这样，当将抽象语法树编译到堆栈机时，我们会递归地思考并在树下降时输出程序集。尽管对于不熟悉递归概念的读者来说，这似乎有点困难，但它是处理树等自相似数据结构时的标准技术。</p>
<p> 让我们考虑下面的例子。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../../img/blog/c6820209048de0d36fab3c94c1acd096_MD5.svg"></p>
<p> 表示加法和乘法的抽象语法树</p>
<p>执行代码生成的函数接收树的根节点。</p>
<p>按照上述步骤，该函数所做的第一件事是编译左子树。换句话说，我们将编译数字 2。 2 的计算结果是 2，所以该子树的编译结果是 <code>PUSH 2</code> 。</p>
<p>然后代码生成函数尝试编译右子树。这将递归地编译子树的左侧，从而输出 <code>PUSH 3</code> 。接下来我们将编译子树的右侧，它将输出 <code>PUSH 4</code> 。</p>
<p>然后代码生成函数返回到递归调用并输出与子树运算符的类型匹配的代码。第一个输出是将堆栈顶部的两个元素替换为它们的乘积的代码。接下来，输出用它们的和替换栈顶两个元素的代码。结果将是下面的组件。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PUSH 2</span><br><span class="line">PUSH 3</span><br><span class="line">PUSH 4</span><br><span class="line">MUL</span><br><span class="line">ADD</span><br></pre></td></tr></table></figure>

<p>使用这种方法，抽象语法树可以机械地简化为汇编。</p>
<h3 id="如何在-x86-64-上创建堆栈机器"><a href="#如何在-x86-64-上创建堆栈机器" class="headerlink" title="如何在 x86-64 上创建堆栈机器"></a><a href="#x86-64%E3%81%AB%E3%81%8A%E3%81%91%E3%82%8B%E3%82%B9%E3%82%BF%E3%83%83%E3%82%AF%E3%83%9E%E3%82%B7%E3%83%B3%E3%81%AE%E5%AE%9F%E7%8F%BE%E6%96%B9%E6%B3%95">如何在 x86-64 上创建堆栈机器</a></h3><p>到目前为止，我们一直在讨论虚拟堆栈机。实际的 x86-64 是寄存器机，而不是堆栈机。 x86-64 操作通常被定义为在两个寄存器之间操作，而不是在堆栈顶部的两个值之间操作。因此，为了在 x86-64 上使用堆栈机技术，您需要使用寄存器机在某种意义上模拟堆栈机。</p>
<p>用寄存器机模拟堆栈机相对容易。堆栈机上的一条指令可以使用多条指令来实现。</p>
<p> 让我们解释一下具体的方法。</p>
<p>首先，准备一个指向堆栈顶部元素的寄存器。该寄存器称为堆栈指针。如果要弹出堆栈顶部的两个值，请取出堆栈指针指向的两个元素，并将它们更改为您从中删除堆栈指针的元素的数量。同样，压入时，您所要做的就是更改堆栈指针的值并写入它指向的内存区域。</p>
<p>x86-64 RSP 寄存器设计用作堆栈指针。 x86-64 上的 <code>push</code> 和 <code>pop</code> 等指令隐式使用 RSP 作为堆栈指针，修改其值，并访问 RSP 指向的内存，这是一个命令要做的事情。因此，当像堆栈机一样使用 x86-64 指令集时，可以直接使用 RSP 作为堆栈指针。现在，让我们使用 x86-64 作为堆栈机来编译表达式 <code>1+2</code> 。下面是 x86-64 程序集。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 将左操作数和右操作数推入栈中</span><br><span class="line">push 1</span><br><span class="line">push 2// 弹出左操作数和右操作数到RAX和RDI中，然后执行加法</span><br><span class="line">pop rdi</span><br><span class="line">pop rax</span><br><span class="line">add rax, rdi// 将相加的结果推入栈中</span><br><span class="line">push rax</span><br></pre></td></tr></table></figure>

<p>由于 x86-64 没有指令 “ 将 RSP 指向的两个元素相加 “，因此您需要将它们加载到寄存器中，执行加法，然后将结果推回堆栈。这就是上面的 <code>add</code> 命令的作用。</p>
<p>同样，在 x86-64 上实现 <code>2*3+4*5</code> 时，它看起来像这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 计算2*3并将结果推入栈中</span><br><span class="line">push 2</span><br><span class="line">push 3</span><br><span class="line">pop rdi</span><br><span class="line">pop rax</span><br><span class="line">mul rax, rdi</span><br><span class="line">push rax// 计算4*5并将结果推入栈中</span><br><span class="line">push 4</span><br><span class="line">push 5</span><br><span class="line">pop rdi</span><br><span class="line">pop rax</span><br><span class="line">mul rax, rdi</span><br><span class="line">push rax// 对栈顶的两个值进行相加</span><br><span class="line">// 即计算2*3+4*5</span><br><span class="line">pop rdi</span><br><span class="line">pop rax</span><br><span class="line">add rax, rdi</span><br><span class="line">push rax</span><br></pre></td></tr></table></figure>

<p>这样，通过使用 x86-64 堆栈操作指令，即使在 x86-64 上也可以运行与堆栈机非常相似的代码。</p>
<p>以下 <code>gen</code> 函数将此技术实现为 C 函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">gen</span><span class="params">(Node *node)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (node-&gt;kind == ND_NUM) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;  push %d\n&quot;</span>, node-&gt;val);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  gen(node-&gt;lhs);</span><br><span class="line">  gen(node-&gt;rhs);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;  pop rdi\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;  pop rax\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span> (node-&gt;kind) &#123;</span><br><span class="line">  <span class="keyword">case</span> ND_ADD:</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;  add rax, rdi\n&quot;</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> ND_SUB:</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;  sub rax, rdi\n&quot;</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> ND_MUL:</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;  imul rax, rdi\n&quot;</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> ND_DIV:</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;  cqo\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;  idiv rdi\n&quot;</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;  push rax\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然它在解析或代码生成中并不是特别重要，但上面的代码使用了 <code>idiv</code> 指令，该指令的规范很棘手，所以让我们解释一下。</p>
<p><code>idiv</code> 是执行有符号除法的指令。如果 x86-64 的 <code>idiv</code> 有一个简单的规范，上面的代码就会写成 <code>idiv rax, rdi</code> ，但是如果两个这样的寄存器是 则所采用的除法指令在 x86-64 上不存在。相反， <code>idiv</code> 隐式采用 RDX 和 RAX，将它们一起视为 128 位整数，将其除以参数寄存器的 64 位值，然后返回设置在 RAX 中，余数设置在黑索金。使用 <code>cqo</code> 指令，可以将 RAX 中的 64 位值扩展为 128 位，并在 RDX 和 RAX 中设置，因此在上面的代码中， <code>idiv</code> 在调用 <code>cqo</code> 。</p>
<p>好了，关于堆栈机的解释就到此结束了。到目前为止，您应该能够执行复杂的解析并将生成的抽象语法树转换为机器代码。让我们回去编写一个编译器来运用这些知识！</p>
<h2 id="第-5-步：创建一种可以执行四种算术运算的语言"><a href="#第-5-步：创建一种可以执行四种算术运算的语言" class="headerlink" title="第 5 步：创建一种可以执行四种算术运算的语言"></a><a href="#%E3%82%B9%E3%83%86%E3%83%83%E3%83%975%E5%9B%9B%E5%89%87%E6%BC%94%E7%AE%97%E3%81%AE%E3%81%A7%E3%81%8D%E3%82%8B%E8%A8%80%E8%AA%9E%E3%81%AE%E4%BD%9C%E6%88%90">第 5 步：创建一种可以执行四种算术运算的语言</a></h2><p>在本章中，我们将修改前面章节中创建的编译器并对其进行扩展，以便它可以处理包含优先括号的四种算术运算的表达式。所有必要的部分都已包含在内，因此只需编写少量新代码。尝试更改编译器的 <code>main</code> 函数以使用新创建的解析器和代码生成器。该代码应如下所示。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">    error(<span class="string">&quot;参数数量不正确&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 对输入进行词法分析和语法分析</span></span><br><span class="line">  user_input = argv[<span class="number">1</span>];</span><br><span class="line">  token = tokenize(user_input);</span><br><span class="line">  Node *node = expr();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 输出汇编的前半部分</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;.intel_syntax noprefix\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;.globl main\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;main:\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 遍历抽象语法树并生成代码</span></span><br><span class="line">  gen(node);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 栈顶应该保留整个表达式的值</span></span><br><span class="line">  <span class="comment">// 将其加载到RAX中并作为函数的返回值</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;  pop rax\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;  ret\n&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时，由加法、减法、乘法和优先级括号组成的表达式应该可以正确编译。让我们添加一些测试。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">assert 47 &#x27;5+6*7&#x27;</span><br><span class="line">assert 15 &#x27;5*(9-6)&#x27;</span><br><span class="line">assert 4 &#x27;(3+5)/2&#x27;</span><br></pre></td></tr></table></figure>

<p>请注意，为了便于解释，到目前为止的故事流程就好像 <code>*</code> 、 <code>/</code> 和 <code>()</code> 一次性全部实现。事实上，最好避免一次全部实施。由于最初有一个可以执行加法和减法的函数，因此首先尝试引入一个抽象语法树和一个使用它的代码生成器，而不破坏该函数。由于我们当时没有添加新功能，因此不需要新的测试。之后，请实施 <code>*</code> 、 <code>/</code> 和 <code>()</code> ，包括测试。</p>
<p> 参考实现</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/rui314/chibicc/commit/3c1e3831009edff2ea237d3e59680ba9d4bb2e14">3c1e3831009edff2</a></li>
</ul>
<p>コラム:  专栏：9cc 中的内存管理</p>
<p>如果您已经读完本书，您可能想知道内存管理在这个编译器中是如何工作的。到目前为止我们看到的代码使用了 calloc（malloc 的一个变体），但它没有调用 free。换句话说，分配的内存不会被释放。这不是有点疏忽吗？</p>
<p>事实上，这种 “ 不进行内存管理作为内存管理策略 “ 的设计是作者在考虑了各种权衡后有意选择的。</p>
<p>这种设计的优点是，通过不释放内存，您可以像编写具有垃圾收集器的语言一样编写代码。这不仅消除了编写内存管理代码的需要，还消除了与手动内存管理相关的神秘错误。</p>
<p>另一方面，考虑到它像普通 PC 一样在计算机上运行，​​实际上不存在因不释放而引起的问题。编译器是一个短暂的程序，它只读取单个 C 文件并输出汇编代码。当程序结束时，操作系统会自动释放所有分配的内存。因此，唯一的问题是总共分配多少内存，但根据我的实际测量，即使编译相当大的 C 文件，内存占用也只有 100 MiB 左右。</p>
<p>因此，不释放是一个现实有效的策略。例如，D 语言编译器 DMD 基于同样的思想，采用只分配不释放的策略。 </p>
<h2 id="步骤-6：一元加和一元减"><a href="#步骤-6：一元加和一元减" class="headerlink" title="步骤 6：一元加和一元减"></a><a href="#%E3%82%B9%E3%83%86%E3%83%83%E3%83%976%E5%8D%98%E9%A0%85%E3%83%97%E3%83%A9%E3%82%B9%E3%81%A8%E5%8D%98%E9%A0%85%E3%83%9E%E3%82%A4%E3%83%8A%E3%82%B9">步骤 6：一元加和一元减</a></h2><p>执行减法的 <code>-</code> 运算符不仅可以在两个术语之间使用，例如 <code>5-3</code> ，也可以在单个术语之间使用，例如 <code>-3</code> 您可以写在前面。类似地， <code>+</code> 运算符可以通过省略左侧而写为 <code>+3</code> 。像这样只使用一项的运算符称为 “ 一元运算符 “。另一方面，采用两项的运算符称为二元运算符。</p>
<p>除了 <code>+</code> 和 <code>-</code> 之外，C 还具有一元运算符，例如用于获取指针的 <code>&amp;</code> 和用于取消引用指针的 <code>*</code> 。 ，但在这一步中我们将只实现 <code>+</code> 和 <code>-</code> 。</p>
<p>一元 <code>+</code> 和一元 <code>-</code> 与二元 <code>+</code> 和 <code>-</code> 是相同的符号，但它们的定义不同。二进制 <code>-</code> 被定义为从左侧减去右侧的运算，但由于一元 <code>-</code> 本来就没有左侧，因此二进制 <code>-</code> 该定义本身没有任何意义。在 C 语言中，一元 <code>-</code> 被定义为反转右侧符号的运算。一元 <code>+</code> 是一个运算符，它返回右侧不变。这是一个并不真正需要使用的运算符，但它除了一元 <code>-</code> 之外还存在。</p>
<p>可以适当地将 <code>+</code> 和 <code>-</code> 视为具有相同名称、具有相似但不同定义的多个运算符：一元和二元。它是一元还是二元取决于上下文。包含一元 <code>+</code> &#x2F; <code>-</code> 的新语法如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">expr    = mul (&quot;+&quot; mul | &quot;-&quot; mul)*</span><br><span class="line">mul     = unary (&quot;*&quot; unary | &quot;/&quot; unary)*</span><br><span class="line">unary   = (&quot;+&quot; | &quot;-&quot;)? primary</span><br><span class="line">primary = num | &quot;(&quot; expr &quot;)&quot;</span><br></pre></td></tr></table></figure>

<p>上面的新语法添加了一个新的非终结符号 <code>unary</code> ，并且 <code>mul</code> 现在使用 <code>unary</code> 而不是 <code>primary</code> 。我是。 <code>X?</code> 是可选元素的 EBNF 语法，即 <code>X</code> 出现零次或一次。根据规则 <code>unary = (&quot;+&quot; | &quot;-&quot;)? primary</code> ，非终结符号 <code>unary</code> 可能有一个 <code>+</code> 或 <code>-</code> ，或者没有。它后面是 <code>primary</code> 。</p>
<p>检查 <code>-3</code> 、 <code>-(3+5)</code> 和 <code>-3*+5</code> 等表达式是否与此新语法匹配。 <code>-3*+5</code> 的语法树如下所示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../../img/blog/6f66164ff96d5c4c63b6023b64e7b911_MD5.svg"></p>
<p>让我们更改解析器以遵循这个新语法。像往常一样，解析器的更改应该通过将语法直接映射到函数调用来完成。解析 <code>unary</code> 的函数如下所示。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Node *<span class="title function_">unary</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (consume(<span class="string">&#x27;+&#x27;</span>))</span><br><span class="line">    <span class="keyword">return</span> primary();</span><br><span class="line">  <span class="keyword">if</span> (consume(<span class="string">&#x27;-&#x27;</span>))</span><br><span class="line">    <span class="keyword">return</span> new_node(ND_SUB, new_node_num(<span class="number">0</span>), primary());</span><br><span class="line">  <span class="keyword">return</span> primary();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这里，我决定在解析阶段将 <code>+x</code> 替换为 <code>x</code> ，将 <code>-x</code> 替换为 <code>0-x</code> 。因此，此步骤不需要更改代码生成器。</p>
<p>您可以通过编写一些测试并将它们与添加一元 <code>+</code> &#x2F; <code>-</code> 的代码一起签入来完成此步骤。编写测试时，尽量将测试结果保持在 0-255 范围内。像 <code>-10+20</code> 这样的表达式使用一元 <code>-</code> 但整体值为正数，因此使用此测试。</p>
<p> 参考实现</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/rui314/chibicc/commit/bb5fe99dbad62c9516ec6a4bc64e444d09115e6d">bb5fe99dbad62c95</a></li>
</ul>
<h2 id="第-7-步：比较运算符"><a href="#第-7-步：比较运算符" class="headerlink" title="第 7 步：比较运算符"></a><a href="#%E3%82%B9%E3%83%86%E3%83%83%E3%83%977-%E6%AF%94%E8%BC%83%E6%BC%94%E7%AE%97%E5%AD%90">第 7 步：比较运算符</a></h2><p>在本节中： <code>&lt;</code> 、 <code>&lt;=</code> 、 <code>&gt;</code> 、 <code>&gt;=</code> 、 <code>==</code> 、 <code>!=</code> 实施。虽然这些比较运算符看起来有特殊含义，但它们实际上是将两个整数合并为一个，就像 <code>+</code> 和 <code>-</code> 一样，它是一个返回两个整数的普通二元运算符。就像 <code>+</code> 返回两边相加的结果一样，例如 <code>==</code> 如果两边相同则返回 1，如果不同则返回 0。</p>
<h3 id="分词器更改"><a href="#分词器更改" class="headerlink" title="分词器更改"></a><a href="#%E3%83%88%E3%83%BC%E3%82%AF%E3%83%8A%E3%82%A4%E3%82%B6%E3%81%AE%E5%A4%89%E6%9B%B4">分词器更改</a></h3><p>到目前为止我们处理的符号标记的长度都是一个字符，我们在代码中也假设了这一点，但是为了处理诸如 <code>==</code> 这样的比较运算符，我们对代码进行了泛化，需要这样做。让我们在 <code>Token</code> 结构中存储一个名为 <code>len</code> 的成员，以便我们可以将字符串的长度存储在令牌中。新的结构类型如下所示。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Token</span> &#123;</span></span><br><span class="line">  TokenKind kind; <span class="comment">// 令牌的类型</span></span><br><span class="line">  Token *next;    <span class="comment">// 下一个输入令牌</span></span><br><span class="line">  <span class="type">int</span> val;        <span class="comment">// 仅当kind为TK_NUM时使用，表示数值</span></span><br><span class="line">  <span class="type">char</span> *str;      <span class="comment">// 令牌字符串</span></span><br><span class="line">  <span class="type">int</span> len;        <span class="comment">// 令牌的长度</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>此更改还需要更改 <code>consume</code> 和 <code>expect</code> 等函数来改进它们，以便它们接受字符串而不是字符。这是一个进行了一些更改的示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">consume</span><span class="params">(<span class="type">char</span> *op)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (token-&gt;kind != TK_RESERVED ||</span><br><span class="line">      <span class="built_in">strlen</span>(op) != token-&gt;len ||</span><br><span class="line">      <span class="built_in">memcmp</span>(token-&gt;str, op, token-&gt;len))</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  token = token-&gt;next;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当对由多个字符组成的符号进行标记时，必须首先对较长的标记进行标记。例如，如果字符串的其余部分以 <code>&gt;</code> 开头，则可以使用 &lt; b3 如果您检查它以 &gt; 开头的可能性， <code>&gt;=</code> 将被错误地标记为两个标记， <code>&gt;</code> 和 <code>=</code> 。完毕。</p>
<h3 id="新语法"><a href="#新语法" class="headerlink" title="新语法"></a><a href="#%E6%96%B0%E3%81%97%E3%81%84%E6%96%87%E6%B3%95">新语法</a></h3><p>要向解析器添加对比较运算符的支持，请考虑添加比较运算符后语法会是什么样子。如果按照优先级从低到高的顺序编写到目前为止出现的运算符，它将如下所示：</p>
<ol>
<li><p><code>==</code> <code>!=</code></p>
</li>
<li><p><code>&lt;</code> <code>&lt;=</code> <code>&gt;</code> <code>&gt;=</code></p>
</li>
<li><p><code>+</code> <code>-</code></p>
</li>
<li><p><code>*</code> <code>/</code></p>
</li>
<li><p>一元 <code>+</code> 一元 <code>-</code></p>
</li>
<li><p><code>()</code></p>
</li>
</ol>
<p>优先级可以用生成语法来表达，其中具有不同优先级的运算符映射到不同的非终结符。如果我们以与 <code>expr</code> 和 <code>mul</code> 相同的方式考虑语法，则添加比较运算符的新语法如下。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">expr       = equality</span><br><span class="line">equality   = relational (&quot;==&quot; relational | &quot;!=&quot; relational)*</span><br><span class="line">relational = add (&quot;&lt;&quot; add | &quot;&lt;=&quot; add | &quot;&gt;&quot; add | &quot;&gt;=&quot; add)*</span><br><span class="line">add        = mul (&quot;+&quot; mul | &quot;-&quot; mul)*</span><br><span class="line">mul        = unary (&quot;*&quot; unary | &quot;/&quot; unary)*</span><br><span class="line">unary      = (&quot;+&quot; | &quot;-&quot;)? primary</span><br><span class="line">primary    = num | &quot;(&quot; expr &quot;)&quot;</span><br></pre></td></tr></table></figure>

<p><code>equality</code> 有 <code>==</code> 和 <code>!=</code> ， <code>relational</code> 有 <code>&lt;</code> ， <code>&lt;=</code> ， &lt; 它代表 b6&gt;和 <code>&gt;=</code> 。这些非终结符可以使用解析左关联运算符的模式直接映射到函数。</p>
<p>注意，在上面的语法中， <code>expr</code> 和 <code>equality</code> 被分开，表示整个表达式是 <code>equality</code> 。我本来可以将 <code>equality</code> 的右侧直接写在 <code>expr</code> 的右侧，但我认为上面的语法可能更容易阅读。</p>
<p>コラム: 专栏：简单而冗长的代码与高级而简洁的代码</p>
<p>在递归降序解析中，您编写的代码几乎完全对应于产生式规则，因此解析相似规则的函数看起来是相同的。您到目前为止编写的 <code>relational</code> 、 <code>equality</code> 、 <code>add</code> 和 <code>mul</code> 也应该具有类似的功能。</p>
<p>人们很自然地会想到如何使用元编程技术（例如 C 宏、C++ 模板、高阶函数和代码生成）更好地抽象这些函数的常见模式。事实上，这样的事情是可以做的。然而，本书并不是有意这样做的。理由如下。</p>
<p>简单的代码很容易理解，即使有些冗长。如果您稍后最终对类似的功能进行类似的更改，那么实际上没什么大不了的。另一方面，高度抽象的代码可能很难理解，因为您首先需要了解抽象机制，然后再了解如何使用它。例如，如果我在本书开始时编写了一个使用元编程生成递归下降解析函数的函数，那么这本书就会困难得多。</p>
<p>您不必总是以编写优雅而简洁的代码为目标。当你的目标是这样的时候，你往往会让代码变得更难，以至于不能再难了。</p>
<p>编写代码的人成为该代码的专家，因此他们倾向于认为从专家的角度来看简洁、精益的代码就是好代码，但大多数代码读者与作者有相同的感觉。没有必要这样。首先要精通它，所以你需要在某种程度上质疑自己作为代码编写者的感觉。创建易于理解和维护的程序的一项重要技术是有意编写简单的代码，必要时可以写得更好。</p>
<h3 id="汇编代码生成"><a href="#汇编代码生成" class="headerlink" title="汇编代码生成"></a><a href="#%E3%82%A2%E3%82%BB%E3%83%B3%E3%83%96%E3%83%AA%E3%82%B3%E3%83%BC%E3%83%89%E3%81%AE%E7%94%9F%E6%88%90">汇编代码生成</a></h3><p>在 x86-64 上，使用 cmp 指令进行比较。从堆栈中弹出两个整数，执行比较，如果它们相同则将 RAX 设置为 1，否则设置为 0，代码如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pop rdi</span><br><span class="line">pop rax</span><br><span class="line">cmp rax, rdi</span><br><span class="line">sete al</span><br><span class="line">movzb rax, al</span><br></pre></td></tr></table></figure>

<p>对于一个简短的程序集来说，代码有点冗长，所以让我们一步一步地完成它。</p>
<p>前两行将值从堆栈中弹出。第三行比较弹出的值。比较结果去哪儿了？在 x86-64 上，比较指令的结果设置在特殊的 “ 标志寄存器 “ 中。标志寄存器是每次执行整数运算或比较运算指令时更新的寄存器，包含指示结果是否为 0 的位、指示是否发生溢出的位、指示结果是否小于的位 0 等都有。</p>
<p>标志寄存器不是普通的整数寄存器，因此如果要将比较结果设置到 RAX 中，则需要将标志寄存器的特定位复制到 RAX 中。 <code>sete</code> 指令执行此操作。如果前一个 <code>cmp</code> 指令检查的两个寄存器中的值相同，则 <code>sete</code> 指令将指定寄存器（此处为 AL）设置为 1。否则设置为 0。</p>
<p>AL 是本书中尚未出现的新寄存器名称，但 AL 实际上只是另一个指向 RAX 低 8 位的寄存器。因此，当 <code>sete</code> 将值设置为 AL 时，RAX 也会自动更新。然而，当通过 AL 更新 RAX 时，高 56 位保持其原始值，因此如果要将整个 RAX 设置为 0 或 1，则必须将高 56 位清零。 <code>movzb</code> 指令执行此操作。如果 <code>sete</code> 指令可以直接写入 RAX 就好了，但是 <code>sete</code> 被设计为只接受 8 位寄存器作为参数，所以比较指令可以这样写我们将使用两条指令来设置 RAX 中的值。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../../img/blog/06de9cc7e6089d326d9aa40e45c6a426_MD5.svg"></p>
<p>其他比较运算符可以使用其他指令代替 <code>sete</code> 来实现。使用 <code>setl</code> 表示 <code>&lt;</code> ，使用 <code>setle</code> 表示 <code>&lt;=</code> ，使用 <code>setne</code> 表示 <code>!=</code> 。请。</p>
<p><code>&gt;</code> 和 <code>&gt;=</code> 不需要代码生成器支持。请在解析器中切换两边并将其读取为 <code>&lt;</code> 或 <code>&lt;=</code> 。</p>
<p> 参考实现</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/rui314/chibicc/commit/6ddba4be5f63388607fc77fd786267b9ddcb14c9">6ddba4be5f633886</a></li>
</ul>
<hr>
<h1 id="单独编译和链接"><a href="#单独编译和链接" class="headerlink" title="单独编译和链接"></a><a href="#%E5%88%86%E5%89%B2%E3%82%B3%E3%83%B3%E3%83%91%E3%82%A4%E3%83%AB%E3%81%A8%E3%83%AA%E3%83%B3%E3%82%AF">单独编译和链接</a></h1><p>在此阶段之前，开发一直采用仅由一个 C 文件和一个测试 shell 脚本组成的文件结构。这个结构并没有什么问题，但是由于源代码越来越长，我决定将其拆分为多个 C 文件，以便于阅读。在这一步中，我们将把一个文件 9cc.c 拆分为以下五个文件。</p>
<ul>
<li><code>9cc.h</code> ：头文件</li>
<li><code>main.c</code> : <code>main</code> 功能</li>
<li><code>parse.c</code> ：解析器</li>
<li><code>codegen.c</code> ：代码生成器</li>
</ul>
<p>由于 <code>main</code> 函数很小，我可以将它放在另一个 C 文件中，但从语义上讲，它不属于 <code>parse.c</code> 或 <code>codegen.c</code> ，所以我会将其分成一个单独的文件。</p>
<h2 id="步骤8：分割文件并更改Makefile"><a href="#步骤8：分割文件并更改Makefile" class="headerlink" title="步骤8：分割文件并更改Makefile"></a><a href="#%E3%82%B9%E3%83%86%E3%83%83%E3%83%978-%E3%83%95%E3%82%A1%E3%82%A4%E3%83%AB%E5%88%86%E5%89%B2%E3%81%A8makefile%E3%81%AE%E5%A4%89%E6%9B%B4">步骤8：分割文件并更改Makefile</a></h2><h3 id="分割文件"><a href="#分割文件" class="headerlink" title="分割文件"></a><a href="#%E3%83%95%E3%82%A1%E3%82%A4%E3%83%AB%E3%81%AE%E5%88%86%E5%89%B2">分割文件</a></h3><p>尝试使用本章开头所示的配置来拆分文件。 <code>9cc.h</code> 是一个头文件。根据程序的结构，每个 <code>.c</code> 文件可能有一个 <code>.h</code> 文件，但额外的声明不会造成任何特定的危害。，没有必要管理这样的详细的依赖关系在这里。准备一个名为 <code>9cc.h</code> 的文件，并将其作为 <code>#include &quot;9cc.h&quot;</code> 包含在所有 C 文件中。</p>
<h3 id="生成文件更改"><a href="#生成文件更改" class="headerlink" title="生成文件更改"></a><a href="#makefile%E3%81%AE%E5%A4%89%E6%9B%B4">生成文件更改</a></h3><p>现在我们已经将程序更改为多个文件，让我们也更新 <code>Makefile</code> 。下面的 <code>Makefile</code> 编译并链接当前目录中的所有 .c 文件，以创建一个名为 9cc 的可执行文件。假设只有一个文件 9cc.h 作为项目头文件，并且所有 .c 文件都包含该头文件。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">CFLAGS=-std=c11 -g -static</span><br><span class="line">SRCS=$(wildcard *.c)</span><br><span class="line">OBJS=$(SRCS:.c=.o)</span><br><span class="line"></span><br><span class="line">9cc: $(OBJS)</span><br><span class="line">        $(CC) -o 9cc $(OBJS) $(LDFLAGS)</span><br><span class="line"></span><br><span class="line">$(OBJS): 9cc.h</span><br><span class="line"></span><br><span class="line">test: 9cc</span><br><span class="line">        ./test.sh</span><br><span class="line"></span><br><span class="line">clean:</span><br><span class="line">        rm -f 9cc *.o *~ tmp*</span><br><span class="line"></span><br><span class="line">.PHONY: test clean</span><br></pre></td></tr></table></figure>

<p>注意 <code>Makefile</code> 的缩进必须是制表符。</p>
<p>在 <code>Makefile</code> 中，由冒号分隔的行和由制表符缩进的零个或多个命令行构成了一条规则。冒号之前的名称称为 “ 目标 “。冒号后的零个或多个文件名称为从属文件。</p>
<p>当您运行 <code>make foo</code> 时， <code>make</code> 尝试创建一个名为 <code>foo</code> 的文件。如果指定的目标文件已存在，则仅当目标文件早于依赖文件时， <code>make</code> 才会重新运行目标规则。这使得仅当源代码更改时才可以重新生成二进制文件等行为。</p>
<p><code>.PHONY</code> 是一个特殊名称，用于表示虚拟目标。 <code>make test</code> 和 <code>make clean</code> 不会执行来创建 <code>test</code> 和 <code>clean</code> 等文件，但通常 <code>make</code> 不会执行不知道这一点，所以如果碰巧存在名为 <code>test</code> 或 <code>clean</code> 的文件，它将使用 <code>make test</code> 或 <code>make clean</code> 不再做任何事。通过用 <code>.PHONY</code> 指定这样一个虚拟目标，你并不真的想创建一个具有该名称的文件，但是无论指定的目标文件是否存在，规则都会被执行。你可以告诉 <code>make</code> 应该执行命令。</p>
<p><code>CFLAGS</code> 、 <code>SRCS</code> 和 <code>OBJS</code> 是变量。</p>
<p><code>CFLAGS</code> 是 make 的内置规则识别的变量，包含要传递给 C 编译器的命令行选项。在这里我们传递以下标志：</p>
<ul>
<li><code>-std=c11</code> ：告诉源代码是用最新的 C 标准 C11 编写的。</li>
<li><code>-g</code> ：输出调试信息</li>
<li><code>-static</code> ：静态链接</li>
</ul>
<p><code>SRCS</code> 右侧使用的 <code>wildcard</code> 是 make 提供的函数，扩展为与函数参数匹配的文件名。 <code>$(wildcard *.c)</code> 目前扩展为 <code>main.c parse.c codegen.c</code> 。</p>
<p><code>OBJS</code> 右侧使用变量替换规则生成一个值，将 SRC 中的.c 替换为.o。 <code>SRCS</code> 变为 <code>main.c parse.c codegen.c</code> ，因此 <code>OBJS</code> 变为 <code>main.o parse.o codegen.o</code> 。</p>
<p>考虑到这些事情，让我们跟踪一下执行 <code>make 9cc</code> 时发生的情况。该命令的最终目标是创建 <code>9cc</code> 文件，因为 make 尝试生成指定为参数的目标（如果没有参数，则选择第一个规则，因此在本例中，9cc 执行无需指定）。 make 通过遍历依赖项并尝试构建丢失或过时的文件来实现此目的。</p>
<p><code>9cc</code> 的依赖文件是当前目录中与 <code>.c</code> 文件对应的 <code>.o</code> 文件。如果 <code>.o</code> 文件在上次运行 make 时保留下来，并且它的时间戳比相应的 <code>.c</code> 文件更新，那么 make 会费心重新运行相同的命令。我不这样做那。仅当 <code>.o</code> 文件不存在或 <code>.c</code> 文件较新时才运行编译器生成 <code>.o</code> 文件。</p>
<p>规则 <code>$(OBJS): 9cc.h</code> 表示所有 <code>.o</code> 文件依赖于 <code>9cc.h</code> 。因此，如果更改 <code>9cc.h</code> ，所有 <code>.o</code> 文件都将重新编译。</p>
<p>コラム:  专栏：static 关键字的各种含义</p>
<p>C 中的 <code>static</code> 关键字有两个主要用途：</p>
<ol>
<li><p>将 <code>static</code> 添加到局部变量，以便即使退出函数后它们的值也能保存</p>
</li>
<li><p>在全局变量和函数中添加 <code>static</code> ，使变量和函数的作用域成为文件作用域。</p>
</li>
</ol>
<p>虽然这两种用法没有什么共同点，但是它们使用了相同的关键字，这是学习 C 时的困惑点之一。理想情况下，他们应该使用不同的关键字，例如用于用法 1 的 <code>persistent</code> 和用于用法 2 的 <code>private</code> 。更理想的情况是，对于用法 2，最好使用 <code>private</code> 作为默认值并将 <code>public</code> 附加到全局范围内的变量和函数。</p>
<p>C 重用关键字的原因是为了与过去编写的代码资产兼容。如果向语言添加新关键字（例如 <code>private</code> ），则使用该关键字作为变量或函数名称的现有程序将不再编译。 C 不喜欢这样，因此他决定在不同的上下文中重用现有的关键字，而不是添加更多关键字。</p>
<p>如果我在 20 世纪 70 年代的某个时候决定添加新关键字而不是重复使用 <code>static</code> 关键字，我可能可以节省大量的代码更改。如果您考虑到那时该怎么做，那就是相当困难的问题。</p>
<hr>
<h1 id="函数和局部变量"><a href="#函数和局部变量" class="headerlink" title="函数和局部变量"></a><a href="#%E9%96%A2%E6%95%B0%E3%81%A8%E3%83%AD%E3%83%BC%E3%82%AB%E3%83%AB%E5%A4%89%E6%95%B0">函数和局部变量</a></h1><p>在本章中，我们将实现函数和局部变量。我们还实现了一个简单的控制结构。完成本章后，您将能够编译如下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// mからnまでを足す</span><br><span class="line">sum(m, n) &#123;</span><br><span class="line">  acc = 0;</span><br><span class="line">  for (i = m; i &lt;= n; i = i + 1)</span><br><span class="line">    acc = acc + i;</span><br><span class="line">  return acc;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main() &#123;</span><br><span class="line">  return sum(1, 10); // 55を返す</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然上面的代码和 C 还有差距，但我想可以说已经相当接近 C 了。</p>
<h2 id="第9步：单字符局部变量"><a href="#第9步：单字符局部变量" class="headerlink" title="第9步：单字符局部变量"></a><a href="#%E3%82%B9%E3%83%86%E3%83%83%E3%83%9791%E6%96%87%E5%AD%97%E3%81%AE%E3%83%AD%E3%83%BC%E3%82%AB%E3%83%AB%E5%A4%89%E6%95%B0">第9步：单字符局部变量</a></h2><p>到上一章为止，我们已经能够为可以执行四种算术运算的语言创建编译器。在本节中，我们将向该语言添加功能以允许使用变量。具体来说，目标是能够编译包含变量的多个语句，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = 3;</span><br><span class="line">b = 5 * 6 - 8;</span><br><span class="line">a + b / 2;</span><br></pre></td></tr></table></figure>

<p>我们用最后一个表达式的结果作为整个程序的计算结果。我认为你可以说这种语言比只使用四个算术运算的语言具有更 “ 真实的语言 “ 感觉。</p>
<p>在本章中，我们将首先解释如何实现变量，然后我们将逐步实现变量。</p>
<h3 id="分词器更改-1"><a href="#分词器更改-1" class="headerlink" title="分词器更改"></a><a href="#%E3%83%88%E3%83%BC%E3%82%AF%E3%83%8A%E3%82%A4%E3%82%B6%E3%81%AE%E5%A4%89%E6%9B%B4-1">分词器更改</a></h3><p>现在您已经知道如何实现变量了，让我们开始实现它们吧。然而，支持任意数量的变量很快就变得太困难了，所以我们决定在这一步中将变量限制为单个小写字母，因此变量 <code>a</code> 是 RBP-8，变量 <code>b</code> 是 RBP-16，变量 <code>c</code> 是 RBP-24，依此类推。由于字母表中有 26 个字符，如果我们决定将 RSP 下推 26 x 8，即 208 个字节，那么在调用该函数时，我们将能够为所有单字符变量保留空间。</p>
<p>我们现在就来实现它。首先，让我们修改分词器，使其除了前面的语法元素之外还可以对单字符变量进行分词。为此，我们需要添加新的令牌类型。由于可以从 <code>str</code> 成员中读取变量名，因此无需向 <code>Token</code> 类型添加新成员。因此，令牌类型为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">  TK_RESERVED, <span class="comment">// 符号</span></span><br><span class="line">  TK_IDENT,    <span class="comment">// 标识符</span></span><br><span class="line">  TK_NUM,      <span class="comment">// 整数令牌</span></span><br><span class="line">  TK_EOF,      <span class="comment">// 表示输入结束的令牌</span></span><br><span class="line">&#125; TokenKind;</span><br></pre></td></tr></table></figure>

<p>修改标记生成器，为字母表中的小写字母创建 <code>TK_IDENT</code> 类型的标记。您应该将以下 <code>if</code> 语句添加到标记生成器中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="string">&#x27;a&#x27;</span> &lt;= *p &amp;&amp; *p &lt;= <span class="string">&#x27;z&#x27;</span>) &#123;</span><br><span class="line">  cur = new_token(TK_IDENT, cur, p++);</span><br><span class="line">  cur-&gt;len = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解析器的变化"><a href="#解析器的变化" class="headerlink" title="解析器的变化"></a><a href="#%E3%83%91%E3%83%BC%E3%82%B5%E3%81%AE%E5%A4%89%E6%9B%B4">解析器的变化</a></h3><p>通过递归下降解析，如果您知道语法，则可以将其机械地映射到函数调用。因此，为了考虑应该对解析器进行更改，有必要考虑添加变量名（标识符）时新语法将是什么样子。</p>
<p>我们将标识符称为 <code>ident</code> 。这是一个终结符，就像 <code>num</code> 一样。任何可以使用数字的地方都可以使用变量，因此将 <code>num</code> 替换为 <code>num | ident</code> 创建的语法允许在与数字相同的位置使用变量。</p>
<p>除此之外，我们还需要在语法中添加一个赋值表达式。由于无法分配变量，我们希望创建一种允许 <code>a=1</code> 等表达式的语法。在这里，我们使用可以写成 <code>a=b=1</code> 的语法来匹配 C。</p>
<p>此外，我希望能够编写用分号分隔的多个语句，因此生成的新语法如下。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">program    = stmt*</span><br><span class="line">stmt       = expr &quot;;&quot;</span><br><span class="line">expr       = assign</span><br><span class="line">assign     = equality (&quot;=&quot; assign)?</span><br><span class="line">equality   = relational (&quot;==&quot; relational | &quot;!=&quot; relational)*</span><br><span class="line">relational = add (&quot;&lt;&quot; add | &quot;&lt;=&quot; add | &quot;&gt;&quot; add | &quot;&gt;=&quot; add)*</span><br><span class="line">add        = mul (&quot;+&quot; mul | &quot;-&quot; mul)*</span><br><span class="line">mul        = unary (&quot;*&quot; unary | &quot;/&quot; unary)*</span><br><span class="line">unary      = (&quot;+&quot; | &quot;-&quot;)? primary</span><br><span class="line">primary    = num | ident | &quot;(&quot; expr &quot;)&quot;</span><br></pre></td></tr></table></figure>

<p>首先，检查 <code>42;</code> 和 <code>a=b=2; a+b;</code> 等程序是否符合此语法。之后，修改您到目前为止创建的解析器，以便它可以解析上述语法。在这个阶段，像 <code>a+1=5</code> 这样的表达式也可以被解析，这是正确的。消除此类语义上无效的表达式将在下一步中完成。修改解析器没有什么特别棘手的，您应该能够像以前一样通过将语法元素映射到函数调用来完成此操作。</p>
<p>由于我们通过用分号分隔来乘以多个表达式，因此我们需要将多个节点作为解析结果保存在某处。现在，请准备以下全局数组并按顺序存储解析结果节点。如果用 NULL 填充最后一个节点，您将能够看到它的结束位置。下面显示了一些要添加的新代码。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Node *code[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line">Node *<span class="title function_">assign</span><span class="params">()</span> &#123;</span><br><span class="line">  Node *node = equality();</span><br><span class="line">  <span class="keyword">if</span> (consume(<span class="string">&quot;=&quot;</span>))</span><br><span class="line">    node = new_node(ND_ASSIGN, node, assign());</span><br><span class="line">  <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Node *<span class="title function_">expr</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> assign();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Node *<span class="title function_">stmt</span><span class="params">()</span> &#123;</span><br><span class="line">  Node *node = expr();</span><br><span class="line">  expect(<span class="string">&quot;;&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">program</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (!at_eof())</span><br><span class="line">    code[i++] = stmt();</span><br><span class="line">  code[i] = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>抽象语法树需要能够表达一个新的 “ 代表局部变量的节点 “。为此，我们为局部变量添加一个新类型，为节点添加一个新成员。例如，它应该如下所示：此数据结构使解析器为标识符标记创建并返回类型为 <code>ND_LVAR</code> 的节点。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">  ND_ADD,    <span class="comment">// +</span></span><br><span class="line">  ND_SUB,    <span class="comment">// -</span></span><br><span class="line">  ND_MUL,    <span class="comment">// *</span></span><br><span class="line">  ND_DIV,    <span class="comment">// /</span></span><br><span class="line">  ND_ASSIGN, <span class="comment">// =</span></span><br><span class="line">  ND_LVAR,   <span class="comment">// 局部变量</span></span><br><span class="line">  ND_NUM,    <span class="comment">// 整数</span></span><br><span class="line">&#125; NodeKind;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> <span class="title">Node</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象语法树节点</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">  NodeKind kind; <span class="comment">// 节点类型</span></span><br><span class="line">  Node *lhs;     <span class="comment">// 左操作数</span></span><br><span class="line">  Node *rhs;     <span class="comment">// 右操作数</span></span><br><span class="line">  <span class="type">int</span> val;       <span class="comment">// 仅在kind为ND_NUM时使用</span></span><br><span class="line">  <span class="type">int</span> offset;    <span class="comment">// 仅在kind为ND_LVAR时使用</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>offset</code> 是一个成员，表示距局部变量基指针的偏移量。目前，局部变量处于由名称决定的固定位置，例如 RBP-8 中的变量 <code>a</code> 、RBP-16 中的 <code>b</code> 等，因此偏移量为语法这样可以在分析阶段确定。下面的代码读取标识符并返回 <code>ND_LVAR</code> 类型的节点。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Node *<span class="title function_">primary</span><span class="params">()</span> &#123;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  Token *tok = consume_ident();</span><br><span class="line">  <span class="keyword">if</span> (tok) &#123;</span><br><span class="line">    Node *node = <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="keyword">sizeof</span>(Node));</span><br><span class="line">    node-&gt;kind = ND_LVAR;</span><br><span class="line">    node-&gt;offset = (tok-&gt;str[<span class="number">0</span>] - <span class="string">&#x27;a&#x27;</span> + <span class="number">1</span>) * <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ...</span><br></pre></td></tr></table></figure>

<h3 id="代码生成器更改"><a href="#代码生成器更改" class="headerlink" title="代码生成器更改"></a><a href="#%E3%82%B3%E3%83%BC%E3%83%89%E3%82%B8%E3%82%A7%E3%83%8D%E3%83%AC%E3%83%BC%E3%82%BF%E3%81%AE%E5%A4%89%E6%9B%B4">代码生成器更改</a></h3><p>使用我们到目前为止所学到的知识，让我们修改代码生成器以处理包含变量的表达式。此更改添加了一个将表达式计算为左值的函数。下面代码中的函数 <code>gen_lval</code> 就是这样做的。 <code>gen_lval</code> 当给定节点指向变量时计算变量的地址并将其推入堆栈。否则显示错误。这将消除像 <code>(a+1)=2</code> 这样的表达式。</p>
<p>当使用变量作为右值时，首先将其计算为左值，然后将堆栈顶部的计算结果视为地址，并从该地址加载值。代码如下所示。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">gen_lval</span><span class="params">(Node *node)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (node-&gt;kind != ND_LVAR)</span><br><span class="line">    error(<span class="string">&quot;赋值操作左值不是变量&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;  mov rax, rbp\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;  sub rax, %d\n&quot;</span>, node-&gt;offset);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;  push rax\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">gen</span><span class="params">(Node *node)</span> &#123;</span><br><span class="line">  <span class="keyword">switch</span> (node-&gt;kind) &#123;</span><br><span class="line">  <span class="keyword">case</span> ND_NUM:</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;  push %d\n&quot;</span>, node-&gt;val);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">case</span> ND_LVAR:</span><br><span class="line">    gen_lval(node);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;  pop rax\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;  mov rax, [rax]\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;  push rax\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">case</span> ND_ASSIGN:</span><br><span class="line">    gen_lval(node-&gt;lhs);</span><br><span class="line">    gen(node-&gt;rhs);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;  pop rdi\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;  pop rax\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;  mov [rax], rdi\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;  push rdi\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  gen(node-&gt;lhs);</span><br><span class="line">  gen(node-&gt;rhs);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;  pop rdi\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;  pop rax\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span> (node-&gt;kind) &#123;</span><br><span class="line">  <span class="keyword">case</span> ND_ADD:</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;  add rax, rdi\n&quot;</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> ND_SUB:</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;  sub rax, rdi\n&quot;</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> ND_MUL:</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;  imul rax, rdi\n&quot;</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> ND_DIV:</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;  cqo\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;  idiv rdi\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;  push rax\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="主要功能变化"><a href="#主要功能变化" class="headerlink" title="主要功能变化"></a><a href="#%E3%83%A1%E3%82%A4%E3%83%B3%E9%96%A2%E6%95%B0%E3%81%AE%E5%A4%89%E6%9B%B4">主要功能变化</a></h3><p>现在我们已经拥有了所有部分，让我们更改 <code>main</code> 函数并实际运行编译器。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">    error(<span class="string">&quot;参数数量不正确&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 对输入进行词法分析和语法分析</span></span><br><span class="line">  <span class="comment">// 结果存储在code中</span></span><br><span class="line">  user_input = argv[<span class="number">1</span>];</span><br><span class="line">  tokenize();</span><br><span class="line">  program();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 输出汇编的前半部分</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;.intel_syntax noprefix\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;.globl main\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;main:\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 函数开头</span></span><br><span class="line">  <span class="comment">// 分配26个变量的内存空间</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;  push rbp\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;  mov rbp, rsp\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;  sub rsp, 208\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 顺序生成代码从第一个表达式开始</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; code[i]; i++) &#123;</span><br><span class="line">    gen(code[i]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 表达式的计算结果应该留在栈中</span></span><br><span class="line">    <span class="comment">// 因此为了避免栈溢出，我们在这里弹出计算结果</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;  pop rax\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 函数结尾</span></span><br><span class="line">  <span class="comment">// 最后一个表达式的结果保存在RAX中，作为返回值</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;  mov rsp, rbp\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;  pop rbp\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;  ret\n&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="第10步：多字符局部变量"><a href="#第10步：多字符局部变量" class="headerlink" title="第10步：多字符局部变量"></a><a href="#%E3%82%B9%E3%83%86%E3%83%83%E3%83%9710%E8%A4%87%E6%95%B0%E6%96%87%E5%AD%97%E3%81%AE%E3%83%AD%E3%83%BC%E3%82%AB%E3%83%AB%E5%A4%89%E6%95%B0">第10步：多字符局部变量</a></h2><p>在上一章中，我们将变量名固定为一个字母，并将其视为从 a 到 z 的 26 个局部变量始终存在。本节提供对名称长于一个字符的标识符的支持，允许编译如下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">foo = 1;</span><br><span class="line">bar = 2 + 3;</span><br><span class="line">return foo + bar; </span><br></pre></td></tr></table></figure>

<p>变量无需定义即可使用。因此，解析器必须确定每个标识符以前是否见过，如果是新的，则自动在堆栈区域中分配一个变量。</p>
<p>首先，更改标记生成器以将多字符标识符读取为 <code>TK_IDENT</code> 类型标记。</p>
<p>我们将把变量表示为链表。让我们使用名为 <code>LVar</code> 的结构来表示一个变量，并将第一个元素保存为名为 <code>locals</code> 的指针。用代码表达的话，看起来像这样：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LVar</span> <span class="title">LVar</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 局部变量的类型</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LVar</span> &#123;</span></span><br><span class="line">  LVar *next; <span class="comment">// 下一个变量或NULL</span></span><br><span class="line">  <span class="type">char</span> *name; <span class="comment">// 变量的名称</span></span><br><span class="line">  <span class="type">int</span> len;    <span class="comment">// 名称的长度</span></span><br><span class="line">  <span class="type">int</span> offset; <span class="comment">// 从RBP的偏移量</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 局部变量链表</span></span><br><span class="line">LVar *locals;</span><br></pre></td></tr></table></figure>

<p>在解析器中，当出现 <code>TK_IDENT</code> 类型的标记时，它会检查该标识符是否曾经出现过。您可以通过跟随 <code>locals</code> 并查看变量名称来判断变量是否已存在。如果该变量之前出现过，则按原样使用该变量的 <code>offset</code> 。对于新变量，创建新的 <code>LVar</code> ，设置新的偏移量，然后使用该偏移量。</p>
<p> 下面是一个按名称搜索变量的函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过名称搜索变量。如果找不到，则返回NULL。</span></span><br><span class="line">LVar *<span class="title function_">find_lvar</span><span class="params">(Token *tok)</span> &#123;</span><br><span class="line">  <span class="keyword">for</span> (LVar *var = locals; var; var = var-&gt;next)</span><br><span class="line">    <span class="keyword">if</span> (var-&gt;len == tok-&gt;len &amp;&amp; !<span class="built_in">memcmp</span>(tok-&gt;str, var-&gt;name, var-&gt;len))</span><br><span class="line">      <span class="keyword">return</span> var;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在你的解析器中，你应该只添加如下代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Token *tok = consume_ident();</span><br><span class="line"><span class="keyword">if</span> (tok) &#123;</span><br><span class="line">  Node *node = <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="keyword">sizeof</span>(Node));</span><br><span class="line">  node-&gt;kind = ND_LVAR;</span><br><span class="line"></span><br><span class="line">  LVar *lvar = find_lvar(tok);</span><br><span class="line">  <span class="keyword">if</span> (lvar) &#123;</span><br><span class="line">    node-&gt;offset = lvar-&gt;offset;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    lvar = <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="keyword">sizeof</span>(LVar));</span><br><span class="line">    lvar-&gt;next = locals;</span><br><span class="line">    lvar-&gt;name = tok-&gt;str;</span><br><span class="line">    lvar-&gt;len = tok-&gt;len;</span><br><span class="line">    lvar-&gt;offset = locals-&gt;offset + <span class="number">8</span>;</span><br><span class="line">    node-&gt;offset = lvar-&gt;offset;</span><br><span class="line">    locals = lvar;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="第11步：返回语句"><a href="#第11步：返回语句" class="headerlink" title="第11步：返回语句"></a><a href="#%E3%82%B9%E3%83%86%E3%83%83%E3%83%9711return%E6%96%87">第11步：返回语句</a></h2><p>在本章中，我们将添加 <code>return</code> 语句，以便我们可以编译如下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = 3;</span><br><span class="line">b = 5 * 6 - 8;</span><br><span class="line">return a + b / 2;</span><br></pre></td></tr></table></figure>

<p>假设 <code>return</code> 语句可以写在程序中间。与普通 C 一样，程序执行将在第一个 <code>return</code> 处中止，并且函数将返回。例如，下面的程序返回第一个 <code>return</code> 的值，即 5。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">return 5;</span><br><span class="line">return 8;</span><br></pre></td></tr></table></figure>

<p>为了实现这个功能，我们首先考虑一下添加了 <code>return</code> 的语法会发生什么。到目前为止，语句只是一个表达式，但新语法允许 <code>return &lt;式&gt;;</code> 。所以新的语法是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">program = stmt*</span><br><span class="line">stmt    = expr &quot;;&quot;</span><br><span class="line">        | &quot;return&quot; expr &quot;;&quot;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>为了实现这一点，分词器、解析器和代码生成器都需要进行一些调整。</p>
<p>首先，让标记生成器识别 <code>return</code> 标记并用 <code>TK_RETURN</code> 类型标记表示它。只有有限数量的标记（称为关键字）在语法中具有特殊含义，例如 <code>return</code> 、 <code>while</code> 和 <code>int</code> 。让每个令牌都有不同的类型，就像这样。</p>
<p>要确定下一个标记是否是 <code>return</code> ，似乎您所要做的就是检查标记器的剩余输入字符串是否以 <code>return</code> 开头，但在这种情况下，<code>returnx</code> 这样的标记会被错误地标记为 <code>return</code> 和 <code>x</code> 。所以这里我们需要确保输入以 <code>return</code> 开头，并且下一个字符不是令牌字符。</p>
<p>下面是一个函数，用于确定给定字符是否是标记字符，即字母数字字符或下划线。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">is_alnum</span><span class="params">(<span class="type">char</span> c)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (<span class="string">&#x27;a&#x27;</span> &lt;= c &amp;&amp; c &lt;= <span class="string">&#x27;z&#x27;</span>) ||</span><br><span class="line">         (<span class="string">&#x27;A&#x27;</span> &lt;= c &amp;&amp; c &lt;= <span class="string">&#x27;Z&#x27;</span>) ||</span><br><span class="line">         (<span class="string">&#x27;0&#x27;</span> &lt;= c &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>) ||</span><br><span class="line">         (c == <span class="string">&#x27;_&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用此函数，您可以将以下代码添加到 <code>tokenize</code> 将 <code>return</code> 标记为 <code>TK_RETURN</code> 。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">strncmp</span>(p, <span class="string">&quot;return&quot;</span>, <span class="number">6</span>) == <span class="number">0</span> &amp;&amp; !is_alnum(p[<span class="number">6</span>])) &#123;</span><br><span class="line">  tokens[i].ty = TK_RETURN;</span><br><span class="line">  tokens[i].str = p;</span><br><span class="line">  i++;</span><br><span class="line">  p += <span class="number">6</span>;</span><br><span class="line">  <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来，让我们修改解析器，以便它可以解析包含 TK_RETURN 的标记序列。为此，首先添加节点类型 <code>ND_RETURN</code> 来表示 <code>return</code> 语句。接下来，修改读取语句的函数，使其能够解析 <code>return</code> 语句。像往常一样，您可以通过将语法直接映射到函数调用来解析语法。新的 <code>stmt</code> 函数如下所示。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Node *<span class="title function_">stmt</span><span class="params">()</span> &#123;</span><br><span class="line">  Node *node;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (consume(TK_RETURN)) &#123;</span><br><span class="line">    node = <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="keyword">sizeof</span>(Node));</span><br><span class="line">    node-&gt;kind = ND_RETURN;</span><br><span class="line">    node-&gt;lhs = expr();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    node = expr();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!consume(<span class="string">&#x27;;&#x27;</span>))</span><br><span class="line">    error_at(tokens[pos].str, <span class="string">&quot;&#x27;;&#x27;不是令牌&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ND_RETURN</code> 类型节点仅在此处生成，因此我决定使用 <code>malloc</code> 来当场设置值，而不是创建新函数。</p>
<p>最后，修改代码生成器，使其为 <code>ND_RETURN</code> 类型的节点输出适当的汇编代码。新 <code>gen</code> 函数的一部分如下所示。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">gen</span><span class="params">(Node *node)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (node-&gt;kind == ND_RETURN) &#123;</span><br><span class="line">    gen(node-&gt;lhs);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;  pop rax\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;  mov rsp, rbp\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;  pop rbp\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;  ret\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure>

<p>在上面的代码中，函数调用 <code>gen(node-&gt;lhs)</code> 输出的表达式的代码是 <code>return</code> 的返回值。该代码应在堆栈顶部留下一个值。 <code>gen(node-&gt;lhs)</code> 之后的程序集从堆栈中弹出值，将其设置到 RAX 中，然后从函数返回。</p>
<p>上一章之前实现的函数始终在函数末尾输出一条 <code>ret</code> 指令。按照本章所述实现 <code>return</code> 语句将导致为每个 <code>return</code> 语句输出额外的 <code>ret</code> 指令。这些指令可以组合在一起，但为了简单起见，我们决定允许输出多个 <code>ret</code> 指令。此时无需担心这些细节，因此优先考虑实现简单性非常重要。能够编写困难的代码是一项有用的技能，但有时更有用的技能并不是一开始就让代码变得太难。</p>
<p>コラム:  专栏：语法层次结构</p>
<p>“ 正则表达式 “ 通常用于判断输入是否匹配某种规则，但更复杂的语法无法使用正则表达式来表达。例如，原则上不可能编写一个正则表达式来确定字符串中括号是否平衡。</p>
<p>上下文无关语法（可以用 BNF 表示的语法）比正则表达式更强大；例如，它们只能表示带有平衡括号的字符串（BNF 中的 <code>S → SS | &quot;(&quot; S &quot;)&quot; | ε</code> ）。然而，与正则表达式一样，上下文无关语法也有其局限性，上下文无关语法无法表达普通编程语言中出现的复杂规则。例如，规则 “ 变量必须在使用之前声明 “ 是 C 语法的一部分，但这样的规则不能使用上下文无关语法来表达。</p>
<p>如果你编写一个 C 语言编译器，你可以说编译器接受的输入是有效的 C 程序，而它不接受的输入是无效的 C 程序，除非编译器有 bug。也就是说，如果你有普通计算机的能力，就可以判断问题是否符合 C 语法，而编译器整体上可以说是比上下文无关语法更强大的语法判断器。这样，总能用 YES&#x2F;NO 判断是否与该文法匹配的文法称为 Decidable。</p>
<p>您还可以考虑不可判定的语法。例如，问题 “ 当给定一个计算机程序作为输入并执行时，该程序最终执行 <code>exit</code> 函数并退出，还是继续无限期地运行？” 已被证明一般是不可能的在不实际运行程序的情况下确定是&#x2F;否（假设您在具有无限内存的虚拟计算机上运行它）。换句话说，对于程序是否会停止的问题，如果程序停止，你可以回答 “ 是 “，但不能回答 “ 否 “，因为如果程序不停止，它就会无限期地继续运行。</p>
<p>这样，决策机不仅有可能返回 YES&#x2F;NO，而且决策机没有完成执行的一类文法称为图灵可识别的。</p>
<p>换句话说，存在语法层次结构：正则表达式 &lt; 上下文无关语法 &lt; 可判定 &lt; 图灵可识别。这些语法层次结构作为计算机科学的一部分得到了广泛的研究。著名的未解决问题 P≟NP 也是一个与语法层次结构相关的问题。</p>
<h2 id="1973年C编译器"><a href="#1973年C编译器" class="headerlink" title="1973年C编译器"></a><a href="#%E5%B9%B4%E3%81%AEc%E3%82%B3%E3%83%B3%E3%83%91%E3%82%A4%E3%83%A9">1973年C编译器</a></h2><p>到目前为止，我们一直在逐步构建编译器。从某种意义上来说，这个发展过程可以说是追随了 C 的历史。</p>
<p>如果你看看当前版本的 C，你会发现有些部分没有多大意义或者不必要地复杂，但如果不回顾历史就无法理解这些东西。当您阅读早期的 C 代码并查看 C 的早期形式以及该语言和编译器的后续发展时，当前 C 的许多令人困惑的方面开始变得有意义。</p>
<p>C 于 1972 年作为 Unix 语言开发。 1972 年或 1973 年（C 历史上非常早期的时期）的源代码保留在磁带上，从中读取的文件发布在 Internet 上。我们看一下当时 C 编译器的代码。下面是一个函数，它接收 <code>printf</code> 格式的消息并将其打印为编译错误消息。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">error(s, p1, p2) &#123;</span><br><span class="line">  <span class="keyword">extern</span> <span class="built_in">printf</span>, line, fout, flush, <span class="built_in">putchar</span>, nerror;</span><br><span class="line">  <span class="type">int</span> f;</span><br><span class="line"></span><br><span class="line">  nerror++;</span><br><span class="line">  flush();</span><br><span class="line">  f = fout;</span><br><span class="line">  fout = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d: &quot;</span>, line);</span><br><span class="line">  <span class="built_in">printf</span>(s, p1, p2);</span><br><span class="line">  <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">  fout = f;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它看起来有点奇怪，类似 C，非 C 语言。那时的 C 就是这样一种语言。当你阅读这段代码时，你首先注意到的是，就像我们创建的编译器的早期版本一样，函数返回值或参数没有类型。这里，s 是一个指向字符串的指针， <code>p1</code> 和 <code>p2</code> 应该是整数，但在当时的机器上它们的大小都是相同的，所以像这样的变量是没有类型。</p>
<p>第二行包含 <code>error</code> 引用的全局变量和函数的声明。当时，C 编译器没有头文件或 C 预处理器，因此程序员必须通过这种方式告诉编译器变量和函数的存在。</p>
<p>与我们当前的编译器一样，函数仅检查名称是否存在，而不检查参数的类型或数量是否匹配。将预期数量的参数放入堆栈后，他们可以跳转到函数体，函数调用就会成功，所以他们可能认为这样就可以了。</p>
<p><code>fout</code> 是一个全局变量，保存输出文件描述符的编号。此时， <code>fprintf</code> 还不存在，为了将字符串写入标准错误而不是标准输出，需要通过全局变量切换输出目的地。</p>
<p>在 <code>error</code> 内部， <code>printf</code> 被调用两次。第二个 printf 除了格式字符串之外还传递两个值。那么，当显示仅包含一个值的错误消息时，您该怎么办？</p>
<p>事实上，即使您只是强制它使用更少的参数，这个 <code>error</code> 函数也可以正常工作。回想一下，此时函数参数检查还不存在。像 <code>s</code> 、 <code>p1</code> 、 <code>p2</code> 这样的参数只是指向堆栈指针中的第 1 个、第 2 个和第 3 个字，但实际上 <code>p2</code> 的值。 <code>printf</code> 访问的额外参数等于第一个参数字符串中包含的 <code>%d</code> 和 <code>%s</code> 的数量，因此 <code>%d</code> 永远不会被访问。因此，即使参数数量不匹配也没有问题。</p>
<p>这样看来，早期的 C 编译器与现在的 9cc 有很多相似之处。</p>
<p>让我们看另一个代码示例。下面的代码是一个函数，它将传递的字符串复制到静态分配的区域中，并返回指向该区域开头的指针。换句话说，这是一个像 <code>strdup</code> 这样使用静态空间的函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">copy(s)</span><br><span class="line"><span class="type">char</span> s[]; &#123;</span><br><span class="line">  <span class="keyword">extern</span> tsp;</span><br><span class="line">  <span class="type">char</span> tsp[], otsp[];</span><br><span class="line"></span><br><span class="line">  otsp = tsp;</span><br><span class="line">  <span class="keyword">while</span>(*tsp++ = *s++);</span><br><span class="line">  <span class="keyword">return</span>(otsp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当时，还没有设计出 <code>int *p</code> 形式的声明语法。相反，指针类型被声明为 <code>int p[]</code> 。函数参数列表和函数体之间有类似变量定义的东西，但这是将 <code>s</code> 声明为指针类型。</p>
<p>关于这个早期的 C 编译器，还有一些值得一提的事情。</p>
<ul>
<li>此时该结构还不存在。</li>
<li><code>&amp;&amp;</code> 和 <code>||</code> 等运算符尚不可用。此时， <code>&amp;</code> 和 <code>|</code> 是上下文相关的，因为它们仅在 <code>if</code> 等条件表达式中才成为逻辑运算符。</li>
<li><code>+=</code> 等运算符被写为 <code>=+</code> 。在此语法中，如果您打算将 -1 分配给 <code>i</code> 并写入不带空格的 <code>i=-1</code> ，它将被解释为 <code>i =- 1</code> 。存在一个问题： <code>i</code> 将会递减，这是一种意外行为。</li>
<li>唯一的整数类型是 char 和 int；short 和 long 不存在。没有用于声明类型（例如 “ 函数指针数组 “）的语法，并且不可能编写复杂类型。</li>
</ul>
<p>除了上述之外，20 世纪 70 年代初期的 C 还缺乏各种特性。然而，这个 C 编译器是用 C 编写的，从上面的源代码可以看出。在结构出现之前，C 就已经是自托管的了。</p>
<p>通过查看旧的源代码，您还可以推断出为什么 C 的某些令人困惑的语法最终会变成当前的形式。如果变量名称始终位于 <code>extern</code> 或 <code>auto</code> 或 <code>int</code> 或 <code>char</code> 之后，则解析变量定义很容易。 <code>[]</code> 代表一个指针，如果它简单地跟在变量名后面，也很容易解析。然而，很明显，如果这种语法沿着早期编译器中看到的路线发展，它最终会以目前不必要的复杂形式出现。</p>
<p>嗯，Unix 和 C 的共同发明者 Dennis Ritchie 在 1973 年左右所做的事情是真正的增量开发。他一边开发 C 语言本身，一边使用 C 语言编写编译器。当前版本的 C 并不是某种随着语言不断添加功能而达到特殊点的成品，而只是在丹尼斯·里奇 (Dennis Ritchie) 认为该语言具有足够功能时作为一种语言完成的。这就是发生的事情。</p>
<p>即使有了我们的编译器，我们也从一开始就没有追求完整的版本。 C 的完整形式没有任何特殊含义，因此可能没有必要专门追求它。在任何时间点继续开发一种具有合理特性集的语言，并最终将其转换为 C，是原始 C 编译器使用的历史悠久的开发方法。让我们满怀信心、继续发展！</p>
<p>コラム: 专栏：Rob Pike 的 5 条编程规则</p>
<p>9cc 受到 Rob Pike 编程哲学的影响。 Rob Pike 是 Dennis Ritchie 的前同事，Dennis Ritchie 是 C 语言的创建者、Go 语言的创建者，并且与 Unix 的创建者 Ken Thompson 共同创建了 Unicode 的 UTF-8。</p>
<p>我引用 Rob Pike 的 5 条编程规则。</p>
<ol>
<li><p>无法预测程序的哪些部分将占用时间。瓶颈出现在令人惊讶的地方，因此在知道它们在哪里之前，不要试图猜测它们在哪里并添加性能技巧。</p>
</li>
<li><p>测量一下。在测量之前不要尝试优化。另外，即使您测量了它，也不要尝试优化代码中速度极慢的部分以外的任何内容。</p>
</li>
<li><p>当 n 很小时，花哨的算法会很慢，而且 n 通常也很小。复杂的算法有大量的常数部分。除非您知道 n 通常很大，否则不要变得复杂。 （即使 n 很大，也先应用规则 2。）</p>
</li>
<li><p>复杂的算法比简单的算法更容易出现错误并且更难实现。应使用简单的算法和数据结构。</p>
</li>
<li><p>数据才是最重要的。如果您选择正确的数据结构并很好地表示您的数据，您的算法几乎总是微不足道的。编程的核心是数据结构，而不是算法。</p>
</li>
</ol>
<h2 id="第-12-步：添加控制结构"><a href="#第-12-步：添加控制结构" class="headerlink" title="第 12 步：添加控制结构"></a><a href="#%E3%82%B9%E3%83%86%E3%83%83%E3%83%9712-%E5%88%B6%E5%BE%A1%E6%A7%8B%E6%96%87%E3%82%92%E8%B6%B3%E3%81%99">第 12 步：添加控制结构</a></h2><p>在本节中，我们将向语言添加以下控制结构： <code>if</code> 、 <code>if … else</code> 、 <code>while</code> 和 <code>for</code> 。尽管这些控制结构乍一看似乎很复杂，但当直接编译成汇编时，它们相对容易实现。</p>
<p>由于汇编中没有与 C 控制结构相对应的内容，因此 C 控制结构在汇编中由分支指令和标签表示。从某种意义上来说，这与使用 <code>goto</code> 重写控制结构是一样的。正如人类可以手动将控制结构重写为 <code>goto</code> 语句一样，只需根据模式生成代码即可轻松实现控制结构。</p>
<p>还有各种其他控制语法，例如 <code>do … while</code> 、 <code>goto</code> 、 <code>continue</code> 和 <code>break</code> ，但它们不需要实现现在还没有。</p>
<p>添加了 <code>if</code> 、 <code>while</code> 和 <code>for</code> 的新语法如下所示。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">program = stmt*</span><br><span class="line">stmt    = expr &quot;;&quot;</span><br><span class="line">        | &quot;if&quot; &quot;(&quot; expr &quot;)&quot; stmt (&quot;else&quot; stmt)?</span><br><span class="line">        | &quot;while&quot; &quot;(&quot; expr &quot;)&quot; stmt</span><br><span class="line">        | &quot;for&quot; &quot;(&quot; expr? &quot;;&quot; expr? &quot;;&quot; expr? &quot;)&quot; stmt</span><br><span class="line">        | ...</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>在读取 <code>expr? &quot;;&quot;</code> 时，我们向前看一个 token，并假设如果下一个 token 是 <code>;</code> 则 <code>expr</code> 不存在，否则 &lt; 可以读取 b3&gt;&lt; &#x2F;b3&gt; 等等。</p>
<p><code>if (A) B</code> 编译成如下所示的程序集：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  A编译后的代码 // スタックトップに結果が入っているはず</span><br><span class="line">  pop rax</span><br><span class="line">  cmp rax, 0</span><br><span class="line">  je  .LendXXX</span><br><span class="line">  B编译后的代码</span><br><span class="line">.LendXXX:</span><br></pre></td></tr></table></figure>

<p> 所以 <code>if (A) B</code> 是</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  if (A == 0)</span><br><span class="line">    goto end;</span><br><span class="line">  B;</span><br><span class="line">end:</span><br></pre></td></tr></table></figure>

<p>将以同样的方式进行扩展。确保 <code>XXX</code> 是序列号或类似的内容，以便所有标签都是唯一的。</p>
<p><code>if (A) B else C</code> 编译成如下所示的程序集：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">  A编译后的代码 // スタックトップに結果が入っているはず</span><br><span class="line">  pop rax</span><br><span class="line">  cmp rax, 0</span><br><span class="line">  je  .LelseXXX</span><br><span class="line">  B编译后的代码</span><br><span class="line">  jmp .LendXXX</span><br><span class="line">.LelseXXX</span><br><span class="line">  C编译后的代码</span><br><span class="line">.LendXXX</span><br></pre></td></tr></table></figure>

<p>即， <code>if (A) B else C</code> 展开如下。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  if (A == 0)</span><br><span class="line">    goto els;</span><br><span class="line">  B;</span><br><span class="line">  goto end;</span><br><span class="line">els:</span><br><span class="line">  C;</span><br><span class="line">end:</span><br></pre></td></tr></table></figure>

<p>读取 <code>if</code> 语句时，先读一个标记并检查 <code>else</code> 是否存在，如果存在 <code>else</code> ，则检查 <code>if … else</code> ，否则编译为 <code>if</code> ，不带 <code>else</code> 。</p>
<p>像这样编译 <code>while (A) B</code> ：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.LbeginXXX:</span><br><span class="line">  A编译后的代码</span><br><span class="line">  pop rax</span><br><span class="line">  cmp rax, 0</span><br><span class="line">  je  .LendXXX</span><br><span class="line">  B编译后的代码</span><br><span class="line">  jmp .LbeginXXX</span><br><span class="line">.LendXXX:</span><br></pre></td></tr></table></figure>

<p>换句话说， <code>while (A) B</code> 被扩展为如下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">begin:</span><br><span class="line">  if (A == 0)</span><br><span class="line">    goto end;</span><br><span class="line">  B;</span><br><span class="line">  goto begin;</span><br><span class="line">end:</span><br></pre></td></tr></table></figure>

<p>像这样编译 <code>for (A; B; C) D</code> ：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">  A编译后的代码</span><br><span class="line">.LbeginXXX:</span><br><span class="line">  B编译后的代码</span><br><span class="line">  pop rax</span><br><span class="line">  cmp rax, 0</span><br><span class="line">  je  .LendXXX</span><br><span class="line">  D编译后的代码</span><br><span class="line">  C编译后的代码</span><br><span class="line">  jmp .LbeginXXX</span><br><span class="line">.LendXXX:</span><br></pre></td></tr></table></figure>

<p><code>for (A; B; C) D</code> 对应的 C 代码如下所示。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  A;</span><br><span class="line">begin:</span><br><span class="line">  if (B == 0)</span><br><span class="line">    goto end;</span><br><span class="line">  D;</span><br><span class="line">  C;</span><br><span class="line">  goto begin;</span><br><span class="line">end:</span><br></pre></td></tr></table></figure>

<p>请注意，以 <code>.L</code> 开头的标签会被汇编器特别识别，并自动成为文件范围。文件范围标签可以从同一文件内引用，但不能从其他文件引用。因此，如果使 <code>if</code> 和 <code>for</code> 的编译器生成的标签从 <code>.L</code> 开始，则其他文件中包含的标签就无需担心冲突。</p>
<p>使用 cc 编译一个小循环并使用程序集作为参考。</p>
<p>コラム:  专栏：编译器检测运行时错误</p>
<p>当用 C 语言编写程序时，通常会在数组末尾写入数据，或者由于指针错误而损坏不相关的数据结构。这些错误也可能成为安全漏洞，因此我们的想法是在编译器的帮助下在运行时主动检测错误。</p>
<p>例如，如果将 <code>-fstack-protector</code> 选项传递给 GCC，则编译后的函数将向序言中的函数框架输出一个称为 “ 金丝雀 “ 的随机指针大小的整数，并且金丝雀将打印在尾声。这将确认该值没有改变。这样，如果堆栈的内容由于数组缓冲区溢出而在不知不觉中被覆盖，则金丝雀值几乎肯定会发生变化，因此可以在函数返回时检测到错误。如果检测到错误，程序通常会立即终止。</p>
<p>LLVM 有一个叫做 TSan (ThreadSanitizer) 的东西，它可以输出代码，在运行时检测多个线程在没有正确保护锁的情况下访问共享数据结构。此外，LLVM 的 UBSan (UndefinedBehaviorSanitizer) 可以输出代码，在运行时检测您是否无意中踩到了 C 中的未定义行为。例如，有符号整数溢出在 C 中是未定义的行为，因此如果发生有符号整数溢出，UBSan 将报告错误。</p>
<p>由于 TSan 等会使程序速度变慢数倍，因此将其添加到经常使用的程序的编译选项中是不合理的，但诸如堆栈金丝雀之类的运行成本相对较低的功能可以根据环境使用。默认情况下它可能处于打开状态。</p>
<p>近年来，借助此类编译器的动态错误检测得到了积极的研究，并且为使用 C 和 C++ 等非内存安全语言编写相当安全的程序做出了巨大贡献。</p>
<h2 id="第13步：块"><a href="#第13步：块" class="headerlink" title="第13步：块"></a><a href="#%E3%82%B9%E3%83%86%E3%83%83%E3%83%9713-%E3%83%96%E3%83%AD%E3%83%83%E3%82%AF">第13步：块</a></h2><p>此步骤支持 “ 块 “，允许您在 <code>&#123; … &#125;</code> 之间编写多个语句。块的正式名称是复合语句，但由于它的单词很长，所以通常简称为块。</p>
<p>块具有将多个语句组合成单个语句的作用。上面步骤中实现的 <code>if</code> 和 <code>while</code> 只允许在条件表达式为 true 时执行一条语句，但是在这一步中你可以通过实现它，你将能够像在 C 语言中一样，编写用 <code>&#123;&#125;</code> 括起来的多个语句。</p>
<p>函数体实际上也是一个块。语法上要求函数体必须是一个块。函数定义中的 <code>&#123; … &#125;</code> 实际上在语法上与 <code>if</code> 或 <code>while</code> 之后编写的 <code>&#123; … &#125;</code> 相同。</p>
<p> 添加块的语法如下所示。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">program = stmt*</span><br><span class="line">stmt    = expr &quot;;&quot;</span><br><span class="line">        | &quot;&#123;&quot; stmt* &quot;&#125;&quot;</span><br><span class="line">        | ...</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>在此语法中，如果 <code>stmt</code> 以 <code>&quot;&#123;&quot;</code> 开头，则将出现零个或多个 <code>stmt</code> ，直到 <code>&quot;&#125;&quot;</code> 出现。这是一件好事。要解析 <code>stmt* &quot;&#125;&quot;</code> ，请在 <code>while</code> 语句中重复调用 <code>stmt</code> ，直到出现 <code>&quot;&#125;&quot;</code> ，并将结果存储在向量中。请返回它作为</p>
<p>要实现块，请添加代表该块的节点类型 <code>ND_BLOCK</code> 。表示节点的结构 <code>Node</code> 必须使用包含块中包含的表达式的向量进行填充。如果节点的类型为 <code>ND_BLOCK</code> ，则代码生成器应按顺序为节点中包含的语句生成代码。请注意，每个语句都会在堆栈上留下一个值，因此不要忘记每次都将其弹出。</p>
<h2 id="第14步：响应函数调用"><a href="#第14步：响应函数调用" class="headerlink" title="第14步：响应函数调用"></a><a href="#%E3%82%B9%E3%83%86%E3%83%83%E3%83%9714-%E9%96%A2%E6%95%B0%E3%81%AE%E5%91%BC%E3%81%B3%E5%87%BA%E3%81%97%E3%81%AB%E5%AF%BE%E5%BF%9C%E3%81%99%E3%82%8B">第14步：响应函数调用</a></h2><p>此步骤的目标是能够识别没有参数的函数调用，例如 <code>foo()</code> 并将其编译为 <code>call foo</code> 。</p>
<p> 函数调用的新语法如下所示。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">primary = num</span><br><span class="line">        | ident (&quot;(&quot; &quot;)&quot;)?</span><br><span class="line">        | &quot;(&quot; expr &quot;)&quot;</span><br></pre></td></tr></table></figure>

<p>读取 <code>ident</code> 后向前看一个标记，您可以判断 <code>ident</code> 是变量名还是函数名。</p>
<p>为了进行测试，请准备一个包含 <code>int foo() &#123; printf(&quot;OK\n&quot;); &#125;</code> 等内容的 C 文件，将其编译为包含 <code>cc -c</code> 的目标文件，并将其与编译器的输出链接。通过这样做，您应该能够在整体上正确链接，并且您应该能够确认您要调用的函数被正确调用。</p>
<p>一旦成功，下一步就是能够编写像 <code>foo(3, 4)</code> 这样的函数调用。无需检查参数的数量或类型。通过简单地按顺序评估参数，将在堆栈上创建要传递给函数的参数，因此我们可以按照 x86-64 ABI 指定的顺序将它们复制到寄存器并调用该函数。不需要支持超过 6 个参数。</p>
<p>为了进行测试，就像上面一样，您应该能够准备一个像 <code>int foo(int x, int y) &#123; printf(&quot;%d\n&quot;, x + y); &#125;</code> 这样的函数，并通过链接它来检查它的操作。</p>
<p>x86-64 函数调用 ABI 很简单（只要遵循上面的方法），但有一个警告。在调用函数之前，RSP 必须是 16 的倍数。由于 <code>push</code> 和 <code>pop</code> 以 8 字节为单位改变 RSP，因此在发出 <code>call</code> 指令时 RSP 不一定必须是 16 的倍数。限制。如果不遵守这一承诺，假设 RSP 为 16 的倍数的函数将遭受一种神秘现象，即它们只有一半的时间会失败。确保在调用该函数之前调整 RSP，使其成为 16 的倍数。</p>
<h2 id="第-15-步：解决函数定义问题"><a href="#第-15-步：解决函数定义问题" class="headerlink" title="第 15 步：解决函数定义问题"></a><a href="#%E3%82%B9%E3%83%86%E3%83%83%E3%83%9715-%E9%96%A2%E6%95%B0%E3%81%AE%E5%AE%9A%E7%BE%A9%E3%81%AB%E5%AF%BE%E5%BF%9C%E3%81%99%E3%82%8B">第 15 步：解决函数定义问题</a></h2><p>完成此操作后，我们现在可以定义该函数。然而，C 函数定义很难解析，所以我不会一次全部实现它们。目前，我们的语言只有 int 类型，因此我们实现了 <code>foo(x, y) &#123; … &#125;</code> 语法，而不是 <code>int foo(int x, int y) &#123; … &#125;</code> 语法，该语法省略了类型名称。</p>
<p>被调用方需要能够使用 <code>x</code> 和 <code>y</code> 等名称来访问参数，但目前还无法通过名称直接访问寄存器中传递的值。 。要做的就是像 <code>x</code> 和 <code>y</code> 这样的局部变量存在一样进行编译，并在函数的序言中设置该局部变量的寄存器值。将其写入堆栈上的区域。之后，您应该能够毫无区别地处理参数和局部变量。</p>
<p>到目前为止，行为与用 <code>main() &#123; … &#125;</code> 隐式包围整个事物相同，但这种情况将被废除，所有代码都将编写在某个函数内。然后，在解析顶层时，当您首先读取标记时，它始终是函数名称，然后是参数列表，然后是函数体。易于阅读。</p>
<p>完成此步骤后，您将能够使用递归计算并显示斐波那契数列，这应该会使其变得更有趣。</p>
<h2 id="二进制级接口"><a href="#二进制级接口" class="headerlink" title="二进制级接口"></a><a href="#%E3%83%90%E3%82%A4%E3%83%8A%E3%83%AA%E3%83%AC%E3%83%99%E3%83%AB%E3%81%AE%E3%82%A4%E3%83%B3%E3%82%BF%E3%83%BC%E3%83%95%E3%82%A7%E3%82%A4%E3%82%B9">二进制级接口</a></h2><p>C 语言规范定义了源代码级别的规范。例如，语言规范指定如何定义函数，以及应包含哪些文件来声明哪些函数。另一方面，语言规范并没有规定为符合标准而编写的源代码将被转换成哪种机器语言。这是有道理的，因为 C 语言标准并不是根据任何特定的指令集来确定的。</p>
<p>因此，乍一看似乎没有必要明确确定机器语言级别的规范，但实际上，每个平台在某种程度上都确定了规范。该规范称为 ABI（应用程序二进制接口）。</p>
<p>到目前为止，本书中调用函数的方式意味着参数以特定顺序放置在寄存器中。此外，返回值承诺设置为 RAX。这些如何调用函数的规则称为 “ 函数调用约定 “。函数调用约定是 ABI 的一部分。</p>
<p>除了如何传递参数和返回值之外，C 语言 ABI 还包括以下内容：</p>
<ul>
<li>被函数调用改变的寄存器和没有改变的寄存器（RBP 等在返回前都恢复到原来的值，但有些寄存器不需要恢复到原来的值）</li>
<li><code>int</code> 和 <code>long</code> 等类型的大小</li>
<li>结构布局规则（结构成员在内存中实际排列的规则）</li>
<li>位域布局规则（例如，位域应该从最低有效位开始排列还是从最高有效位开始排列？）</li>
</ul>
<p>ABI 只是软件层面的约定，所以有可能想到与本书中解释的不同的东西，但是不兼容 ABI 的代码不能互相调用和使用，所以基本上，CPU 供应商和 OS 供应商定义平台标准 ABI。有两种广泛使用的 x86-64 系统：System V ABI（用于 Unix 和 macOS）和 Microsoft ABI（用于 Windows）。请注意，这两个调用约定并不是必然分开的，而只是不同的人创建了单独的约定。</p>
<p>到目前为止，在本书中，我们已经使用自己的编译器来调用用另一个编译器编译的函数。这是可能的，因为我们的 C 编译器和另一个编译器具有相同的 ABI。</p>
<hr>
<h1 id="指针和字符串文字"><a href="#指针和字符串文字" class="headerlink" title="指针和字符串文字"></a><a href="#%E3%83%9D%E3%82%A4%E3%83%B3%E3%82%BF%E3%81%A8%E6%96%87%E5%AD%97%E5%88%97%E3%83%AA%E3%83%86%E3%83%A9%E3%83%AB">指针和字符串文字</a></h1><p>在前面的章节中，我们开发了一种可以执行有意义的计算的语言，但是我们的语言仍然无法显示 <code>Hello world</code> 。是时候添加一些字符串以便程序可以输出有意义的消息了。</p>
<p>C 字符串文字与 <code>char</code> 类型、全局变量和数组密切相关。以以下函数为例。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Hello, world!\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码将以与下面的代码相同的方式编译。但是， <code>msg</code> 是一个唯一标识符，不会与其他标识符重叠。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> msg[<span class="number">15</span>] = <span class="string">&quot;Hello, world!\n&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> &#123;</span><br><span class="line">  <span class="built_in">printf</span>(msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们的编译器仍然缺乏一些支持字符串文字的功能。在本章中，我们将按顺序实现以下函数，以便我们可以支持字符串文字并使用 <code>printf</code> 等显示消息。</p>
<ol>
<li><p>一元 <code>&amp;</code> 和一元 <code>*</code></p>
</li>
<li><p> 指针</p>
</li>
<li><p> 大批</p>
</li>
<li><p> 全局变量</p>
</li>
<li><p> 字符类型</p>
</li>
<li><p> 字符串字面量</p>
</li>
</ol>
<p>我们还将在本章中添加测试上述功能所需的功能。</p>
<h2 id="步骤-16：一元-amp-和一元"><a href="#步骤-16：一元-amp-和一元" class="headerlink" title="步骤 16：一元 &amp; 和一元 *"></a><a href="#%E3%82%B9%E3%83%86%E3%83%83%E3%83%9716-%E5%8D%98%E9%A0%85%E3%81%A8%E5%8D%98%E9%A0%85">步骤 16：一元 &amp; 和一元 *</a></h2><p>在此步骤中，实现指针的第一步是实现返回地址的一元 <code>&amp;</code> 和引用地址的一元 <code>*</code> 。</p>
<p>这些运算符最初是返回或获取指针类型值的运算符，但由于我们的编译器还没有除整数之外的任何类型，因此我们用整数类型替换指针类型。我会决定。也就是说， <code>&amp;x</code> 将变量 <code>x</code> 的地址仅作为整数返回。另外， <code>*x</code> 是将 <code>x</code> 的值视为地址并从该地址读取值的操作。</p>
<p>实现这样的运算符允许如下代码工作：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x = 3;</span><br><span class="line">y = &amp;x;</span><br><span class="line">return *y; // 3を返す</span><br></pre></td></tr></table></figure>

<p>此外，利用局部变量在内存中连续分配的事实，还可以通过指针间接强制访问堆栈上的变量。下面的代码假设变量 <code>x</code> 位于堆栈上变量 <code>y</code> 上方 8 个字节。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x = 3;</span><br><span class="line">y = 5;</span><br><span class="line">z = &amp;y + 8;</span><br><span class="line">return *z; // 3を返す</span><br></pre></td></tr></table></figure>

<p>在这种不区分指针类型和整数类型的实现中，例如，表达式 <code>*4</code> 将是从地址 4 读取值的表达式，但我们假设现在这样就可以了。</p>
<p>实施相对容易。添加一元 <code>&amp;</code> 和一元 <code>*</code> 的语法如下所示。根据此语法修改解析器，将一元 <code>&amp;</code> 和一元 <code>*</code> 分别读取为 <code>ND_ADDR</code> 和 <code>ND_DEREF</code> 类型的节点。请如此。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">unary = &quot;+&quot;? primary</span><br><span class="line">      | &quot;-&quot;? primary</span><br><span class="line">      | &quot;*&quot; unary</span><br><span class="line">      | &quot;&amp;&quot; unary</span><br></pre></td></tr></table></figure>

<p>代码生成器的更改很少。下面列出了这些更改。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> ND_ADDR:</span><br><span class="line">  gen_lval(node-&gt;lhs);</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">case</span> ND_DEREF:</span><br><span class="line">  gen(node-&gt;lhs);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;  pop rax\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;  mov rax, [rax]\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;  push rax\n&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span>;</span><br></pre></td></tr></table></figure>

<h2 id="第17步：消除隐式变量定义并引入-int-关键字"><a href="#第17步：消除隐式变量定义并引入-int-关键字" class="headerlink" title="第17步：消除隐式变量定义并引入 int 关键字"></a><a href="#%E3%82%B9%E3%83%86%E3%83%83%E3%83%9717-%E6%9A%97%E9%BB%99%E3%81%AE%E5%A4%89%E6%95%B0%E5%AE%9A%E7%BE%A9%E3%82%92%E5%BB%83%E6%AD%A2%E3%81%97%E3%81%A6int%E3%81%A8%E3%81%84%E3%81%86%E3%82%AD%E3%83%BC%E3%83%AF%E3%83%BC%E3%83%89%E3%82%92%E5%B0%8E%E5%85%A5%E3%81%99%E3%82%8B">第17步：消除隐式变量定义并引入 int 关键字</a></h2><p>到目前为止，所有变量和函数返回值都隐式设置为 int。因此，我们没有麻烦地用类型名称来定义变量，例如 <code>int x;</code> ，并假设所有新标识符都是新的变量名称。你不能再做出这样的假设。那么，我们首先修改这一点。请实现以下功能。</p>
<ul>
<li>不要将新标识符视为变量名，并将未定义的变量标记为错误。</li>
<li>请务必以 <code>int x;</code> 格式定义变量。无需支持 <code>int x = 3;</code> 等初始化表达式。同样，我们不需要像 <code>int x, y;</code> 这样的东西。只实施最简单的事情。</li>
<li>到目前为止，函数都是以 <code>foo(x, y)</code> 的形式编写的，但我们将它们修改为 <code>int foo(int x, int y)</code> 的形式。目前，顶层应该只有函数定义，因此解析器首先读取 <code>int</code> ，然后按应有的方式读取函数名称，然后读取列 <code>int &lt;引数の名前&gt;</code> 。意味着阅读。不需要支持任何更困难的语法，也不需要做任何事情只是为了 “ 为未来的扩展做准备 “。只需编写足够的代码来读取 “int &lt;函数名称&gt;(&lt;由重复 int &lt;变量名称组成的参数列表&gt;&gt;)”。</li>
</ul>
<h2 id="第18步：引入指针类型"><a href="#第18步：引入指针类型" class="headerlink" title="第18步：引入指针类型"></a><a href="#%E3%82%B9%E3%83%86%E3%83%83%E3%83%9718-%E3%83%9D%E3%82%A4%E3%83%B3%E3%82%BF%E5%9E%8B%E3%82%92%E5%B0%8E%E5%85%A5%E3%81%99%E3%82%8B">第18步：引入指针类型</a></h2><h3 id="定义一个表示指针的类型"><a href="#定义一个表示指针的类型" class="headerlink" title="定义一个表示指针的类型"></a><a href="#%E3%83%9D%E3%82%A4%E3%83%B3%E3%82%BF%E3%82%92%E8%A1%A8%E3%81%99%E5%9E%8B%E3%82%92%E5%AE%9A%E7%BE%A9%E3%81%99%E3%82%8B">定义一个表示指针的类型</a></h3><p>在此步骤中，以前仅允许在类型名称中使用 <code>int</code> ，但现在允许在 <code>int</code> 后跟零个或多个 <code>*</code> 作为类型名称。也就是说，它允许解析诸如 <code>int *x</code> 和 <code>int ***x</code> 之类的定义。</p>
<p>当然，诸如 “ 指向 int 的指针 “ 之类的类型必须由编译器处理。例如，如果变量 <code>x</code> 是指向 int 的指针，则编译器必须知道表达式 <code>*x</code> 的类型为 int。由于类型可以像您想要的那样复杂，例如 “ 指向 int 的指针的指针 “，因此不能仅用固定大小的类型来表达。</p>
<p>所以我们要做的就是使用指针。到目前为止，通过映射与变量关联的唯一信息是距堆栈上基指针 (RBP) 的偏移量。更改此设置以便您可以拥有变量类型。粗略地说，变量类型应该是如下结构。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Type</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">enum</span> &#123;</span> INT, PTR &#125; ty;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Type</span> *<span class="title">ptr_to</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这里 <code>ty</code> 可以有两个值之一：int 类型或 “ 指向 “ 类型的指针。仅当 <code>ty</code> 的类型为 “ 指向 “ 的指针时， <code>ptr_to</code> 才是有意义的成员，在这种情况下，它包含指向 “ Put 所指向的 Type 对象的指针 “。例如，对于 “ 指向 int 的指针 “，表示该类型的数据结构内部如下。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../../img/blog/a646a0bc04bdbaea4703ac333d649f82_MD5.svg"></p>
<p> 表示指向 int 的指针的数据结构</p>
<p>如果它是一个 “ 指向 int 指针的指针 “，它将如下所示：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../../img/blog/ab8b4213a762b079860fb603db4db2b0_MD5.svg"></p>
<p> 表示指向 int 的指针的数据结构</p>
<p>通过这种方式，可以在编译器内表达任意数量的困难类型。</p>
<h3 id="赋值给指针所指向的值"><a href="#赋值给指针所指向的值" class="headerlink" title="赋值给指针所指向的值"></a><a href="#%E3%83%9D%E3%82%A4%E3%83%B3%E3%82%BF%E3%81%8C%E6%8C%87%E3%81%97%E3%81%A6%E3%81%84%E3%82%8B%E5%80%A4%E3%81%AB%E4%BB%A3%E5%85%A5%E3%81%99%E3%82%8B">赋值给指针所指向的值</a></h3><p>如何编译赋值表达式左侧不是简单变量名（例如 <code>*p=3</code> ）的表达式？这些表达式的基本概念与左侧为简单变量时相同。在这种情况下，您可以将 <code>*p</code> 编译为左值，以便生成 <code>p</code> 的地址。</p>
<p>当编译表示 <code>*p=3</code> 的语法树时，代码会沿着树递归生成，但首先调用的是 <code>*p</code> 作为左值。用于编译的代码生成器。</p>
<p>代码生成器将根据给定语法树的类型进行分支。对于一个简单的变量，如上所述，我们将输出输出该变量地址的代码，但这里我们给出了一个解引用运算符，所以我们需要做一些不同的事情。如果给出了解引用运算符，则将其中的语法树编译为 “ 右值 “。然后它应该编译成计算某个地址的代码（否则您无法取消引用该结果）。然后你可以将该地址留在堆栈上。</p>
<p>完成此步骤后，您应该能够编译如下语句：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x;</span><br><span class="line"><span class="type">int</span> *y;</span><br><span class="line">y = &amp;x;</span><br><span class="line">*y = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">return</span> x; <span class="comment">// → 3</span></span><br></pre></td></tr></table></figure>

<h2 id="第19步：实现指针加法和减法"><a href="#第19步：实现指针加法和减法" class="headerlink" title="第19步：实现指针加法和减法"></a><a href="#%E3%82%B9%E3%83%86%E3%83%83%E3%83%9719-%E3%83%9D%E3%82%A4%E3%83%B3%E3%82%BF%E3%81%AE%E5%8A%A0%E7%AE%97%E3%81%A8%E6%B8%9B%E7%AE%97%E3%82%92%E5%AE%9F%E8%A3%85%E3%81%99%E3%82%8B">第19步：实现指针加法和减法</a></h2><p>在此步骤中，我们将能够为指针值 <code>p</code> 编写诸如 <code>p+1</code> 和 <code>p-5</code> 之类的表达式。虽然这看起来像是简单的整数加法，但实际上是完全不同的运算。 <code>p+1</code> 并不意味着将 <code>p</code> 所保存的地址加 1，而是使其成为指向 <code>p</code> 的下一个元素的指针。这意味着必须将指针指向的数据类型添加到 <code>p</code> 中。例如，如果 <code>p</code> 指向 int，根据我们的 ABI， <code>p+1</code> 将添加 4 作为地址中的字节数。另一方面，如果 <code>p</code> 是指向 int 的指针，则 <code>p+1</code> 将加 8。</p>
<p>因此，在添加或减去指针时，您需要一种方法来知道类型的大小，但目前 int 为 4，指针为 8，所以请这样编写代码。</p>
<p>由于现阶段我们还没有办法分配连续内存（我们的编译器还没有数组），因此编写测试有点困难。您可以简单地寻求外部编译器的帮助，在那里进行 malloc，并使用编译器输出中的帮助器函数编写测试。例如，您可以像这样测试它。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int *p;</span><br><span class="line">alloc4(&amp;p, 1, 2, 4, 8);</span><br><span class="line">int *q;</span><br><span class="line">q = p + 2;</span><br><span class="line">*q;  // → 4</span><br><span class="line">q = p + 3;</span><br><span class="line">return *q;  // → 8</span><br></pre></td></tr></table></figure>

<p>コラム:  列：int 或 long 的大小</p>
<p>像 x86-64 System V ABI 这样的数据模型（其中 int 为 32 位、long 和指针为 64 位）称为 LP64。这意味着长整型和指针都是 64 位。即使在 x86-64 上具有相同的 ABI，Windows 也使用 LLP64，这是一种数据模型，其中 int 和 long 为 32 位，long long 和指针为 64 位。</p>
<p>LP64 和 LLP64 不兼容 ABI，因为它们的长度不同。例如，如果您创建一个包含长成员的结构体，将整个结构体按原样写入文件，然后通过将文件中的数据直接转换为该结构体来读取它，则可以在 Unix 和 Windows 中写入该文件。不能互相传递阅读。</p>
<p>C 规范规定 int 是 “ 普通 “int 对象，具有执行环境体系结构建议的自然大小。当你这么说的时候，感觉就像你必须在 64 位机器上将 int 变成 64 位，但什么是自然的是一个主观问题，而且即使是 64 位机器通常也可以自然地处理 32 位操作，它不是即使在 64 位机器上，将 int 设为 32 位也必然是错误的。</p>
<p>如果你现实地考虑一下，将 int 设为 64 位会导致以下问题：</p>
<ul>
<li>在极少数情况下，int 需要大到 64 位，因此将 int 设为 64 位只会浪费内存。</li>
<li>如果 short 是 16 位，int 和 long 是 64 位，那么就没有代表 32 位整数的类型。</li>
</ul>
<p>由于上述原因，int 在大多数现有 64 位机器上都是 32 位。然而，具有 64 位 int 的 ILP64 也存在。例如，旧的 Cray 超级计算机是 ILP64。</p>
<h2 id="第20步：sizeof运算符"><a href="#第20步：sizeof运算符" class="headerlink" title="第20步：sizeof运算符"></a><a href="#%E3%82%B9%E3%83%86%E3%83%83%E3%83%9720-sizeof%E6%BC%94%E7%AE%97%E5%AD%90">第20步：sizeof运算符</a></h2><p><code>sizeof</code> 看起来像一个函数，但从语法上讲它是一个一元运算符。在 C 中，大多数运算符都是符号，但从语法上讲，没有特殊原因说明运算符必须是符号，事实上 <code>sizeof</code> 是一个例外。</p>
<p>让我们回顾一下 <code>sizeof</code> 运算符的行为。 <code>sizeof</code> 是一个运算符，返回参数表达式类型在内存中的字节数。例如，在我们的 ABI 中，如果 <code>x</code> 是 <code>int</code> ，则 <code>sizeof(x)</code> 返回 4；如果 <code>x</code> 是指针，则返回 8。 <code>sizeof</code> 的参数中可以写任何表达式，例如，如果表达式 <code>x+3</code> 的类型整体为 int，则 <code>sizeof(x+3)</code> 为 4，如果是一个指针，它将返回 8。</p>
<p>我们的编译器还没有数组，但如果 <code>x</code> 是数组， <code>sizeof(x)</code> 将返回 <code>x</code> 的整个大小（以字节为单位）。例如，如果 <code>x</code> 定义为 <code>int x[10]</code> ，则 <code>sizeof(x)</code> 将返回 40。如果 <code>x</code> 定义为 <code>int x[5][10]</code> ，则 <code>sizeof(x)</code> 为 200， <code>sizeof(x[0])</code> 为 40， <code>sizeof(x[0][0])</code> 变为 4。</p>
<p><code>sizeof</code> 运算符的参数只是为了告诉您类型而编写的；它们并不是要执行的实际表达式。例如，即使您编写表达式 <code>sizeof(x[3])</code> ，实际上也不会发生对 <code>x[3]</code> 的访问。表达式 <code>x[3]</code> 的总体类型在编译时已知，因此表达式 <code>sizeof(x[3])</code> 在编译时被替换为该类型的大小。因此，赋予 <code>sizeof</code> 的具体表达式例如 <code>x[3]</code> 在运行时不再存在。</p>
<p>  <code>sizeof</code> 的行为如下所示。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">int x;</span><br><span class="line">int *y;</span><br><span class="line"></span><br><span class="line">sizeof(x); // 4</span><br><span class="line">sizeof(y); // 8</span><br><span class="line"></span><br><span class="line">sizeof(x + 3); // 4</span><br><span class="line">sizeof(y + 3); // 8</span><br><span class="line">sizeof(*y);    // 4</span><br><span class="line"></span><br><span class="line">// sizeofに渡す式は何でもよい</span><br><span class="line">sizeof(1); // 4</span><br><span class="line"></span><br><span class="line">// sizeofの結果は現在int型なのでsizeof(int)と同じ</span><br><span class="line">sizeof(sizeof(1)); // 4</span><br></pre></td></tr></table></figure>

<p>现在，让我们实现这个 <code>sizeof</code> 运算符。实现 <code>sizeof</code> 运算符涉及修改分词器和解析器。</p>
<p>首先，修改标记生成器以将关键字 <code>sizeof</code> 识别为 <code>TK_SIZEOF</code> 类型的标记。</p>
<p>接下来，我们修改解析器以将 <code>sizeof</code> 替换为 <code>int</code> 类型的常量。添加了 <code>sizeof</code> 运算符的语法如下所示。在下面的语法中， <code>sizeof</code> 被定义为一元运算符，其优先级与一元加和一元减相同。这与 C 的语法相同。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">unary = &quot;sizeof&quot; unary</span><br><span class="line">      | (&quot;+&quot; | &quot;-&quot;)? primary</span><br></pre></td></tr></table></figure>

<p>在这个语法中，不仅允许 <code>sizeof(x)</code> ，也允许 <code>sizeof x</code> ，在实际的 C 中也是如此。</p>
<p>在解析器中，当 <code>sizeof</code> 运算符出现时，作为其参数的表达式会像往常一样被解析，与结果语法树关联的类型为 <code>int</code> 如果是，则将其替换为数字 4，如果是指针，则替换为数字 8。由于解析器将其替换为常量，因此无需对代码生成树进行任何更改。</p>
<h2 id="第21步：实现数组"><a href="#第21步：实现数组" class="headerlink" title="第21步：实现数组"></a><a href="#%E3%82%B9%E3%83%86%E3%83%83%E3%83%9721-%E9%85%8D%E5%88%97%E3%82%92%E5%AE%9F%E8%A3%85%E3%81%99%E3%82%8B">第21步：实现数组</a></h2><h3 id="定义数组类型"><a href="#定义数组类型" class="headerlink" title="定义数组类型"></a><a href="#%E9%85%8D%E5%88%97%E5%9E%8B%E3%82%92%E5%AE%9A%E7%BE%A9%E3%81%99%E3%82%8B">定义数组类型</a></h3><p>在这一步中我们将实现数组。到目前为止，我们只处理了足以容纳寄存器的数据，但这是我们第一次处理比这个大的数据。</p>
<p>然而，当涉及到数组时，C 的语法是有限制的。您不能将数组作为函数参数传递或将数组作为函数返回值返回。如果您出于此目的编写代码，则数组本身不会按值传递，但会自动创建并传递指向该数组的指针。也不支持直接对数组进行赋值和复制（必须使用 memcpy）。</p>
<p>因此，无需在函数和变量之间传递不适合寄存器的数据。能够在堆栈上分配大于一个字的内存区域就足够了。</p>
<p>请允许读取如下变量定义。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int a[10];</span><br></pre></td></tr></table></figure>

<p>上面 a 的类型是一个数组，数组长度为 10，元素类型为 int。与指针类型一样，数组类型可以像您想要的那样复杂，因此就像步骤 7 中一样，使用 ptr_to 指向数组元素的类型。表示类型的结构应如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Type</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">enum</span> &#123;</span> INT, PTR, ARRAY &#125; ty;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Type</span> *<span class="title">ptr_to</span>;</span></span><br><span class="line">  <span class="type">size_t</span> array_size;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这里， <code>array_size</code> 是一个仅对数组类型有意义的字段，是一个保存数组中元素数量的变量。</p>
<p>完成此操作后，您应该能够轻松地为堆栈上的数组分配空间。要查找数组的大小（以字节为单位），只需将数组元素的大小（以字节为单位）乘以数组中元素的数量即可。到目前为止，堆栈区域应该为所有变量保留为一个字，但请更改这一点并确保数组具有所需的大小。</p>
<h3 id="实现从数组到指针的隐式类型转换"><a href="#实现从数组到指针的隐式类型转换" class="headerlink" title="实现从数组到指针的隐式类型转换"></a><a href="#%E9%85%8D%E5%88%97%E3%81%8B%E3%82%89%E3%83%9D%E3%82%A4%E3%83%B3%E3%82%BF%E3%81%B8%E3%81%AE%E6%9A%97%E9%BB%99%E3%81%AE%E5%9E%8B%E5%A4%89%E6%8F%9B%E3%82%92%E5%AE%9F%E8%A3%85%E3%81%99%E3%82%8B">实现从数组到指针的隐式类型转换</a></h3><p>数组和指针经常结合使用，所以 C 的语法允许它在不区分指针和数组的情况下工作，但是这适得其反，让我们很难理解数组和指针之间的关系，似乎变得越来越困难让程序员能够理解。因此，这里我们来解释一下数组和指针的关系。</p>
<p>首先，在 C 中，数组和指针是完全不同的类型。</p>
<p>指针（在 x86-64 上）是 8 字节值类型。正如 + 和 - 等运算符是为整数定义的一样，+ 和 - 也为指针定义（形式略有不同）。此外，指针还定义了一元 <code>*</code> 运算符，它允许您引用指针所指向的内容。除了一元 <code>*</code> 之外，指针没有什么特别的。换句话说，指针是像 int 一样的普通类型。</p>
<p>另一方面，数组是一种可以是任意字节数的类型。与指针不同，为数组定义的运算符很少。唯一定义的运算符是 <code>sizeof</code> 运算符（它返回数组的大小）和 &amp; 运算符（它返回指向数组第一个元素的指针）。没有其他运算符可以应用于数组。</p>
<p>那么为什么像 <code>a[3]</code> 这样的表达式可以编译呢？在 C 中， <code>a[3]</code> 被定义为等同于 <code>*(a+3)</code> 。数组中不是没有定义 + 运算符吗？</p>
<p>这就是将数组隐式转换为指针的语法发挥作用的地方。数组会隐式转换为指向数组第一个元素的指针，除非用作 <code>sizeof</code> 或一元 <code>&amp;</code> 的操作数。因此， <code>*(a+3)</code> 是一个将数组 a 第一个元素的指针解引用加 3 的表达式，相当于访问数组的第三个元素，意义相同。</p>
<p>在 C 中，没有用于数组访问的 <code>[]</code> 运算符。 C 中的 <code>[]</code> 只是通过指针访问数组元素的简写符号。</p>
<p>类似地，如果将数组作为函数参数传递，它就会成为指向数组第一个元素的指针，或者您可以像直接将数组分配给指针一样编写它，但这也是可能的，如上所示。这取决于原因。</p>
<p>因此，编译器在实现大多数运算符时必须将数组转换为指针。这应该不会太难实施。除非您正在实现 <code>sizeof</code> 和一元 <code>&amp;</code> ，否则当您解析运算符的操作数时，如果它是 T 类型的数组，它将被解释为指向 T 的指针。 ，应该足够了。对于数组类型值，代码生成器应生成将值的地址压入堆栈的代码。</p>
<p>完成此操作后，您应该能够运行如下代码。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int a[2];</span><br><span class="line">*a = 1;</span><br><span class="line">*(a + 1) = 2;</span><br><span class="line">int *p;</span><br><span class="line">p = a;</span><br><span class="line">return *p + *(p + 1)  // → 3</span><br></pre></td></tr></table></figure>

<p>本书有意避免深入研究 C 语言规范的细节，直到编译器更加成熟。这是有原因的。在实现有规范的编程语言时，在某种程度上成为语言律师是必要的，但从一开始就过多关注细节并不是一种可取的开发方式。就像当你画一幅画时，你首先完成整个事物的粗略草图，而不是只详细地绘制一个部分，当你在实现一种编程语言时，尝试平衡它，这样你就不会变得太多首先是语言律师，我们需要维护和发展它。</p>
<h2 id="第22步：实现数组下标"><a href="#第22步：实现数组下标" class="headerlink" title="第22步：实现数组下标"></a><a href="#%E3%82%B9%E3%83%86%E3%83%83%E3%83%9722-%E9%85%8D%E5%88%97%E3%81%AE%E6%B7%BB%E5%AD%97%E3%82%92%E5%AE%9F%E8%A3%85%E3%81%99%E3%82%8B">第22步：实现数组下标</a></h2><p>在 C 中， <code>x[y]</code> 被定义为等同于 <code>*(x+y)</code> 。因此，实现下标相对简单。只需在解析器中将 <code>x[y]</code> 读取为 <code>*(x+y)</code> 即可。例如， <code>a[3]</code> 变为 <code>*(a+3)</code> 。</p>
<p>在这个语法中， <code>3[a]</code> 被扩展为 <code>*(3+a)</code> ，所以如果 <code>a[3]</code> 有效， <code>3[a]</code> 也应该有效，但在 C 中所以一个表达式像 <code>3[a]</code> 实际上是合法的。尝试一下。</p>
<h2 id="第23步：实现全局变量"><a href="#第23步：实现全局变量" class="headerlink" title="第23步：实现全局变量"></a><a href="#%E3%82%B9%E3%83%86%E3%83%83%E3%83%9723-%E3%82%B0%E3%83%AD%E3%83%BC%E3%83%90%E3%83%AB%E5%A4%89%E6%95%B0%E3%82%92%E5%AE%9F%E8%A3%85%E3%81%99%E3%82%8B">第23步：实现全局变量</a></h2><p>我希望很快就能在程序中编写文字字符串。在 C 中，文字字符串是一个字符数组。这很好，因为我们已经实现了数组，但不同的是文字字符串不是存在于堆栈上的值。字符串文字驻留在内存中的固定位置，而不是堆栈上。因此，要实现字符串文字，我们首先添加一个全局变量。</p>
<p>到目前为止，顶层只允许函数定义。让我们更改该语法，以便我们可以在顶层编写全局变量。</p>
<p>变量定义解析起来有些棘手，因为它们看起来与函数定义相似。例如，比较以下四个定义。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *foo;</span><br><span class="line"><span class="type">int</span> foo[<span class="number">10</span>];</span><br><span class="line"><span class="type">int</span> *<span class="title function_">foo</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">foo</span><span class="params">()</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>上面的两个 foo 是变量定义，下面的两个是函数定义，但是直到找到成为函数名或变量名的标识符并读取下一个标记之前，您无法区分它们。因此，您需要首先调用 “ 读取类型名称的前半部分 “ 函数，读取后面应该出现的标识符，然后尝试向前读取一个标记。如果预读标记为 “(“，则表示正在读取函数定义；否则，表示正在读取变量定义。</p>
<p>将已解析的全局变量的名称放入映射中，以便您可以按名称查找它们。仅当变量名称无法解析为局部变量时，才会尝试将其解析为全局变量。这允许以自然的方式让局部变量隐藏同名的全局变量。</p>
<p>解析器将局部变量引用和全局变量引用转换为抽象语法树中的单独节点。由于名称可以在解析阶段解析，因此类型也可以在该阶段分离。</p>
<p>到目前为止，所有变量都应该位于堆栈上，因此变量的读写是相对于 RBP（基指针）的。全局变量不是堆栈上的值，而是内存中的固定位置，因此编译时可以直接访问该地址。请参考实际的 gcc 输出。</p>
<p>一旦你实现了它，你会惊讶地发现局部变量和全局变量有很大的不同。之所以可以写得没有视觉上的区别，是因为 C 语言抽象得很好。局部变量和全局变量实际上在内部实现完全不同。</p>
<h2 id="第24步：实现字符类型"><a href="#第24步：实现字符类型" class="headerlink" title="第24步：实现字符类型"></a><a href="#%E3%82%B9%E3%83%86%E3%83%83%E3%83%9724-%E6%96%87%E5%AD%97%E5%9E%8B%E3%82%92%E5%AE%9F%E8%A3%85%E3%81%99%E3%82%8B">第24步：实现字符类型</a></h2><p>数组是一种可以大于一个单词的类型，但字符是一种可以小于一个单词的类型。要完成此步骤，您可能需要编写一个函数，该函数接受表示类型的对象并返回该类型的大小（以字节为单位）。首先，添加一个字符类型，然后修改该函数，使其为该字符类型返回 1。</p>
<p>在此步骤中无需实现文字字符（用单引号括起来的字符）。避免一次性实施所有事情的冲动，并保持变化尽可能小。</p>
<p>所以在这一步中，字符实际上只是一个小整数类型。 <code>movsx ecx, BYTE PTR [rax]</code> 可以从 RAX 指向的地址中读取一个字节并将其放入 ECX 中。如果不需要符号扩展，请使用 <code>movzx</code> 指令，如 <code>movzx ecx, BYTE PTR [rax]</code> 。写入时，使用 8 位寄存器作为源寄存器，如 <code>mov [rax], cl</code> 。</p>
<p>  请参考实际的编译输出。</p>
<p>实现此步骤后，您应该能够运行如下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">char x[3];</span><br><span class="line">x[0] = -1;</span><br><span class="line">x[1] = 2;</span><br><span class="line">int y;</span><br><span class="line">y = 4;</span><br><span class="line">return x[0] + y;  // → 3</span><br></pre></td></tr></table></figure>

<h2 id="第-25-步：实现字符串文字"><a href="#第-25-步：实现字符串文字" class="headerlink" title="第 25 步：实现字符串文字"></a><a href="#%E3%82%B9%E3%83%86%E3%83%83%E3%83%9725-%E6%96%87%E5%AD%97%E5%88%97%E3%83%AA%E3%83%86%E3%83%A9%E3%83%AB%E3%82%92%E5%AE%9F%E8%A3%85%E3%81%99%E3%82%8B">第 25 步：实现字符串文字</a></h2><p>此步骤解析用双引号括起来的字符串，以便可以对其进行编译。现在我们已经有了必要的部分：数组、全局变量和字符类型，我认为实现起来会相对容易。</p>
<p>首先，修改标记生成器，以便当找到双引号时，读取到下一个双引号以创建字符串标记。这一步不需要实现反斜杠转义等。一步一步来很重要，所以即使看起来很容易实现，也尽量不要这样做。</p>
<p>在生成要在 CPU 上执行的机器代码时，无法输出表示字符串文字数据的汇编代码。在输出汇编中，全局数据和代码必须不混合地编写。换句话说，在输出代码时，我们希望首先输出代码中出现的所有字符串文字，但是通过语法树来做到这一点是很痛苦的。执行此操作的一个简单方法是拥有一个包含您见过的所有字符串文字的向量，并在每次解析器看到字符串时简单地添加到它。</p>
<p>  请参考实际的编译输出。</p>
<p>此时，您应该能够使用 <code>printf</code> 输出字符串。这是一个很好的机会，可以使用自己的编程语言来编写比测试代码等显而易见的东西更复杂的东西。例如，是否可以用您自己的语言编写 8 皇后问题的求解器？人类花了几十年的时间才开发出一种编程语言，使我们能够轻松地编写这个级别的代码。对于人类和你们来说，这都是一个巨大的进步，它可以在几周内实施。</p>
<p>（当调用带有可变长度参数的函数时，浮点参数的数量存储在 AL 中。我们的编译器还没有浮点数。因此，在调用函数时，（在执行之前始终将 AL 设置为 0 所以。）</p>
<h2 id="步骤-26：从文件中读取输入"><a href="#步骤-26：从文件中读取输入" class="headerlink" title="步骤 26：从文件中读取输入"></a><a href="#%E3%82%B9%E3%83%86%E3%83%83%E3%83%9726-%E5%85%A5%E5%8A%9B%E3%82%92%E3%83%95%E3%82%A1%E3%82%A4%E3%83%AB%E3%81%8B%E3%82%89%E8%AA%AD%E3%82%80">步骤 26：从文件中读取输入</a></h2><p>到目前为止，我一直将 C 代码直接传递给参数字符串，但由于输入逐渐变长，我认为是时候修改它，以便它像普通 C 编译器一样将文件名作为命令行参数.让我们吧。打开给定文件、读取其内容并返回以 <code>&#39;\0&#39;</code> 结尾的字符串的函数可以简明地编写如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定されたファイルの内容を返す</span></span><br><span class="line"><span class="type">char</span> *<span class="title function_">read_file</span><span class="params">(<span class="type">char</span> *path)</span> &#123;</span><br><span class="line">  <span class="comment">// ファイルを開く</span></span><br><span class="line">  FILE *fp = fopen(path, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (!fp)</span><br><span class="line">    error(<span class="string">&quot;cannot open %s: %s&quot;</span>, path, strerror(errno));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ファイルの長さを調べる</span></span><br><span class="line">  <span class="keyword">if</span> (fseek(fp, <span class="number">0</span>, SEEK_END) == <span class="number">-1</span>)</span><br><span class="line">    error(<span class="string">&quot;%s: fseek: %s&quot;</span>, path, strerror(errno));</span><br><span class="line">  <span class="type">size_t</span> size = ftell(fp);</span><br><span class="line">  <span class="keyword">if</span> (fseek(fp, <span class="number">0</span>, SEEK_SET) == <span class="number">-1</span>)</span><br><span class="line">    error(<span class="string">&quot;%s: fseek: %s&quot;</span>, path, strerror(errno));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ファイル内容を読み込む</span></span><br><span class="line">  <span class="type">char</span> *buf = <span class="built_in">calloc</span>(<span class="number">1</span>, size + <span class="number">2</span>);</span><br><span class="line">  fread(buf, size, <span class="number">1</span>, fp);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ファイルが必ず&quot;\n\0&quot;で終わっているようにする</span></span><br><span class="line">  <span class="keyword">if</span> (size == <span class="number">0</span> || buf[size - <span class="number">1</span>] != <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">    buf[size++] = <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  buf[size] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">  fclose(fp);</span><br><span class="line">  <span class="keyword">return</span> buf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于编译器的实现，每行以换行符结尾的数据比以换行符或 EOF 结尾的数据更容易处理，因此如果文件的最后一个字节不是 <code>\n</code> ，我决定自动添加 <code>\n</code> 。</p>
<p>严格来说，如果给您一个无法随机访问的特殊文件，此功能将无法正常工作。例如，如果您指定表示标准输入的设备文件 <code>/dev/stdin</code> 或命名管道作为文件名，则您应该会看到显示诸如 <code>/dev/stdin: fseek: Illegal seek</code> 之类的错误消息。不过，实际上这个功能应该没问题。修改您的代码以使用此函数读取文件的内容并将其视为输入。</p>
<p>由于输入文件通常包含多行，因此您还应该增强显示错误消息的功能。发生错误时，如果您决定显示输入文件名、出错行的行号以及该行的内容，则错误消息将如下所示。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">foo.c:10: x = y + + 5;</span><br><span class="line">                  ^ 式ではありません</span><br></pre></td></tr></table></figure>

<p>显示此类错误消息的函数如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 入力ファイル名</span></span><br><span class="line"><span class="type">char</span> *filename;</span><br><span class="line"></span><br><span class="line"><span class="comment">// エラーの起きた場所を報告するための関数</span></span><br><span class="line"><span class="comment">// 下のようなフォーマットでエラーメッセージを表示する</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// foo.c:10: x = y + + 5;</span></span><br><span class="line"><span class="comment">//                   ^ 式ではありません</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">error_at</span><span class="params">(<span class="type">char</span> *loc, <span class="type">char</span> *msg)</span> &#123;</span><br><span class="line">  <span class="comment">// locが含まれている行の開始地点と終了地点を取得</span></span><br><span class="line">  <span class="type">char</span> *line = loc;</span><br><span class="line">  <span class="keyword">while</span> (user_input &lt; line &amp;&amp; line[<span class="number">-1</span>] != <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">    line--;</span><br><span class="line"></span><br><span class="line">  <span class="type">char</span> *end = loc;</span><br><span class="line">  <span class="keyword">while</span> (*end != <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">    end++;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 見つかった行が全体の何行目なのかを調べる</span></span><br><span class="line">  <span class="type">int</span> line_num = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">char</span> *p = user_input; p &lt; line; p++)</span><br><span class="line">    <span class="keyword">if</span> (*p == <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">      line_num++;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 見つかった行を、ファイル名と行番号と一緒に表示</span></span><br><span class="line">  <span class="type">int</span> indent = <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;%s:%d: &quot;</span>, filename, line_num);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;%.*s\n&quot;</span>, (<span class="type">int</span>)(end - line), line);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// エラー箇所を&quot;^&quot;で指し示して、エラーメッセージを表示</span></span><br><span class="line">  <span class="type">int</span> pos = loc - line + indent;</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;%*s&quot;</span>, pos, <span class="string">&quot;&quot;</span>); <span class="comment">// pos個の空白を出力</span></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;^ %s\n&quot;</span>, msg);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然这个错误信息输出例程相当简单，但可以说它以相当专业的格式输出错误。</p>
<p>コラム:  专栏：错误恢复</p>
<p>如果输入代码在语法上不正确，许多编译器将尝试跳过错误并继续解析其余代码。目标是找到尽可能多的错误，而不仅仅是一个。从解析器错误中恢复并继续解析的能力称为 “ 错误恢复 “。</p>
<p>错误恢复是旧编译器的一个非常重要的功能。在 20 世纪 60 年代和 1970 年代，程序员在计算机中心使用大型计算机进行分时，要求他们带入要编译的代码并等待，有时甚至是一整夜，然后才能得到编译结果。在这样的环境下，编译器的重要任务之一就是指出尽可能多的可能的错误。在较旧的编译器教科书中，错误恢复是解析的主要主题之一。</p>
<p>如今，使用编译器进行开发更具交互性，因此错误恢复不再是一个重要的话题。我们开发的编译器只打印第一条错误消息。在现代，这在很多情况下就足够了。</p>
<h2 id="第-27-步：行注释和块注释"><a href="#第-27-步：行注释和块注释" class="headerlink" title="第 27 步：行注释和块注释"></a><a href="#%E3%82%B9%E3%83%86%E3%83%83%E3%83%9727-%E8%A1%8C%E3%82%B3%E3%83%A1%E3%83%B3%E3%83%88%E3%81%A8%E3%83%96%E3%83%AD%E3%83%83%E3%82%AF%E3%82%B3%E3%83%A1%E3%83%B3%E3%83%88">第 27 步：行注释和块注释</a></h2><p>我们的编译器逐渐发展，编写成熟的代码已经成为可能。在这种情况下，您想要的是注释。本章实现了注释。</p>
<p>C 中的注释有两种类型。一条注释称为行注释，注释从 <code>//</code> 开始到行尾。另一种类型称为块注释，其中 <code>/*</code> 是开始符号， <code>*/</code> 是结束符号。除了两个字符序列 <code>*/</code> 之外，块注释中的所有字符都会被跳过。</p>
<p>从语法上讲，注释被视为与单个空格字符相同。因此，分词器很自然地会像空格一样跳过注释。跳过注释的代码如下所示。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">tokenize</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">char</span> *p = user_input;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (*p) &#123;</span><br><span class="line">    <span class="comment">// 空白文字をスキップ</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isspace</span>(*p)) &#123;</span><br><span class="line">      p++;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 行コメントをスキップ</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strncmp</span>(p, <span class="string">&quot;//&quot;</span>, <span class="number">2</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">      p += <span class="number">2</span>;</span><br><span class="line">      <span class="keyword">while</span> (*p != <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">        p++;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ブロックコメントをスキップ</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strncmp</span>(p, <span class="string">&quot;/*&quot;</span>, <span class="number">2</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="type">char</span> *q = <span class="built_in">strstr</span>(p + <span class="number">2</span>, <span class="string">&quot;*/&quot;</span>);</span><br><span class="line">      <span class="keyword">if</span> (!q)</span><br><span class="line">        error_at(p, <span class="string">&quot;コメントが閉じられていません&quot;</span>);</span><br><span class="line">      p = q + <span class="number">2</span>;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<p>这里我们使用 C 标准库中的 <code>strstr</code> 函数来查找块注释的结尾。 <code>strstr</code> 在字符串中搜索字符串，如果找到则返回指向所传递字符串开头的指针，如果未找到则返回 NULL。</p>
<p>コラム:  专栏：块注释和嵌套</p>
<p>块注释不能嵌套。 <code>/*</code> 在注释中没有特殊含义，因此注释掉现有的块注释。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/* /* ... */ */</span><br></pre></td></tr></table></figure>

<p>第一个 <code>*/</code> 将结束注释，第二个 <code>*/</code> 将导致语法错误。</p>
<p>如果要注释掉所有可能包含块注释的行，请使用 C 预处理器。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#if 0</span><br><span class="line">...</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>

<p>一种方法是将其包装在 <code>#if 0</code> 中，如下所示。</p>
<h2 id="步骤-28：用-C-重写测试"><a href="#步骤-28：用-C-重写测试" class="headerlink" title="步骤 28：用 C 重写测试"></a><a href="#%E3%82%B9%E3%83%86%E3%83%83%E3%83%9728-%E3%83%86%E3%82%B9%E3%83%88%E3%82%92c%E3%81%A7%E6%9B%B8%E3%81%8D%E7%9B%B4%E3%81%99">步骤 28：用 C 重写测试</a></h2><p>在此步骤中，我们将重写测试以使 <code>make test</code> 更快。当您执行此步骤时，您可能已经在 shell 脚本中编写了 100 多个测试。 Shell 脚本测试为每个测试启动多个进程。换句话说，对于每个测试，我都会启动自己的编译器、汇编器、链接器并测试自身。</p>
<p>即使对于小程序来说，启动进程也不是那么快。因此，如果您执行数百次，总共将花费相当长的时间。您的测试脚本可能需要几秒钟才能运行。</p>
<p>我首先在 shell 脚本中编写测试的原因是因为否则我无法进行正确的测试。在计算器级语言中，没有 <code>if</code> 或 <code>==</code> ，因此无法验证该语言内计算结果的准确性。但现在可以验证了。现在可以比较结果以查看它们是否正确，如果不正确，则显示错误消息（作为字符串）并退出。</p>
<p>因此，在这一步中，将用 shell 脚本编写的测试重写为 C 文件。</p>
<h1 id="C-类型语法"><a href="#C-类型语法" class="headerlink" title="C 类型语法"></a><a href="#type">C 类型语法</a></h1><p>本章介绍如何阅读 C 类型语法。到本章结束时，读者将能够按照逐步的方法解码诸如 <code>void (*x)(int)</code> 和 <code>void (*signal(int, void (*)(int)))(int)</code> 之类的复杂类型。应该是这样。</p>
<h2 id="代表类型的图表"><a href="#代表类型的图表" class="headerlink" title="代表类型的图表"></a><a href="#%E5%9E%8B%E3%82%92%E8%A1%A8%E3%81%99%E5%9B%B3">代表类型的图表</a></h2><p>C 语言可以表达的类型比较简单。为了将类型语法的复杂性与类型本身的复杂性分开，让我们暂时将语法放在一边，只考虑类型。</p>
<p>诸如指针和数组之类的复杂类型可以通过用箭头连接简单类型的图表来表示。例如，下图显示了表示 “ 指向 int 的指针 “ 的类型。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../../img/blog/4c3a749491fed60036e8c70840e3c681_MD5.svg"></p>
<p>在日语中，从箭头的终点到起点读作 “int 指针的指针 “。在英语中，发音相反：指向 int 指针的指针，遵循箭头的方向。</p>
<p>假设变量 <code>x</code> 具有上图所示的类型。对于 “ <code>x</code> 的类型是什么？” 这个问题，最简单的答案是 “ 它是一个指针 “。这是因为第一个箭头指向的类型是指针类型。注意， <code>x</code> 首先是一个指针，而不是 <code>int</code> 这样的类型。 “ 该指针指向什么类型？” 这个问题的答案是 “ 它是一个指针 “。这是因为跟随一个箭头的指针也是一种指针类型。最后，” 该指针指向什么类型？” 这个问题的答案是 “int”。</p>
<p>下图显示了一个 “int 指针数组 “。数组的长度是 20。在实际的编译器中，数组的长度也表示为代表数组的类型的成员，如下图所示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../../img/blog/28a0d0b33ca1290558c334017d93013f_MD5.svg"></p>
<p>如果变量 <code>x</code> 具有上图所示的类型，则 <code>x</code> 是长度为 20 的数组类型，并且该数组的元素是指针，该指针指向的变为&lt; b2&gt;。</p>
<p>函数类型也可以用图形表示。下图显示了带有两个参数（一个 int 和一个指向 int 的指针）并返回一个 void 指针的函数类型。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../../img/blog/3ff805c41a8cd70412adac62e7e4088e_MD5.svg"></p>
<p>最后，让我们看一个更复杂的例子。下图显示了一种称为函数指针的类型，它采用 int 作为参数，并返回一个指向返回 int 的函数的指针。用文字表达很复杂，但用图表表达时，你会发现它很长，结构也很简单。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../../img/blog/a31ebf2dc070eaf5a531a5e847963463_MD5.svg"></p>
<p>如果变量 <code>x</code> 具有上图所示的类型，则 <code>x</code> 是指针类型，该指针指向一个函数，该函数的参数类型为 In <code>int</code> ，返回类型为指针类型，指针指向一个函数，该函数的返回值类型为 <code>int</code> 。</p>
<p>在内部，编译器使用与上图相同的方法来表示类型。换句话说，涉及指针、数组和函数的复杂类型在编译器内部表示为由指针连接的简单类型结构组成的数据结构，其顺序与上图所示的顺序相同。因此，毫不夸张地说，这张图就是型的真实形态。</p>
<h2 id="表示类型的符号"><a href="#表示类型的符号" class="headerlink" title="表示类型的符号"></a><a href="#%E5%9E%8B%E3%82%92%E8%A1%A8%E3%81%99%E8%A8%98%E6%B3%95">表示类型的符号</a></h2><p>尽管用如上所示的图表表示类型时更容易理解类型的含义，但每次都画图表来理解类型是很乏味的。在本节中，我们将考虑一种可以写得更紧凑而又不影响图表清晰度的符号。</p>
<p>除非包含功能类型，否则所有框都将以菊花链形式排列在图中，没有任何分支。因此，如果类型只有指针或数组，您应该能够通过在图中从左到右书写类型的名称来用文本表达图。</p>
<p>我们来考虑一下具体的记法。代表指针的框将由符号 <code>*</code> 表示。另外，规则是在表示长度为 n 的数组的框中写入 <code>[n]</code> ，并在表示内置类型（例如 int）的框中写入类型名称。那么，下图就可以用字符串 <code>* * int</code> 来表示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../../img/blog/4c3a749491fed60036e8c70840e3c681_MD5.svg"></p>
<p>从箭头起点开始依次出现 pointer、pointer、int，因此表示法为 <code>* * int</code> 。相反，如果我们给出符号 <code>* * int</code> ，我们也可以画出上面的图。换句话说，这种文本表示是一种符号，允许您以文本形式紧凑地写下与图表相同的信息。</p>
<p>下图可以用字符串 <code>[20] * int</code> 来表示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../../img/blog/28a0d0b33ca1290558c334017d93013f_MD5.svg"></p>
<p>对于函数，我们将其写为 “ <code>func(引数の型, …) 返り値の型</code> “。例如下图所示的类型写为 <code>func(int, * int) * void</code> 。鼓励读者检查该符号是否与图表相符。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../../img/blog/3ff805c41a8cd70412adac62e7e4088e_MD5.svg"></p>
<p>最后，如下图所示的类型是 <code>* func(int) * func() int</code> 。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/../../img/blog/a31ebf2dc070eaf5a531a5e847963463_MD5.svg"></p>
<p>到目前为止描述的符号可能是类型的最直接和最简单的文本表示。事实上，Go 编程语言中的类型语法与这里描述的表示法完全相同。 Go 是一门由 C 的创建者参与开发的语言，Go 中的类型语法通过吸取 C 的经验教训而得到了巧妙的改进。 </p>
<h1 id="综上所述"><a href="#综上所述" class="headerlink" title="综上所述"></a><a href="#%E3%81%8A%E3%82%8F%E3%82%8A%E3%81%AB">综上所述</a></h1><p>本书正文以 Markdown 格式编写。我使用 Pandoc 将 Markdown 转换为 HTML，使用 Graphviz 创建语法树图，使用 draw.io 创建其他图表。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://icefjl.github.io">ICEFJL</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://icefjl.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/C%E8%AF%AD%E8%A8%80%E8%87%AA%E5%88%B6%E7%BC%96%E8%AF%91%E5%99%A8.html">http://icefjl.github.io/posts/计算机基础/C语言自制编译器.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://icefjl.github.io" target="_blank">Fu Jinlong's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA-%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/">计算机/计算机基础</a></div><div class="post_share"></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/%E5%BD%92%E6%A1%A3/%E5%BD%92%E6%A1%A31.html" title="归档1"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/web/post9.webp" onerror="onerror=null;src='/img/web/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">归档1</div></div></a></div><div class="next-post pull-right"><a href="/posts/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python%E5%BA%94%E7%94%A8.html" title="Python应用"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/web/post0.jpg" onerror="onerror=null;src='/img/web/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Python应用</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="giscus-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/web/avatar.jpg" onerror="this.onerror=null;this.src='/img/web/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">ICEFJL</div><div class="author-info__description">Fu Jinlong's Blog</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">68</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">21</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">20</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/icefjl"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="mailto:fujinlong24@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9D%A5%E6%BA%90"><span class="toc-number">1.</span> <span class="toc-text">来源</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D"><span class="toc-number">2.</span> <span class="toc-text">介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%AC%E4%B9%A6%E5%81%87%E8%AE%BE%E7%9A%84%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83"><span class="toc-number">2.1.</span> <span class="toc-text">本书假设的开发环境</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E8%AE%A1%E7%AE%97%E5%99%A8%E7%BA%A7%E8%AF%AD%E8%A8%80"><span class="toc-number">3.</span> <span class="toc-text">创建计算器级语言</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC-1-%E6%AD%A5%EF%BC%9A%E5%88%9B%E5%BB%BA%E4%B8%80%E7%A7%8D%E7%BC%96%E8%AF%91%E6%95%B4%E6%95%B0%E7%9A%84%E8%AF%AD%E8%A8%80"><span class="toc-number">3.1.</span> <span class="toc-text">第 1 步：创建一种编译整数的语言</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E7%BC%96%E8%AF%91%E5%99%A8%E4%B8%BB%E4%BD%93"><span class="toc-number">3.1.1.</span> <span class="toc-text">创建编译器主体</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95"><span class="toc-number">3.1.2.</span> <span class="toc-text">创建自动化测试</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-make-%E6%9E%84%E5%BB%BA"><span class="toc-number">3.1.3.</span> <span class="toc-text">使用 make 构建</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-git-%E8%BF%9B%E8%A1%8C%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6"><span class="toc-number">3.1.4.</span> <span class="toc-text">使用 git 进行版本控制</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC2%E6%AD%A5%EF%BC%9A%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%8F%AF%E4%BB%A5%E5%8A%A0%E5%87%8F%E6%B3%95%E7%9A%84%E7%BC%96%E8%AF%91%E5%99%A8"><span class="toc-number">3.2.</span> <span class="toc-text">第2步：创建一个可以加减法的编译器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC-3-%E6%AD%A5%EF%BC%9A%E5%BC%95%E5%85%A5%E5%88%86%E8%AF%8D%E5%99%A8"><span class="toc-number">3.3.</span> <span class="toc-text">第 3 步：引入分词器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC-4-%E6%AD%A5%EF%BC%9A%E6%94%B9%E8%BF%9B%E9%94%99%E8%AF%AF%E6%B6%88%E6%81%AF"><span class="toc-number">3.4.</span> <span class="toc-text">第 4 步：改进错误消息</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95%E6%8F%8F%E8%BF%B0%E6%96%B9%E6%B3%95%E4%B8%8E%E9%80%92%E5%BD%92%E4%B8%8B%E9%99%8D%E8%A7%A3%E6%9E%90"><span class="toc-number">3.5.</span> <span class="toc-text">语法描述方法与递归下降解析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%92%E5%BD%92%E9%99%8D%E5%BA%8F%E8%A7%A3%E6%9E%90"><span class="toc-number">3.5.1.</span> <span class="toc-text">递归降序解析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A0%86%E5%8F%A0%E6%9C%BA"><span class="toc-number">3.6.</span> <span class="toc-text">堆叠机</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E5%88%B0%E5%A0%86%E6%A0%88%E6%9C%BA"><span class="toc-number">3.6.1.</span> <span class="toc-text">编译到堆栈机</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%9C%A8-x86-64-%E4%B8%8A%E5%88%9B%E5%BB%BA%E5%A0%86%E6%A0%88%E6%9C%BA%E5%99%A8"><span class="toc-number">3.6.2.</span> <span class="toc-text">如何在 x86-64 上创建堆栈机器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC-5-%E6%AD%A5%EF%BC%9A%E5%88%9B%E5%BB%BA%E4%B8%80%E7%A7%8D%E5%8F%AF%E4%BB%A5%E6%89%A7%E8%A1%8C%E5%9B%9B%E7%A7%8D%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E7%9A%84%E8%AF%AD%E8%A8%80"><span class="toc-number">3.7.</span> <span class="toc-text">第 5 步：创建一种可以执行四种算术运算的语言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AD%A5%E9%AA%A4-6%EF%BC%9A%E4%B8%80%E5%85%83%E5%8A%A0%E5%92%8C%E4%B8%80%E5%85%83%E5%87%8F"><span class="toc-number">3.8.</span> <span class="toc-text">步骤 6：一元加和一元减</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC-7-%E6%AD%A5%EF%BC%9A%E6%AF%94%E8%BE%83%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">3.9.</span> <span class="toc-text">第 7 步：比较运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E8%AF%8D%E5%99%A8%E6%9B%B4%E6%94%B9"><span class="toc-number">3.9.1.</span> <span class="toc-text">分词器更改</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B0%E8%AF%AD%E6%B3%95"><span class="toc-number">3.9.2.</span> <span class="toc-text">新语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B1%87%E7%BC%96%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90"><span class="toc-number">3.9.3.</span> <span class="toc-text">汇编代码生成</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%95%E7%8B%AC%E7%BC%96%E8%AF%91%E5%92%8C%E9%93%BE%E6%8E%A5"><span class="toc-number">4.</span> <span class="toc-text">单独编译和链接</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AD%A5%E9%AA%A48%EF%BC%9A%E5%88%86%E5%89%B2%E6%96%87%E4%BB%B6%E5%B9%B6%E6%9B%B4%E6%94%B9Makefile"><span class="toc-number">4.1.</span> <span class="toc-text">步骤8：分割文件并更改Makefile</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%89%B2%E6%96%87%E4%BB%B6"><span class="toc-number">4.1.1.</span> <span class="toc-text">分割文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%9F%E6%88%90%E6%96%87%E4%BB%B6%E6%9B%B4%E6%94%B9"><span class="toc-number">4.1.2.</span> <span class="toc-text">生成文件更改</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%92%8C%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F"><span class="toc-number">5.</span> <span class="toc-text">函数和局部变量</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC9%E6%AD%A5%EF%BC%9A%E5%8D%95%E5%AD%97%E7%AC%A6%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F"><span class="toc-number">5.1.</span> <span class="toc-text">第9步：单字符局部变量</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E8%AF%8D%E5%99%A8%E6%9B%B4%E6%94%B9-1"><span class="toc-number">5.1.1.</span> <span class="toc-text">分词器更改</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E6%9E%90%E5%99%A8%E7%9A%84%E5%8F%98%E5%8C%96"><span class="toc-number">5.1.2.</span> <span class="toc-text">解析器的变化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90%E5%99%A8%E6%9B%B4%E6%94%B9"><span class="toc-number">5.1.3.</span> <span class="toc-text">代码生成器更改</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E8%A6%81%E5%8A%9F%E8%83%BD%E5%8F%98%E5%8C%96"><span class="toc-number">5.1.4.</span> <span class="toc-text">主要功能变化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC10%E6%AD%A5%EF%BC%9A%E5%A4%9A%E5%AD%97%E7%AC%A6%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F"><span class="toc-number">5.2.</span> <span class="toc-text">第10步：多字符局部变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC11%E6%AD%A5%EF%BC%9A%E8%BF%94%E5%9B%9E%E8%AF%AD%E5%8F%A5"><span class="toc-number">5.3.</span> <span class="toc-text">第11步：返回语句</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1973%E5%B9%B4C%E7%BC%96%E8%AF%91%E5%99%A8"><span class="toc-number">5.4.</span> <span class="toc-text">1973年C编译器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC-12-%E6%AD%A5%EF%BC%9A%E6%B7%BB%E5%8A%A0%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84"><span class="toc-number">5.5.</span> <span class="toc-text">第 12 步：添加控制结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC13%E6%AD%A5%EF%BC%9A%E5%9D%97"><span class="toc-number">5.6.</span> <span class="toc-text">第13步：块</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC14%E6%AD%A5%EF%BC%9A%E5%93%8D%E5%BA%94%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8"><span class="toc-number">5.7.</span> <span class="toc-text">第14步：响应函数调用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC-15-%E6%AD%A5%EF%BC%9A%E8%A7%A3%E5%86%B3%E5%87%BD%E6%95%B0%E5%AE%9A%E4%B9%89%E9%97%AE%E9%A2%98"><span class="toc-number">5.8.</span> <span class="toc-text">第 15 步：解决函数定义问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%BA%A7%E6%8E%A5%E5%8F%A3"><span class="toc-number">5.9.</span> <span class="toc-text">二进制级接口</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%96%87%E5%AD%97"><span class="toc-number">6.</span> <span class="toc-text">指针和字符串文字</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AD%A5%E9%AA%A4-16%EF%BC%9A%E4%B8%80%E5%85%83-amp-%E5%92%8C%E4%B8%80%E5%85%83"><span class="toc-number">6.1.</span> <span class="toc-text">步骤 16：一元 &amp; 和一元 *</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC17%E6%AD%A5%EF%BC%9A%E6%B6%88%E9%99%A4%E9%9A%90%E5%BC%8F%E5%8F%98%E9%87%8F%E5%AE%9A%E4%B9%89%E5%B9%B6%E5%BC%95%E5%85%A5-int-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">6.2.</span> <span class="toc-text">第17步：消除隐式变量定义并引入 int 关键字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC18%E6%AD%A5%EF%BC%9A%E5%BC%95%E5%85%A5%E6%8C%87%E9%92%88%E7%B1%BB%E5%9E%8B"><span class="toc-number">6.3.</span> <span class="toc-text">第18步：引入指针类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AA%E8%A1%A8%E7%A4%BA%E6%8C%87%E9%92%88%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="toc-number">6.3.1.</span> <span class="toc-text">定义一个表示指针的类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B5%8B%E5%80%BC%E7%BB%99%E6%8C%87%E9%92%88%E6%89%80%E6%8C%87%E5%90%91%E7%9A%84%E5%80%BC"><span class="toc-number">6.3.2.</span> <span class="toc-text">赋值给指针所指向的值</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC19%E6%AD%A5%EF%BC%9A%E5%AE%9E%E7%8E%B0%E6%8C%87%E9%92%88%E5%8A%A0%E6%B3%95%E5%92%8C%E5%87%8F%E6%B3%95"><span class="toc-number">6.4.</span> <span class="toc-text">第19步：实现指针加法和减法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC20%E6%AD%A5%EF%BC%9Asizeof%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">6.5.</span> <span class="toc-text">第20步：sizeof运算符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC21%E6%AD%A5%EF%BC%9A%E5%AE%9E%E7%8E%B0%E6%95%B0%E7%BB%84"><span class="toc-number">6.6.</span> <span class="toc-text">第21步：实现数组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E6%95%B0%E7%BB%84%E7%B1%BB%E5%9E%8B"><span class="toc-number">6.6.1.</span> <span class="toc-text">定义数组类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E4%BB%8E%E6%95%B0%E7%BB%84%E5%88%B0%E6%8C%87%E9%92%88%E7%9A%84%E9%9A%90%E5%BC%8F%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">6.6.2.</span> <span class="toc-text">实现从数组到指针的隐式类型转换</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC22%E6%AD%A5%EF%BC%9A%E5%AE%9E%E7%8E%B0%E6%95%B0%E7%BB%84%E4%B8%8B%E6%A0%87"><span class="toc-number">6.7.</span> <span class="toc-text">第22步：实现数组下标</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC23%E6%AD%A5%EF%BC%9A%E5%AE%9E%E7%8E%B0%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F"><span class="toc-number">6.8.</span> <span class="toc-text">第23步：实现全局变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC24%E6%AD%A5%EF%BC%9A%E5%AE%9E%E7%8E%B0%E5%AD%97%E7%AC%A6%E7%B1%BB%E5%9E%8B"><span class="toc-number">6.9.</span> <span class="toc-text">第24步：实现字符类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC-25-%E6%AD%A5%EF%BC%9A%E5%AE%9E%E7%8E%B0%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%96%87%E5%AD%97"><span class="toc-number">6.10.</span> <span class="toc-text">第 25 步：实现字符串文字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AD%A5%E9%AA%A4-26%EF%BC%9A%E4%BB%8E%E6%96%87%E4%BB%B6%E4%B8%AD%E8%AF%BB%E5%8F%96%E8%BE%93%E5%85%A5"><span class="toc-number">6.11.</span> <span class="toc-text">步骤 26：从文件中读取输入</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC-27-%E6%AD%A5%EF%BC%9A%E8%A1%8C%E6%B3%A8%E9%87%8A%E5%92%8C%E5%9D%97%E6%B3%A8%E9%87%8A"><span class="toc-number">6.12.</span> <span class="toc-text">第 27 步：行注释和块注释</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AD%A5%E9%AA%A4-28%EF%BC%9A%E7%94%A8-C-%E9%87%8D%E5%86%99%E6%B5%8B%E8%AF%95"><span class="toc-number">6.13.</span> <span class="toc-text">步骤 28：用 C 重写测试</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#C-%E7%B1%BB%E5%9E%8B%E8%AF%AD%E6%B3%95"><span class="toc-number">7.</span> <span class="toc-text">C 类型语法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E8%A1%A8%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%9B%BE%E8%A1%A8"><span class="toc-number">7.1.</span> <span class="toc-text">代表类型的图表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A1%A8%E7%A4%BA%E7%B1%BB%E5%9E%8B%E7%9A%84%E7%AC%A6%E5%8F%B7"><span class="toc-number">7.2.</span> <span class="toc-text">表示类型的符号</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BB%BC%E4%B8%8A%E6%89%80%E8%BF%B0"><span class="toc-number">8.</span> <span class="toc-text">综上所述</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/%E6%9C%AC%E5%9C%B0/nix%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8.html" title="nix包管理器"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/web/post5.webp" onerror="this.onerror=null;this.src='/img/web/404.jpg'" alt="nix包管理器"/></a><div class="content"><a class="title" href="/posts/%E6%9C%AC%E5%9C%B0/nix%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8.html" title="nix包管理器">nix包管理器</a><time datetime="2024-01-02T10:35:10.000Z" title="发表于 2024-01-02 18:35:10">2024-01-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/%E6%9C%AC%E5%9C%B0/%E9%94%AE%E7%9B%98%E6%8C%89%E9%94%AE%E6%98%A0%E5%B0%84.html" title="键盘按键映射"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/web/post6.webp" onerror="this.onerror=null;this.src='/img/web/404.jpg'" alt="键盘按键映射"/></a><div class="content"><a class="title" href="/posts/%E6%9C%AC%E5%9C%B0/%E9%94%AE%E7%9B%98%E6%8C%89%E9%94%AE%E6%98%A0%E5%B0%84.html" title="键盘按键映射">键盘按键映射</a><time datetime="2023-12-28T15:05:50.000Z" title="发表于 2023-12-28 23:05:50">2023-12-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/Ubuntu%E4%B8%8Bbochs%E5%AE%89%E8%A3%85%E6%AD%A5%E9%AA%A4.html" title="Ubuntu下bochs安装步骤"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/web/post5.webp" onerror="this.onerror=null;this.src='/img/web/404.jpg'" alt="Ubuntu下bochs安装步骤"/></a><div class="content"><a class="title" href="/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/Ubuntu%E4%B8%8Bbochs%E5%AE%89%E8%A3%85%E6%AD%A5%E9%AA%A4.html" title="Ubuntu下bochs安装步骤">Ubuntu下bochs安装步骤</a><time datetime="2023-12-10T10:13:34.000Z" title="发表于 2023-12-10 18:13:34">2023-12-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/%E7%BD%91%E7%BB%9C/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8/ssh%E8%BF%9E%E6%8E%A5%E6%9C%8D%E5%8A%A1%E5%99%A8.html" title="ssh连接服务器"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/web/post7.jpg" onerror="this.onerror=null;this.src='/img/web/404.jpg'" alt="ssh连接服务器"/></a><div class="content"><a class="title" href="/posts/%E7%BD%91%E7%BB%9C/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8/ssh%E8%BF%9E%E6%8E%A5%E6%9C%8D%E5%8A%A1%E5%99%A8.html" title="ssh连接服务器">ssh连接服务器</a><time datetime="2023-12-10T07:55:58.000Z" title="发表于 2023-12-10 15:55:58">2023-12-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%95%99%E8%82%B2%E7%BC%BA%E5%A4%B1%E7%9A%84%E4%B8%80%E8%AF%BE/%E5%A4%A7%E6%9D%82%E7%83%A9.html" title="大杂烩"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/web/post9.webp" onerror="this.onerror=null;this.src='/img/web/404.jpg'" alt="大杂烩"/></a><div class="content"><a class="title" href="/posts/%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%95%99%E8%82%B2%E7%BC%BA%E5%A4%B1%E7%9A%84%E4%B8%80%E8%AF%BE/%E5%A4%A7%E6%9D%82%E7%83%A9.html" title="大杂烩">大杂烩</a><time datetime="2023-12-03T07:37:14.000Z" title="发表于 2023-12-03 15:37:14">2023-12-03</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('/img/web/post1.jpeg')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By ICEFJL</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://fastly.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://fastly.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>function loadGiscus () {
  let nowTheme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'light'

  const config = Object.assign({
    src: 'https://giscus.app/client.js',
    'data-repo': 'icefjl/icefjl.github.io',
    'data-repo-id': 'MDEwOlJlcG9zaXRvcnkzOTEwMjIzNzg=',
    'data-category-id': 'DIC_kwDOF06HKs4CYIVf',
    'data-mapping': 'pathname',
    'data-theme': nowTheme,
    'data-reactions-enabled': '1',
    crossorigin: 'anonymous',
    async: true
  },{"data-strict":1,"data-lang":"zh-CN","data-input-position":"top"})

  let ele = document.createElement('script')
  for (let key in config) {
    ele.setAttribute(key, config[key])
  }
  document.getElementById('giscus-wrap').insertAdjacentElement('afterbegin',ele)
}

function changeGiscusTheme () {
  const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'light'

  function sendMessage(message) {
    const iframe = document.querySelector('iframe.giscus-frame');
    if (!iframe) return;
    iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
  }

  sendMessage({
    setConfig: {
      theme: theme
    }
  });
}

if ('Giscus' === 'Giscus' || !false) {
  if (false) btf.loadComment(document.getElementById('giscus-wrap'), loadGiscus)
  else loadGiscus()
} else {
  function loadOtherComment () {
    loadGiscus()
  }
}</script></div><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://fastly.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></body></html>