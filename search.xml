<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>选择配置</title>
      <link href="/posts/%E5%BA%94%E7%94%A8/%E9%85%8D%E7%BD%AE/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8/%E9%80%89%E6%8B%A9%E9%85%8D%E7%BD%AE.html"/>
      <url>/posts/%E5%BA%94%E7%94%A8/%E9%85%8D%E7%BD%AE/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8/%E9%80%89%E6%8B%A9%E9%85%8D%E7%BD%AE.html</url>
      
        <content type="html"><![CDATA[<h1 id="云计算的一些基本概念"><a href="#云计算的一些基本概念" class="headerlink" title="云计算的一些基本概念"></a>云计算的一些基本概念</h1><p>每家服务商对云服务器的叫法不同，阿里云叫 ECS，AWS 叫 EC2，Azure 就叫虚拟机，其实都是一种东西。所谓 ECS 或是 EC，指的就是 Elastic Compute Service，说人话就是可以扩展性能的云服务器。有时候我们还会接触到 VPS 这个概念，即 Virtual Private Server 个人虚拟化服务器，按我和 AWS 工作人员的聊天记录，云服务器和 VPS 区别在于 VPS 相当于打包的云服务器，即云服务器 + 硬盘 + 流量&#x3D;VPS。</p><p>相比较云服务器，一般来说 VPS 不支持扩展，但价格相对便宜一点，更合适个人使用。不过对于消费者我们不需要关注这些，我们主要考虑<strong>价格、性能、网络、稳定</strong>四个指标就行。</p><p>目前云计算的服务商可太多了，选择厂商时也不能光图便宜，收钱跑路的事也不是没有。在服务器价格堪比白菜的今天，还是尽可能选择大厂的产品好一点。选择云服务器的时候，要看看对方提供给你的机器性能，除了指标之外你需要考虑下这些 ECS&#x2F;VPS 是用了什么样的虚拟化技术，常见的有：</p><ul><li>KVM 和 Xen：支持各种操作系统，包括 Linux、Windows 等。</li><li>OpenVZ：仅支持 Linux，因为它依赖于宿主机的内核。</li></ul><p>一般来说，首选 KVM 和 Xen，尽量不选 OpenVZ 的机器，因为 OpenVZ 是容器化的虚拟机服务，出现<strong>超卖</strong>(即把一份资源同时卖给多个人) 的情况是不可避免的，这样用户的体验好的了吗？</p><p>另一方面我前面说了，服务器买的就是机器 + 网络。买云服务考虑的另一个大头就是网络，看你主要要拿机器做什么，如果都是国内业务，机器一定要离你越近越好，要不然你往机器上传下载东西能卡到你怀疑人生，当然也有的人不需要传东西，在哪就无所谓了。要走国外的流量，还需要研究线路的选择，这个事情比较复杂，我们在这里简单引用下网上的结论：</p><blockquote><p>线路排名一般情况下 CN2 GIA &gt; AS9929 &gt; AS4837 &gt; CN2 GT，具体也要看本地网络。</p></blockquote><p>最后就是带宽问题，根据你的需要考虑是按固定带宽合适，还是按流量计费合适，这都涉及到个人业务类型的不同，选择合适又省钱的方案即可。<br><strong>实战：以阿里云为例</strong></p><p>首先，阿里云支持所有个人用户免费试用 3 个月云 ECS，任何个人用户都可申请，详见：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://free.aliyun.com/?spm=5176.28508143.J_4VYgf18xNlTAyFFbOuOQe.13.e939154affazg3&amp;scm=20140722.M_10076474._.V_1</span><br></pre></td></tr></table></figure><p>个人免费试用结束后，在校生还可以进行学生身份认证，继续试用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://developer.aliyun.com/plan/student?spm=5176.28261954.J_7341193060.2.563a2fde1D6yBR&amp;scm=20140722.S_card@@%E5%85%B6%E4%BB%96@@2796646.S_card0.ID_card@@%E5%85%B6%E4%BB%96@@2796646-RL_%E9%AB%98%E6%A0%A1%E8%AE%A1%E5%88%92-LOC_search~UND~card~UND~item-OR_ser-V_3-P0_0</span><br></pre></td></tr></table></figure><p>这样个人版免费试用 3 个月 + 完成学生认证 1 个月 + 完成 ECS 实验认证 6 个月，共免费 10 个月，高校学生通用权益面向所有中国高校学生开放，具体包括中国大陆及港澳台地区专科、本科、硕士、博士、在职研究生等在校学生。</p><p>完成学生认证还能获得 300 无门槛优惠券，一年内有效。如果要是阿里云的合作院校 (包括清华大学、北京大学、浙江大学、上海交通大学、中国科学技术大学、华南理工大学和香港科技大学) 还能拿到 3 折优惠。</p>]]></content>
      
      
      <categories>
          
          <category> 应用 </category>
          
          <category> 配置 </category>
          
          <category> 云服务器 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>快捷键</title>
      <link href="/posts/%E5%BD%92%E6%A1%A3/%E5%BF%AB%E6%8D%B7%E9%94%AE.html"/>
      <url>/posts/%E5%BD%92%E6%A1%A3/%E5%BF%AB%E6%8D%B7%E9%94%AE.html</url>
      
        <content type="html"><![CDATA[<h1 id="windows-快捷键"><a href="#windows-快捷键" class="headerlink" title="windows 快捷键"></a>windows 快捷键</h1><p><a href="https://www.bilibili.com/read/cv28139330/">来源</a></p><ul><li>快速显示桌面 Win+D 键</li></ul><blockquote><p>只要按下 Windows+D 键，所有的窗口都会缩小，桌面就出现了。如果你想再看看刚才的窗口，再单击 Windows+D 键就行。</p></blockquote><ul><li>开启文件管理器 Win+E 键</li><li>快速锁定计算机 Win+L 键</li><li>开启 Emoji 图标 Win+.键</li><li>打开剪切板 Win+V 键</li><li>开启 Windows 设置 Win+I 键</li><li>快速打开显示设置 Win+U 键</li><li>快速打开投影选项 Win+P 键</li><li>打开 Windows 运行 Win+R 键</li></ul><blockquote><p>按组合键 Windows+R 键，可以快速打开运行对话框，在运行界面文本框中输入不同的指令，有不同的效果，而我比较常使用的几个 Window+R 快捷键如下：<br>notepad——打开记事本<br>calc——小计算器工具<br>control——控制面板系<br>cmd——命令提示符<br>regedit——注册表编辑器<br>mspaint——画图</p></blockquote><ul><li>打开系统搜索 Win+S 键</li><li>打开电脑常用管理工具 Win+X 键</li></ul><blockquote><p>按快捷键 Windows+X 键，可以打开 Windows 系统常用管理工具集合，每个工具名称选项后面都有一个字母，当按 Win+X 键后，再按对应的工具名称代替字母，就可以打开该工具界面。</p></blockquote><ul><li>桌面展示多任务窗口 Win+Tab 键</li><li>快速截图，Windows+Shift+S</li></ul>]]></content>
      
      
      <categories>
          
          <category> 归档 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>dot语言</title>
      <link href="/posts/%E5%BA%94%E7%94%A8/%E8%AF%AD%E8%A8%80/%E5%BD%92%E6%A1%A31/dot%E8%AF%AD%E8%A8%80.html"/>
      <url>/posts/%E5%BA%94%E7%94%A8/%E8%AF%AD%E8%A8%80/%E5%BD%92%E6%A1%A31/dot%E8%AF%AD%E8%A8%80.html</url>
      
        <content type="html"><![CDATA[<h1 id="UML-绘制-dot-语言"><a href="#UML-绘制-dot-语言" class="headerlink" title="UML 绘制 -dot 语言"></a>UML 绘制 -dot 语言</h1><h2 id="DOT-语言基础"><a href="#DOT-语言基础" class="headerlink" title="DOT 语言基础"></a>DOT 语言基础</h2><h3 id="基本的-DOT-文件"><a href="#基本的-DOT-文件" class="headerlink" title="基本的 DOT 文件"></a>基本的 DOT 文件</h3><p>demo01.dot</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">digraph demo&#123;</span><br><span class="line">    A-&gt;B[dir<span class="operator">=</span>both]<span class="comment">;</span></span><br><span class="line">    B-&gt;C[dir<span class="operator">=</span>none]<span class="comment">;</span></span><br><span class="line">    C-&gt;D[dir<span class="operator">=</span>back]<span class="comment">;</span></span><br><span class="line">    D-&gt;A[dir<span class="operator">=</span>forward]<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="从-DOT-文件生成图像"><a href="#从-DOT-文件生成图像" class="headerlink" title="从 DOT 文件生成图像"></a>从 DOT 文件生成图像</h3><p><code>dot demo01.dot –Tpng –o demo01.png</code></p><p><img src="/../../../../img/blog/74874464eb38dc31e7f31a7b7d592c80_MD5.png" alt="渲染结果" title="渲染结果"></p><h2 id="PlantUML"><a href="#PlantUML" class="headerlink" title="PlantUML"></a>PlantUML</h2><p>PlantUML 是基于 Graphviz 的一个开源项目，并支持快速绘制：</p><ul><li>时序图</li><li>用例图</li><li>类图</li><li>活动图 (here is the new syntax),</li><li>组件图</li><li>状态图</li><li>Deployment diagram,</li><li>对象图</li><li>wireframe graphical interface</li></ul><p>可以生成 png,svg,Latex 格式的图片，可以作为插件使用：</p><ul><li>Intellij idea</li><li>Eclipse</li><li>NetBeans</li><li>Ckeditor</li><li>TinyMCE Editor</li><li>Sublime Text Editor</li><li>Vim</li><li>Emacs</li><li>Atom</li><li>….</li></ul><p>下面说一下 Sublime Text 安装 PlantUML 的过程：</p><ul><li>下载 PlantUML for Sublime 插件，并解压</li><li>通过 Preferences -&gt; Browse Packages … 打开 sublime 的 Packages 目录，解压后的插件放在 Packages 目录下</li><li>重启 Sublime</li><li>为了简化使用，可以在 Sublime 里配置个快捷键。打开 Preferences -&gt; Key Binding - User，添加一个快捷键：<br>  { “keys”: [“alt+d”], “command”: “display_diagrams”}</li></ul><p>上面的代码配置成按住 Alt + d 来生成 PlantUML 图片，你可以修改成你自己喜欢的按键。</p><p>参考自使用 Sublime + PlantUML 高效地画图</p><h2 id="画状态图"><a href="#画状态图" class="headerlink" title="画状态图"></a>画状态图</h2><blockquote><p>我这里以状态图为例，如果你需要画其他图，到 PlantUML 查看</p></blockquote><h3 id="简单状态图"><a href="#简单状态图" class="headerlink" title="简单状态图"></a>简单状态图</h3><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@startuml</span></span><br><span class="line"></span><br><span class="line">[*] --&gt; State1</span><br><span class="line">State1 --&gt; [*]</span><br><span class="line"><span class="attribute">State1 </span>: this is a string</span><br><span class="line"><span class="attribute">State1 </span>: this is another string</span><br><span class="line"></span><br><span class="line">State1 -&gt; State2</span><br><span class="line">State2 --&gt; [*]</span><br><span class="line"></span><br><span class="line"><span class="variable">@enduml</span></span><br></pre></td></tr></table></figure><p>快捷键 <code>alt+d</code></p><p><img src="/../../../../img/blog/14dfa837bb59e55fd868092f1f8ee21f_MD5.png" alt="简单状态图" title="简单状态图"></p><h3 id="合成状态"><a href="#合成状态" class="headerlink" title="合成状态"></a>合成状态</h3><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">@startuml</span><br><span class="line">scale <span class="number">350</span> width</span><br><span class="line">[*] --&gt; NotShooting</span><br><span class="line"></span><br><span class="line"><span class="keyword">state</span> NotShooting &#123;</span><br><span class="line">  [*] --&gt; Idle</span><br><span class="line">  Idle --&gt; Configuring : EvConfig</span><br><span class="line">  Configuring --&gt; Idle : EvConfig</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">state</span> Configuring &#123;</span><br><span class="line">  [*] --&gt; NewValueSelection</span><br><span class="line">  NewValueSelection --&gt; NewValuePreview : EvNewValue</span><br><span class="line">  NewValuePreview --&gt; NewValueSelection : EvNewValueRejected</span><br><span class="line">  NewValuePreview --&gt; NewValueSelection : EvNewValueSaved</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">state</span> NewValuePreview &#123;</span><br><span class="line">     State1 -&gt; State2</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure><ul><li>scale 350 width,指定图的宽度为 350，等比例缩放</li></ul><p><img src="/../../../../img/blog/8889e96d393176baca71128ae43a3f8c_MD5.png" alt="合成状态图" title="合成状态图"></p><h2 id="长名字"><a href="#长名字" class="headerlink" title="长名字"></a>长名字</h2><p>如果状态的名称过长，使用 state 关键字</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">@startuml</span><br><span class="line">scale <span class="number">600</span> width</span><br><span class="line"></span><br><span class="line">[*] -&gt; State1</span><br><span class="line">S<span class="function"><span class="title">tate1</span> --&gt;</span> State2 : Succeeded</span><br><span class="line">S<span class="function"><span class="title">tate1</span> --&gt;</span> [*] : Aborted</span><br><span class="line">S<span class="function"><span class="title">tate2</span> --&gt;</span> State3 : Succeeded</span><br><span class="line">S<span class="function"><span class="title">tate2</span> --&gt;</span> [*] : Aborted</span><br><span class="line">state State3 &#123;</span><br><span class="line">  state <span class="string">&quot;Accumulate Enough Data\nLong State Name&quot;</span> <span class="keyword">as</span> long1</span><br><span class="line">  long1 : Just a test</span><br><span class="line">  [*] --&gt; long1</span><br><span class="line">  <span class="function"><span class="title">long1</span> --&gt;</span> long1 : New Data</span><br><span class="line">  <span class="function"><span class="title">long1</span> --&gt;</span> ProcessData : Enough Data</span><br><span class="line">&#125;</span><br><span class="line">S<span class="function"><span class="title">tate3</span> --&gt;</span> State3 : Failed</span><br><span class="line">S<span class="function"><span class="title">tate3</span> --&gt;</span> [*] : Succeeded / Save Result</span><br><span class="line">S<span class="function"><span class="title">tate3</span> --&gt;</span> [*] : Aborted</span><br><span class="line"> </span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure><p><img src="/../../../../img/blog/57d3a5dd32692daa220db432b336e265_MD5.png" alt="长名字" title="长名字"></p><h2 id="并发状态"><a href="#并发状态" class="headerlink" title="并发状态"></a>并发状态</h2><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@startuml</span></span><br><span class="line">[*] --&gt; Active</span><br><span class="line"></span><br><span class="line">state Active &#123;</span><br><span class="line">  <span class="selector-attr">[*]</span> <span class="selector-tag">-</span>&gt; <span class="selector-tag">NumLockOff</span></span><br><span class="line">  <span class="selector-tag">NumLockOff</span> <span class="selector-tag">--</span>&gt; <span class="selector-tag">NumLockOn</span> : <span class="selector-tag">EvNumLockPressed</span></span><br><span class="line">  <span class="selector-tag">NumLockOn</span> <span class="selector-tag">--</span>&gt; <span class="selector-tag">NumLockOff</span> : <span class="selector-tag">EvNumLockPressed</span></span><br><span class="line">  <span class="selector-tag">--</span></span><br><span class="line">  <span class="selector-attr">[*]</span> <span class="selector-tag">-</span>&gt; <span class="selector-tag">CapsLockOff</span></span><br><span class="line">  <span class="selector-tag">CapsLockOff</span> <span class="selector-tag">--</span>&gt; <span class="selector-tag">CapsLockOn</span> : <span class="selector-tag">EvCapsLockPressed</span></span><br><span class="line">  <span class="selector-tag">CapsLockOn</span> <span class="selector-tag">--</span>&gt; <span class="selector-tag">CapsLockOff</span> : <span class="selector-tag">EvCapsLockPressed</span></span><br><span class="line">  <span class="selector-tag">--</span></span><br><span class="line">  <span class="selector-attr">[*]</span> <span class="selector-tag">-</span>&gt; <span class="selector-tag">ScrollLockOff</span></span><br><span class="line">  <span class="selector-tag">ScrollLockOff</span> <span class="selector-tag">--</span>&gt; <span class="selector-tag">ScrollLockOn</span> : <span class="selector-tag">EvCapsLockPressed</span></span><br><span class="line">  <span class="selector-tag">ScrollLockOn</span> <span class="selector-tag">--</span>&gt; <span class="selector-tag">ScrollLockOff</span> : <span class="selector-tag">EvCapsLockPressed</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">@enduml</span></span><br></pre></td></tr></table></figure><ul><li>用 – 作为分隔符来合成并发状态。</li></ul><p><img src="/../../../../img/blog/caefc3b72183028882bff59b4e6c746f_MD5.png" alt="并发状态" title="并发状态"></p><h2 id="箭头方向"><a href="#箭头方向" class="headerlink" title="箭头方向"></a>箭头方向</h2><ul><li>使用 -&gt;定义水平箭头，也可以使用下列格式强制设置箭头方向：<br>1)-down-&gt; (default arrow)<br>2)-right-&gt; or -&gt;<br>3)-left-&gt;<br>4)-up-&gt;</li></ul><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@startuml</span></span><br><span class="line">[*] -up-&gt; First</span><br><span class="line">First -&gt; Second</span><br><span class="line">Second --&gt; Third</span><br><span class="line">Third --&gt; Fourth</span><br><span class="line">Fourth -left-&gt; Last</span><br><span class="line"><span class="variable">@enduml</span></span><br></pre></td></tr></table></figure><p><img src="/../../../../img/blog/73cca000c91a0ff919c227bd1fe40b37_MD5.png" alt="箭头方向" title="箭头方向"></p><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>关键字：</p><ul><li>note left of</li><li>note right of</li><li>note top of</li><li>note bottom of</li></ul><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@startuml</span></span><br><span class="line"></span><br><span class="line">[*] --&gt; Active</span><br><span class="line">Active --&gt; Inactive</span><br><span class="line"></span><br><span class="line">note left of <span class="attribute">Active </span>: this is a short\nnote</span><br><span class="line"></span><br><span class="line">note right of Inactive</span><br><span class="line">  A note can also</span><br><span class="line">  be defined on</span><br><span class="line">  several lines</span><br><span class="line">end note</span><br><span class="line"></span><br><span class="line"><span class="variable">@enduml</span></span><br></pre></td></tr></table></figure><p><img src="/../../../../img/blog/70c94bcabe4036a70541501974ccd747_MD5.png"></p><ul><li>浮动注释</li></ul><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@startuml</span></span><br><span class="line"></span><br><span class="line">state foo</span><br><span class="line">note <span class="string">&quot;This is a floating note&quot;</span> as N1</span><br><span class="line"></span><br><span class="line"><span class="variable">@enduml</span></span><br></pre></td></tr></table></figure><p><img src="/../../../../img/blog/13f5a6ff290b369a2105fb5c2956c6db_MD5.png"></p><ul><li>合成状态的注释</li></ul><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@startuml</span><br><span class="line"></span><br><span class="line">[*] --&gt; NotShooting</span><br><span class="line"></span><br><span class="line"><span class="keyword">state</span> <span class="string">&quot;Not Shooting State&quot;</span> as NotShooting &#123;</span><br><span class="line">  <span class="keyword">state</span> <span class="string">&quot;Idle mode&quot;</span> as Idle</span><br><span class="line">  <span class="keyword">state</span> <span class="string">&quot;Configuring mode&quot;</span> as Configuring</span><br><span class="line">  [*] --&gt; Idle</span><br><span class="line">  Idle --&gt; Configuring : EvConfig</span><br><span class="line">  Configuring --&gt; Idle : EvConfig</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">note right of NotShooting : This is a note <span class="keyword">on</span> a composite <span class="keyword">state</span></span><br><span class="line"></span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure><p><img src="/../../../../img/blog/5f2c463f9e29caf59e32adbeaaaa326d_MD5.png"></p><h2 id="主题修改"><a href="#主题修改" class="headerlink" title="主题修改"></a>主题修改</h2><ul><li>使用 skinparam 命令改变字体和颜色。</li></ul><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">@startuml</span><br><span class="line">skinparam backgroundColor LightYellow</span><br><span class="line">skinparam state &#123;</span><br><span class="line">  StartColor MediumBlue</span><br><span class="line">  EndColor Red</span><br><span class="line">  BackgroundColor #e0f</span><br><span class="line">  BackgroundColor<span class="symbol">&lt;&lt;Warning&gt;&gt;</span> #aaa</span><br><span class="line">  FontColor<span class="symbol">&lt;&lt;Warning&gt;&gt;</span> Orange</span><br><span class="line">  BorderColor Orange</span><br><span class="line">  FontName Monaco</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[*] <span class="comment">--&gt; NotShooting</span></span><br><span class="line"></span><br><span class="line">state &quot;Not Shooting State&quot; <span class="keyword">as</span> NotShooting &#123;</span><br><span class="line">  state &quot;Idle mode&quot; <span class="keyword">as</span> Idle <span class="symbol">&lt;&lt;Warning&gt;&gt;</span></span><br><span class="line">  state &quot;Configuring mode&quot; <span class="keyword">as</span> Configuring</span><br><span class="line">  [*] <span class="comment">--&gt; Idle</span></span><br><span class="line">  Idle <span class="comment">--&gt; Configuring : EvConfig</span></span><br><span class="line">  Configuring <span class="comment">--&gt; Idle : EvConfig</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">NotShooting <span class="comment">--&gt; [*]</span></span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure><p><img src="/../../../../img/blog/081500d0764e88c7966714f64c229846_MD5.png"></p><p>有一个网站，可以实时预览 <a href="https://www.planttext.com/">PlantText UML Editor</a></p><h1 id="使用-graphviz-绘图"><a href="#使用-graphviz-绘图" class="headerlink" title="使用 graphviz 绘图"></a>使用 graphviz 绘图</h1><h2 id="Graphviz-简介"><a href="#Graphviz-简介" class="headerlink" title="Graphviz 简介"></a>Graphviz 简介</h2><p>本文介绍一个高效而简洁的绘图工具 <code>graphviz</code>。<code>graphviz</code> 是贝尔实验室开发的一个开源的工具包，它使用一个特定的 <code>DSL</code> (领域特定语言): <code>dot</code> 作为脚本语言，然后使用布局引擎来解析此脚本，并完成自动布局。<code>graphviz</code> 提供丰富的导出格式，如常用的图片格式，SVG，PDF 格式等。<br><code>graphviz</code> 中包含了众多的布局器：</p><ul><li><code>dot</code> 默认布局方式，主要用于有向图</li><li><code>neato</code> 基于 spring-model (又称 force-based) 算法</li><li><code>twopi</code> 径向布局</li><li><code>circo</code> 圆环布局</li><li><code>fdp</code> 用于无向图</li></ul><p><code>graphviz</code> 的设计初衷是对 <code>有向图/无向图</code> 等进行自动布局，开发人员使用 dot 脚本定义图形元素，然后选择算法进行布局，最终导出结果。<br>首先，在 dot 脚本中定义图的顶点和边，顶点和边都具有各自的属性，比如形状，颜色，填充模式，字体，样式等。然后使用合适的布局算法进行布局。布局算法除了绘制各个顶点和边之外，需要尽可能的将顶点均匀的分布在画布上，并且尽可能的减少边的交叉 (如果交叉过多，就很难看清楚顶点之间的关系了)。所以使用 <code>graphviz</code> 的一般流程为：</p><ul><li>定义一个图，并向图中添加需要的顶点和边</li><li>为顶点和边添加样式</li><li>使用布局引擎进行绘制</li></ul><p>一旦熟悉这种开发模式，就可以快速的将你的想法绘制出来。配合一个良好的编辑器 (vim&#x2F;emacs) 等，可以极大的提高开发效率，与常见的 GUI 应用的所见即所得模式对应，此模式称为所思即所得。比如在我的机器上，使用 Sublime Text 编辑 <code>dot</code> 脚本，然后将 <code>F7/Cmd-B</code> 映射为调用 <code>dot引擎</code> 去绘制当前脚本，并打开一个新的窗口来显示运行结果：<br><img src="/../../../../img/blog/7ad541744727621ce1e239645f0b0789_MD5.png"><br>对于开发人员而言，经常会用到的图形绘制可能包括：函数调用关系，一个复杂的数据结构，系统的模块组成，抽象语法树等。</p><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><p>graphviz 包含 3 中元素，<code>图</code>，<code>顶点</code> 和 <code>边</code>。每个元素都可以具有各自的属性，用来定义字体，样式，颜色，形状等。下面是一些简单的示例，可以帮助我们快速的了解 graphviz 的基本用法。</p><h3 id="第一个-Graphviz-图"><a href="#第一个-Graphviz-图" class="headerlink" title="第一个 Graphviz 图"></a>第一个 Graphviz 图</h3><p>比如，要绘制一个有向图，包含 4 个节点 <code>a,b,c,d</code>。其中 <code>a</code> 指向 <code>b</code>，<code>b</code> 和 <code>c</code> 指向 <code>d</code>。可以定义下列脚本：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">digraph abc&#123;</span><br><span class="line">a;</span><br><span class="line">b;</span><br><span class="line">c;</span><br><span class="line">d;</span><br><span class="line"> </span><br><span class="line">a -&gt; b;</span><br><span class="line">b -&gt; d;</span><br><span class="line">c -&gt; d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 <code>dot</code> 布局方式，绘制出来的效果如下：<br><img src="/../../../../img/blog/b99b503eb30fd8f4f804167926fd2b0d_MD5.gif"><br>默认的顶点中的文字为定义顶点变量的名称，形状为椭圆。边的默认样式为黑色实线箭头，我们可以在脚本中做一下修改，将顶点改为 <code>方形</code>，边改为 <code>虚线</code>。</p><h3 id="定义顶点和边的样式"><a href="#定义顶点和边的样式" class="headerlink" title="定义顶点和边的样式"></a>定义顶点和边的样式</h3><p>在 <code>digraph</code> 的花括号内，添加顶点和边的新定义：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">node [shape=&quot;record&quot;];</span><br><span class="line">edge [style=&quot;dashed&quot;];</span><br></pre></td></tr></table></figure><p>则绘制的效果如下：<br><img src="/../../../../img/blog/4e52eacca5026225fd829601d6f697fb_MD5.gif"></p><h3 id="进一步修改顶点和边样式"><a href="#进一步修改顶点和边样式" class="headerlink" title="进一步修改顶点和边样式"></a>进一步修改顶点和边样式</h3><p>进一步，我们将顶点 <code>a</code> 的颜色改为 <code>淡绿色</code>，并将 <code>c</code> 到 <code>d</code> 的边改为 <code>红色</code>，脚本如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">digraph abc&#123;</span><br><span class="line">node [shape=&quot;record&quot;];</span><br><span class="line">edge [style=&quot;dashed&quot;];</span><br><span class="line"> </span><br><span class="line">a [style=&quot;filled&quot;, color=&quot;black&quot;, fillcolor=&quot;chartreuse&quot;];</span><br><span class="line">b;</span><br><span class="line">c;</span><br><span class="line">d;</span><br><span class="line"> </span><br><span class="line">a -&gt; b;</span><br><span class="line">b -&gt; d;</span><br><span class="line">c -&gt; d [color=&quot;red&quot;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>绘制的结果如下：<br><img src="/../../../../img/blog/771137c47d5a0770518f7162af0ae504_MD5.gif"><br>应当注意到，顶点和边都接受属性的定义，形式为在顶点和边的定义之后加上一个由方括号括起来的 <code>key-value</code> 列表，每个 <code>key-value</code> 对由逗号隔开。如果图中顶点和边采用统一的风格，则可以在图定义的首部定义 <code>node</code>, <code>edge</code> 的属性。比如上图中，定义所有的顶点为方框，所有的边为虚线，在具体的顶点和边之后定义的属性将覆盖此全局属性。如特定与 <code>a</code> 的绿色，<code>c</code> 到 <code>d</code> 的边的红色。</p><h3 id="以图片为节点"><a href="#以图片为节点" class="headerlink" title="以图片为节点"></a>以图片为节点</h3><p>除了颜色，节点还可以使用图片。不过需要注意的是，在使用图片作为节点的时候，需要将本来的形状设置为 <code>none</code>，并且将 <code>label</code> 置为空字符串，避免出现文字对图片的干扰。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">digraph abc&#123;</span><br><span class="line">node [shape=&quot;record&quot;];</span><br><span class="line">edge [style=&quot;dashed&quot;];</span><br><span class="line"> </span><br><span class="line">a [style=&quot;filled&quot;, color=&quot;black&quot;, fillcolor=&quot;chartreuse&quot;];</span><br><span class="line">b;</span><br><span class="line">c [shape=&quot;none&quot;, image=&quot;logos/browser-icon-chrome-resized.png&quot;, label=&quot;&quot;];</span><br><span class="line">d;</span><br><span class="line"> </span><br><span class="line">a -&gt; b;</span><br><span class="line">b -&gt; d;</span><br><span class="line">c -&gt; d [color=&quot;red&quot;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/../../../../img/blog/e673f5edaf4987f14a187fc08892d72d_MD5.png"></p><h2 id="子图的绘制"><a href="#子图的绘制" class="headerlink" title="子图的绘制"></a>子图的绘制</h2><p>graphviz 支持子图，即图中的部分节点和边相对对立 (软件的模块划分经常如此)。比如，我们可以将顶点 c 和 d 归为一个子图：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">digraph abc&#123;</span><br><span class="line">node [shape=&quot;record&quot;];</span><br><span class="line">edge [style=&quot;dashed&quot;];</span><br><span class="line"> </span><br><span class="line">a [style=&quot;filled&quot;, color=&quot;black&quot;, fillcolor=&quot;chartreuse&quot;];</span><br><span class="line">b;</span><br><span class="line"> </span><br><span class="line">    subgraph cluster_cd&#123;</span><br><span class="line">    label=&quot;c and d&quot;;</span><br><span class="line">    bgcolor=&quot;mintcream&quot;;</span><br><span class="line">    c;</span><br><span class="line">    d;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">a -&gt; b;</span><br><span class="line">b -&gt; d;</span><br><span class="line">c -&gt; d [color=&quot;red&quot;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将 <code>c</code> 和 <code>d</code> 划分到 <code>cluster_cd</code> 这个子图中，标签为 <code>c and d</code>, 并添加背景色，以方便与主图区分开，绘制结果如下：<br><img src="/../../../../img/blog/fe829a415f4567d8294e30b6d54ec7ba_MD5.gif"><br>应该注意的是，子图的名称必须以 <code>cluster</code> 开头，否则 <code>graphviz</code> 无法设别。</p><h3 id="数据结构的可视化"><a href="#数据结构的可视化" class="headerlink" title="数据结构的可视化"></a>数据结构的可视化</h3><p>实际开发中，经常要用到的是对复杂数据结构的描述，<code>graphviz</code> 提供完善的机制来绘制此类图形。</p><h4 id="一个-Hash-表的数据结构"><a href="#一个-Hash-表的数据结构" class="headerlink" title="一个 Hash 表的数据结构"></a>一个 Hash 表的数据结构</h4><p>比如一个 hash 表的内容，可能具有下列结构：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">st_hash_type</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> (*compare) ();</span><br><span class="line">    <span class="type">int</span> (*hash) ();</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">st_table_entry</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> hash;</span><br><span class="line">    <span class="type">char</span> *key;</span><br><span class="line">    <span class="type">char</span> *record;</span><br><span class="line">    st_table_entry *next;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">st_table</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">st_hash_type</span> *<span class="title">type</span>;</span></span><br><span class="line">    <span class="type">int</span> num_bins; <span class="comment">/* slot count */</span></span><br><span class="line">    <span class="type">int</span> num_entries; <span class="comment">/* total number of entries */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">st_table_entry</span> **<span class="title">bins</span>;</span> <span class="comment">/* slot */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="绘制-Hash-表的数据结构"><a href="#绘制-Hash-表的数据结构" class="headerlink" title="绘制 Hash 表的数据结构"></a>绘制 Hash 表的数据结构</h4><p>从代码上看，由于结构体存在引用关系，不够清晰，如果层次较多，则很难以记住各个结构之间的关系，我们可以通过下图来更清楚的展示：<br><img src="/../../../../img/blog/12a33ca70cb0bcf5621219fe4cec1a0a_MD5.gif"><br>脚本如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">digraph st2&#123;</span><br><span class="line">fontname = &quot;Verdana&quot;;</span><br><span class="line">fontsize = 10;</span><br><span class="line">rankdir=TB;</span><br><span class="line"> </span><br><span class="line">node [fontname = &quot;Verdana&quot;, fontsize = 10, color=&quot;skyblue&quot;, shape=&quot;record&quot;];</span><br><span class="line"> </span><br><span class="line">edge [fontname = &quot;Verdana&quot;, fontsize = 10, color=&quot;crimson&quot;, style=&quot;solid&quot;];</span><br><span class="line"> </span><br><span class="line">st_hash_type [label=&quot;&#123;&lt;head&gt;st_hash_type|(*compare)|(*hash)&#125;&quot;];</span><br><span class="line">st_table_entry [label=&quot;&#123;&lt;head&gt;st_table_entry|hash|key|record|&lt;next&gt;next&#125;&quot;];</span><br><span class="line">st_table [label=&quot;&#123;st_table|&lt;type&gt;type|num_bins|num_entries|&lt;bins&gt;bins&#125;&quot;];</span><br><span class="line"> </span><br><span class="line">st_table:bins -&gt; st_table_entry:head;</span><br><span class="line">st_table:type -&gt; st_hash_type:head;</span><br><span class="line">st_table_entry:next -&gt; st_table_entry:head [style=&quot;dashed&quot;, color=&quot;forestgreen&quot;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>应该注意到，在顶点的形状为 <code>record</code> 的时候，<code>label</code> 属性的语法比较奇怪，但是使用起来非常灵活。比如，用竖线 “|” 隔开的串会在绘制出来的节点中展现为一条分隔符。用 <code>&lt;&gt;</code> 括起来的串称为锚点，当一个节点具有多个锚点的时候，这个特性会非常有用，比如节点 <code>st_table</code> 的 <code>type</code> 属性指向 <code>st_hash_type</code>，第 4 个属性指向 <code>st_table_entry</code> 等，都是通过锚点来实现的。<br>我们发现，使用默认的 <code>dot</code> 布局后，绿色的这条边覆盖了数据结构 <code>st_table_entry</code>，并不美观，因此可以使用别的布局方式来重新布局，如使用 <code>circo</code> 算法：<br><img src="/../../../../img/blog/e3cb870ad854cb6d856c765d6b256ca0_MD5.gif"><br>则可以得到更加合理的布局结果。</p><h3 id="Hash-表的实例"><a href="#Hash-表的实例" class="headerlink" title="Hash 表的实例"></a>Hash 表的实例</h3><p>另外，这个 hash 表的一个实例如下：<br><img src="/../../../../img/blog/3809051b78163ea25b528cdf8d5026e3_MD5.gif"><br>脚本如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">digraph st&#123;</span><br><span class="line">fontname = &quot;Verdana&quot;;</span><br><span class="line">fontsize = 10;</span><br><span class="line">rankdir = LR;</span><br><span class="line">rotate = 90;</span><br><span class="line"> </span><br><span class="line">node [ shape=&quot;record&quot;, width=.1, height=.1];</span><br><span class="line">node [fontname = &quot;Verdana&quot;, fontsize = 10, color=&quot;skyblue&quot;, shape=&quot;record&quot;];</span><br><span class="line"> </span><br><span class="line">edge [fontname = &quot;Verdana&quot;, fontsize = 10, color=&quot;crimson&quot;, style=&quot;solid&quot;];</span><br><span class="line">node [shape=&quot;plaintext&quot;];</span><br><span class="line"> </span><br><span class="line">st_table [label=&lt;</span><br><span class="line">    &lt;table border=&quot;0&quot; cellborder=&quot;1&quot; cellspacing=&quot;0&quot; align=&quot;left&quot;&gt;</span><br><span class="line">    &lt;tr&gt;</span><br><span class="line">    &lt;td&gt;st_table&lt;/td&gt;</span><br><span class="line">    &lt;/tr&gt;</span><br><span class="line">    &lt;tr&gt;</span><br><span class="line">    &lt;td&gt;num_bins=5&lt;/td&gt;</span><br><span class="line">    &lt;/tr&gt;</span><br><span class="line">    &lt;tr&gt;</span><br><span class="line">    &lt;td&gt;num_entries=3&lt;/td&gt;</span><br><span class="line">    &lt;/tr&gt;</span><br><span class="line">    &lt;tr&gt;</span><br><span class="line">    &lt;td port=&quot;bins&quot;&gt;bins&lt;/td&gt;</span><br><span class="line">    &lt;/tr&gt;</span><br><span class="line">    &lt;/table&gt;</span><br><span class="line">&gt;];</span><br><span class="line"> </span><br><span class="line">node [shape=&quot;record&quot;];</span><br><span class="line">num_bins [label=&quot; &lt;b1&gt; | &lt;b2&gt; | &lt;b3&gt; | &lt;b4&gt; | &lt;b5&gt; &quot;, height=2];</span><br><span class="line">node[ width=2 ];</span><br><span class="line"> </span><br><span class="line">entry_1 [label=&quot;&#123;&lt;e&gt;st_table_entry|&lt;next&gt;next&#125;&quot;];</span><br><span class="line">entry_2 [label=&quot;&#123;&lt;e&gt;st_table_entry|&lt;next&gt;null&#125;&quot;];</span><br><span class="line">entry_3 [label=&quot;&#123;&lt;e&gt;st_table_entry|&lt;next&gt;null&#125;&quot;];</span><br><span class="line"> </span><br><span class="line">st_table:bins -&gt; num_bins:b1;</span><br><span class="line">num_bins:b1 -&gt; entry_1:e;</span><br><span class="line">entry_1:next -&gt; entry_2:e;</span><br><span class="line">num_bins:b3 -&gt; entry_3:e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上例中可以看到，节点的 <code>label</code> 属性支持类似于 <code>HTML</code> 语言中的 TABLE 形式的定义，通过行列的数目来定义节点的形状，从而使得节点的组成更加灵活。</p><h3 id="软件模块组成图"><a href="#软件模块组成图" class="headerlink" title="软件模块组成图"></a>软件模块组成图</h3><p>Apache httpd 模块关系<br><img src="/../../../../img/blog/2befb398276e7bdfba84ff65de32a786_MD5.gif"><br>在实际的开发中，随着系统功能的完善，软件整体的结构会越来越复杂，通常开发人员会将软件划分为可理解的多个子模块，各个子模块通过协作，完成各种各样的需求。<br>下面有个例子，是某软件设计时的一个草稿：<br><img src="/../../../../img/blog/9f04472ca0960627d840020534ab1397_MD5.gif"><br>IDP 支持层为一个相对独立的子系统，其中包括如数据库管理器，配置信息管理器等模块，另外为了提供更大的灵活性，将很多其他的模块抽取出来作为外部模块，而支持层提供一个模块管理器，来负责加载&#x2F;卸载这些外部的模块集合。<br>这些模块间的关系较为复杂，并且有部分模块关系密切，应归类为一个子系统中，上图对应的 <code>dot</code> 脚本为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">digraph idp_modules&#123;</span><br><span class="line"> </span><br><span class="line">rankdir = TB;</span><br><span class="line">fontname = &quot;Microsoft YaHei&quot;;</span><br><span class="line">fontsize = 12;</span><br><span class="line"> </span><br><span class="line">node [ fontname = &quot;Microsoft YaHei&quot;, fontsize = 12, shape = &quot;record&quot; ]; </span><br><span class="line">edge [ fontname = &quot;Microsoft YaHei&quot;, fontsize = 12 ];</span><br><span class="line"> </span><br><span class="line">    subgraph cluster_sl&#123;</span><br><span class="line">        label=&quot;IDP支持层&quot;;</span><br><span class="line">        bgcolor=&quot;mintcream&quot;;</span><br><span class="line">        node [shape=&quot;Mrecord&quot;, color=&quot;skyblue&quot;, style=&quot;filled&quot;];</span><br><span class="line">        network_mgr [label=&quot;网络管理器&quot;];</span><br><span class="line">        log_mgr [label=&quot;日志管理器&quot;];</span><br><span class="line">        module_mgr [label=&quot;模块管理器&quot;];</span><br><span class="line">        conf_mgr [label=&quot;配置管理器&quot;];</span><br><span class="line">        db_mgr [label=&quot;数据库管理器&quot;];</span><br><span class="line">    &#125;;</span><br><span class="line"> </span><br><span class="line">    subgraph cluster_md&#123;</span><br><span class="line">        label=&quot;可插拔模块集&quot;;</span><br><span class="line">        bgcolor=&quot;lightcyan&quot;;</span><br><span class="line">        node [color=&quot;chartreuse2&quot;, style=&quot;filled&quot;];</span><br><span class="line">        mod_dev [label=&quot;开发支持模块&quot;];</span><br><span class="line">        mod_dm [label=&quot;数据建模模块&quot;];</span><br><span class="line">        mod_dp [label=&quot;部署发布模块&quot;];</span><br><span class="line">    &#125;;</span><br><span class="line"> </span><br><span class="line">mod_dp -&gt; mod_dev [label=&quot;依赖...&quot;];</span><br><span class="line">mod_dp -&gt; mod_dm [label=&quot;依赖...&quot;];</span><br><span class="line">mod_dp -&gt; module_mgr [label=&quot;安装...&quot;, color=&quot;yellowgreen&quot;, arrowhead=&quot;none&quot;];</span><br><span class="line">mod_dev -&gt; mod_dm [label=&quot;依赖...&quot;];</span><br><span class="line">mod_dev -&gt; module_mgr [label=&quot;安装...&quot;, color=&quot;yellowgreen&quot;, arrowhead=&quot;none&quot;];</span><br><span class="line">mod_dm -&gt; module_mgr [label=&quot;安装...&quot;, color=&quot;yellowgreen&quot;, arrowhead=&quot;none&quot;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="状态图"><a href="#状态图" class="headerlink" title="状态图"></a>状态图</h3><p>有限自动机示意图<br><img src="/../../../../img/blog/4524e3fd3dbec4dc95770ca17e113fcc_MD5.gif"><br>上图是一个简易有限自动机，接受 <code>a</code> 及 <code>a</code> 结尾的任意长度的串。其脚本定义如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">digraph automata_0 &#123;</span><br><span class="line">size = &quot;8.5, 11&quot;;</span><br><span class="line">fontname = &quot;Microsoft YaHei&quot;;</span><br><span class="line">fontsize = 10;</span><br><span class="line"> </span><br><span class="line">node [shape = circle, fontname = &quot;Microsoft YaHei&quot;, fontsize = 10];</span><br><span class="line">edge [fontname = &quot;Microsoft YaHei&quot;, fontsize = 10];</span><br><span class="line"> </span><br><span class="line">0 [ style = filled, color=lightgrey ];</span><br><span class="line">2 [ shape = doublecircle ];</span><br><span class="line"> </span><br><span class="line">0 -&gt; 2 [ label = &quot;a &quot; ];</span><br><span class="line">0 -&gt; 1 [ label = &quot;other &quot; ];</span><br><span class="line">1 -&gt; 2 [ label = &quot;a &quot; ];</span><br><span class="line">1 -&gt; 1 [ label = &quot;other &quot; ];</span><br><span class="line">2 -&gt; 2 [ label = &quot;a &quot; ];</span><br><span class="line">2 -&gt; 1 [ label = &quot;other &quot; ];</span><br><span class="line"> </span><br><span class="line">&quot;Machine: a&quot; [ shape = plaintext ];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>形状值为 plaintext 的表示不用绘制边框，仅展示纯文本内容，这个在绘图中，绘制指示性的文本时很有用，如上图中的 <code>Machine: a</code>。</p><h3 id="OSGi-中模块的生命周期图"><a href="#OSGi-中模块的生命周期图" class="headerlink" title="OSGi 中模块的生命周期图"></a>OSGi 中模块的生命周期图</h3><p>OSGi 中，模块具有生命周期，从安装到卸载，可能的状态具有已安装，已就绪，正在启动，已启动，正在停止，已卸载等。如下图所示：<br><img src="/../../../../img/blog/7447c00aa1d954a54cf4e9f277959905_MD5.gif"><br>对应的脚本如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">digraph module_lc&#123;</span><br><span class="line">rankdir=TB;</span><br><span class="line">fontname = &quot;Microsoft YaHei&quot;;</span><br><span class="line">fontsize = 12;</span><br><span class="line"> </span><br><span class="line">node [fontname = &quot;Microsoft YaHei&quot;, fontsize = 12, shape = &quot;Mrecord&quot;, color=&quot;skyblue&quot;, style=&quot;filled&quot;]; </span><br><span class="line">edge [fontname = &quot;Microsoft YaHei&quot;, fontsize = 12, color=&quot;darkgreen&quot; ];</span><br><span class="line"> </span><br><span class="line">installed [label=&quot;已安装状态&quot;];</span><br><span class="line">resolved [label=&quot;已就绪状态&quot;];</span><br><span class="line">uninstalled [label=&quot;已卸载状态&quot;];</span><br><span class="line">starting [label=&quot;正在启动&quot;];</span><br><span class="line">active [label=&quot;已激活(运行)状态&quot;];</span><br><span class="line">stopping [label=&quot;正在停止&quot;];</span><br><span class="line">start [label=&quot;&quot;, shape=&quot;circle&quot;, width=0.5, fixedsize=true, style=&quot;filled&quot;, color=&quot;black&quot;];</span><br><span class="line"> </span><br><span class="line">start -&gt; installed [label=&quot;安装&quot;];</span><br><span class="line">installed -&gt; uninstalled [label=&quot;卸载&quot;];</span><br><span class="line">installed -&gt; resolved [label=&quot;准备&quot;];</span><br><span class="line">installed -&gt; installed [label=&quot;更新&quot;];</span><br><span class="line">resolved -&gt; installed [label=&quot;更新&quot;];</span><br><span class="line">resolved -&gt; uninstalled [label=&quot;卸载&quot;];</span><br><span class="line">resolved -&gt; starting [label=&quot;启动&quot;];</span><br><span class="line">starting -&gt; active [label=&quot;&quot;];</span><br><span class="line">active -&gt; stopping [label=&quot;停止&quot;];</span><br><span class="line">stopping -&gt; resolved [label=&quot;&quot;]; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="其他实例"><a href="#其他实例" class="headerlink" title="其他实例"></a>其他实例</h2><p>一棵简单的抽象语法树 (AST)<br>表达式 <code>(3+4)*5</code> 在编译时期，会形成一棵语法树，一边在计算时，先计算 <code>3+4</code> 的值，最后与 5 相乘。<br><img src="/../../../../img/blog/0b07148c9b17e090e58a50cc7abbcf9d_MD5.gif"><br>对应的脚本如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">digraph ast&#123;</span><br><span class="line">fontname = &quot;Microsoft YaHei&quot;;</span><br><span class="line">fontsize = 10;</span><br><span class="line"> </span><br><span class="line">node [shape = circle, fontname = &quot;Microsoft YaHei&quot;, fontsize = 10];</span><br><span class="line">edge [fontname = &quot;Microsoft YaHei&quot;, fontsize = 10];</span><br><span class="line">node [shape=&quot;plaintext&quot;];</span><br><span class="line"> </span><br><span class="line">mul [label=&quot;mul(*)&quot;];</span><br><span class="line">add [label=&quot;add(+)&quot;];</span><br><span class="line"> </span><br><span class="line">add -&gt; 3</span><br><span class="line">add -&gt; 4;</span><br><span class="line">mul -&gt; add;</span><br><span class="line">mul -&gt; 5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="简单的-UML-类图"><a href="#简单的-UML-类图" class="headerlink" title="简单的 UML 类图"></a>简单的 UML 类图</h3><p>下面是一简单的 UML 类图，<code>Dog</code> 和 <code>Cat</code> 都是 <code>Animal</code> 的子类，<code>Dog</code> 和 <code>Cat</code> 同属一个包，且有可能有联系 <code>(0..n)</code>。<br><img src="/../../../../img/blog/e5cfa1d03e1920983c78f7e753014b20_MD5.gif"><br>脚本：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">digraph G&#123;</span><br><span class="line"> </span><br><span class="line">fontname = &quot;Courier New&quot;</span><br><span class="line">fontsize = 10</span><br><span class="line"> </span><br><span class="line">node [ fontname = &quot;Courier New&quot;, fontsize = 10, shape = &quot;record&quot; ];</span><br><span class="line">edge [ fontname = &quot;Courier New&quot;, fontsize = 10 ];</span><br><span class="line"> </span><br><span class="line">Animal [ label = &quot;&#123;Animal |+ name : String\l+ age : int\l|+ die() : void\l&#125;&quot; ];</span><br><span class="line"> </span><br><span class="line">    subgraph clusterAnimalImpl&#123;</span><br><span class="line">        bgcolor=&quot;yellow&quot;</span><br><span class="line">        Dog [ label = &quot;&#123;Dog||+ bark() : void\l&#125;&quot; ];</span><br><span class="line">        Cat [ label = &quot;&#123;Cat||+ meow() : void\l&#125;&quot; ];</span><br><span class="line">    &#125;;</span><br><span class="line"> </span><br><span class="line">edge [ arrowhead = &quot;empty&quot; ];</span><br><span class="line"> </span><br><span class="line">Dog-&gt;Animal;</span><br><span class="line">Cat-&gt;Animal;</span><br><span class="line">Dog-&gt;Cat [arrowhead=&quot;none&quot;, label=&quot;0..*&quot;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="状态图-1"><a href="#状态图-1" class="headerlink" title="状态图"></a>状态图</h3><p><img src="/../../../../img/blog/ad495299eb1919018e96a0f6f47882a8_MD5.gif"><br>脚本：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">digraph finite_state_machine &#123;</span><br><span class="line">rankdir = LR;</span><br><span class="line">size = &quot;8,5&quot;</span><br><span class="line"> </span><br><span class="line">node [shape = doublecircle]; </span><br><span class="line"> </span><br><span class="line">LR_0 LR_3 LR_4 LR_8;</span><br><span class="line"> </span><br><span class="line">node [shape = circle];</span><br><span class="line"> </span><br><span class="line">LR_0 -&gt; LR_2 [ label = &quot;SS(B)&quot; ];</span><br><span class="line">LR_0 -&gt; LR_1 [ label = &quot;SS(S)&quot; ];</span><br><span class="line">LR_1 -&gt; LR_3 [ label = &quot;S($end)&quot; ];</span><br><span class="line">LR_2 -&gt; LR_6 [ label = &quot;SS(b)&quot; ];</span><br><span class="line">LR_2 -&gt; LR_5 [ label = &quot;SS(a)&quot; ];</span><br><span class="line">LR_2 -&gt; LR_4 [ label = &quot;S(A)&quot; ];</span><br><span class="line">LR_5 -&gt; LR_7 [ label = &quot;S(b)&quot; ];</span><br><span class="line">LR_5 -&gt; LR_5 [ label = &quot;S(a)&quot; ];</span><br><span class="line">LR_6 -&gt; LR_6 [ label = &quot;S(b)&quot; ];</span><br><span class="line">LR_6 -&gt; LR_5 [ label = &quot;S(a)&quot; ];</span><br><span class="line">LR_7 -&gt; LR_8 [ label = &quot;S(b)&quot; ];</span><br><span class="line">LR_7 -&gt; LR_5 [ label = &quot;S(a)&quot; ];</span><br><span class="line">LR_8 -&gt; LR_6 [ label = &quot;S(b)&quot; ];</span><br><span class="line">LR_8 -&gt; LR_5 [ label = &quot;S(a)&quot; ];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="时序图"><a href="#时序图" class="headerlink" title="时序图"></a>时序图</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">digraph G &#123; </span><br><span class="line">    rankdir=&quot;LR&quot;; </span><br><span class="line">    node[shape=&quot;point&quot;, width=0, height=0]; </span><br><span class="line">    edge[arrowhead=&quot;none&quot;, style=&quot;dashed&quot;] </span><br><span class="line">    &#123; </span><br><span class="line">        rank=&quot;same&quot;; </span><br><span class="line">        edge[style=&quot;solided&quot;];</span><br><span class="line">        LC[shape=&quot;plaintext&quot;]; </span><br><span class="line">        LC -&gt; step00 -&gt; step01 -&gt; step02 -&gt; step03 -&gt; step04 -&gt; step05; </span><br><span class="line">    &#125; </span><br><span class="line">    &#123; </span><br><span class="line">        rank=&quot;same&quot;; </span><br><span class="line">        edge[style=&quot;solided&quot;];</span><br><span class="line">        Agency[shape=&quot;plaintext&quot;];</span><br><span class="line">        Agency -&gt; step10 -&gt; step11 -&gt; step12 -&gt; step13 -&gt; step14 -&gt; step15; </span><br><span class="line">    &#125; </span><br><span class="line">    &#123; </span><br><span class="line">        rank=&quot;same&quot;; </span><br><span class="line">        edge[style=&quot;solided&quot;];</span><br><span class="line">        Agent[shape=&quot;plaintext&quot;];</span><br><span class="line">        Agent -&gt; step20 -&gt; step21 -&gt; step22 -&gt; step23 -&gt; step24 -&gt; step25; </span><br><span class="line">    &#125; </span><br><span class="line">    step00 -&gt; step10 [label=&quot;sends email new custumer&quot;, arrowhead=&quot;normal&quot;]; </span><br><span class="line">    step11 -&gt; step01 [label=&quot;declines&quot;, arrowhead=&quot;normal&quot;]; </span><br><span class="line">    step12 -&gt; step02 [label=&quot;accepts&quot;, arrowhead=&quot;normal&quot;]; </span><br><span class="line">    step13 -&gt; step23 [label=&quot;forward to&quot;, arrowhead=&quot;normal&quot;]; </span><br><span class="line">    step24 -&gt; step14; </span><br><span class="line">    step14 -&gt; step04 [arrowhead=&quot;normal&quot;]; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>rankdir=&quot;LR&quot;</code> 表示，布局从左 <code>L</code> 到右 <code>R</code>。可以看到，在代码中有 <code>&#123;&#125;</code> 括起来的部分。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123; </span><br><span class="line">    rank=&quot;same&quot;; </span><br><span class="line">    edge[style=&quot;solided&quot;];</span><br><span class="line">    Agency[shape=&quot;plaintext&quot;];</span><br><span class="line">    Agency -&gt; step10 -&gt; step11 -&gt; step12 -&gt; step13 -&gt; step14 -&gt; step15; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每一个 <code>rank=&quot;same&quot;</code> 的 block 中的所有节点都会在同一条线上。我们设置了所有的线为虚线，但是在该 block 中，将线改为 <code>solided</code>。<br><img src="/../../../../img/blog/e2e975df8269fb35db1608ded52aa67f_MD5.png"></p><h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><p><a href="https://max.book118.com/html/2017/0513/106648582.shtm">Graphviz中文教程指南.pdf (book118.com)</a></p><p>事实上，从 <code>dot</code> 的语法及上述的示例中，很容易看出，dot 脚本很容易被其他语言生成。比如，使用一些简单的数据库查询就可以生成数据库中的 ER 图的 dot 脚本。<br>如果你追求高效的开发速度，并希望快速的将自己的想法画出来，那么 <code>graphviz</code> 是一个很不错的选择。<br>当然，<code>graphviz</code> 也有一定的局限，比如绘制时序图 (序列图) 就很难实现。<code>graphviz</code> 的节点出现在画布上的位置事实上是不确定的，依赖于所使用的布局算法，而不是在脚本中出现的位置，这可能使刚开始接触 <code>graphviz</code> 的开发人员有点不适应。<code>graphviz</code> 的强项在于自动布局，当图中的顶点和边的数目变得很多的时候，才能很好的体会这一特性的好处：<br><img src="/../../../../img/blog/afab2574c523235e7ade49f26ccb1580_MD5.gif"><br>比如上图，或者较上图更复杂的图，如果采用手工绘制显然是不可能的，只能通过 <code>graphviz</code> 提供的自动布局引擎来完成。如果仅用于展示模块间的关系，子模块与子模块间通信的方式，模块的逻辑位置等，<code>graphviz</code> 完全可以胜任，但是如果图中对象的物理位置必须是准确的，如节点 A 必须位于左上角，节点 B 必须与 A 相邻等特性，使用 <code>graphviz</code> 则很难做到。毕竟，它的强项是自动布局，事实上，所有的节点对与布局引擎而言，权重在初始时都是相同的，只是在渲染之后，节点的大小，形状等特性才会影响权重。<br>本文只是初步介绍了 <code>graphviz</code> 的简单应用，如图的定义，顶点&#x2F;边的属性定义，如果运行等，事实上还有很多的属性，如画布的大小，字体的选择，颜色列表等，大家可以通过 <code>graphviz</code> 的官网来找到更详细的资料。<br>文中的代码都已经在 <a href="https://github.com/abruzzi/graphviz-scripts">Github</a> 上。</p>]]></content>
      
      
      <categories>
          
          <category> 应用 </category>
          
          <category> 语言 </category>
          
          <category> 归档1 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>xmake使用</title>
      <link href="/posts/%E5%AD%A6%E4%B9%A0/%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/Xmake/xmake%E4%BD%BF%E7%94%A8.html"/>
      <url>/posts/%E5%AD%A6%E4%B9%A0/%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/Xmake/xmake%E4%BD%BF%E7%94%A8.html</url>
      
        <content type="html"><![CDATA[<h1 id="clion"><a href="#clion" class="headerlink" title="clion"></a>clion</h1><p><a href="https://blog.csdn.net/m0_69086552/article/details/130444581">xmake配合clion用指南-CSDN博客</a><br><a href="https://zhuanlan.zhihu.com/p/640701847">Xmake 新手教程 - 知乎 (zhihu.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> 构建工具 </category>
          
          <category> Xmake </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Git提交规范引入指南</title>
      <link href="/posts/%E5%BA%94%E7%94%A8/%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7/Git/Git%E6%8F%90%E4%BA%A4%E8%A7%84%E8%8C%83%E5%BC%95%E5%85%A5%E6%8C%87%E5%8D%97.html"/>
      <url>/posts/%E5%BA%94%E7%94%A8/%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7/Git/Git%E6%8F%90%E4%BA%A4%E8%A7%84%E8%8C%83%E5%BC%95%E5%85%A5%E6%8C%87%E5%8D%97.html</url>
      
        <content type="html"><![CDATA[<p><a href="https://juejin.cn/post/6844903793033756680">超详细的Git提交规范引入指南 - 掘金 (juejin.cn)</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">feat - 新功能 feature  </span><br><span class="line">fix - 修复 bug  </span><br><span class="line">docs - 文档注释  </span><br><span class="line">style - 代码格式(不影响代码运行的变动)  </span><br><span class="line">refactor - 重构、优化(既不增加新功能，也不是修复bug)  </span><br><span class="line">perf - 性能优化  </span><br><span class="line">test - 增加测试  </span><br><span class="line">chore - 构建过程或辅助工具的变动  </span><br><span class="line">revert - 回退  </span><br><span class="line">build - 打包</span><br></pre></td></tr></table></figure><p><a href="https://www.conventionalcommits.org/zh-hans/v1.0.0/">约定式提交 (conventionalcommits.org)</a></p>]]></content>
      
      
      <categories>
          
          <category> 应用 </category>
          
          <category> 编程工具 </category>
          
          <category> Git </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>flutter</title>
      <link href="/posts/%E5%BA%94%E7%94%A8/%E8%AF%AD%E8%A8%80/Dart/flutter.html"/>
      <url>/posts/%E5%BA%94%E7%94%A8/%E8%AF%AD%E8%A8%80/Dart/flutter.html</url>
      
        <content type="html"><![CDATA[<h1 id="开发"><a href="#开发" class="headerlink" title="开发"></a>开发</h1><ul><li><a href="https://book.flutterchina.club/">第二版序 | 《Flutter实战·第二版》 (flutterchina.club)</a></li></ul><h1 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h1><ul><li><a href="https://isar.dev/zh/">主页 | Isar 数据库</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 应用 </category>
          
          <category> 语言 </category>
          
          <category> Dart </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>服务器应用</title>
      <link href="/posts/%E5%BA%94%E7%94%A8/%E9%85%8D%E7%BD%AE/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BA%94%E7%94%A8.html"/>
      <url>/posts/%E5%BA%94%E7%94%A8/%E9%85%8D%E7%BD%AE/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BA%94%E7%94%A8.html</url>
      
        <content type="html"><![CDATA[<h1 id="memos"><a href="#memos" class="headerlink" title="memos"></a>memos</h1><ul><li><a href="https://zhuanlan.zhihu.com/p/650596106">Memos：私有、轻量、开源、自托管的备忘录 - 知乎 (zhihu.com)</a></li><li><a href="https://www.usememos.com/docs/advanced-settings/cloudflare-r2">Configuring Cloudflare R2 Storage - Memos (usememos.com)</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 应用 </category>
          
          <category> 配置 </category>
          
          <category> 云服务器 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>cloudflare</title>
      <link href="/posts/%E5%BA%94%E7%94%A8/%E9%85%8D%E7%BD%AE/%E8%BD%AF%E4%BB%B6%E9%85%8D%E7%BD%AE/cloudflare.html"/>
      <url>/posts/%E5%BA%94%E7%94%A8/%E9%85%8D%E7%BD%AE/%E8%BD%AF%E4%BB%B6%E9%85%8D%E7%BD%AE/cloudflare.html</url>
      
        <content type="html"><![CDATA[<h1 id="在-CloudFlare-上解析自己的域名"><a href="#在-CloudFlare-上解析自己的域名" class="headerlink" title="在 CloudFlare 上解析自己的域名"></a>在 CloudFlare 上解析自己的域名</h1><p>在我们获取到域名的时候，我们首先需要将域名设置 DNS 记录。而作为世界最大的免费 CDN 提供商的 CloudFlare，旗下自然会有 DNS 解析服务。在这篇教程中，我来和大家一起将域名绑定至 CloudFlare 上并解析。</p><h2 id="准备材料"><a href="#准备材料" class="headerlink" title="准备材料"></a>准备材料</h2><ul><li>一枚域名</li><li>一枚邮箱（最好是 gmail、outlook 之类的常用邮箱）</li></ul><h2 id="部署步骤"><a href="#部署步骤" class="headerlink" title="部署步骤"></a>部署步骤</h2><ul><li>打开 CloudFlare 的官网：<a href="https://dash.cloudflare.com/">https://dash.cloudflare.com/</a> ，如果没账户的可以点击 “Sign up” 进行注册。如有账户输入邮箱及密码即可</li></ul><p><a href="https://cdn.jsdelivr.net/gh/Misaka-blog/imgs@main/20230303190104.png"><img src="/../../../../img/blog/f802feb65b8566bfe6ae18dcfd24f1cd_MD5.png"></a></p><ul><li>点击 “Add site” 按钮</li></ul><p>[<img src="/../../../../img/blog/747f2a8c91fba51126981ebf5415e91b_MD5.png">](..&#x2F;..&#x2F;..&#x2F;img&#x2F;blog&#x2F;747 f 2 a 8 c 91 fba 51126981 ebf 5415 e 91 b_MD 5. png)</p><ul><li>输入自己的域名，点击 “Add site” 按钮</li></ul><p>[<img src="/../../../../img/blog/ed2f08154eb37ab584cfda8dd31a961e_MD5.png">](..&#x2F;..&#x2F;..&#x2F;img&#x2F;blog&#x2F;ed 2 f 08154 eb 37 ab 584 cfda 8 dd 31 a 961 e_MD 5. png)</p><ul><li>选择计划。一般选择 Free 的。点击 “Continue”</li></ul><p>[<img src="/../../../../img/blog/db6434e3c9185c140b37127c2ee093aa_MD5.png">](..&#x2F;..&#x2F;..&#x2F;img&#x2F;blog&#x2F;db 6434 e 3 c 9185 c 140 b 37127 c 2 ee 093 aa_MD 5. png)</p><ul><li>设置 DNS 记录。可以先在这里设置，也可以点击 “Continue” 跳过</li></ul><p>[<img src="/../../../../img/blog/379454efb1c1c26bbd8bceb2fd33f098_MD5.png">](..&#x2F;..&#x2F;..&#x2F;img&#x2F;blog&#x2F;379454 efb 1 c 1 c 26 bbd 8 bceb 2 fd 33 f 098_MD 5. png)</p><ul><li><p>按照提示修改 CloudFlare 的 DNS 服务器。<br><a href="https://help.aliyun.com/zh/dws/user-guide/change-dns-servers-for-a-domain-name">如何修改域名的DNS_域名-阿里云帮助中心 (aliyun.com)</a><br>[<img src="/../../../../img/blog/f097765c33bc36ffde5035bee327920d_MD5.png">](..&#x2F;..&#x2F;..&#x2F;img&#x2F;blog&#x2F;f 097765 c 33 bc 36 ffde 5035 bee 327920 d_MD 5. png)</p></li><li><p>点击 “Check nameservers” 检查 DNS 解析状态</p></li></ul><p>[<img src="/../../../../img/blog/108fcd0a8d2accc07f107eb2e36d35c1_MD5.png">](..&#x2F;..&#x2F;..&#x2F;img&#x2F;blog&#x2F;108 fcd 0 a 8 d 2 accc 07 f 107 eb 2 e 36 d 35 c 1_MD 5. png)</p><ul><li>如出现类似此邮件，即为设置成功</li></ul><p><a href="https://cdn.jsdelivr.net/gh/Misaka-blog/imgs@main/20230303191402.png"><img src="/../../../../img/blog/17c9924add3c42dc76dd2decd738ad26_MD5.png"></a></p><h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><h2 id="zerotrust"><a href="#zerotrust" class="headerlink" title="zerotrust"></a>zerotrust</h2><h3 id="tunnel"><a href="#tunnel" class="headerlink" title="tunnel"></a>tunnel</h3><ul><li><a href="https://sspai.com/post/79278#!">CloudFlare Tunnel 免费内网穿透的简明教程 - 少数派 (sspai.com)</a></li><li><a href="https://blog.borber.top/tech/cf-tunnel-proxy-ssh/">cloudflare tunnel 代理 ssh | BORBER</a></li><li><a href="https://zhuanlan.zhihu.com/p/621870045">使用cloudflare tunnel免费内网穿透，实现网站的外网访问和远程桌面 - 知乎 (zhihu.com)</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 应用 </category>
          
          <category> 配置 </category>
          
          <category> 软件配置 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>编辑器配置</title>
      <link href="/posts/%E5%BA%94%E7%94%A8/%E9%85%8D%E7%BD%AE/%E8%BD%AF%E4%BB%B6%E9%85%8D%E7%BD%AE/%E7%BC%96%E8%BE%91%E5%99%A8%E9%85%8D%E7%BD%AE.html"/>
      <url>/posts/%E5%BA%94%E7%94%A8/%E9%85%8D%E7%BD%AE/%E8%BD%AF%E4%BB%B6%E9%85%8D%E7%BD%AE/%E7%BC%96%E8%BE%91%E5%99%A8%E9%85%8D%E7%BD%AE.html</url>
      
        <content type="html"><![CDATA[<h1 id="helix"><a href="#helix" class="headerlink" title="helix"></a>helix</h1><h2 id="官方文档"><a href="#官方文档" class="headerlink" title="官方文档"></a>官方文档</h2><ul><li><a href="https://docs.helix-editor.com/configuration.html">Configuration (helix-editor.com)</a></li><li><a href="https://zjp-cn.github.io/helix-book/title-page.html">Helix - Helix Book 中文翻译 (较旧)</a></li></ul><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="shell"><a href="#shell" class="headerlink" title="shell"></a>shell</h3><ul><li><a href="https://github.com/helix-editor/helix/discussions/6209">Using PowerShell core as shell</a></li><li><a href="https://github.com/helix-editor/helix/discussions/7455">shell编码问题</a></li><li><a href="https://github.com/helix-editor/helix/discussions/8776">使用nushell</a></li></ul><h2 id="可参考"><a href="#可参考" class="headerlink" title="可参考"></a>可参考</h2><ul><li><a href="https://github.com/helix-editor/helix/discussions/8000">Turning Helix into an IDE with the help of WezTerm and CLI tools</a></li><li><a href="https://zhuanlan.zhihu.com/p/611325203">Helix editor 笔记 (持续更新) - 知乎 (zhihu.com)</a></li><li><a href="https://zhuanlan.zhihu.com/p/607673321">开始使用 HELIX EDITOR 编辑器 - 知乎 (zhihu.com)</a></li><li><a href="https://www.zhihu.com/question/462847687">如何评价文本编辑器Helix Editor? - 知乎 (zhihu.com)</a></li></ul><h1 id="neovim"><a href="#neovim" class="headerlink" title="neovim"></a>neovim</h1><h2 id="windows"><a href="#windows" class="headerlink" title="windows"></a>windows</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>安装必要组件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scoop install neovim neovide git lazygit gcc ripgrep fd unzip tree-sitter luarocks</span><br></pre></td></tr></table></figure><p>下载并安装 LazyVim 配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/LazyVim/starter $env:LOCALAPPDATA\nvim --depth=1</span><br></pre></td></tr></table></figure><p>为了显示 Neovim 界面中的图标，需要安装一款 <a href="https://www.nerdfonts.com/font-downloads">Nerd Font</a> 字体，这里选择 <a href="https://github.com/ryanoasis/nerd-fonts/releases/download/v3.0.2/UbuntuMono.zip">UbuntuMono Nerd Font</a> 字体。可以通过 Scoop 进行安装：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scoop bucket add nerd-fonts</span><br><span class="line">scoop install UbuntuMono-NF</span><br></pre></td></tr></table></figure><p>在配置文件 <code>$env:LOCALAPPDATA\nvim\lua\config\options.lua</code> 中添加下行代码来设置字体：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> opt = vim.opt</span><br><span class="line"> </span><br><span class="line">opt.guifont = <span class="string">&quot;UbuntuMono Nerd Font:h12&quot;</span></span><br></pre></td></tr></table></figure><p>在命令行中使用 <code>neovide</code> 命令就可以启动 Neovim 了。值得注意的是， Neovide 只要使用参数 <code>--wsl</code> 就可以在 WSL 环境中运行，不过这时 LazyVim 的配置也需要安装到 WSL 环境中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/LazyVim/starter ~/.config/nvim --depth=1</span><br></pre></td></tr></table></figure><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>程序第一次运行时会自动下载和安装插件。如果遇到网络问题而导致安装失败也没关系，按下 <code>R</code> （大写）重新安装直至成功为止。所有插件安装成功后， <code>nvim-treesitter</code> 还会继续安装组件，等所有插件和组件安装完毕后，按下 <code>q</code> 退出安装界面。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="https://www.fournoas.com/posts/neovim-on-windows/">Windows 下使用 Neovim · 白汤四物 (fournoas.com)</a></li><li><a href="https://www.cnblogs.com/zwyyy456/p/17479396.html">Neovim 的配置与使用 - zwyyy456 (cnblogs.com)</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 应用 </category>
          
          <category> 配置 </category>
          
          <category> 软件配置 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>nodejs管理</title>
      <link href="/posts/%E5%BA%94%E7%94%A8/%E9%85%8D%E7%BD%AE/%E8%AF%AD%E8%A8%80%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/nodejs%E7%AE%A1%E7%90%86.html"/>
      <url>/posts/%E5%BA%94%E7%94%A8/%E9%85%8D%E7%BD%AE/%E8%AF%AD%E8%A8%80%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/nodejs%E7%AE%A1%E7%90%86.html</url>
      
        <content type="html"><![CDATA[<h1 id="nrm-使用详解"><a href="#nrm-使用详解" class="headerlink" title="nrm 使用详解"></a>nrm 使用详解</h1><p><a href="https://github.com/Pana/nrm" title=" https://github.com/Pana/nrm">nrm</a>（NPM registry manager）是 npm 的镜像源管理工具，使用它可以快速切换 npm 源。</p><ul><li>全局安装</li></ul><p><code>$ npm i -g nrm</code></p><ul><li>查看版本</li></ul><p><code>$ nrm -V</code></p><ul><li>查看所有源</li></ul><p>其中 <code>*</code> 号表示当前使用的源。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ nrm ls</span><br><span class="line"></span><br><span class="line">* npm -------- https://registry.npmjs.org/</span><br><span class="line">  yarn ------- https://registry.yarnpkg.com/</span><br><span class="line">  cnpm ------- http://r.cnpmjs.org/</span><br><span class="line">  taobao ----- https://www.npmmirror.com/</span><br><span class="line">  nj --------- https://registry.nodejitsu.com/</span><br><span class="line">  npmMirror -- https://skimdb.npmjs.com/registry/</span><br><span class="line">  edunpm ----- http://registry.enpmjs.org/</span><br></pre></td></tr></table></figure><p>或者通过 <code>nrm current</code> 命令查看当前源的名称。</p><ul><li>切换源</li></ul><p>其中 <code>&lt;registry&gt;</code> 就是上面命令所列出来的名称。</p><p>相比上面的命令，是不是方便好记多了。</p><p><code>$ nrm use &lt;registry&gt; # 例如 nrm use taobao</code></p><blockquote><p>注意切换源之后，我们安装依赖仍使用 <code>npm i &lt;name&gt;</code> 的方式来进行安装。</p></blockquote><ul><li>添加源</li></ul><p>适用于企业内部定制的私有源，<code>&lt;registry&gt;</code> 表示源名称，<code>&lt;url&gt;</code> 表示源地址。</p><p><code>$ nrm add &lt;registry&gt; &lt;url&gt;</code></p><ul><li>删除源</li></ul><p><code>$ nrm del &lt;registry&gt;</code></p><ul><li>测试源的响应时间</li></ul><p><code>$ nrm test &lt;registry&gt;</code></p><h1 id="nvm"><a href="#nvm" class="headerlink" title="nvm"></a>nvm</h1><h2 id="设置国内镜像"><a href="#设置国内镜像" class="headerlink" title="设置国内镜像"></a>设置国内镜像</h2><p>终端输入：</p><p>设置 npm_mirror:</p><p><code>nvm npm_mirror https://npmmirror.com/mirrors/npm/</code></p><p> 设置 node_mirror:</p><p><code>nvm node_mirror https://npmmirror.com/mirrors/node/</code></p><h2 id="使用-nvm-管理版本（nvm-常用命令）"><a href="#使用-nvm-管理版本（nvm-常用命令）" class="headerlink" title="使用 nvm 管理版本（nvm 常用命令）"></a>使用 nvm 管理版本（nvm 常用命令）</h2><p><strong>nvm install latest</strong> 安装最新版本 node.js<br><strong>nvm use 版本号</strong> 使用某一具体版本，例如 ：nvm use 14.3.0<br><strong>nvm list</strong> 列出当前已安装的所有版本<br><strong>nvm ls</strong> 列出当前已安装的所有版本<br><strong>nvm uninstall 版本号</strong> 卸载某一具体版本，例如：nvm use 14.3.0<br><strong>nvm ls-remote</strong> Mac 版本中,列出全部可以安装的 node 版本<br><strong>nvm ls available</strong> windows 版本,列出全部可以安装的 node 版本<br><strong>nvm current</strong> 显示当前的版本<br><strong>nvm alias</strong> 给不同的版本号添加别名<br><strong>nvm unalias</strong> 删除已定义的别名<br><strong>nvm reinstall-packages</strong> 在当前版本 node 环境下，重新全局安装指定版本号的 npm 包</p>]]></content>
      
      
      <categories>
          
          <category> 应用 </category>
          
          <category> 配置 </category>
          
          <category> 语言环境配置 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>归档2</title>
      <link href="/posts/%E5%BD%92%E6%A1%A3/%E5%BD%92%E6%A1%A32.html"/>
      <url>/posts/%E5%BD%92%E6%A1%A3/%E5%BD%92%E6%A1%A32.html</url>
      
        <content type="html"><![CDATA[<h1 id="如何将-C-盘中-QQ-与微信数据（聊天记录）迁移到其他工作盘"><a href="#如何将-C-盘中-QQ-与微信数据（聊天记录）迁移到其他工作盘" class="headerlink" title="如何将 C 盘中 QQ 与微信数据（聊天记录）迁移到其他工作盘"></a>如何将 C 盘中 QQ 与微信数据（聊天记录）迁移到其他工作盘</h1><p>1.QQ 数据迁移 (聊天记录等)</p><p>第一步：打开 QQ 界面，点击左下角的菜单栏，弹出菜单栏窗口，点击 “ 设置 “，如下图：</p><p><img src="/../../img/blog/049d8d4e9777256eab9f06d96e8c033a_MD5.webp"></p><p>第二步：弹出窗口如下图，选择 “ 文件管理 “ 栏目，我们会看到默认接收的文件及保存的文档都存放在 C 盘（占用空间比较大哦），选择其他空余的磁盘目录。点击 “ 更改目录 “ 即可。</p><p><img src="/../../img/blog/4be393b0810eef9b055f34138c7f2dfa_MD5.webp"></p><p>第三步：修改完毕会弹出如下图所示的迁移窗口</p><p><img src="/../../img/blog/cdc3ef3a0db65e59209f473ab3dcd9ae_MD5.webp"></p><p>2.微信数据迁移 (聊天记录等)</p><p>第一步：打开电脑微信，同理，点击菜单栏的设置</p><p><img src="/../../img/blog/6fab39cc1bd1d8c9c2919fa709b69a6a_MD5.webp"></p><p>第二步：弹出窗口如下图，选择 “ 文件管理 “ 栏目，我们会看到微信文件地默认保存位置都存放在 C 盘（占用空间比较大哦），选择其他空余的磁盘目录，点击 “ 更改 “ 即可。</p><p><img src="/../../img/blog/37bd5bac9f1cb95b31f1ca0f14298bb7_MD5.webp"></p><p>第三步：修改完毕会弹出如下图所示的迁移窗口</p><p><img src="/../../img/blog/038b9498df9dad80194ed61406fc4e01_MD5.webp"></p><p>经过 QQ 与微信数据（聊天记录）迁移，看看你的 C 盘是不是空出来了很多。</p>]]></content>
      
      
      <categories>
          
          <category> 归档 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Clion配置</title>
      <link href="/posts/%E5%BA%94%E7%94%A8/%E9%85%8D%E7%BD%AE/%E8%BD%AF%E4%BB%B6%E9%85%8D%E7%BD%AE/Clion%E9%85%8D%E7%BD%AE.html"/>
      <url>/posts/%E5%BA%94%E7%94%A8/%E9%85%8D%E7%BD%AE/%E8%BD%AF%E4%BB%B6%E9%85%8D%E7%BD%AE/Clion%E9%85%8D%E7%BD%AE.html</url>
      
        <content type="html"><![CDATA[<h1 id="主题推荐"><a href="#主题推荐" class="headerlink" title="主题推荐"></a>主题推荐</h1><p>我推荐使用新 UI + onedark 的组合（我目前所使用的）。</p><p>效果如下：</p><p><img src="/../../../../img/blog/88e12615834ebf321da6affceb85ca9b_MD5.webp" alt="主题1"></p><p>如果你使用的是旧版本的 UI，我之前经常使用的主题有以下三个：</p><ol><li><p>Atom Material Icons 效果大概如下，这个一个用于将文件夹颜色更明亮的插件，新 UI 暂时不可用<img src="/../../../../img/blog/9fc7eb29ba080b68a52f75c538ab550f_MD5.webp" alt="fileicon"></p></li><li><p>material-theme-ui：插件主页 <a href="https://link.juejin.cn/?target=https://plugins.jetbrains.com/plugin/8006-material-theme-ui" title="https://plugins.jetbrains.com/plugin/8006-material-theme-ui">plugins.jetbrains.com&#x2F;plugin&#x2F;8006…</a></p></li><li><p>one-dark-theme：插件主页 <a href="https://link.juejin.cn/?target=https://plugins.jetbrains.com/plugin/11938-one-dark-theme" title="https://plugins.jetbrains.com/plugin/11938-one-dark-theme">plugins.jetbrains.com&#x2F;plugin&#x2F;1193…</a></p></li></ol><h1 id="编辑器与-clang-format-设置"><a href="#编辑器与-clang-format-设置" class="headerlink" title="编辑器与 clang-format 设置"></a>编辑器与 clang-format 设置</h1><h2 id="鼠标滚轮改变字体大小"><a href="#鼠标滚轮改变字体大小" class="headerlink" title="鼠标滚轮改变字体大小"></a>鼠标滚轮改变字体大小</h2><p>Editor -&gt; General -&gt; Change font size with Ctrl+Mouse Wheel 打上勾就行。</p><p><img src="/../../../../img/blog/38d048c74f31da95d2718f2a160fc77a_MD5.webp" alt="mouse control"></p><h2 id="clang-format-的使用"><a href="#clang-format-的使用" class="headerlink" title="clang-format 的使用"></a>clang-format 的使用</h2><p>关于 clang-format 是什么，我截一段 chatgpt 的回答。</p><p><img src="/../../../../img/blog/7419f7ee138374a549afd555cdfb27c4_MD5.webp" alt="clang-format简介"></p><p>CLion 是自带 clang-format 的，你只需要开启即可，他会自动扫描项目根目录下的 clang-format 文件进行相应的格式化，开启后你每次创建一个新项目他也会自动生成一个 clang-format 文件到项目根目录，这个文件配置是根据 CLion 默认的格式化的格式来的，如果想要更改格式化风格，只需要更改 clang-formt 配置文件即可。</p><p>一般来说，我们只需要配置基本风格就行，一个.clang-format 文件大概长这样：</p><p><img src="/../../../../img/blog/1006bda458606b389bd355cb22603d24_MD5.webp" alt=".clang-format"></p><p>一般来说没有什么特殊需求，那么就只需要填写 BasedOnStyle 即可，是 Google 风格还是 LLVM 风格还是 Microsoft 风格，都取决于上述的前三行代码，后面的都可以不用写。我这个配置文件是想要使用 Google 的格式化风格，但是 Googel 风格默认的代码边距太短了，所以进行了一系列的调整。</p><p>下面是 CLion 如何开启 clang-format，开启后 CLion 对代码的格式化将会以你项目根目录的 clang-format 文件为主。</p><p><img src="/../../../../img/blog/22d7bda4a10573bfba11ef3a28ff984e_MD5.webp" alt="clang-format1"></p><h3 id="我的-clang-format-配置"><a href="#我的-clang-format-配置" class="headerlink" title="我的 .clang-format 配置"></a>我的 .clang-format 配置</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br></pre></td><td class="code"><pre><span class="line">BasedOnStyle: Google</span><br><span class="line">Language: Cpp</span><br><span class="line">AccessModifierOffset: -3</span><br><span class="line">AlignAfterOpenBracket: Align</span><br><span class="line">AlignConsecutiveMacros: AcrossComments</span><br><span class="line">AlignConsecutiveAssignments: AcrossComments</span><br><span class="line">AlignConsecutiveDeclarations: AcrossComments</span><br><span class="line">AlignEscapedNewlines: Left</span><br><span class="line">AlignOperands: true</span><br><span class="line">AlignTrailingComments: true</span><br><span class="line">AllowAllArgumentsOnNextLine: true</span><br><span class="line">AllowAllParametersOfDeclarationOnNextLine: true</span><br><span class="line">AllowShortBlocksOnASingleLine: Always</span><br><span class="line">AllowShortCaseLabelsOnASingleLine: true</span><br><span class="line">AllowShortFunctionsOnASingleLine: All</span><br><span class="line">AllowShortLambdasOnASingleLine: All</span><br><span class="line">AllowShortIfStatementsOnASingleLine: AllIfsAndElse</span><br><span class="line">AllowShortLoopsOnASingleLine: true</span><br><span class="line">AlwaysBreakAfterReturnType: None</span><br><span class="line">AlwaysBreakBeforeMultilineStrings: false</span><br><span class="line">AlwaysBreakTemplateDeclarations: Yes</span><br><span class="line">BinPackArguments: true</span><br><span class="line">BinPackParameters: true</span><br><span class="line">BraceWrapping:</span><br><span class="line">  AfterCaseLabel: false</span><br><span class="line">  AfterClass: true</span><br><span class="line">  AfterControlStatement: Always</span><br><span class="line">  AfterEnum: false</span><br><span class="line">  AfterFunction: true</span><br><span class="line">  AfterNamespace: false</span><br><span class="line">  AfterObjCDeclaration: false</span><br><span class="line">  AfterStruct: true</span><br><span class="line">  AfterUnion: true</span><br><span class="line">  AfterExternBlock: true</span><br><span class="line">  BeforeCatch: true</span><br><span class="line">  BeforeElse: true</span><br><span class="line"></span><br><span class="line">BreakBeforeBinaryOperators: None</span><br><span class="line">BreakBeforeBraces: Custom</span><br><span class="line">BreakBeforeInheritanceComma: false</span><br><span class="line">BreakInheritanceList: BeforeColon</span><br><span class="line">BreakBeforeTernaryOperators: true</span><br><span class="line">BreakConstructorInitializersBeforeComma: false</span><br><span class="line">BreakConstructorInitializers: BeforeColon</span><br><span class="line">BreakAfterJavaFieldAnnotations: false</span><br><span class="line">BreakStringLiterals: true</span><br><span class="line">ColumnLimit: 80</span><br><span class="line">CommentPragmas: &quot;^ NOLINT:&quot;</span><br><span class="line">CompactNamespaces: false</span><br><span class="line">ConstructorInitializerIndentWidth: 2</span><br><span class="line">ContinuationIndentWidth: 2</span><br><span class="line">Cpp11BracedListStyle: true</span><br><span class="line">DeriveLineEnding: true</span><br><span class="line">DerivePointerAlignment: true</span><br><span class="line">DisableFormat: false</span><br><span class="line">ExperimentalAutoDetectBinPacking: false</span><br><span class="line">FixNamespaceComments: true</span><br><span class="line">ForEachMacros:</span><br><span class="line">  - foreach</span><br><span class="line">  - Q_FOREACH</span><br><span class="line">  - BOOST_FOREACH</span><br><span class="line">IncludeBlocks: Regroup</span><br><span class="line">IncludeCategories:</span><br><span class="line">  - Regex: &#x27;^&lt;ext/.*.h&gt;&#x27;</span><br><span class="line">    Priority: 2</span><br><span class="line">    SortPriority: 0</span><br><span class="line">  - Regex: &#x27;^&lt;.*.h&gt;&#x27;</span><br><span class="line">    Priority: 1</span><br><span class="line">    SortPriority: 0</span><br><span class="line">  - Regex: &quot;^&lt;.*&quot;</span><br><span class="line">    Priority: 2</span><br><span class="line">    SortPriority: 0</span><br><span class="line">  - Regex: &quot;.*&quot;</span><br><span class="line">    Priority: 3</span><br><span class="line">    SortPriority: 0</span><br><span class="line">IncludeIsMainRegex: &quot;([-_](test|unittest))?$&quot;</span><br><span class="line">IncludeIsMainSourceRegex: &quot;&quot;</span><br><span class="line">IndentCaseLabels: true</span><br><span class="line">IndentGotoLabels: true</span><br><span class="line">IndentPPDirectives: None</span><br><span class="line">IndentWidth: 3</span><br><span class="line">IndentWrappedFunctionNames: false</span><br><span class="line">JavaScriptQuotes: Leave</span><br><span class="line">JavaScriptWrapImports: true</span><br><span class="line">KeepEmptyLinesAtTheStartOfBlocks: false</span><br><span class="line">MacroBlockBegin: &quot;&quot;</span><br><span class="line">MacroBlockEnd: &quot;&quot;</span><br><span class="line">MaxEmptyLinesToKeep: 1</span><br><span class="line">NamespaceIndentation: None</span><br><span class="line">ObjCBinPackProtocolList: Never</span><br><span class="line">ObjCBlockIndentWidth: 4</span><br><span class="line">ObjCSpaceAfterProperty: false</span><br><span class="line">ObjCSpaceBeforeProtocolList: true</span><br><span class="line">PenaltyBreakAssignment: 2</span><br><span class="line">PenaltyBreakBeforeFirstCallParameter: 1</span><br><span class="line">PenaltyBreakComment: 300</span><br><span class="line">PenaltyBreakFirstLessLess: 120</span><br><span class="line">PenaltyBreakString: 1000</span><br><span class="line">PenaltyBreakTemplateDeclaration: 10</span><br><span class="line">PenaltyExcessCharacter: 1000000</span><br><span class="line">PenaltyReturnTypeOnItsOwnLine: 200</span><br><span class="line">PointerAlignment: Right</span><br><span class="line">RawStringFormats:</span><br><span class="line">  - Language: Cpp</span><br><span class="line">    Delimiters:</span><br><span class="line">      - cc</span><br><span class="line">      - CC</span><br><span class="line">      - cpp</span><br><span class="line">      - Cpp</span><br><span class="line">      - CPP</span><br><span class="line">      - &quot;c++&quot;</span><br><span class="line">      - &quot;C++&quot;</span><br><span class="line">    CanonicalDelimiter: &quot;&quot;</span><br><span class="line">    BasedOnStyle: google</span><br><span class="line">  - Language: TextProto</span><br><span class="line">    Delimiters:</span><br><span class="line">      - pb</span><br><span class="line">      - PB</span><br><span class="line">      - proto</span><br><span class="line">      - PROTO</span><br><span class="line">    EnclosingFunctions:</span><br><span class="line">      - EqualsProto</span><br><span class="line">      - EquivToProto</span><br><span class="line">      - PARSE_PARTIAL_TEXT_PROTO</span><br><span class="line">      - PARSE_TEST_PROTO</span><br><span class="line">      - PARSE_TEXT_PROTO</span><br><span class="line">      - ParseTextOrDie</span><br><span class="line">      - ParseTextProtoOrDie</span><br><span class="line">    CanonicalDelimiter: &quot;&quot;</span><br><span class="line">    BasedOnStyle: google</span><br><span class="line">ReflowComments: true</span><br><span class="line">SortIncludes: CaseInsensitive</span><br><span class="line">SortUsingDeclarations: false</span><br><span class="line">SpaceAfterCStyleCast: false</span><br><span class="line">SpaceAfterLogicalNot: false</span><br><span class="line">SpaceAfterTemplateKeyword: true</span><br><span class="line">SpaceBeforeAssignmentOperators: true</span><br><span class="line">SpaceBeforeCpp11BracedList: false</span><br><span class="line">SpaceBeforeCtorInitializerColon: true</span><br><span class="line">SpaceBeforeInheritanceColon: true</span><br><span class="line">SpaceBeforeParens: ControlStatements</span><br><span class="line">SpaceBeforeRangeBasedForLoopColon: true</span><br><span class="line">SpaceInEmptyBlock: false</span><br><span class="line">SpaceInEmptyParentheses: false</span><br><span class="line">SpacesBeforeTrailingComments: 3</span><br><span class="line">SpacesInAngles: false</span><br><span class="line">SpacesInConditionalStatement: false</span><br><span class="line">SpacesInContainerLiterals: false</span><br><span class="line">SpacesInCStyleCastParentheses: false</span><br><span class="line">SpacesInParentheses: false</span><br><span class="line">SpacesInSquareBrackets: false</span><br><span class="line">SpaceBeforeSquareBrackets: false</span><br><span class="line">Standard: Auto</span><br><span class="line">StatementMacros:</span><br><span class="line">  - Q_UNUSED</span><br><span class="line">  - QT_REQUIRE_VERSION</span><br><span class="line">TabWidth: 4</span><br></pre></td></tr></table></figure><h1 id="编译工具链设置"><a href="#编译工具链设置" class="headerlink" title="编译工具链设置"></a>编译工具链设置</h1><h2 id="编译工具链的添加与解释"><a href="#编译工具链的添加与解释" class="headerlink" title="编译工具链的添加与解释"></a>编译工具链的添加与解释</h2><p>这个配置是进行 C++ 开发的关键，因为这个编译工具链就意味着 C++ 的编译环境。</p><p>按下图点开对应的信息，如果你任何编译工具链都没有添加，由于新版本的 CLion 它会自带一个 mingw 的编译套件，所以默认会有一个 CLion 自带的 mingw 编译工具链，如下图所示我的编译工具链稍微有点丰富，有 msvc、g++、clang++、mingw，作为一个刚刚入门学编程的新手，我建议编译工具链这一块暂时就没必要了解了，但在 CLion 中编译的具体配置流程我认为还是有必要讲清楚。<img src="/../../../../img/blog/e2c771d0ded72e510ad702f4cb46fc6a_MD5.webp" alt="bianyi"></p><p>CLion 中添加编译工具链非常简单，你本机把对应工具链的路径加入到了环境变量，那么在你点击 <code>+</code> 对应编译链类型后，会自动扫描到，如果实在没有扫描到，那么也可以自己填入对应的路径，整个编译链包括：</p><ol><li><p>cmake，用于跨平台以及简化底层编译脚本的工具。</p></li><li><p>cmake 生成更底层的编译命令 (对应上述的 Build Tool)，比如 gmake 也就是解析. makefile 文件进行命令执行，比如 ninja 解析 .ninja 文件进行命令执行（编译速度比 makefile 更快，亲身体验）。</p></li><li><p>C 语言的编译器 (clang&#x2F;gcc&#x2F;cl 等等)。</p></li><li><p>C++ 的编译器 (clang++&#x2F;g++&#x2F;cl 等等)。</p></li></ol><p>如果是 mingw，那么上述的一套都是包含的，只需要把 Toolset 这个选项选择为 mingw 对应的目录即可，选择好后，CLion 会自动识别上述四件套的位置。</p><p>接下来简单介绍如何添加一些工具链：</p><ul><li>安装 msvc 编译工具链：直接到官网下载 VS2022，然后安装对应 C++ 环境，打开 CLion 后添加 msvc 环境时就会自动识别。官网：<a href="https://link.juejin.cn/?target=https://visualstudio.microsoft.com/zh-hans/vs/" title="https://visualstudio.microsoft.com/zh-hans/vs/">visualstudio.microsoft.com&#x2F;zh-hans&#x2F;vs&#x2F;</a></li></ul><p>其实对于我们 C++ 程序员而言，最需要的就是一个 Linux 环境，因为很多底层的系统调用是不在 C++ 标准之内的，C++ 想要做到跨平台很难，所以我们需要把开发环境切换到 Linux 系统，正好 windows 提供了 Linux 子系统，也就是 wsl，完美的解决了这个问题，不要考虑日常的使用和开发环境我们到底选哪个了，我全都要！</p><p>而 CLion 对 wsl 的适配程度和正常的本机开发几乎没有任何区别，我们只需要现在 Windows 上安装 wsl2 后，CLion 便可以自动识别你本机的 wsl 环境了，但是你有了 wsl，并不意味着你有了对应的编译链，之前说了，编译链是包括四个东西的，你需要一一手动再 wsl 上先安装好，CLion 会自动识别到的，如果识别不到，由于是通过 <code>apt install</code> 命令安装的，大家应该都清楚在具体那个目录下，实在不清楚可以使用 <code>which</code> 命令。</p><ul><li>安装 wsl2：其实 wsl2 的安装已经被简化到了极致，在 powershell 中 <code>wsl --install</code> 即可。 具体的官方文档如下 <a href="https://link.juejin.cn/?target=https://learn.microsoft.com/zh-cn/windows/wsl/install" title="https://learn.microsoft.com/zh-cn/windows/wsl/install">learn.microsoft.com&#x2F;zh-cn&#x2F;windo…</a> ，一篇非常简练的博客教程：<a href="https://link.juejin.cn/?target=https://zhuanlan.zhihu.com/p/438255467" title="https://zhuanlan.zhihu.com/p/438255467">zhuanlan.zhihu.com&#x2F;p&#x2F;438255467</a>，如果安装遇到问题（大概率网络问题），请自行谷歌或百度或 bing 或 chatgpt。</li><li>如果需要使用 CLion 进行 Qt 开发，可以查看视频讲解：<a href="https://link.juejin.cn/?target=https://www.bilibili.com/video/BV18q4y1i7kV/" title="https://www.bilibili.com/video/BV18q4y1i7kV/">www.bilibili.com/video/BV18q…</a> ，对应的配置信息：<a href="https://link.juejin.cn/?target=https://gitee.com/yuexingqin/template_qtclion" title="https://gitee.com/yuexingqin/template_qtclion">gitee.com&#x2F;yuexingqin&#x2F;…</a></li><li>如果需要使用 CLion 进行 STM32 开发，那么可以查看稚晖君在知乎写的博客教程：<a href="https://link.juejin.cn/?target=https://zhuanlan.zhihu.com/p/145801160" title="https://zhuanlan.zhihu.com/p/145801160">zhuanlan.zhihu.com&#x2F;p&#x2F;145801160</a></li></ul><h2 id="cmake-配置项的添加与解释"><a href="#cmake-配置项的添加与解释" class="headerlink" title="cmake 配置项的添加与解释"></a>cmake 配置项的添加与解释</h2><p>解释完上述编译链后，我们发现 CLion 中有个很明显的 <code>default</code> 字眼，这个有什么用呢？</p><p>如果排在第一个的编译链，会被设置为默认编译链，如果想要其他的编译链为默认，点击上移即可。</p><p>至于具体的作用，别急，先等我讲完 CLion 中 cmake 配置项的处理。</p><p><img src="/../../../../img/blog/be20d186f43d21e980bb5a66c92d58bd_MD5.webp" alt="clion1"></p><p>如上图所示，第二个 <code>CMake</code> 选项就是我们现在要讲的东西，而这两个正好也是整个开发环境中最重要的东西，第一个编译工具链决定了 CLion 中已经识别了本机有哪些编译环境，而第二个 <code>CMake</code> 选项，则是用于配置 cmake 基于哪些配置项生成。</p><p>所以我们现在应该了解了 CLion 是如何去编译项目生成可执行文件的了。</p><ol><li><p>通过 cmake 配置选项运行整个项目的 CMakeList.txt</p></li><li><p>生成 makefile 或其他底层脚本后再通过对应的工具去执行这个脚本</p></li><li><p>运行编译好的程序</p></li></ol><p>而我们现在讲的就是添加 cmake 配置选项，如果你手动敲 cmake 命令的话，那样对应的就是命令行参数了。</p><p><img src="/../../../../img/blog/e8cae55de729fc524cfc69218e494ab9_MD5.webp" alt="clion3"></p><p>上述图片中已经解释了一些配置的作用。这些配置项一般是不常改动，使用默认值就行，比如 <code>Build options</code> 是执行最后的脚本所用的参数，默认为 <code>-j 12</code>，比如如果是 makefile，那么就是 <code>make -j12</code>。</p><p>下面是大家可能需要进行一些配置的选项：</p><ol><li><p>Build type：这是程序最终编译的类型，意味着编译器该以何种程度对源代码进行优化，比如 Debug 版本一般再 gcc 中对应 o2 的优化，release 版本对应 o3 的优化，两者一般存在 10 倍左右的性能差距。</p></li><li><p>Toolchain：这是前面所说的编译工具链，一般来说，想要切换编译器，你切换这个选项就行了，默认使用 default 工具链。</p></li><li><p>Generator：这是前面所说的工具链中的较为底层的脚本的运行工具，可以是 makefile 或者 ninja，不选的话也是默认工具链里的那个。</p></li><li><p>CMake options：这个是 cmake 运行时可以加入的命令行参数，比如我们可以 -D 来定义对应的变量控制对应的 cmake 行为，甚至于前面的 Build type 我们完全可以不写（当然这是 CLion，这个空必须得被填充），然后使用 -DCMAKE_BUILD_TYPE&#x3D;Release，这个变量可以决定最终 cmake 生成的执行脚本是按照 release 的标准去运行的，又比如 -DBUILD_SHARED_LIBS&#x3D;ON，那么最终是会生成动态库而不是静态库，我上图中的 -DENABLE_TEST&#x3D;ON 是内部的 cmake 有定义一个变量默认为 OFF 值，如果为 ON 时会加入测试代码为子项目。</p></li></ol><p>现在 cmake 在 CLion 中的配置项已经讲完了，简单实践一下来体验之前讲的 CLion 到整个运行的流程，我这里就直接配图了：</p><ol><li><p>通过 cmake 配置选项运行整个项目的 CMakeList.txt。<img src="/../../../../img/blog/4a465ad3b52d1bff6147583d7661fc75_MD5.webp" alt="clion4"></p></li><li><p>生成 makefile 或其他底层脚本后再通过对应的工具去执行这个脚本。我们先看一眼上一步 cmake 生成的文件（放出了两个不同的配置项产生的脚本，第一个使用的 Generator 为 ninja，第二个使用的为 gmake）：<img src="/../../../../img/blog/ab4d9f999e9c03e883f62955143b8f7c_MD5.webp" alt="clion5"> 如果想要继续执行这个脚本，应该在 CLion 中执行对应的源代码，CLion 会自动识别入口点函数，然后给出可执行的按钮，如图：<img src="/../../../../img/blog/de8e460363e1c84849bf05e20d615f9e_MD5.webp" alt="clion6"> 点击执行后，不仅会直接对应的 makefile 或 build. ninja 还会顺便把这个程序运行到 CLion 内置的终端环境中。</p></li><li><p>运行编译好的程序：这一步已经在第二步一并执行了。</p></li></ol><p>理解了这三步以及 cmake 的配置之后，我相信如果突然间 CLion 不出现执行程序的按钮，或者一个外部的项目我们无法跑起来，那么我们肯定是会有对应的排查思路了。比如没有执行程序的按钮，那可能对应的 cmake 配置项你还没设置好，如果外部项目跑不起来，你可以把那四个编译工具链中的某个换其他的环境试试？</p><h1 id="cmake-的使用与实战"><a href="#cmake-的使用与实战" class="headerlink" title="cmake 的使用与实战"></a>cmake 的使用与实战</h1><p>经过上述文字和图片讲解，我们很自然的想到，整个 CLion 运行 C++ 代码其实就是在运行 cmake 和 makefile(或 build.ninja)，第二个过程我们参与不了，但是第一个 cmake 的编写过程我们却需要一直接触。</p><p>下面用 CLion 新建项目自动生成的 cmake 模板来简单对 cmake 语法热热身。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cmake_minimum_required(VERSION 3.22)</span><br><span class="line">project(untitled)</span><br><span class="line"></span><br><span class="line">set(CMAKE_CXX_STANDARD 17)</span><br><span class="line"></span><br><span class="line">add_executable(untitled main.cpp)</span><br></pre></td></tr></table></figure><ul><li><code>cmake_minimum_required</code> 命令：规定了编译本项目的 cmake 工具至少需要 3.22 版本。</li><li><code>project</code> 命令：规定了本项目的项目名称，同时也根据这个传入的值生成了一堆变量，常用的如下：</li></ul><ol><li><p><code>PROJECT_NAME</code> ：项目名称</p></li><li><p><code>PROJECT_BINARY_DIR</code> ：项目的二进制文件目录，即编译后的可执行文件和库文件的输出目录</p></li><li><p><code>PROJECT_SOURCE_DIR</code> ：项目的源文件目录，即包含 CMakeLists.txt 文件的目录</p></li></ol><p>举个简单例子说明上述变量的作用： 比如一个测试的子项目中的 CMakeList.txt，可能需要写下面的语句（先不管 file 命令），由于是作为直接的子项目，那么里面肯定不会存在 project 语句，所以 PROJECT_SOURCE_DIR 变量表示的仍然是整个项目的根目录，直接通过 <code>$&#123;&#125;</code> 的形式来使用它即可，这样就不需要关心相对或绝对路径了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">file(GLOB SONIC_TEST_FILES</span><br><span class="line">     &quot;$&#123;PROJECT_SOURCE_DIR&#125;/tests/*.h&quot;</span><br><span class="line">     &quot;$&#123;PROJECT_SOURCE_DIR&#125;/tests/*.cpp&quot;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><ul><li><code>set</code> 命令：设置对应变量为对应的值，该变量存在，则修改该变量的值，如果不存在则会创建并初始化为对应的值，这里对 set 的使用是设置了 CMAKE_CXX_STANDARD 变量为 17，这个变量可以控制最终编译采用的 C++ 版本，这里是使用 C++17。</li><li><code>add_executable</code> 命令：这是用于生成可执行程序的命令，第一个参数为该执行程序最终编译后生成的文件名，后面跟着的都是需要编译的源代码。</li></ul><p>对于新手而言，其实不太需要自己手写 cmake，因为 CLion 会在你新建源文件的时候把相应源文件添加到 add_excutable 命令的后面，但项目稍微大一点或者说引入了很多外部库，那么大概率会抛弃 CLion 的这种自动化了。</p><h2 id="常用的-cmake-变量（入门）"><a href="#常用的-cmake-变量（入门）" class="headerlink" title="常用的 cmake 变量（入门）"></a>常用的 cmake 变量（入门）</h2><p>下面只列出了部分变量的作用，更多的变量请查看文档：<a href="https://link.juejin.cn/?target=https://cmake.org/cmake/help/latest/manual/cmake-variables.7.html" title="https://cmake.org/cmake/help/latest/manual/cmake-variables.7.html">cmake.org&#x2F;cmake&#x2F;help&#x2F;…</a></p><ul><li><code>PROJECT_NAME</code> ：项目名称</li><li><code>PROJECT_BINARY_DIR</code> ：项目的二进制文件目录，即编译后的可执行文件和库文件的输出目录</li><li><code>PROJECT_SOURCE_DIR</code> ：项目的源文件目录，即包含 CMakeLists.txt 文件的目录</li><li><code>CMAKE_BINARY_DIR</code> ：当前 CMake 运行的二进制文件目录，通常和 PROJECT_BINARY_DIR 是同一个目录</li><li><code>CMAKE_SOURCE_DIR</code> ：当前 CMake 运行的源文件目录，通常和 PROJECT_SOURCE_DIR 是同一个目录</li><li><code>CMAKE_C_STANDARD</code> ：指定 C 语言的标准版本</li><li><code>CMAKE_CXX_STANDARD</code> ：指定 C++ 语言的标准版本</li><li><code>CMAKE_CXX_FLAGS</code> ：指定编译 C++ 代码时使用的编译选项</li><li><code>CMAKE_C_FLAGS</code> ：指定编译 C 代码时使用的编译选项</li><li><code>CMAKE_EXE_LINKER_FLAGS</code> ：指定链接可执行文件时使用的链接选项</li><li><code>CMAKE_SYSTEM_NAME</code> ：指定当前操作系统名称（如 Windows、Linux 等）</li><li><code>CMAKE_SYSTEM_PROCESSOR</code> ：指定当前处理器的类型（如 x86、x86_64 等）</li><li><code>CMAKE_CXX_COMPILER_ID</code> ：指定了当前使用的 C++ 编译器，同理可得 C 的编译器对应的名字。</li></ul><p>对这些变量做一个简单的实践：</p><ol><li>通过 message 打印出 PROJECT_BINARY_DIR、PROJECT_SOURCE_DIR、CMAKE_BINARY_DIR、CMAKE_SOURCE_DIR 来加以验证。 目录结构：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">  ├── CMakeLists.txt</span><br><span class="line">  ├── main.cpp</span><br><span class="line">  └── sub</span><br><span class="line">      └── CMakeLists.txt</span><br></pre></td></tr></table></figure><p>cmake:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">main:</span><br><span class="line">    cmake_minimum_required(VERSION 3.14)</span><br><span class="line">    project(main)</span><br><span class="line">    </span><br><span class="line">    add_subdirectory(sub)</span><br><span class="line">    </span><br><span class="line">    message(STATUS &quot;main:$&#123;PROJECT_NAME&#125;\n  pro-src:$&#123;PROJECT_SOURCE_DIR&#125;\n pro-bin:$&#123;PROJECT_BINARY_DIR&#125;\n cmake-src:$&#123;CMAKE_SOURCE_DIR&#125;\n cmake-bin:$&#123;CMAKE_BINARY_DIR&#125;&quot;)</span><br><span class="line">    </span><br><span class="line">    sub:</span><br><span class="line">    project(sub)</span><br><span class="line">    </span><br><span class="line">    message(STATUS &quot;sub:$&#123;PROJECT_NAME&#125;\n  pro-src:$&#123;PROJECT_SOURCE_DIR&#125;\n pro-bin:$&#123;PROJECT_BINARY_DIR&#125;\n cmake-src:$&#123;CMAKE_SOURCE_DIR&#125;\n cmake-bin:$&#123;CMAKE_BINARY_DIR&#125;&quot;)</span><br></pre></td></tr></table></figure><p>打印信息如下：我们发现 CMake 对应的变量没有变化，而 Prject 有了变量，因为我们在 sub 也使用了 project 命令。<br>        <img src="/../../../../img/blog/ab5b458791433d39b9dff10131e59101_MD5.webp" alt="clion7"></p><ol><li>通过变量检测环境执行不同的 cmake 代码：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#判断当前的操作系统</span><br><span class="line">if (CMAKE_SYSTEM_NAME MATCHES &quot;Linux&quot;)</span><br><span class="line">    target_link_libraries(my-logger PUBLIC fmt-header-only pthread)</span><br><span class="line">    message(STATUS &quot;Now is Linux&quot;)</span><br><span class="line">elseif (CMAKE_SYSTEM_NAME MATCHES &quot;Windows&quot;)</span><br><span class="line">    target_link_libraries(my-logger PUBLIC fmt-header-only ws2_32)</span><br><span class="line">    message(STATUS &quot;Now is windows&quot;)</span><br><span class="line">endif ()</span><br><span class="line">#判断当前使用的编译器</span><br><span class="line">if (CMAKE_CXX_COMPILER_ID STREQUAL &quot;GNU&quot;)</span><br><span class="line">  # Do something for GCC</span><br><span class="line">elseif (CMAKE_CXX_COMPILER_ID STREQUAL &quot;Intel&quot;)</span><br><span class="line">  # Do something for Intel C++</span><br><span class="line">elseif (CMAKE_CXX_COMPILER_ID STREQUAL &quot;Microsoft&quot;)</span><br><span class="line">  # Do something for Microsoft Visual C++</span><br><span class="line">elseif (CMAKE_CXX_COMPILER_ID STREQUAL &quot;Clang&quot;)</span><br><span class="line">  # Do something for Clang</span><br><span class="line">endif()</span><br><span class="line"></span><br><span class="line">#判断当前的系统架构</span><br><span class="line">if (CMAKE_SYSTEM_PROCESSOR MATCHES &quot;i|x86|x86_64|AMD64&quot;)</span><br><span class="line">  # Do something for x86 architecture</span><br><span class="line">elseif (CMAKE_SYSTEM_PROCESSOR MATCHES &quot;^(arm|aarch64)&quot;)</span><br><span class="line">  # Do something for ARM architecture</span><br><span class="line">elseif (CMAKE_SYSTEM_PROCESSOR MATCHES &quot;^(mips|mipsel|mips64)&quot;)</span><br><span class="line">  # Do something for MIPS architecture</span><br><span class="line">elseif (CMAKE_SYSTEM_PROCESSOR MATCHES &quot;^(powerpc|ppc64)&quot;)</span><br><span class="line">  # Do something for PowerPC architecture</span><br><span class="line">endif()</span><br></pre></td></tr></table></figure><ol><li>通过调整链接时的 flag 防止动态链接，因为如果你是使用 Windows 平台下的编译工具链，CLion 有些时候最终链接并不是采用静态链接，导致你最终生成的可执行程序没法直接执行，这个时候你就需要使用下面的命令来强制静态链接了：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set(CMAKE_EXE_LINKER_FLAGS &quot;-static&quot;)</span><br></pre></td></tr></table></figure><h2 id="常用的-cmake-命令（入门）"><a href="#常用的-cmake-命令（入门）" class="headerlink" title="常用的 cmake 命令（入门）"></a>常用的 cmake 命令（入门）</h2><p>下列只列出了部分命令，如果你以后有需要用到的其他命令，请前往官网进行查询：<a href="https://link.juejin.cn/?target=https://cmake.org/cmake/help/latest/manual/cmake-commands.7.html" title="https://cmake.org/cmake/help/latest/manual/cmake-commands.7.html">cmake.org&#x2F;cmake&#x2F;help&#x2F;…</a></p><p>我个人较为常用的命令：</p><ol><li><p><a href="https://link.juejin.cn/?target=https://cmake.org/cmake/help/latest/command/project.html" title="https://cmake.org/cmake/help/latest/command/project.html">project</a>：用于定义项目名称、版本号和语言。</p></li><li><p><a href="https://link.juejin.cn/?target=https://cmake.org/cmake/help/latest/command/add_executable.html" title="https://cmake.org/cmake/help/latest/command/add_executable.html">add_executable</a>：用于添加可执行文件。第一个参数很重要，被称为 target，可以作为 target_xxx 命令的接收对象。</p></li><li><p><a href="https://link.juejin.cn/?target=https://cmake.org/cmake/help/latest/command/add_library.html" title="https://cmake.org/cmake/help/latest/command/add_library.html">add_library</a>：用于添加库文件，可以创建静态库或动态库。第一个参数很重要，被称为 target，可以作为 target_xxx 命令的接收对象。简单使用如下</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">add_library(test_lib a.cc b.cc) #默认生成静态库  </span><br><span class="line">add_library(test_lib SHARED a.cc b.cc) #默认生成静态库</span><br></pre></td></tr></table></figure><ol><li><p><a href="https://link.juejin.cn/?target=https://cmake.org/cmake/help/latest/command/add_definitions.html" title="https://cmake.org/cmake/help/latest/command/add_definitions.html">add_definitions</a>：用于添加宏定义，注意该命令没有执行顺序的问题，只要改项目中用了该命令定义宏，那么所有的源代码都会被定义这个宏 <code>add_definitions(-DFOO -DBAR …)</code> 。</p></li><li><p><a href="https://link.juejin.cn/?target=https://cmake.org/cmake/help/latest/command/add_subdirectory.html" title="https://cmake.org/cmake/help/latest/command/add_subdirectory.html">add_subdirectory</a>：用于添加子项目目录，如果有该条语句，就先会跑去执行子项目的 cmake 代码，这样会导致一些需要执行后立马生效的语句作用不到，比如 include_directories 和 link_directories 如果执行在这条语句后面，则他们添加的目录在子项目中无法生效。有些命令如 target_include_directories 和 target_link_directories 是根据目标 target 是否被链接使用来生效的，所以这些命令的作用范围与执行顺序无关，且恰好同一个 cmake 项目中产生的库文件是可以直接通过名称链接的，无论链接对象是在子目录还是父目录</p></li><li><p><a href="https://link.juejin.cn/?target=https://cmake.org/cmake/help/latest/command/target_link_libraries.html" title="https://cmake.org/cmake/help/latest/command/target_link_libraries.html">target_link_libraries</a>：用于将可执行文件或库文件链接到库文件或可执行文件。身为 target_xxx 的一员，很明显第二个参数也可以进行权限控制。</p></li><li><p><a href="https://link.juejin.cn/?target=https://cmake.org/cmake/help/latest/command/include_directories.html" title="https://cmake.org/cmake/help/latest/command/include_directories.html">include_directories</a>：用于指定头文件搜索路径，优点是简单直接，缺点是无法进行权限控制，一旦被执行后，后续的所有代码都能搜索到对应的文件路径。</p></li><li><p><a href="https://link.juejin.cn/?target=https://cmake.org/cmake/help/latest/command/target_include_directories.html" title="https://cmake.org/cmake/help/latest/command/target_include_directories.html">target_include_directories</a>：指定头文件搜索路径，并将搜索路径关联到一个 target 上，这里的 target 一般是指生成可执行程序命令里的 target 或者生成库文件的 target，与上一个命令的不同点在于可以设置导出权限，比如现在我写了一个项目，这个项目引入了其他库，但是我不想让其他库的符号暴露出去（毕竟使用这个项目的人只关注这个项目的接口，不需要关注其他依赖的接口）可以通过 PRIVATE 将头文件搜索目录设置不导出的权限。</p></li><li><p><a href="https://link.juejin.cn/?target=https://cmake.org/cmake/help/latest/command/link_directories.html" title="https://cmake.org/cmake/help/latest/command/link_directories.html">link_directories</a>：与前面的 include_directories 命令类似，添加的是库的搜索路径。</p></li><li><p><a href="https://link.juejin.cn/?target=https://cmake.org/cmake/help/latest/command/target_link_directories.html" title="https://cmake.org/cmake/help/latest/command/target_link_directories.html">target_link_directories</a>：和前面的 include 版本一样的，只是改成了库路径。</p></li><li><p>if\elseif\endif ，在编程语言立马已经用烂了，现在主要是了解 if(condition) 中的条件到底如何判断的，以及内部都支持哪些操作，比如大于等于啥的，这方面直接看官方文档吧，非常好懂：<a href="https://link.juejin.cn/?target=https://cmake.org/cmake/help/latest/command/if.html" title="https://cmake.org/cmake/help/latest/command/if.html">cmake.org&#x2F;cmake&#x2F;help&#x2F;…</a></p></li><li><p><a href="https://link.juejin.cn/?target=https://cmake.org/cmake/help/latest/command/aux_source_directory.html" title="https://cmake.org/cmake/help/latest/command/aux_source_directory.html">aux_source_directory</a>：这个指令简单实用，第一个参数传递一个文件目录，它会扫描这里面所有的源文件放到第二个参数定义的变量名中。注意第一个参数只能是文件夹。</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aux_source_directory($&#123;PROJECT_SOURCE_DIR&#125; SRC)</span><br></pre></td></tr></table></figure><ol><li><a href="https://link.juejin.cn/?target=https://cmake.org/cmake/help/latest/command/file.html" title="https://cmake.org/cmake/help/latest/command/file.html">file</a>：可以说是上面那个命令的增强版本，但如果熟悉这个命令的朋友肯定很快站出来反对，因为这个命令实在是太强大了，你如果翻一翻这个官方文档就会发现它具备几乎文件系统的所有功能，什么读写文件啊，什么从网上下载文件，本地上传文件之类的它都有，计算文件的相对路径，路径转化等等。但我们平时用到的最多的命令还是用来获取文件到变量里。比如 file(GLOB FILES “ 文件路径表示 1” “ 文件路径表示 2” …) GLOB 会产生一个由所有匹配 globbing 表达式的文件组成的列表，并将其保存到第二个参数定义的变量中。Globbing 表达式与正则表达式类似，但更简单，比如如果要实现前一个命令的功能可以这么写：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file(GLOB SRC &quot;$&#123;PROJECT_SOURCE_DIR&#125;/*.cc&quot;)</span><br></pre></td></tr></table></figure><p>如果 GLOB 换成 GLOB_RECURSE ，那么上述命令将递归的搜寻其子目录的所有符合条件的文件，而不仅仅是一个层级。</p><ol><li><a href="https://link.juejin.cn/?target=https://cmake.org/cmake/help/latest/command/execute_process.html" title="https://cmake.org/cmake/help/latest/command/execute_process.html">execute_process</a>：用于执行外部的命令，如下的示例代码是执行 git clone 命令，执行命令的工作目录在 <code>$&#123;CMAKE_BINARY_DIR&#125;/deps/</code></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">execute_process(COMMAND git clone https://github.com/&lt;username&gt;/&lt;repository&gt;.git</span><br><span class="line">                WORKING_DIRECTORY $&#123;CMAKE_BINARY_DIR&#125;/deps/&lt;repository&gt;)</span><br></pre></td></tr></table></figure><ol><li><p><a href="https://link.juejin.cn/?target=https://cmake.org/cmake/help/latest/command/message.html" title="https://cmake.org/cmake/help/latest/command/message.html">message</a>：打印出信息用于 debug。</p></li><li><p><a href="https://link.juejin.cn/?target=https://cmake.org/cmake/help/latest/command/option.html" title="https://cmake.org/cmake/help/latest/command/option.html">option</a>：用于快速设置定义变量并赋值为对应的 bool 值，常被用于判断某些操作是否执行。</p></li><li><p><a href="https://link.juejin.cn/?target=https://cmake.org/cmake/help/latest/command/find_package.html%23id5" title="https://cmake.org/cmake/help/latest/command/find_package.html#id5">find_package</a>：用于查找外界的 package，其实就是查找外界对应的 <code>&lt;package&gt;Config.cmake</code> 和 <code>Find&lt;package&gt;.cmake</code> 文件，这些文件里有外界包对应的变量信息以及库和头文件的各种路径信息。我们需要注意一些有关 <code>find_package</code> 命令查找 Config.cmake 路径的变量：</p></li></ol><ul><li><code>CMAKE_PREFIX_PATH</code> 变量是一个路径列表，CMake 会在这些路径中搜索包的 <code>Config.cmake</code> 文件。</li><li><code>&lt;Package&gt;_DIR</code> 变量是指向包的 <code>Config.cmake</code> 文件的路径。如果你手动设置了这个变量，那么 <code>find_package</code> 命令就可以找到包的信息。</li></ul><p>同时他的一些常用参数如下：</p><ul><li><code>CONFIG</code> ：显式指定 find_package 去查找 <code>&lt;package&gt;Config.cmake</code> 文件，一般只要你在变量里面指定了 <code>&lt;package&gt;Config.cmake</code> 的路径，那么该参数填不填都没差别。我建议最好还是带上该参数比较好。</li><li><code>REQUIRED</code> ：该参数表示如果没找到，那么直接产生 cmake 错误，退出 cmake 执行过程，如果没有 REQUIRED，则即使没找到也不会终止编译。</li><li><code>PATHS</code> ：这个参数的效果和前面的变量类似，也是指定查找的路径。</li><li><code>COMPONENTS</code> ：用于指定查找的模块，模块分离在不同的文件中，需要使用哪个就指定哪个模块。典型的就是使用 Qt 时的 cmake 代码，比如 <code>find_package(Qt5 COMPONENT Core Gui Widgets REQUIRED)</code> 。</li><li>VERSION：可能有很多个不同版本的包，则需要通过该参数来指定，如：<code>find_package(XXX VERSION 1.2.3)</code>。</li></ul><ol><li><a href="https://link.juejin.cn/?target=https://cmake.org/cmake/help/latest/command/include.html" title="https://cmake.org/cmake/help/latest/command/include.html">include</a>：从文件或模块加载并运行 CMake 代码。我用这个命令实际上只是为了使用 <a href="https://link.juejin.cn/?target=https://cmake.org/cmake/help/latest/module/FetchContent.html%23id1" title="https://cmake.org/cmake/help/latest/module/FetchContent.html#id1">FetchContent</a><a href="https://link.juejin.cn/?target=https://cmake.org/cmake/help/latest/module/FetchContent.html%23fetchcontent" title="https://cmake.org/cmake/help/latest/module/FetchContent.html#fetchcontent">¶</a> 这个 module 的功能，该功能是从 cmake3.11 开始支持的，使用该 module 前需要通过 include 命令加载该模块，命令如下：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">include(FetchContent)</span><br></pre></td></tr></table></figure><ol><li><a href="https://link.juejin.cn/?target=https://cmake.org/cmake/help/latest/module/FetchContent.html%23id1" title="https://cmake.org/cmake/help/latest/module/FetchContent.html#id1">FetchContent</a>：这是一个模块功能，它用来从代码仓库中拉取代码，例如我要把最近写的日志库引入到当前的项目中使用（注意这中间不会有任何代理，所以拉取 GitHub 的仓库可能失败）：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">include(FetchContent)#引入功能模块</span><br><span class="line"></span><br><span class="line">FetchContent_Declare(</span><br><span class="line">        my-logger   #项目名称</span><br><span class="line">        GIT_REPOSITORY https://github.com/ACking-you/my-logger.git #仓库地址</span><br><span class="line">        GIT_TAG        v1.6.2  #仓库的版本tag</span><br><span class="line">        GIT_SHALLOW TRUE    #是否只拉取最新的记录</span><br><span class="line">)</span><br><span class="line">FetchContent_MakeAvailable(my-logger)</span><br><span class="line"></span><br><span class="line">add_excutable(main $&#123;SRC&#125;)</span><br><span class="line">#链接到程序进行使用</span><br><span class="line">target_link_libraries(main my-logger)</span><br></pre></td></tr></table></figure><p>这样引入第三方库的好处显而易见，优点类似于包管理的效果了，但缺少了最关键的中心仓库来确保资源的有效和稳定。参考 golang 再做个 proxy 层级就好了。 同样可以拉取最新的 googletest 可以使用下列语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">FetchContent_Declare(</span><br><span class="line">        googletest</span><br><span class="line">        GIT_REPOSITORY https://github.com/google/googletest.git</span><br><span class="line">        GIT_TAG        release-1.12.1</span><br><span class="line">        GIT_SHALLOW TRUE</span><br><span class="line">)</span><br><span class="line"># For Windows: Prevent overriding the parent project&#x27;s compiler/linker settings</span><br><span class="line">set(gtest_force_shared_crt ON CACHE BOOL &quot;&quot; FORCE)</span><br><span class="line">FetchContent_MakeAvailable(googletest)</span><br><span class="line"></span><br><span class="line">target_link_libraries(main gtest_main)</span><br></pre></td></tr></table></figure><ol><li><a href="https://link.juejin.cn/?target=https://cmake.org/cmake/help/latest/command/function.html" title="https://cmake.org/cmake/help/latest/command/function.html">function&#x2F;endfunction</a> ：在 cmake 中用于定义函数，复用 cmake 代码的命令。第一个参数为函数的名称，后面为参数的名称，使用参数和使用变量时一样的，但是如果参数是列表类型，则在传入的时候就会被展开，然后与函数参数依次对应，多余的参数被 <code>ARGN</code> 参数吸收。</li></ol><p>更多较为常用的命令：</p><ul><li><a href="https://link.juejin.cn/?target=https://cmake.org/cmake/help/latest/command/add_custom_command.html" title="https://cmake.org/cmake/help/latest/command/add_custom_command.html">add_custom_command</a>：添加自定义规则命令，同样也是执行外界命令，但多了根据依赖和产物判断执行时机的作用。</li><li><a href="https://link.juejin.cn/?target=https://cmake.org/cmake/help/latest/command/install.html" title="https://cmake.org/cmake/help/latest/command/install.html">install</a>：添加 install 操作。</li><li><a href="https://link.juejin.cn/?target=https://cmake.org/cmake/help/latest/command/string.html" title="https://cmake.org/cmake/help/latest/command/string.html">string</a>：对 string 的所有操作，比如字符串替换啥的。</li><li><a href="https://link.juejin.cn/?target=https://cmake.org/cmake/help/latest/command/list.html" title="https://cmake.org/cmake/help/latest/command/list.html">list</a>：对 list 的所有操作，比如列表处理之类的。</li><li><a href="https://link.juejin.cn/?target=https://cmake.org/cmake/help/latest/command/foreach.html" title="https://cmake.org/cmake/help/latest/command/foreach.html">foreach</a>：cmake 中的 for 循环。</li><li>…</li></ul><p>利用上述命令实现 Qt 开发中调用 uic 工具把 大量的 <code>.ui</code> 文件转化为 <code>.cpp</code> 和 <code>.h</code> 文件，并实现当 ui 文件更新时或 <code>.cpp/.h</code> 文件不存在时才创建对应的 <code>.cpp/.h</code> 文件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#函数功能实现</span><br><span class="line">function(get_ui_source)</span><br><span class="line">foreach (item $&#123;ARGN&#125;)</span><br><span class="line">set(UIC_EXE_PATH $&#123;VCPKG_ROOT&#125;/installed/x64-windows/tools/qt5/bin/uic.exe)</span><br><span class="line">get_filename_component(name $&#123;item&#125; NAME_WLE)</span><br><span class="line">string(PREPEND name &quot;ui_&quot;)</span><br><span class="line">set(output_h $&#123;PROJECT_SOURCE_DIR&#125;/ui_gen/$&#123;name&#125;.h)</span><br><span class="line">set(output_cpp $&#123;PROJECT_SOURCE_DIR&#125;/ui_gen/$&#123;name&#125;.cpp)</span><br><span class="line">file(TIMESTAMP $&#123;item&#125; ui_time)</span><br><span class="line">#当.h 文件已经存在时，仅当.ui 文件被更新了才重新生成.h 文件</span><br><span class="line">if (EXISTS $&#123;output_h&#125;)</span><br><span class="line">file(TIMESTAMP $&#123;output_h&#125; h_time)</span><br><span class="line">if (ui_time GREATER h_time)</span><br><span class="line">execute_process(COMMAND $&#123;UIC_EXE_PATH&#125; $&#123;item&#125; -o $&#123;output_h&#125;)</span><br><span class="line">endif ()</span><br><span class="line">else ()</span><br><span class="line">execute_process(COMMAND $&#123;UIC_EXE_PATH&#125; $&#123;item&#125; -o $&#123;output_h&#125;)</span><br><span class="line">endif ()</span><br><span class="line">#当.cpp 文件已经存在时，仅当.ui 文件被更新了才重新生成.cpp 文件</span><br><span class="line">if (EXISTS $&#123;output_cpp&#125;)</span><br><span class="line">file(TIMESTAMP $&#123;output_cpp&#125; cpp_time)</span><br><span class="line">if (ui_time GREATER cpp_time)</span><br><span class="line">execute_process(COMMAND $&#123;UIC_EXE_PATH&#125; $&#123;item&#125; -o $&#123;output_cpp&#125;)</span><br><span class="line">endif ()</span><br><span class="line">else ()</span><br><span class="line">execute_process(COMMAND $&#123;UIC_EXE_PATH&#125; $&#123;item&#125; -o $&#123;output_cpp&#125;)</span><br><span class="line">endif ()</span><br><span class="line">endforeach ()</span><br><span class="line">endfunction()</span><br><span class="line"></span><br><span class="line">get_ui_source($&#123;UI_FILES&#125;) #功能的使用</span><br></pre></td></tr></table></figure><h1 id="ideaVim-的使用与设置"><a href="#ideaVim-的使用与设置" class="headerlink" title="ideaVim 的使用与设置"></a>ideaVim 的使用与设置</h1><p>关于 vim 的基本操作，这里就不细讲，网络上大把大把的教程，我这里只讲在 CLion 中怎么使用 vim，怎么配置 vim 让它在 CLion 中更好用。</p><p>在使用 ideaVim 前，我们需要先下载 IdeaVim 这个拓展，ideaVim 的链接：<a href="https://link.juejin.cn/?target=https://plugins.jetbrains.com/plugin/164-ideavim" title="https://plugins.jetbrains.com/plugin/164-ideavim">plugins.jetbrains.com&#x2F;plugin&#x2F;164-…</a>，下载好后，应该是默认启用了的。</p><p>一、配置 ctrl+c 和 ctrl+v 和 ctrl+a 防止这些你常用的快捷键被 vim 占用</p><p><img src="/../../../../img/blog/ea65ef8d63700932304f37cd6a03b3ce_MD5.webp" alt="clion8"></p><p><img src="/../../../../img/blog/9b6f9bdd71f86623aa79f719cd9bb29c_MD5.webp" alt="clion8"></p><p>二、配置.ideavimrc。</p><p>点击 <code>Open ~/.ideavimrc</code> 后，加入下面的配置（这是我个人使用的配置）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">let mapleader = &quot;,&quot;</span><br><span class="line">let g:mapleader = &quot;,&quot;</span><br><span class="line">set timeoutlen=300</span><br><span class="line"></span><br><span class="line">&quot; general</span><br><span class="line">imap jk &lt;Esc&gt;</span><br><span class="line">imap kj &lt;Esc&gt;</span><br><span class="line">vnoremap q &lt;Esc&gt;</span><br><span class="line">nmap &lt;C-o&gt; :action Back&lt;CR&gt;</span><br><span class="line">nmap &lt;C-i&gt; :action Forward&lt;CR&gt;</span><br><span class="line">nnoremap &lt;Leader&gt;r :&lt;C-u&gt;action RenameElement&lt;CR&gt;</span><br><span class="line"></span><br><span class="line">&quot; Redo</span><br><span class="line">nnoremap U &lt;C-r&gt;</span><br><span class="line"></span><br><span class="line">&quot; code editing</span><br><span class="line">nnoremap == :&lt;C-u&gt;action ReformatCode&lt;CR&gt;</span><br><span class="line">vnoremap == :&lt;C-u&gt;action ReformatCode&lt;CR&gt;</span><br><span class="line">nnoremap cc :&lt;C-u&gt;action CommentByLineComment&lt;CR&gt;</span><br><span class="line">vnoremap cc :&lt;C-u&gt;action CommentByLineComment&lt;CR&gt;</span><br><span class="line"></span><br><span class="line">&quot; Run and debug</span><br><span class="line">nnoremap \r :action RunClass&lt;cr&gt;</span><br><span class="line">nnoremap \i :&lt;C-u&gt;action OptimizeImports&lt;CR&gt;</span><br><span class="line">nnoremap \R :action Run&lt;cr&gt;</span><br><span class="line"></span><br><span class="line">nnoremap [[ :action MethodUp&lt;cr&gt;</span><br><span class="line">nnoremap ]] :action MethodDown&lt;cr&gt; </span><br></pre></td></tr></table></figure><p>加入后点击右上角的小图标进行刷新即可。</p><p><img src="/../../../../img/blog/bd92c93c5430e968753dbdc0787e958c_MD5.webp" alt="ideavim"></p><p>上述配置文件实现了下面的功能：</p><ol><li><p>按下 j+k 或者 k+j 将会退出插入模式。</p></li><li><p>在可视模式下按 q 退出。</p></li><li><p>ctrl+o 可以实现指针回退到上一次的位置，ctrl+i 前进到上次的位置。可以类比为 VS 李的前进和后退按钮（一般查看定义查看的比较深，可以使用该命令回退或前进）。</p></li><li><p>, + r 可以实现 CLion 中的重构变量名。</p></li><li><p>U 取消撤销（由于 vim 中按 u 是撤销，而取消撤销需要 ctrl+r，这让人很不习惯）</p></li><li><p>&#x3D; + &#x3D;实现代码格式化。</p></li><li><p>c + c 实现代码注释</p></li><li><p>[ + [跳转到前一个函数位置</p></li><li><p>] + ] 跳转到下一个函数位置</p></li><li><p>\ + r 运行当前的可执行程序（如果当前代码段里面有运行按钮的话）</p></li><li><p>\ + R 运行当前可执行程序，这个是直接相当于按了右上角的三角按钮运行</p></li><li><p>\ + i 优化导入的包</p></li></ol><p>C++ 后端</p><ul><li><a href="https://circlereader.com/">官方主页</a></li><li><a href="https://circlereader.com/download">下载新版</a></li><li><a href="https://support.qq.com/products/317910">问题反馈</a></li><li><a href="https://circlereader.com/donate">捐赠支持 ❤️</a></li></ul><p>浏览器扩展 Circle 阅读助手排版，版权归 juejin.cn 所有</p>]]></content>
      
      
      <categories>
          
          <category> 应用 </category>
          
          <category> 配置 </category>
          
          <category> 软件配置 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>归档1</title>
      <link href="/posts/%E5%BD%92%E6%A1%A3/%E5%BD%92%E6%A1%A31.html"/>
      <url>/posts/%E5%BD%92%E6%A1%A3/%E5%BD%92%E6%A1%A31.html</url>
      
        <content type="html"><![CDATA[<h1 id="油猴脚本访问本地文件"><a href="#油猴脚本访问本地文件" class="headerlink" title="油猴脚本访问本地文件"></a>油猴脚本访问本地文件</h1><h2 id="Chrome-浏览器如何开启文件访问权限"><a href="#Chrome-浏览器如何开启文件访问权限" class="headerlink" title="Chrome 浏览器如何开启文件访问权限"></a>Chrome 浏览器如何开启文件访问权限</h2><p>点击右侧三个点 -》更多工具 -》拓展程序 -》详情</p><p><img src="/../../../img/blog/4273299c4c579271d48f0ac66f0c88a7_MD5.png" alt="图片.png" title="图片.png"></p><p>打开允许访问文件网址</p><p><img src="/../../../img/blog/0f54277cfaba5532eec2d80e0ac5e5ac_MD5.png" alt="图片.png" title="图片.png"></p><h2 id="火狐浏览器如何开启文件访问权限"><a href="#火狐浏览器如何开启文件访问权限" class="headerlink" title="火狐浏览器如何开启文件访问权限"></a>火狐浏览器如何开启文件访问权限</h2><p>FireFox 默认没有提供一个页面可以设置这个选项，但可以通过修改浏览器的配置项，来达到目地。</p><p>具体方法如下：</p><p>I: 在地址栏输入 <code>about:config</code> 并回车, 进入配置项页面 (可能会有一个警告页面，直接点击按钮进入就好了）。</p><p>II: 配置以下三项</p><table><thead><tr><th>条目名称</th><th>值</th><th>提醒</th></tr></thead><tbody><tr><td>capability.policy.policynames</td><td>localfilelinks</td><td>-</td></tr><tr><td>capability.policy.localfilelinks.sites</td><td>moz-extension:&#x2F;&#x2F;612ab18c-c29e-4211-bd50-3f208d227db7</td><td>这个值，你应该使用自己拿到的 <code>扩展标识</code>, 如果你允许多个扩展的话，这里用空格隔开</td></tr><tr><td>capability.policy.localfilelinks.checkloaduri.enabled</td><td>allAccess</td><td>-</td></tr></tbody></table><p>这样操作:</p><p>复制条目名称，粘帖到搜索栏进行搜索, 如果搜索到，就双击修改它的值就行了。</p><p>如果没有搜索到，就鼠标右键 &gt; 新建 &gt; 字符串 (String)，把 <code>条目名称</code> 和 <code>值</code> 依次粘帖进去即可。</p><h2 id="打开-Tampermonkey-文件访问地址"><a href="#打开-Tampermonkey-文件访问地址" class="headerlink" title="打开 Tampermonkey 文件访问地址"></a>打开 Tampermonkey 文件访问地址</h2><p>打开设置 -》高级</p><p><img src="/../../../img/blog/d79d945c4e0e893c85f498c0bccb994a_MD5.png" alt="图片.png" title="图片.png"></p><p>进入安全项 -》允许脚本访问本地文件，选择所有本地文件，修改后保存</p><p><img src="/../../../img/blog/fbc81377c82c6f738e61cf3c66931d67_MD5.png" alt="图片.png" title="图片.png"></p><h2 id="修改脚本"><a href="#修改脚本" class="headerlink" title="修改脚本"></a>修改脚本</h2><p>在脚本中添加以下内容并保存</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// @match          file:///*</span><br></pre></td></tr></table></figure><h1 id="CSDN-下载文章"><a href="#CSDN-下载文章" class="headerlink" title="CSDN 下载文章"></a>CSDN 下载文章</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">(function doPrint()&#123;      </span><br><span class="line">&#x27;use strict&#x27;;</span><br><span class="line">var articleBox = $(&quot;div.article_content&quot;);</span><br><span class="line">articleBox.removeAttr(&quot;style&quot;);</span><br><span class="line">var head_str = &quot;&quot;;       </span><br><span class="line">var foot_str = &quot;&quot;;   </span><br><span class="line">var older = document.body.innerHTML;       </span><br><span class="line">var title= document.getElementsByClassName(&#x27;article-title-box&#x27;)[0].innerHTML; </span><br><span class="line">var main_body = document.getElementsByClassName(&#x27;article_content&#x27;)[0].innerHTML;</span><br><span class="line">document.body.innerHTML = head_str + title + main_body + foot_str;</span><br><span class="line">$(&quot;#mainBox&quot;).width(&quot;100%&quot;);</span><br><span class="line">document.getElementsByTagName(&#x27;body&#x27;)[0].style.zoom=0.8;     </span><br><span class="line">window.print();</span><br><span class="line">document.body.innerHTML = older;</span><br><span class="line">return false;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/p1279030826/article/details/106602341">【新】CSDN文章一键打印、输出PDF（自动阅读全文、全清爽模式）csdn打印_JavonPeng的博客-CSDN博客</a></p><h1 id="kms-激活-office-visio2019"><a href="#kms-激活-office-visio2019" class="headerlink" title="kms 激活 office+visio2019"></a>kms 激活 office+visio2019</h1><p><a href="https://www.cnblogs.com/shan333/p/14894774.html">kms 激活 office+visio2019</a></p><h2 id="一、kms-激活-office-2019"><a href="#一、kms-激活-office-2019" class="headerlink" title="一、kms 激活 office 2019"></a><strong>一、kms 激活 office 2019</strong></h2><p>1、<strong>卸载干净 office 有关产品</strong>：先把自己电脑上所有关于 office 的产品卸载干净，然后才开始使用 office tool 安装和激活 office 2019；</p><p>2、<strong>下载 office Tool plus 工具</strong>：下载那个比较全的那个包吧，最大那个 [即<strong>第一个安装包</strong>]；官网： <a href="https://otp.landian.vip/zh-cn/download.html">https://otp.landian.vip/zh-cn/download.html</a></p><p>3、<strong>解压 office tool plus 工具包，移除残留的旧 office</strong>：先解压 office Tool plus 工具包，利用 office Tool plus 工具 [Office Tool Plus. exe]，先把自己电脑的老版本 office 卸载了:  双击 Office Tool Plus. exe，选择  <strong>工具箱 -》修复工具 -》移除 office-》使用 office Tool plus 移除 office-》开始</strong></p><p>4、<strong>部署</strong>：点击  <strong>部署</strong></p><p><img src="/../../../img/blog/39f707e55ae7cc259c78dc8feedff9cf_MD5.png"></p><p><strong>按上图，选好、设置好后，点击当前页面右上角的开始部署</strong></p><p>5、<strong>激活</strong>：点击  <strong>激活</strong></p><p><img src="/../../../img/blog/34e7f96c985852aa6812ba0c920ba89a_MD5.png"></p><p><strong>按上图，</strong>  选好、填好，点击当前页面右上角的激活</p><p><strong>✿  密钥管理填写   NMMKJ-6 RK 4 F-KMJVX-8 D 9 MJ-6 MWKP，KMS 服务器，填写 kms. 03 k. org</strong></p><p>■ 备用的秘钥： N 9 J 9 Q-Q 7 MMP-XDDM 6-63 KKP-76 FPM</p><p>■ 备用的 KMS 主机： <a href="https://catqu.com/?p=111">kms.catqu.com</a></p><p><strong>▷  注意细节：复制粘贴的时候，不要多复制了空格哈~</strong></p><hr><h2 id="二、kms-激活-visio-2019"><a href="#二、kms-激活-visio-2019" class="headerlink" title="二、kms 激活 visio 2019"></a><strong>二、kms 激活 visio 2019</strong></h2><p>1、安装 visio 2019，同样部署、激活：<br>部署时选择 + 添加产品：选择 visio 专业版 2019 批量版</p><p>然后那些系数，就用安装 office 时的系数，点击开始部署，部署完就激活：</p><p><img src="/../../../img/blog/003beba19ea0eeea637c70aa9f54f72b_MD5.png"></p><p><strong>密钥管理填写   9 BGNQ-K 37 YR-RQHF 2-38 RQ 3-7 VCBB，KMS 服务器，填写 kms. 03 k. org</strong></p><hr><h2 id="三、注意事项："><a href="#三、注意事项：" class="headerlink" title="三、注意事项："></a><strong>三、注意事项：</strong></h2><p><strong>仅批量版 (Volume) 支持 KMS 激活</strong>，<strong>零售版 (Retail) 不支持使用 KMS 激活。</strong>    <strong>KMS 有效期为 180 天，正常情况下系统会自动续期，所以不用担心过期，除非服务器挂了。</strong></p><p>除了使用这些公网 KMS 外，还可自行搭建 KMS 使用，具体请自行查找相关资料。</p><p>部分 KMS 可能会因为地区问题在某些地方不可用，建议使用前自行检测可用性。</p><p><strong>使用 KMS 激活并不会显著影响 Office 的功能，</strong>无法登录账号是因为 Windows 系统太旧、Internet Explorer 问题或者网络问题，与使用 KMS 无关。</p><hr><h2 id="四、KMS-地址列表"><a href="#四、KMS-地址列表" class="headerlink" title="四、KMS 地址列表"></a><strong>四、KMS 地址列表</strong></h2><p><strong>■ 好用、常用几个如下：</strong></p><p><strong>****</strong><a href="https://03k.org/kms.html">kms.03k.org</a><strong>****</strong></p><p><strong><strong>**</strong></strong><a href="https://catqu.com/?p=111">kms.catqu.com</a><strong><strong>**</strong></strong></p><p><strong><a href="https://www.ghpym.com/kms.html">kms.ghpym.com</a></strong></p><p>参考文章： <a href="https://juejin.cn/post/6844903746485354504">https://juejin.cn/post/6844903746485354504</a> 《安装和激活 Office 2019》</p><p><a href="https://www.coolhub.top/tech-articles/kms_list.html">https://www.coolhub.top/tech-articles/kms_list.html</a> 《KMS 地址列表》</p><h1 id="visio-使用"><a href="#visio-使用" class="headerlink" title="visio 使用"></a>visio 使用</h1><p><a href="https://zhuanlan.zhihu.com/p/341329517">visio教程：如何调整连接线上文字的位置</a><br><a href="https://blog.csdn.net/zz603976046/article/details/109079481">visio如何使箭头指向插图的任意一处</a></p><h1 id="坚果云清除"><a href="#坚果云清除" class="headerlink" title="坚果云清除"></a>坚果云清除</h1><h2 id="文件资源管理器图标删除"><a href="#文件资源管理器图标删除" class="headerlink" title="文件资源管理器图标删除"></a>文件资源管理器图标删除</h2><p>使用电脑应用管理删除坚果云</p><h2 id="Windows-清理桌面右键菜单中新增选项中的多余选项"><a href="#Windows-清理桌面右键菜单中新增选项中的多余选项" class="headerlink" title="Windows 清理桌面右键菜单中新增选项中的多余选项"></a>Windows 清理桌面右键菜单中新增选项中的多余选项</h2><p>在卸载坚果云时一开始没注意，最近在使用的时候发现右键新增的里面出现了 <code>.nol</code> 等坚果云的文件，于是找了一下能删除多余选项的方法。<br>感觉自己以后还能用到所以记下来方便自己查阅。</p><ol><li><p>找到需要删去选项对应的扩展名</p></li><li><p>打开注册表编辑器</p></li><li><p><code>HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Explorer\Discardable\PostSetup\ShellNew\Classes</code></p></li></ol><p><img src="/../../../img/blog/%E5%9D%9A%E6%9E%9C%E4%BA%91%E6%B8%85%E9%99%A4-1.png"><br>4. 删去其中你不要的扩展名</p><p>[<img src="/../../../img/blog/65510735567700606.png">ng)</p><ol><li>按照以上步骤操作完成后，发现已经消失的残留项再次出现，说明软件卸载后，注册表未清理干净。请按照以下路径寻找【<code>HKEY_CLASSES_ROOT\.gf\ShellNew</code>】，右键单击【NullFile】，左键单击【删除（D）】。</li></ol><p>[<img src="/../../../img/blog/06701246621604386.png">ng)</p><blockquote><p>我自己并没有出现 <code>NullFile</code> 选项，我选择将整个 ShellNew 都给删去了</p></blockquote><p>此时回到桌面查看右键新建菜单应该已经清理完毕</p><h1 id="病毒免杀工具"><a href="#病毒免杀工具" class="headerlink" title="病毒免杀工具"></a>病毒免杀工具</h1><h2 id="Backdoor-factory"><a href="#Backdoor-factory" class="headerlink" title="Backdoor-factory"></a>Backdoor-factory</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p><a href="https://github.com/secretsquirrel/the-backdoor-factory">secretsquirrel&#x2F;the-backdoor-factory: Patch PE, ELF, Mach-O binaries with shellcode new version in development, available only to sponsors (github.com)</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker pull secretsquirrel/the-backdoor-factory</span><br><span class="line">sudo docker run -it -v /home/icefjl:/home/tmp:Z secretsquirrel/the-backdoor-factory bash</span><br></pre></td></tr></table></figure><h3 id="⾸先检查宿主能否被⽀持-“-插⼊-“shellcode。"><a href="#⾸先检查宿主能否被⽀持-“-插⼊-“shellcode。" class="headerlink" title="⾸先检查宿主能否被⽀持 “ 插⼊ “shellcode。"></a>⾸先检查宿主能否被⽀持 “ 插⼊ “shellcode。</h3><p>主要使⽤下⾯两个参数 -f：指定测试程序 -S：检查该程序是否支持<br>检查命令: .&#x2F;backdoor. py -f &#x2F;root&#x2F;putty. exe -S</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -no-pie hello.c -o hello</span><br></pre></td></tr></table></figure><h3 id="搜索该⽂件可⽤的-Code-Caves-代码缝隙"><a href="#搜索该⽂件可⽤的-Code-Caves-代码缝隙" class="headerlink" title="搜索该⽂件可⽤的 Code Caves (代码缝隙)"></a>搜索该⽂件可⽤的 Code Caves (代码缝隙)</h3><p>使⽤命令 .&#x2F;backdoor. py -f test. exe -c -l 600<br>-c：code cave (代码裂缝) -l：代码裂缝大小</p><h3 id="获取该⽂件的可⽤-Payload"><a href="#获取该⽂件的可⽤-Payload" class="headerlink" title="获取该⽂件的可⽤ Payload"></a>获取该⽂件的可⽤ Payload</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./backdoor.py -f /root/putty.exe -s -show</span><br></pre></td></tr></table></figure><h2 id="Metaspoit"><a href="#Metaspoit" class="headerlink" title="Metaspoit"></a>Metaspoit</h2><h3 id="使⽤-Backdoor-的-user-supplied-shellcode-模块加载⾃定义的-Shellcode"><a href="#使⽤-Backdoor-的-user-supplied-shellcode-模块加载⾃定义的-Shellcode" class="headerlink" title="使⽤ Backdoor 的 user_supplied_shellcode 模块加载⾃定义的 Shellcode"></a>使⽤ Backdoor 的 user_supplied_shellcode 模块加载⾃定义的 Shellcode</h3><p>先⽤ msfvenom ⽣成 raw 格式的 shellcode<br>再使用 backdoor 的 user_supplied_shellcode 模块加载⾃定义的 shellcode</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./backdoor.py -f /home/tmp/ -s user_supplied_shellcode -U /home/tmp/tp1.shell -o payload2</span><br></pre></td></tr></table></figure><h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><p>运行下面的命令来初始化其数据库。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo mfsdb init</span><br></pre></td></tr></table></figure><p>通过运行下面的命令来启动 Metasploit。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ msfconsole</span><br></pre></td></tr></table></figure><h3 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h3><p>MSF 框架由多个模块组成，几个主要模块及其具体功能如下。</p><ol><li><p>Auxiliaries（辅助模块）</p><p> 该模块不会直接在测试者和目标主机之间建立访问，它们只会负责执行扫描、嗅探、识别等相关功能以辅助渗透测试。</p></li><li><p>Exploit（漏洞利用模块）</p><p> 漏洞利用模块用于以允许框架执行任意代码的方式利用漏洞。执行的任意代码称为有效载荷。</p></li><li><p>Payload（攻击载荷模块）</p><p> 在 Metasploit 漏洞利用模块的上下文中，有效负载模块封装了作为漏洞利用成功结果而执行的任意代码（shellcode）。这通常涉及创建 Metasploit 会话，但可能会执行代码，例如添加用户帐户，或执行一个简单的 pingback 命令来验证代码是否成功针对易受攻击的目标执行。</p></li><li><p>Post（后期渗透模块）</p><p> 该模块主要用于在取得目标系统远程控制权后，进行一系列的后渗透攻击动作，如获取敏感信息、实施跳板攻击等。</p></li><li><p>Encoders（编码工具模块）</p><p> 编码器接收有效载荷的原始字节并运行某种编码算法，例如按位异或。这些模块对于编码诸如空字节之类的不良字符非常有用。</p></li></ol><p>使用 MSF 渗透测试时，可以综合使用以上模块，对目标系统进行侦察并发动攻击，大致的步骤如下所示。</p><ul><li>扫描目标机系统，寻找可用漏洞。</li><li>选择并配置一个漏洞利用模块。</li><li>选择并配置一个攻击载荷模块。</li><li>选择一个编码技术，用来绕过杀毒软件的查杀。</li><li>渗透攻击。</li></ul><h3 id="Msfvenom"><a href="#Msfvenom" class="headerlink" title="Msfvenom"></a>Msfvenom</h3><p><a href="https://blog.csdn.net/RFZ_322/article/details/123367668">(13 条消息) Kali 利用 msf 渗透 Windows 电脑（超详细）_kali msf_HonkerG 的博客-CSDN 博客</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat test1.elf | msfvenom -p - -a x64 --platform linux -e x86/shikata_ga_nai -f elf -o test1e.elf</span><br></pre></td></tr></table></figure><h2 id="免杀项目"><a href="#免杀项目" class="headerlink" title="免杀项目"></a>免杀项目</h2><h3 id="专利"><a href="#专利" class="headerlink" title="专利"></a>专利</h3><ul><li><a href="https://github.com/scmanjarrez/pymetangine">scmanjarrez&#x2F;pymetangine: A python metamorphic engine for PE&#x2F;PE+ files. (github.com)</a></li><li><a href="https://github.com/OmegaPointZero/Caveman">https://github.com/OmegaPointZero/Caveman</a></li><li><a href="https://github.com/guitmz/ezuri">https://github.com/guitmz/ezuri</a></li><li><a href="https://github.com/sebastiencs/Packer_ELF">sebastiencs&#x2F;Packer_ELF: ELF packer - x86_64 (github.com)</a></li></ul><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul><li><a href="https://github.com/jakuta-tech/GhostShell">https://github.com/jakuta-tech/GhostShell</a></li><li><a href="https://github.com/elfmaster/maya">https://github.com/elfmaster/maya</a></li><li><a href="https://github.com/wdblair/packitup">https://github.com/wdblair/packitup</a></li><li><a href="https://github.com/invokr/elf-stuff">https://github.com/invokr/elf-stuff</a></li><li><a href="https://github.com/terminaldweller/mutator">https://github.com/terminaldweller/mutator</a></li><li><a href="https://github.com/compilepeace/KAAL_BHAIRAV">https://github.com/compilepeace/KAAL_BHAIRAV</a></li><li><a href="https://github.com/AidenPearce369/elfxtract">https://github.com/AidenPearce369/elfxtract</a></li></ul><h1 id="vscode-和-vs2019-代码行数统计"><a href="#vscode-和-vs2019-代码行数统计" class="headerlink" title="vscode 和 vs2019 代码行数统计"></a>vscode 和 vs2019 代码行数统计</h1><h2 id="1、vscode-代码行数统计"><a href="#1、vscode-代码行数统计" class="headerlink" title="1、vscode 代码行数统计"></a>1、vscode 代码行数统计</h2><p>按 Ctrl+Shift+X 在插件市场搜索 VS Code Counter 点击安装<br>按住按 Ctrl+Shift+P 在命令输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Count lines in workspace</span><br></pre></td></tr></table></figure><p><img src="/../../../img/blog/d42fe65ec918b634c00fa3a605acfc78_MD5.png"><br><img src="/../../../img/blog/bcf1882238e3552922259a84188023ef_MD5.png"></p><h2 id="2、Visual-Studio-代码行数统计"><a href="#2、Visual-Studio-代码行数统计" class="headerlink" title="2、Visual Studio 代码行数统计"></a>2、Visual Studio 代码行数统计</h2><p>选中解决方案<br>按 [Ctrl+Shift+F] 弹出查找窗口（不统计以#号开头、以&#x2F;开头的代码和空行）<br>1、输入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b*[^:b#/]+.*$</span><br></pre></td></tr></table></figure><p>2、选择使用正则表达式<br><img src="/../../../img/blog/eed9780aadfde534a667b8c9153de5a8_MD5.png"></p><h1 id="1-1-1-1（App）"><a href="#1-1-1-1（App）" class="headerlink" title="1.1.1.1（App）"></a>1.1.1.1（App）</h1><ul><li><a href="https://limbopro.com/archives/956.html">1.1.1.1（App）- Cloudflare DNS &amp; 免费 WARP+ VPN 以及一键刷 Cloudflare warp+ 无限（24PB+）邀请流量 - 毒奶 - 欢迎使用代理访问本站。 (limbopro.com)</a></li><li><a href="https://zhuanlan.zhihu.com/p/636708211">Cloudflare 加入及创建零信任zero trust团队 - 知乎 (zhihu.com)</a></li><li><a href="https://www.chaipip.com/">高精度IP地址查询|查IP|IP地址查询|IP定位|精确定位|百度高精度IP-www.chaipip.com</a></li><li><a href="https://dmesg.app/cf-zero-trust.html">使用 Cloudflare Zero Trust 创建大内网 | 土豆不好吃 (dmesg.app)</a></li><li><a href="https://neko-warp.nloli.xyz/">NEKOWARP (nloli.xyz)</a></li><li><a href="https://www.noiseblog.top/posts/166c7215/">基于Cloudflare Warp+Clash无限流量上网工具 | Noise&amp;Blog (noiseblog.top)</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 归档 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>编译</title>
      <link href="/posts/%E5%AD%A6%E4%B9%A0/%E7%BC%96%E8%AF%91%E6%B1%87%E7%BC%96/%E7%BC%96%E8%AF%91.html"/>
      <url>/posts/%E5%AD%A6%E4%B9%A0/%E7%BC%96%E8%AF%91%E6%B1%87%E7%BC%96/%E7%BC%96%E8%AF%91.html</url>
      
        <content type="html"><![CDATA[<h1 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h1><p><a href="https://www.sigbus.info/compilerbook">低レイヤを知りたい人のためのCコンパイラ作成入門 (sigbus.info)</a></p><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a><a href="#%E3%81%AF%E3%81%98%E3%82%81%E3%81%AB">介绍</a></h1><p>这本书的内容太多了，无法包含在一本书中。在本书中，我们将创建一个将 C 语言编写的源代码转换为汇编语言的程序，即 C 编译器。编译器本身也是使用 C 开发的。直接目标是能够自托管，即使用自制编译器编译自己的源代码。</p><p>在本书中，我决定在整本书中以渐进的方式解释各个主题，以免使编译器的解释变得过于困难。原因如下：</p><p>编译器在概念上可以分为多个阶段：解析、中间传递和代码生成。常见的教科书方法是在章节中解释每个主题，但采用这种方法的书籍往往会变得过于狭窄和深入，使读者难以理解。</p><p>另外，采用创建每个阶段的开发方法，直到所有阶段都完成后才能运行编译器，因此在整个阶段开始工作之前很难注意到您的理解或代码是否存在明确的错误。缺点是你不能。首先，在您自己创建之前，您并不真正知道下一阶段的输入预计是什么，因此您并不真正知道上一阶段要输出什么。另一个问题是很难保持积极性，因为在代码完成之前你根本无法编译任何代码。</p><p>在本书中，我决定采取不同的方法来避免这个陷阱。在本书的前面，您将使用非常简单的语言规范来实现 “ 专有语言 “。该语言非常简单，您无需了解如何编写编译器即可实现它。之后，读者将通过本书不断为 “ 专有语言 “ 添加功能，最终将其发展成与 C 语言一致的东西。</p><p>在这种增量开发方法中，您逐步创建编译器，进行少量提交。通过这种开发方法，编译器在每次提交时总是在某种意义上 “ 完整 “。在一个阶段，它可能只能做一个计算器级别的事情，在另一个阶段，它可能是 C 的一个非常有限的子集，在另一个阶段，它可能是一种几乎可以称为 C 的语言。关键是，在每个阶段，我们的目标都是建立一种具有合理规范的语言，以匹配当时的完成水平。在开发过程中，我们不会只强调某些功能，使其看起来像 C 语言。</p><p>我们还会根据发展阶段分阶段讲解数据结构、算法、计算机科学知识。</p><p>增量开发实现的目标是，在阅读本书的任何时间点，读者都对如何在该级别创建合理的语言有统一的了解。这比只对编译器创建的某些主题进行极其详细的状态要好得多。当您读完本书时，您将精通所有主题。</p><p>本书还解释了如何从头开始编写大型程序。创建大型程序的技能是一种不同于学习数据结构和算法的独特技能，但我认为解释此类事情的书籍并不多。而且，即使有人向你解释，除非你亲自体验，否则你也不会真正知道一种开发方法是好是坏。本书旨在使您在将自己的语言开发为 C 语言的过程中，能够给您带来良好开发方法的实践经验。</p><p>如果作者的计划成功的话，通过阅读本书，读者不仅会学到创建编译器和 CPU 指令集的技术，还会学到如何将大程序分解成小步骤，一点一点地创建。学习测试技术、版本控制技术，甚至如何为一个雄心勃勃的项目（如编写编译器）做准备。</p><p>本书的目标读者是普通的 C 程序员。您不需要是一个非常了解 C 语言规范的超级 C 程序员。了解指针和数组就足够了，并且至少可以花一些时间阅读别人编写的小型 C 程序。</p><p>在写这本书时，我不仅试图解释语言规范和 CPU 规范，而且还尽可能多地解释为什么选择这样的设计。我们还穿插了有关编译器、CPU、计算机行业及其历史的专栏，这些专栏会引起读者的兴趣，使其读起来令人愉快。</p><h2 id="本书假设的开发环境"><a href="#本书假设的开发环境" class="headerlink" title="本书假设的开发环境"></a><a href="#%E6%9C%AC%E6%9B%B8%E3%81%AE%E6%83%B3%E5%AE%9A%E3%81%99%E3%82%8B%E9%96%8B%E7%99%BA%E7%92%B0%E5%A2%83">本书假设的开发环境</a></h2><p>本书假设 64 位 Linux 环境运行在所谓的普通 PC（例如 Intel 或 AMD）上。请根据您使用的发行版提前安装 gcc 等开发工具并 make。如果您使用的是 Ubuntu，则可以通过运行以下命令来安装本书中使用的命令。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt update</span><br><span class="line">$ sudo apt install -y gcc make git binutils libc6-dev</span><br></pre></td></tr></table></figure><p>尽管 macOS 在程序集源代码级别与 Linux 相当兼容，但它并不完全兼容（具体来说，不支持称为 “ 静态链接 “ 的功能）。尽管可以使用本书中的信息为 macOS 创建 C 编译器，但如果您尝试这样做，您可能会遇到一些小的不兼容问题。不建议同时学习创建 C 编译器的技术以及 macOS 和 Linux 之间的差异。当某件事不起作用时，很难知道哪种理解是错误的。</p><p>因此，本书不涉及 macOS。在 macOS 上，请使用某种虚拟环境来准备 Linux 环境。如果您是第一次准备 Linux 虚拟环境，请参阅附录，其中总结了如何使用 Docker 创建开发环境。</p><p>Windows 在汇编源代码级别与 Linux 不兼容。然而，在 Windows 10 中，可以像一个应​​用程序一样在 Windows 上运行 Linux，并且通过使用它，您可以在 Windows 上继续开发。名为 Windows Subsystem for Linux (WSL) 的应用程序就是 Linux 兼容环境。在 Windows 上实现本书内容时，请安装 WSL 并在其中进行开发。</p><p>コラム:  专栏：在线编译器</p><p>查看 C 代码及其编译结果是学习汇编语言的好方法，但是一遍又一遍地编辑和编译源代码，然后检查汇编输出可能会令人惊讶地乏味。有一个非常好的网站可以为您省去麻烦。那就是 Compiler Explorer（俗称 godbolt）。当您在 Compiler Explorer 屏幕左半边的文本框中输入代码时，相应的汇编输出会实时显示在屏幕的右半边。当您想要检查 C 代码被转换成何种类型的汇编时，该网站是一个不错的选择。</p><hr><h1 id="创建计算器级语言"><a href="#创建计算器级语言" class="headerlink" title="创建计算器级语言"></a><a href="#%E9%9B%BB%E5%8D%93%E3%83%AC%E3%83%99%E3%83%AB%E3%81%AE%E8%A8%80%E8%AA%9E%E3%81%AE%E4%BD%9C%E6%88%90">创建计算器级语言</a></h1><p>在本章中，编写 C 编译器的第一步是支持算术运算和其他算术运算符，以便您可以编译如下表达式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">30 + (4 - 2) * -5</span><br></pre></td></tr></table></figure><p>这看似一个简单的目标，但实际上相当困难。数学公式的结构是括号内的表达式优先，或者乘法优先于加法，除非您以某种方式理解这一点，否则您将无法正确执行计算。但是，作为输入给出的公式只是一个平面字符串，而不是结构化数据。为了正确评估表达式，有必要分析字符序列并成功导出隐藏结构。</p><p>本章介绍最常见的解析算法之一，递归下降解析。您日常使用的 C&#x2F;C++ 编译器，例如 GCC 和 Clang，也使用递归下降解析。</p><p>编程时经常需要读取具有某种结构的文本，而不仅仅是编译器。您在本章中学到的技术可以直接用于解决此类问题。可以毫不夸张地说，您将在本章中学到的语法分析技术是受用一生的技术。阅读本章以了解算法并将解析技能添加到程序员的工具箱中。</p><h2 id="第-1-步：创建一种编译整数的语言"><a href="#第-1-步：创建一种编译整数的语言" class="headerlink" title="第 1 步：创建一种编译整数的语言"></a><a href="#%E3%82%B9%E3%83%86%E3%83%83%E3%83%971%E6%95%B4%E6%95%B01%E5%80%8B%E3%82%92%E3%82%B3%E3%83%B3%E3%83%91%E3%82%A4%E3%83%AB%E3%81%99%E3%82%8B%E8%A8%80%E8%AA%9E%E3%81%AE%E4%BD%9C%E6%88%90">第 1 步：创建一种编译整数的语言</a></h2><p>考虑 C 语言最简单的子集。你想象中的语言是什么样的？ <code>main</code> 它是一种只有函数的语言吗？或者也许是一种仅由一种表达方式组成的语言？最终，我认为可以公平地说，仅由一个整数组成的语言是可以想象的最简单的子集。</p><p>在这一步中，我们首先实现最简单的语言。</p><p>您在此步骤中创建的程序是一个编译器，它从输入中读取数字并输出一个程序集，该程序集以该数字作为程序的退出代码退出。因此，输入只是一个像 <code>42</code> 这样的字符串，当它读取它时，它会创建一个编译器，输出如下所示的程序集：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.intel_syntax noprefix</span><br><span class="line">.globl main</span><br><span class="line"></span><br><span class="line">main:</span><br><span class="line">        mov rax, 42</span><br><span class="line">        ret</span><br></pre></td></tr></table></figure><p><code>.intel_syntax noprefix</code> 是一个汇编命令，它在多种汇编编写方法中选择本书中使用的 Intel 表示法。请务必在您这次创建的编译器的开头包含此行。其他行如前一章所述。</p><p>此时，读者可能会想，” 这个程序不能称为编译器。” 老实说我也这么认为。然而，该程序接受由单个数字组成的语言作为输入并输出与该数字相对应的代码，因此根据定义，它是一个很好的编译器。即使像这样简单的程序如果修改它也会很快变得非常复杂，所以让我们先完成这一步。</p><p>从整个开发流程来看，这一步其实非常重要。这是因为我们将使用这一步中创建的内容作为未来开发的骨架。在这一步中，除了创建编译器本身之外，我们还创建构建文件（Makefile）、自动化测试并设置 git 存储库。让我们逐一查看这些任务。</p><p>コラム:  专栏：Intel 表示法和 AT&amp;T 表示法</p><p>除了本书中使用的 Intel 表示法之外，一种称为 AT&amp;T 表示法的汇编表示法也被广泛使用，主要在 Unix 中。默认情况下，gcc 和 objdump 使用 AT&amp;T 表示法输出程序集。</p><p>在 AT&amp;T 表示法中，结果寄存器是第二个参数。因此，在双参数命令中，参数以相反的顺序写入。使用 <code>%</code> 前缀写入寄存器名称，例如 <code>%rax</code> 。使用 <code>$</code> 前缀写入数字，例如 <code>$42</code> 。</p><p>另外，在引用内存时，请使用 <code>()</code> 而不是 <code>[]</code> 以独特的表示法编写表达式。下面举一些例子来进行比较。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mov rbp, rsp   // Intel</span><br><span class="line">mov %rsp, %rbp // AT&amp;T</span><br><span class="line">mov rax, 8     // Intel</span><br><span class="line">mov $8, %rax   // AT&amp;T</span><br><span class="line">mov [rbp + rcx * 4 - 8], rax // Intel</span><br><span class="line">mov %rax, -8(rbp, rcx, 4)    // AT&amp;T</span><br></pre></td></tr></table></figure><p>在我这次创建的编译器中，为了可读性，我决定使用 Intel 表示法。 Intel 的指令集手册使用 Intel 表示法，其优点是可以将手册的描述直接写成代码。 AT&amp;T 表示法和 Intel 表示法的表达能力是相同的。无论使用哪种表示法，生成的机器语言指令序列都是相同的。</p><h3 id="创建编译器主体"><a href="#创建编译器主体" class="headerlink" title="创建编译器主体"></a><a href="#%E3%82%B3%E3%83%B3%E3%83%91%E3%82%A4%E3%83%A9%E6%9C%AC%E4%BD%93%E3%81%AE%E4%BD%9C%E6%88%90">创建编译器主体</a></h3><p>通常我们将输入作为文件提供给编译器，但由于我们不想打开和读取该文件，因此我们将直接将代码作为命令的第一个参数提供。将第一个参数作为数字读取并将其嵌入到固定短语的汇编中的 C 程序可以轻松编写如下。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;参数数量不正确\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;.intel_syntax noprefix\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;.globl main\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;main:\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;  mov rax, %d\n&quot;</span>, atoi(argv[<span class="number">1</span>]));</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;  ret\n&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建一个名为 <code>9cc</code> 的空目录，并在其中创建一个名为 <code>9cc.c</code> 的文件，其中包含上述内容。然后，如下所示运行 9cc 并检查操作。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cc -o 9cc 9cc.c</span><br><span class="line">$ ./9cc 123 &gt; tmp.s</span><br></pre></td></tr></table></figure><p>第一行编译 <code>9cc.c</code> 并创建一个名为 <code>9cc</code> 的可执行文件。第二行将输入 <code>123</code> 传递给 9cc 以生成程序集并将其写入文件 <code>tmp.s</code> 。我们来检查一下 <code>tmp.s</code> 的内容。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ cat tmp.s</span><br><span class="line">.intel_syntax noprefix</span><br><span class="line">.globl main</span><br><span class="line">main:</span><br><span class="line">  mov rax, 123</span><br><span class="line">  ret</span><br></pre></td></tr></table></figure><p>如您所见，它生成得很好。您可以通过将以此方式创建的汇编文件传递给汇编器来创建可执行文件。</p><p>在 Unix 中， <code>cc</code> （或 <code>gcc</code> ）是许多语言的前端，而不仅仅是 C 和 C++，根据确定启动编译器或汇编器。因此，就像编译 9cc 时一样，可以通过将扩展名为 <code>.s</code> 的汇编器文件传递给 <code>cc</code> 来进行汇编。下面是编译并运行生成的可执行文件的示例。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ cc -o tmp tmp.s</span><br><span class="line">$ ./tmp</span><br><span class="line">$ echo $?</span><br><span class="line">123</span><br></pre></td></tr></table></figure><p>在 shell 中，可以在名为 <code>$?</code> 的变量中访问上一个命令的退出代码。在上面的示例中，显示数字 123，这与 9cc 的参数相同。这意味着它工作正常。尝试给出 0 到 255 范围内 123 以外的数字（Unix 进程退出代码应该是 0 到 255），看看 9cc 是否真的有效。</p><h3 id="创建自动化测试"><a href="#创建自动化测试" class="headerlink" title="创建自动化测试"></a><a href="#%E8%87%AA%E5%8B%95%E3%83%86%E3%82%B9%E3%83%88%E3%81%AE%E4%BD%9C%E6%88%90">创建自动化测试</a></h3><p>许多读者可能从未为爱好编程编写过测试，但在本书中，我们将在每次扩展编译器时编写代码来测试新代码。编写测试一开始可能看起来很乏味，但您很快就会开始欣赏它们。如果不写测试代码，最后每次都得手工运行相同的测试来检查操作，但是手工做就麻烦多了。</p><p>我认为编写测试很乏味的印象很大程度上来自于测试框架被夸大以及测试哲学有时很教条这一事实。例如，像 JUnit 这样的测试框架有多种有用的功能，但安装和学习如何使用它们需要时间。因此，本章不介绍此类测试框架。相反，我将在 shell 脚本中编写一个非常简单的手写 “ 测试框架 “，并用它来编写我的测试。</p><p>下面是用于测试的 shell 脚本 <code>test.sh</code> 。 shell 函数 <code>assert</code> 接收两个参数，输入的值和期望输出的值，并实际组装 9cc 结果并将实际结果与期望值进行比较，我们说的就做。在 shell 脚本中，定义 <code>assert</code> 函数后，我们用它来确保 0 和 42 都能正确编译。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="function"><span class="title">assert</span></span>() &#123;</span><br><span class="line">  expected=<span class="string">&quot;<span class="variable">$1</span>&quot;</span></span><br><span class="line">  input=<span class="string">&quot;<span class="variable">$2</span>&quot;</span></span><br><span class="line"></span><br><span class="line">  ./9cc <span class="string">&quot;<span class="variable">$input</span>&quot;</span> &gt; tmp.s</span><br><span class="line">  cc -o tmp tmp.s</span><br><span class="line">  ./tmp</span><br><span class="line">  actual=<span class="string">&quot;$?&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$actual</span>&quot;</span> = <span class="string">&quot;<span class="variable">$expected</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$input</span> =&gt; <span class="variable">$actual</span>&quot;</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$input</span> =&gt; <span class="variable">$expected</span> expected, but got <span class="variable">$actual</span>&quot;</span></span><br><span class="line">    <span class="built_in">exit</span> 1</span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">assert 0 0</span><br><span class="line">assert 42 42</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> OK</span><br></pre></td></tr></table></figure><p>使用上述内容创建 <code>test.sh</code> 并运行 <code>chmod a+x test.sh</code> 使其可执行。让我们实际运行 <code>test.sh</code> 。如果没有发生错误， <code>test.sh</code> 将显示 <code>OK</code> 并退出，如下所示。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ ./test.sh</span><br><span class="line">0 =&gt; 0</span><br><span class="line">42 =&gt; 42</span><br><span class="line">OK</span><br></pre></td></tr></table></figure><p>如果发生错误， <code>test.sh</code> 将不会显示 <code>OK</code> 。相反， <code>test.sh</code> 显示失败测试的预期值和实际值，如下所示。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ./test.sh</span><br><span class="line">0 =&gt; 0</span><br><span class="line">42 expected, but got 123</span><br></pre></td></tr></table></figure><p>如果要调试测试脚本，请在 bash 中使用 <code>-x</code> 选项运行该脚本。使用 <code>-x</code> 选项，bash 显示执行跟踪，如下所示。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">$ bash -x test.sh</span><br><span class="line">+ assert 0 0</span><br><span class="line">+ expected=0</span><br><span class="line">+ input=0</span><br><span class="line">+ cc -o 9cc 9cc.c</span><br><span class="line">+ ./9cc 0</span><br><span class="line">+ cc -o tmp tmp.s</span><br><span class="line">+ ./tmp</span><br><span class="line">+ actual=0</span><br><span class="line">+ &#x27;[&#x27; 0 &#x27;!=&#x27; 0 &#x27;]&#x27;</span><br><span class="line">+ assert 42 42</span><br><span class="line">+ expected=42</span><br><span class="line">+ input=42</span><br><span class="line">+ cc -o 9cc 9cc.c</span><br><span class="line">+ ./9cc 42</span><br><span class="line">+ cc -o tmp tmp.s</span><br><span class="line">+ ./tmp</span><br><span class="line">+ actual=42</span><br><span class="line">+ &#x27;[&#x27; 42 &#x27;!=&#x27; 42 &#x27;]&#x27;</span><br><span class="line">+ echo OK</span><br><span class="line">OK</span><br></pre></td></tr></table></figure><p>我们在本书中使用的 “ 测试框架 “ 只是一个像上面那样的 shell 脚本。与 JUnit 等成熟的测试框架相比，这个脚本可能看起来太简单了，但是这个 shell 脚本的简单性与 9cc 本身的简单性得到了平衡，所以这是更可取的。自动化测试基本上只是一次性运行您编写的代码并机械地比较结果，因此首先测试它而不是考虑太多非常重要。</p><h3 id="使用-make-构建"><a href="#使用-make-构建" class="headerlink" title="使用 make 构建"></a><a href="#make%E3%81%AB%E3%82%88%E3%82%8B%E3%83%93%E3%83%AB%E3%83%89">使用 make 构建</a></h3><p>在本书中，您将构建 9cc 数百次甚至数千次。创建 9cc 可执行文件然后运行测试脚本的工作每次都是一样的，所以交给工具就方便了。 <code>make</code> 命令通常用于此目的。</p><p>运行时，make 读取当前目录中名为 <code>Makefile</code> 的文件并执行其中写入的命令。 <code>Makefile</code> 由一个以冒号结尾的规则和该规则的一系列命令组成。以下 <code>Makefile</code> 用于自动执行您要在此步骤中运行的命令。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">CFLAGS=-std=c11 -g -static</span><br><span class="line"></span><br><span class="line">9cc: 9cc.c</span><br><span class="line"></span><br><span class="line">test: 9cc</span><br><span class="line">        ./test.sh</span><br><span class="line"></span><br><span class="line">clean:</span><br><span class="line">        rm -f 9cc *.o *~ tmp*</span><br><span class="line"></span><br><span class="line">.PHONY: test clean</span><br></pre></td></tr></table></figure><p>在 <code>9cc.c</code> 所在的同一目录中创建文件名为 <code>Makefile</code> 的上述文件。然后，您可以运行 <code>make</code> 来创建 9cc，并运行 <code>make test</code> 来运行测试。由于 make 可以理解文件依赖关系，因此无需在更改 <code>9cc.c</code> 之后和运行 <code>make test</code> 之前运行 <code>make</code> 。仅当可执行文件 9cc 早于 9cc.c 时，make 才会在运行测试之前构建 9cc。</p><p><code>make clean</code> 是删除临时文件的规则。临时文件可以手动 <code>rm</code> ，但是如果你不小心删除了不想删除的文件，那就很麻烦了，所以你也可以使用 <code>Makefile</code> 中这样的实用程序我正打算写呢。</p><p>注意，编写 <code>Makefile</code> 时， <code>Makefile</code> 的缩进必须是制表符。 4 或 8 个空格将导致错误。这只是糟糕的语法，但 make 是 20 世纪 70 年代开发的旧工具，传统上就是这样。</p><p>请务必将选项 <code>-static</code> 传递给 <code>cc</code> 。该选项在 “ 动态链接 “ 一章中进行了解释。您现在不需要考虑太多这个选项的含义。</p><h3 id="使用-git-进行版本控制"><a href="#使用-git-进行版本控制" class="headerlink" title="使用 git 进行版本控制"></a><a href="#git%E3%81%AB%E3%82%88%E3%82%8B%E3%83%90%E3%83%BC%E3%82%B8%E3%83%A7%E3%83%B3%E7%AE%A1%E7%90%86">使用 git 进行版本控制</a></h3><p>本书使用 git 作为版本控制系统。在本书中，我们将逐步创建一个编译器，并且对于每一步，请创建一个 git 提交并编写提交消息。提交消息可以是日语，因此请确保包含实际更改内容的一行摘要。如果要写多行详细说明，请在第一行后留一个空行，然后再写说明。</p><p>Git 仅对您手动生成的文件执行版本控制。运行 9cc 生成的文件可以通过执行相同的命令再次生成，因此不需要将它们纳入版本控制。事实上，包含此类文件会使每次提交的更改不必要地变长，因此应将它们从版本控制中删除，并且不包含在存储库中。</p><p>在 git 中，您可以在名为 <code>.gitignore</code> 的文件中编写要从版本控制中排除的文件的模式。在与 <code>9cc.c</code> 相同的目录中创建 <code>.gitignore</code> 并添加以下内容，并设置 git 忽略临时文件、编辑器备份文件等。让我们开始吧。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">*~</span><br><span class="line">*.o</span><br><span class="line">tmp*</span><br><span class="line">a.out</span><br><span class="line">9cc</span><br></pre></td></tr></table></figure><p>如果这是您第一次使用 Git，请告诉 Git 您的姓名和电子邮件地址。你在这里告诉 git 的姓名和电子邮件地址将被记录在提交日志中。下面是设置作者姓名和电子邮件地址的示例。读者，请输入您的姓名和电子邮件地址。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.name &quot;Rui Ueyama&quot;</span><br><span class="line">$ git config --global user.email &quot;ruiu@cs.stanford.edu&quot;</span><br></pre></td></tr></table></figure><p>要使用 git 创建提交，首先需要使用 <code>git add</code> 添加已更改的文件。由于这是您的第一次提交，因此首先使用 <code>git init</code> 创建一个 git 存储库，然后使用 <code>git add</code> 添加迄今为止创建的所有文件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git init</span><br><span class="line">Initialized empty Git repository in /home/ruiu/9cc</span><br><span class="line">$ git add 9cc.c test.sh Makefile .gitignore</span><br></pre></td></tr></table></figure><p> 然后使用 <code>git commit</code> 提交。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -m &quot;整数1つをコンパイルするコンパイラを作成&quot;</span><br></pre></td></tr></table></figure><p><code>-m</code> （可选）指定提交消息。如果没有 <code>-m</code> 选项，则 <code>git</code> 启动编辑器。您可以通过运行 <code>git log -p</code> 来确认提交是否成功，如下所示。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ git log -p</span><br><span class="line">commit 0942e68a98a048503eadfee46add3b8b9c7ae8b1 (HEAD -&gt; master)</span><br><span class="line">Author: Rui Ueyama &lt;ruiu@cs.stanford.edu&gt;</span><br><span class="line">Date:   Sat Aug 4 23:12:31 2018 +0000    整数1つをコンパイルするコンパイラを作成diff --git a/9cc.c b/9cc.c</span><br><span class="line">new file mode 100644</span><br><span class="line">index 0000000..e6e4599</span><br><span class="line">--- /dev/null</span><br><span class="line">+++ b/9cc.c</span><br><span class="line">@@ -0,0 +1,16 @@</span><br><span class="line">+#include &lt;stdio.h&gt;</span><br><span class="line">+#include &lt;stdlib.h&gt;</span><br><span class="line">+</span><br><span class="line">+int main(int argc, char **argv) &#123;</span><br><span class="line">+  if (argc != 2) &#123;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>最后，让我们将目前创建的 git 存储库上传到 GitHub。没有特别的理由上传到 GitHub，但也没有理由不上传，并且 GitHub 作为代码的备份非常有用。要上传到 GitHub，请创建一个新存储库（在本示例中，我们使用用户 <code>rui314</code> 创建了一个名为 <code>9cc</code> 的存储库），然后使用以下命令创建新存储库。添加存储库作为远程存储库。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git remote add origin git@github.com:rui314/9cc.git</span><br></pre></td></tr></table></figure><p>然后，运行 <code>git push</code> 会将存储库的内容推送到 GitHub。运行 <code>git push</code> 后，尝试在浏览器中打开 GitHub 并验证您的源代码是否已上传。</p><p>这样就完成了创建编译器的第一步。这一步中的编译器太简单了，不能称为编译器，但它是一个很好的程序，包含了编译器所需的所有元素。从现在开始，我们将继续增强这个编译器的功能，尽管可能令人难以置信，但我们将把它开发成一个优秀的 C 编译器。享受第一步的完成。</p><p> 参考实现</p><ul><li><a href="https://github.com/rui314/chibicc/commit/f722daaaae0606115df4ace5a852da23c1a5b0f3">f722daaaae060611</a></li></ul><h2 id="第2步：创建一个可以加减法的编译器"><a href="#第2步：创建一个可以加减法的编译器" class="headerlink" title="第2步：创建一个可以加减法的编译器"></a><a href="#%E3%82%B9%E3%83%86%E3%83%83%E3%83%972%E5%8A%A0%E6%B8%9B%E7%AE%97%E3%81%AE%E3%81%A7%E3%81%8D%E3%82%8B%E3%82%B3%E3%83%B3%E3%83%91%E3%82%A4%E3%83%A9%E3%81%AE%E4%BD%9C%E6%88%90">第2步：创建一个可以加减法的编译器</a></h2><p>在这一步中，我们扩展了上一步中创建的编译器，使其不仅包含 <code>42</code> 等值，还包含 <code>2+11</code> 和 <code>5+20-4</code> 等加法和减法&gt; 允许您接收表情。</p><p>像 <code>5+20-4</code> 这样的表达式可以在编译时计算，并且结果数字（在本例中为 <code>21</code> ）可以嵌入到程序集中，但这会导致编译器就像解释器一样，因此您需要输出在运行时执行加法和减法的程序集。加法和减法的汇编指令是 <code>add</code> 和 <code>sub</code> 。 <code>add</code> 采用两个寄存器，将它们的内容相加，然后将结果写入其第一个参数的寄存器。 <code>sub</code> 与 <code>add</code> 相同，但有减法。使用这些指令， <code>5+20-4</code> 可以编译如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.intel_syntax noprefix</span><br><span class="line">.globl main</span><br><span class="line"></span><br><span class="line">main:</span><br><span class="line">        mov rax, 5</span><br><span class="line">        add rax, 20</span><br><span class="line">        sub rax, 4</span><br><span class="line">        ret</span><br></pre></td></tr></table></figure><p>在上面的程序集中， <code>mov</code> 将 RAX 设置为 5，然后将 20 添加到 RAX 并减去 4。执行 <code>ret</code> 时 RAX 的值应该是 <code>5+20-4</code> 或 21。让我们运行一下并检查一下。将上面的文件保存在 <code>tmp.s</code> 中，组装它，然后尝试运行它。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ cc -o tmp tmp.s</span><br><span class="line">$ ./tmp</span><br><span class="line">$ echo $?</span><br><span class="line">21</span><br></pre></td></tr></table></figure><p> 21 已正确显示，如上所示。</p><p>现在，我应该如何创建这个程序集文件？如果我们将这种涉及加法和减法的表达式视为一种 “ 语言 “，那么这种语言可以定义如下。</p><ul><li>开头有一个数字</li><li>后面跟着零个或多个 “ 术语 “</li><li>术语可以是 <code>+</code> 后跟一个数字，也可以是 <code>-</code> 后跟一个数字。</li></ul><p>如果将此定义翻译成 C 代码，您将得到如下所示的程序：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;参数数量不正确\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">char</span> *p = argv[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;.intel_syntax noprefix\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;.globl main\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;main:\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;  mov rax, %ld\n&quot;</span>, strtol(p, &amp;p, <span class="number">10</span>));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (*p) &#123;</span><br><span class="line">    <span class="keyword">if</span> (*p == <span class="string">&#x27;+&#x27;</span>) &#123;</span><br><span class="line">      p++;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;  add rax, %ld\n&quot;</span>, strtol(p, &amp;p, <span class="number">10</span>));</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (*p == <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">      p++;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;  sub rax, %ld\n&quot;</span>, strtol(p, &amp;p, <span class="number">10</span>));</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;意外的字符: &#x27;%c&#x27;\n&quot;</span>, *p);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;  ret\n&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序有点长，但前半部分和 <code>ret</code> 行与以前相同。中间添加了阅读术语的代码。这次，程序不仅仅是读取单个数字，所以读取一个数字后，我们需要知道它读了多远。由于 <code>atoi</code> 不返回读取的字符数，因此 <code>atoi</code> 不知道从哪里开始阅读下一部分。因此，我们使用了 C 标准库中的 <code>strtol</code> 函数。</p><p><code>strtol</code> 读取数字后，它会更新第二个参数中的指针，以指向读取的最后一个字符之后的字符。因此，读取一个数字后，如果下一个字符是 <code>+</code> 或 <code>-</code> ，则 <code>p</code> 应指向该字符。上面的程序利用了这一事实，在 <code>while</code> 循环中逐个读取术语，并在每次读取一个术语时输出一行汇编。</p><p>现在，让我们运行这个编译器的修改版本。更新 <code>9cc.c</code> 文件后，您只需运行 <code>make</code> 即可创建新的 9cc 文件。执行示例如下所示。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ make</span><br><span class="line">$ ./9cc &#x27;5+20-4&#x27;</span><br><span class="line">.intel_syntax noprefix</span><br><span class="line">.globl main</span><br><span class="line">main:</span><br><span class="line">  mov rax, 5</span><br><span class="line">  add rax, 20</span><br><span class="line">  sub rax, 4</span><br><span class="line">  ret</span><br></pre></td></tr></table></figure><p>看起来程序集已成功输出。为了测试这个新功能，我们向 <code>test.sh</code> 添加一条测试行，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">assert 21 &quot;5+20-4&quot;</span><br></pre></td></tr></table></figure><p>完成此操作后，将更改提交到 git。为此，请运行以下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git add test.sh 9cc.c</span><br><span class="line">$ git commit</span><br></pre></td></tr></table></figure><p>当您运行 <code>git commit</code> 时，编辑器将启动，因此编写 “ 添加加法和减法 “，保存并退出编辑器。尝试使用 <code>git log -p</code> 命令来验证提交是否按预期工作。最后，运行 <code>git push</code> 将提交推送到 GitHub，这一步就完成了！</p><p> 参考实现</p><ul><li><a href="https://github.com/rui314/chibicc/commit/afc9e8f05faddf051aa3a578520d6484ab451282">afc9e8f05faddf05</a></li></ul><h2 id="第-3-步：引入分词器"><a href="#第-3-步：引入分词器" class="headerlink" title="第 3 步：引入分词器"></a><a href="#%E3%82%B9%E3%83%86%E3%83%83%E3%83%973%E3%83%88%E3%83%BC%E3%82%AF%E3%83%8A%E3%82%A4%E3%82%B6%E3%82%92%E5%B0%8E%E5%85%A5">第 3 步：引入分词器</a></h2><p>上一步中创建的编译器有一个缺点。如果输入包含空白字符，则会出现错误。例如，如果如下所示给字符串 <code>5 - 3</code> 加上空格，则在尝试读取 <code>+</code> 或 <code>-</code> 时会发现空格字符。这将导致编译失败。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ./9cc &#x27;5 - 3&#x27; &gt; tmp.s</span><br><span class="line">予期しない文字です: &#x27; &#x27;</span><br></pre></td></tr></table></figure><p>有多种方法可以解决此问题。一种明显的方法是在尝试读取 <code>+</code> 或 <code>-</code> 之前跳过空格。这种方法没有什么特别的错误，但在这一步中我们将采用不同的方法来解决问题。方法是在读取表达式之前将输入拆分为单词。</p><p>就像日语和英语一样，数学公式和编程语言可以被认为是由单词序列组成的。例如， <code>5+20-4</code> 变为 <code>5</code> 、 <code>+</code> 、 <code>20</code> 、 <code>-</code> 、 <code>4</code> 5 您可以将其视为由两个单词组成。这个 “ 词 “ 被称为 “ 令牌 “。标记之间的空白仅用于分隔标记，而不是单词的一部分。因此，在将字符串拆分为标记序列时，删除空格字符是很自然的。将字符串划分为标记字符串称为 “ 标记化 “。</p><p>将字符串分成标记序列还有其他好处。当表达式被划分为标记时，可以对标记进行分类并指定类型。例如， <code>+</code> 和 <code>-</code> 是如您所见的 <code>+</code> 和 <code>-</code> 等符号，而 <code>123</code> 这个字符串表示数字 123。在进行词法分析时，不仅要将输入拆分为简单的字符串，还需要解释每个单独的令牌，在消耗令牌序列时需要考虑更少的事情。</p><p>在当前允许加法和减法的表达式语法中，存在三种类型的标记： <code>+</code> 、 <code>-</code> 和数字。此外，出于编译器实现的原因，最好定义一种特殊类型来表示标记字符串的结尾（相当于以 <code>&#39;\0&#39;</code> 结尾的字符串）。让我们将标记做成一个由指针连接的链表，以便我们可以处理任意长度的输入。</p><p>虽然有点长，但我将在下面发布引入分词器的编译器的改进版本。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 令牌的类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">  TK_RESERVED, <span class="comment">// 符号</span></span><br><span class="line">  TK_NUM,      <span class="comment">// 整数令牌</span></span><br><span class="line">  TK_EOF,      <span class="comment">// 表示输入结束的令牌</span></span><br><span class="line">&#125; TokenKind;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Token</span> <span class="title">Token</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 令牌结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Token</span> &#123;</span></span><br><span class="line">  TokenKind kind; <span class="comment">// 令牌类型</span></span><br><span class="line">  Token *next;    <span class="comment">// 下一个输入令牌</span></span><br><span class="line">  <span class="type">int</span> val;        <span class="comment">// 如果kind为TK_NUM，则为其数值</span></span><br><span class="line">  <span class="type">char</span> *str;      <span class="comment">// 令牌字符串</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前关注的令牌</span></span><br><span class="line">Token *token;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于报告错误的函数</span></span><br><span class="line"><span class="comment">// 与printf相同的参数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">error</span><span class="params">(<span class="type">char</span> *fmt, …)</span> &#123;</span><br><span class="line">  va_list ap;</span><br><span class="line">  va_start(ap, fmt);</span><br><span class="line">  <span class="built_in">vfprintf</span>(<span class="built_in">stderr</span>, fmt, ap);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果下一个令牌是期望的符号，则读取并返回true。</span></span><br><span class="line"><span class="comment">// 否则返回false。</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">consume</span><span class="params">(<span class="type">char</span> op)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (token-&gt;kind != TK_RESERVED || token-&gt;str[<span class="number">0</span>] != op)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  token = token-&gt;next;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果下一个令牌是期望的符号，则读取它。</span></span><br><span class="line"><span class="comment">// 否则报告错误。</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">expect</span><span class="params">(<span class="type">char</span> op)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (token-&gt;kind != TK_RESERVED || token-&gt;str[<span class="number">0</span>] != op)</span><br><span class="line">    error(<span class="string">&quot;&#x27;%c&#x27;不是预期的符号&quot;</span>, op);</span><br><span class="line">  token = token-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果下一个令牌是数字，则读取令牌并返回其数值。</span></span><br><span class="line"><span class="comment">// 否则报告错误。</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">expect_number</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (token-&gt;kind != TK_NUM)</span><br><span class="line">    error(<span class="string">&quot;不是数字&quot;</span>);</span><br><span class="line">  <span class="type">int</span> val = token-&gt;val;</span><br><span class="line">  token = token-&gt;next;</span><br><span class="line">  <span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">at_eof</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> token-&gt;kind == TK_EOF;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建新的令牌并连接到cur</span></span><br><span class="line">Token *<span class="title function_">new_token</span><span class="params">(TokenKind kind, Token *cur, <span class="type">char</span> *str)</span> &#123;</span><br><span class="line">  Token *tok = <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="keyword">sizeof</span>(Token));</span><br><span class="line">  tok-&gt;kind = kind;</span><br><span class="line">  tok-&gt;str = str;</span><br><span class="line">  cur-&gt;next = tok;</span><br><span class="line">  <span class="keyword">return</span> tok;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对输入字符串p进行令牌化并返回其令牌</span></span><br><span class="line">Token *<span class="title function_">tokenize</span><span class="params">(<span class="type">char</span> *p)</span> &#123;</span><br><span class="line">  Token head;</span><br><span class="line">  head.next = <span class="literal">NULL</span>;</span><br><span class="line">  Token *cur = &amp;head;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (*p) &#123;</span><br><span class="line">    <span class="comment">// 跳过空白字符</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isspace</span>(*p)) &#123;</span><br><span class="line">      p++;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (*p == <span class="string">&#x27;+&#x27;</span> || *p == <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">      cur = new_token(TK_RESERVED, cur, p++);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isdigit</span>(*p)) &#123;</span><br><span class="line">      cur = new_token(TK_NUM, cur, p);</span><br><span class="line">      cur-&gt;val = strtol(p, &amp;p, <span class="number">10</span>);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    error(<span class="string">&quot;无法进行令牌化&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  new_token(TK_EOF, cur, p);</span><br><span class="line">  <span class="keyword">return</span> head.next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">    error(<span class="string">&quot;参数数量不正确&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 进行令牌化</span></span><br><span class="line">  token = tokenize(argv[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 输出汇编的前半部分</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;.intel_syntax noprefix\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;.globl main\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;main:\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 表达式的开头必须是一个数字，检查它并输出第一条mov指令</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;  mov rax, %d\n&quot;</span>, expect_number());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 消耗`+ &lt;数&gt;`或`- &lt;数&gt;`的令牌序列并输出汇编</span></span><br><span class="line">  <span class="keyword">while</span> (!at_eof()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (consume(<span class="string">&#x27;+&#x27;</span>)) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;  add rax, %d\n&quot;</span>, expect_number());</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    expect(<span class="string">&#x27;-&#x27;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;  sub rax, %d\n&quot;</span>, expect_number());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;  ret\n&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码不是很短，大约 150 行，但它没有做任何太棘手的事情，所以你应该能够通过从顶部阅读来阅读它。</p><p>让我解释一下上面代码中使用的一些编程技术。</p><ul><li>我决定使用全局变量 <code>token</code> 来表示解析器读取的标记序列。解析器通过 <code>token</code> 的链接列表读取输入。这种使用全局变量的编程风格可能看起来不太干净。然而，在实践中，通过将输入标记序列视为像标准输入一样的流，通常更容易读取解析器代码，就像我们在这里所做的那样。因此，我们这里采用了这样的风格。</li><li>直接接触 <code>token</code> 的代码应该分成 <code>consume</code> 和 <code>expect</code> 等函数，其他函数不应该直接接触 <code>token</code> 。做好了。</li><li><code>tokenize</code> 函数正在构建一个链表。构建链表时，您可以通过创建一个虚拟 <code>head</code> 元素、将新元素连接到它并在末尾返回 <code>head-&gt;next</code> 来简化代码。这种方法浪费了分配给 <code>head</code> 元素的大部分内存，但分配局部变量的成本几乎为零，因此您无需担心。</li><li><code>calloc</code> 是一个分配内存的函数，就像 <code>malloc</code> 一样。与 <code>malloc</code> 不同， <code>calloc</code> 将分配的内存清零。我决定在这里使用 <code>calloc</code> 来节省将元素归零的工作。</li></ul><p>这个改进的版本现在应该能够跳过空格，所以让我们将以下测试添加到单行 <code>test.sh</code> 中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">assert 41 &quot; 12 + 34 - 5 &quot;</span><br></pre></td></tr></table></figure><p>Unix 进程的退出代码是 0 到 255 之间的数字，因此在编写测试时，请确保整个表达式的结果落在 0 到 255 的范围内。</p><p>将测试文件添加到 git 存储库即可完成此步骤。</p><p> 参考实现</p><ul><li><a href="https://github.com/rui314/chibicc/commit/ef6d1791eb2a5ef3af913945ca577ea76d4ff97e">ef6d1791eb2a5ef3</a></li></ul><h2 id="第-4-步：改进错误消息"><a href="#第-4-步：改进错误消息" class="headerlink" title="第 4 步：改进错误消息"></a><a href="#%E3%82%B9%E3%83%86%E3%83%83%E3%83%974%E3%82%A8%E3%83%A9%E3%83%BC%E3%83%A1%E3%83%83%E3%82%BB%E3%83%BC%E3%82%B8%E3%82%92%E6%94%B9%E8%89%AF">第 4 步：改进错误消息</a></h2><p>使用到目前为止我们创建的编译器，如果输入在语法上不正确，我们唯一可以判断的是某个地方有错误。让我们尝试在这一步中改进这个问题。具体来说，我们将能够显示如下所示的直观错误消息。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ ./9cc &quot;1+3++&quot; &gt; tmp.s</span><br><span class="line">1+3++</span><br><span class="line">    ^ 不是数字</span><br><span class="line">$ ./9cc &quot;1 + foo + 5&quot; &gt; tmp.s</span><br><span class="line">1 + foo + 5</span><br><span class="line">    ^ 无法进行令牌化</span><br></pre></td></tr></table></figure><p>为了显示这样的错误消息，我们需要能够知道错误发生在输入的哪个字节。为此，我们将整个程序字符串保存在名为 <code>user_input</code> 的变量中，并定义一个新的错误显示函数，该函数接收指向字符串中间的指针。代码如下所示。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用户输入程序</span></span><br><span class="line"><span class="type">char</span> *user_input;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报告错误位置</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">error_at</span><span class="params">(<span class="type">char</span> *loc, <span class="type">char</span> *fmt, …)</span> &#123;</span><br><span class="line">  va_list ap;</span><br><span class="line">  va_start(ap, fmt);</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> pos = loc - user_input;</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;%s\n&quot;</span>, user_input);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;%*s&quot;</span>, pos, <span class="string">&quot; &quot;</span>); <span class="comment">// 输出pos个空格</span></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;^ &quot;</span>);</span><br><span class="line">  <span class="built_in">vfprintf</span>(<span class="built_in">stderr</span>, fmt, ap);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>error_at</code> 接收的指针是指向代表整个输入的字符串中间的指针。通过获取该指针和指向输入开头的指针之间的差异，您可以知道错误位于输入的哪个字节，因此可以使用 <code>^</code> 显着地标记该位置。</p><p>通过将 <code>argv[1]</code> 保存到 <code>user_input</code> 并将 <code>error(&quot;数ではありません&quot;)</code> 等代码更新为 <code>error_at(token-&gt;str, &quot;数ではありません&quot;)</code> 等代码来完成此步骤。</p><p>实用级别的编译器也应该为输入有错误时的行为编写测试，但目前错误消息只是输出以帮助调试，在这个阶段没有必要编写测试。你没有。</p><p> 参考实现</p><ul><li><a href="https://github.com/rui314/chibicc/commit/c6ff1d98a1419e69c31902447e2caa85af4e9844">c6ff1d98a1419e69</a></li></ul><h2 id="语法描述方法与递归下降解析"><a href="#语法描述方法与递归下降解析" class="headerlink" title="语法描述方法与递归下降解析"></a><a href="#%E6%96%87%E6%B3%95%E3%81%AE%E8%A8%98%E8%BF%B0%E6%96%B9%E6%B3%95%E3%81%A8%E5%86%8D%E5%B8%B0%E4%B8%8B%E9%99%8D%E6%A7%8B%E6%96%87%E8%A7%A3%E6%9E%90">语法描述方法与递归下降解析</a></h2><p>现在，接下来我想在语言中添加用于乘法、除法和优先级的括号，即 <code>*</code> 、 <code>/</code> 、 <code>()</code> 。这是一个重大的技术挑战。这是因为有一个规则，在表达式中必须先计算乘法和除法。例如，表达式 <code>1+2*3</code> 必须解释为 <code>1+(2*3)</code> ，而不是 <code>(1+2)*3</code> 。运算符首先 “ 粘在一起 “ 的规则称为 “ 运算符优先级 “。</p><p>我们应该如何处理运算符优先级？到目前为止，我们创建的编译器只是从头开始读取标记序列并输出程序集，因此如果您只是扩展它并添加 <code>*</code> 和 <code>/</code> 、 <code>1+2*3</code> 将被编译为 <code>(1+2)*3</code> 。</p><p>现有的编译器自然擅长处理运算符优先级。编译器的解析非常强大，只要遵循语法就可以正确解释任何复杂的代码。这个编译器的行为可能给人的印象是它具有超越人类的智力，但实际上，计算机不具备像人类一样阅读文本的能力，因此解析只是通过某种机械机制来执行 。它到底是如何运作的？</p><p>在本章中，让我们暂时放下编码，学习一些解析技术。本章按以下顺序描述解析技术：</p><ol><li><p>首先通过了解解析器输出的数据结构来了解最终目标。</p></li><li><p> 了解定义语法规则的规则</p></li><li><p>学习根据定义语法规则的规则编写解析器的技术</p></li></ol><h3 id="使用树结构表示语法结构"><a href="#使用树结构表示语法结构" class="headerlink" title="使用树结构表示语法结构"></a><a href="#%E6%9C%A8%E6%A7%8B%E9%80%A0%E3%81%AB%E3%82%88%E3%82%8B%E6%96%87%E6%B3%95%E6%A7%8B%E9%80%A0%E3%81%AE%E8%A1%A8%E7%8F%BE">使用树结构表示语法结构</a></h3><p>在编程语言解析器实现中，输入通常是标记的平面序列，输出是表示嵌套结构的树。本书中创建的编译器也遵循该结构。</p><p>在 C 语言中， <code>if</code> 和 <code>while</code> 等语法元素是可以嵌套的。在树结构中表示类似的东西是一种自然的表示方式。</p><p>数学公式的结构是先计算括号内的内容，再计算乘法和除法，然后再计算加法和减法。虽然这种结构乍一看可能不像树，但它实际上是表示表达式结构的一种非常简单的方式。例如，表达式 <code>1*(2+3)</code> 可以被认为是由以下树表示。</p><p><img src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+CjwhRE9DVFlQRSBzdmcgUFVCTElDICItLy9XM0MvL0RURCBTVkcgMS4xLy9FTiIKICJodHRwOi8vd3d3LnczLm9yZy9HcmFwaGljcy9TVkcvMS4xL0RURC9zdmcxMS5kdGQiPgo8IS0tIEdlbmVyYXRlZCBieSBncmFwaHZpeiB2ZXJzaW9uIDIuNDAuMSAoMjAxNjEyMjUuMDMwNCkKIC0tPgo8IS0tIFRpdGxlOiBHIFBhZ2VzOiAxIC0tPgo8c3ZnIHdpZHRoPSIxNzBwdCIgaGVpZ2h0PSIxODhwdCIKIHZpZXdCb3g9IjAuMDAgMC4wMCAxNzAuMDAgMTg4LjAwIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIj4KPGcgaWQ9ImdyYXBoMCIgY2xhc3M9ImdyYXBoIiB0cmFuc2Zvcm09InNjYWxlKDEgMSkgcm90YXRlKDApIHRyYW5zbGF0ZSg0IDE4NCkiPgo8dGl0bGU+RzwvdGl0bGU+Cjxwb2x5Z29uIGZpbGw9IiNmZmZmZmYiIHN0cm9rZT0idHJhbnNwYXJlbnQiIHBvaW50cz0iLTQsNCAtNCwtMTg0IDE2NiwtMTg0IDE2Niw0IC00LDQiLz4KPCEtLSAqIC0tPgo8ZyBpZD0ibm9kZTEiIGNsYXNzPSJub2RlIj4KPHRpdGxlPio8L3RpdGxlPgo8ZWxsaXBzZSBmaWxsPSJub25lIiBzdHJva2U9IiMwMDAwMDAiIGN4PSI2MyIgY3k9Ii0xNjIiIHJ4PSIyNyIgcnk9IjE4Ii8+Cjx0ZXh0IHRleHQtYW5jaG9yPSJtaWRkbGUiIHg9IjYzIiB5PSItMTU3LjgiIGZvbnQtZmFtaWx5PSJUaW1lcyxzZXJpZiIgZm9udC1zaXplPSIxNC4wMCIgZmlsbD0iIzAwMDAwMCI+KjwvdGV4dD4KPC9nPgo8IS0tIDEgLS0+CjxnIGlkPSJub2RlMiIgY2xhc3M9Im5vZGUiPgo8dGl0bGU+MTwvdGl0bGU+CjxlbGxpcHNlIGZpbGw9Im5vbmUiIHN0cm9rZT0iIzAwMDAwMCIgY3g9IjI3IiBjeT0iLTkwIiByeD0iMjciIHJ5PSIxOCIvPgo8dGV4dCB0ZXh0LWFuY2hvcj0ibWlkZGxlIiB4PSIyNyIgeT0iLTg1LjgiIGZvbnQtZmFtaWx5PSJUaW1lcyxzZXJpZiIgZm9udC1zaXplPSIxNC4wMCIgZmlsbD0iIzAwMDAwMCI+MTwvdGV4dD4KPC9nPgo8IS0tIComIzQ1OyZndDsxIC0tPgo8ZyBpZD0iZWRnZTEiIGNsYXNzPSJlZGdlIj4KPHRpdGxlPiomIzQ1OyZndDsxPC90aXRsZT4KPHBhdGggZmlsbD0ibm9uZSIgc3Ryb2tlPSIjMDAwMDAwIiBkPSJNNTQuMjg1NCwtMTQ0LjU3MDhDNTAuMDQwMywtMTM2LjA4MDcgNDQuODQ2NCwtMTI1LjY5MjkgNDAuMTMzNywtMTE2LjI2NzQiLz4KPHBvbHlnb24gZmlsbD0iIzAwMDAwMCIgc3Ryb2tlPSIjMDAwMDAwIiBwb2ludHM9IjQzLjIzNywtMTE0LjY0NzcgMzUuNjM0MywtMTA3LjI2ODcgMzYuOTc2LC0xMTcuNzc4MiA0My4yMzcsLTExNC42NDc3Ii8+CjwvZz4KPCEtLSArIC0tPgo8ZyBpZD0ibm9kZTMiIGNsYXNzPSJub2RlIj4KPHRpdGxlPis8L3RpdGxlPgo8ZWxsaXBzZSBmaWxsPSJub25lIiBzdHJva2U9IiMwMDAwMDAiIGN4PSI5OSIgY3k9Ii05MCIgcng9IjI3IiByeT0iMTgiLz4KPHRleHQgdGV4dC1hbmNob3I9Im1pZGRsZSIgeD0iOTkiIHk9Ii04NS44IiBmb250LWZhbWlseT0iVGltZXMsc2VyaWYiIGZvbnQtc2l6ZT0iMTQuMDAiIGZpbGw9IiMwMDAwMDAiPis8L3RleHQ+CjwvZz4KPCEtLSAqJiM0NTsmZ3Q7KyAtLT4KPGcgaWQ9ImVkZ2UyIiBjbGFzcz0iZWRnZSI+Cjx0aXRsZT4qJiM0NTsmZ3Q7KzwvdGl0bGU+CjxwYXRoIGZpbGw9Im5vbmUiIHN0cm9rZT0iIzAwMDAwMCIgZD0iTTcxLjcxNDYsLTE0NC41NzA4Qzc1Ljk1OTcsLTEzNi4wODA3IDgxLjE1MzYsLTEyNS42OTI5IDg1Ljg2NjMsLTExNi4yNjc0Ii8+Cjxwb2x5Z29uIGZpbGw9IiMwMDAwMDAiIHN0cm9rZT0iIzAwMDAwMCIgcG9pbnRzPSI4OS4wMjQsLTExNy43NzgyIDkwLjM2NTcsLTEwNy4yNjg3IDgyLjc2MywtMTE0LjY0NzcgODkuMDI0LC0xMTcuNzc4MiIvPgo8L2c+CjwhLS0gMiAtLT4KPGcgaWQ9Im5vZGU0IiBjbGFzcz0ibm9kZSI+Cjx0aXRsZT4yPC90aXRsZT4KPGVsbGlwc2UgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjMDAwMDAwIiBjeD0iNjMiIGN5PSItMTgiIHJ4PSIyNyIgcnk9IjE4Ii8+Cjx0ZXh0IHRleHQtYW5jaG9yPSJtaWRkbGUiIHg9IjYzIiB5PSItMTMuOCIgZm9udC1mYW1pbHk9IlRpbWVzLHNlcmlmIiBmb250LXNpemU9IjE0LjAwIiBmaWxsPSIjMDAwMDAwIj4yPC90ZXh0Pgo8L2c+CjwhLS0gKyYjNDU7Jmd0OzIgLS0+CjxnIGlkPSJlZGdlMyIgY2xhc3M9ImVkZ2UiPgo8dGl0bGU+KyYjNDU7Jmd0OzI8L3RpdGxlPgo8cGF0aCBmaWxsPSJub25lIiBzdHJva2U9IiMwMDAwMDAiIGQ9Ik05MC4yODU0LC03Mi41NzA4Qzg2LjA0MDMsLTY0LjA4MDcgODAuODQ2NCwtNTMuNjkyOSA3Ni4xMzM3LC00NC4yNjc0Ii8+Cjxwb2x5Z29uIGZpbGw9IiMwMDAwMDAiIHN0cm9rZT0iIzAwMDAwMCIgcG9pbnRzPSI3OS4yMzcsLTQyLjY0NzcgNzEuNjM0MywtMzUuMjY4NyA3Mi45NzYsLTQ1Ljc3ODIgNzkuMjM3LC00Mi42NDc3Ii8+CjwvZz4KPCEtLSAzIC0tPgo8ZyBpZD0ibm9kZTUiIGNsYXNzPSJub2RlIj4KPHRpdGxlPjM8L3RpdGxlPgo8ZWxsaXBzZSBmaWxsPSJub25lIiBzdHJva2U9IiMwMDAwMDAiIGN4PSIxMzUiIGN5PSItMTgiIHJ4PSIyNyIgcnk9IjE4Ii8+Cjx0ZXh0IHRleHQtYW5jaG9yPSJtaWRkbGUiIHg9IjEzNSIgeT0iLTEzLjgiIGZvbnQtZmFtaWx5PSJUaW1lcyxzZXJpZiIgZm9udC1zaXplPSIxNC4wMCIgZmlsbD0iIzAwMDAwMCI+MzwvdGV4dD4KPC9nPgo8IS0tICsmIzQ1OyZndDszIC0tPgo8ZyBpZD0iZWRnZTQiIGNsYXNzPSJlZGdlIj4KPHRpdGxlPismIzQ1OyZndDszPC90aXRsZT4KPHBhdGggZmlsbD0ibm9uZSIgc3Ryb2tlPSIjMDAwMDAwIiBkPSJNMTA3LjcxNDYsLTcyLjU3MDhDMTExLjk1OTcsLTY0LjA4MDcgMTE3LjE1MzYsLTUzLjY5MjkgMTIxLjg2NjMsLTQ0LjI2NzQiLz4KPHBvbHlnb24gZmlsbD0iIzAwMDAwMCIgc3Ryb2tlPSIjMDAwMDAwIiBwb2ludHM9IjEyNS4wMjQsLTQ1Ljc3ODIgMTI2LjM2NTcsLTM1LjI2ODcgMTE4Ljc2MywtNDIuNjQ3NyAxMjUuMDI0LC00NS43NzgyIi8+CjwvZz4KPC9nPgo8L3N2Zz4K"></p><p> 代表 <code>1*(2+3)</code> 的树</p><p>如果我们采用从树尾开始依次计算的规则，上面的树就代表公式 1 乘以 2+3。也就是说，在上面的树中， <code>1*(2+3)</code> 的具体计算顺序是在树本身中表达的。</p><p>这是另一个例子。下面的树代表 <code>7-3-3</code> 。</p><p><img src="/../../../img/blog/598a3752fe3cd661b4e23065266c5d3f_MD5.svg"></p><p> 代表 <code>7-3-3</code> 的树</p><p>在上面的树中，应用 “ 减法必须从左边计算 “ 规则的结果以树的形式明确地表达。换句话说，上面的树代表表达式 <code>(7-3)-3 = 1</code> ，而不是表达式 <code>7-(3-3) = 7</code> 。如果是后一个表达式，则表示它的树将向右而不是向左更深。</p><p>必须从左开始计算的运算符称为 “ 左关联 “ 运算符，必​​须从右开始计算的运算符称为 “ 右关联 “ 运算符。在 C 中，大多数运算符都定义为左结合，但用于赋值的 <code>=</code> 除外。</p><p>像上面这样的树称为 “ 语法树 “。特别是，尽可能紧凑地表达而不留下多余元素（例如用于在树中分组的括号）的语法树称为 “ 抽象语法树 “（AST）。上述所有语法树都可以称为抽象语法树。</p><p>由于抽象语法树是编译器的内部表示，因此可以将其定义为适合实现目的。然而，由于算术运算符（例如加法和乘法）被定义为两侧（左侧和右侧）的运算，因此任何编译器创建二叉树都是很自然的。另一方面，在函数体中表示表达式是很自然的，只需按顺序执行即可拥有任意数量的表达式，就像所有子元素都是平坦的树一样。</p><p>解析的目标是构造抽象语法树。编译器首先将输入标记序列解析为抽象语法树，然后将其转换为汇编语言。</p><h3 id="使用产生式规则定义语法"><a href="#使用产生式规则定义语法" class="headerlink" title="使用产生式规则定义语法"></a><a href="#%E7%94%9F%E6%88%90%E8%A6%8F%E5%89%87%E3%81%AB%E3%82%88%E3%82%8B%E6%96%87%E6%B3%95%E3%81%AE%E5%AE%9A%E7%BE%A9">使用产生式规则定义语法</a></h3><p>现在，让我们学习如何用编程语言编写语法。大多数编程语言的语法都是使用产生式规则定义的。产生式规则是递归定义语法的规则。</p><p>让我们考虑一下自然语言。在日语中，语法具有嵌套结构。例如，如果将句子 “flowers are beautiful” 中的名词 “flower” 替换为名词短语 “redflower”，则句子变为正确，并且如果将 “red” 进一步扩展为 “ 有点红 “。不过，这仍然是一个正确的句子。您也可以将其放在另一个句子中，例如 “ 我认为小红花很漂亮。”</p><p>这些语法被定义为 “ 一个 ‘ 句子 ‘ 由一个 ‘ 主语 ‘ 和一个 ‘ 谓语 ‘ 组成 “，或者 “ 一个 ‘ 名词短语 ‘ 由一个 ‘ 名词 ‘ 或一个 ‘ 形容词 ‘ 后跟一个 ‘ 名词短语 ‘ 组成。 ‘“ 让我们将其视为定义为这样的规则。然后，通过使用 “ 句子 “ 作为起点并根据规则发展它，可以在定义的语法内创建无限多个有效句子。</p><p>或者，相反，通过考虑与现有句子匹配的扩展过程，您可以考虑该字符串具有什么样的结构。</p><p>上述思想最初是为自然语言设计的，但由于它们与计算机处理的数据具有很高的亲和力，因此产生式规则被用于计算机的各个领域，包括编程语言。</p><h3 id="使用BNF的产生式规则描述"><a href="#使用BNF的产生式规则描述" class="headerlink" title="使用BNF的产生式规则描述"></a><a href="#bnf%E3%81%AB%E3%82%88%E3%82%8B%E7%94%9F%E6%88%90%E8%A6%8F%E5%89%87%E3%81%AE%E8%A8%98%E8%BF%B0">使用BNF的产生式规则描述</a></h3><p>以紧凑且易于理解的方式描述产生式规则的一种表示法是 BNF（巴科斯 - 诺尔形式）及其扩展版本 EBNF（扩展 BNF）。在本书中，我们将使用 EBNF 解释 C 的语法。本节首先描述 BNF，然后描述 EBNF 的扩展。</p><p>在 BNF 中，每条产生式规则都以 <code>A = α₁α₂⋯</code> 的格式表示。这意味着符号 <code>A</code> 可以扩展为 <code>α₁α₂⋯</code> 。 <code>α₁α₂⋯</code> 是零个或多个符号的序列，其中可以包含无法进一步扩展的符号和可以进一步扩展的符号（在某些产生式中位于左侧）。</p><p>不能进一步展开的符号称为 “ 终结符号 “，出现在任何产生式规则左侧并且可以展开的符号称为 “ 非终结符号 “。由这种产生式规则定义的语法通常称为 “ 上下文无关语法 “。</p><p>一个非终结符可以匹配多个产生式。例如，如果 <code>A = α₁</code> 和 <code>A = α₂</code> 都有规则，则 <code>A</code> 是 <code>α₁</code> 或 <code>α₂</code> 。这意味着它可以扩展到 .</p><p>产生式规则的右侧可以为空。在这样的规则中，左侧的符号将被扩展为零长度符号字符串（即，什么都没有）。但是，如果省略右边，就很难理解含义，所以在这种情况下，标准的 BNF 规则是在右边写上ε（epsilon）作为符号，表示没有任何东西。本书也采用了这一规则。</p><p>将字符串用双引号括起来，并像 <code>&quot;foo&quot;</code> 一样编写。字符串始终是终结符。</p><p>以上是 BNF 的基本规则。除了 BNF 规则之外，EBNF 还允许您使用以下符号简洁地编写复杂的规则。</p><table><thead><tr><th>怎么写</th><th>意义</th></tr></thead><tbody><tr><td><code>A*</code></td><td>重复 <code>A</code> 零次或多次</td></tr><tr><td><code>A?</code></td><td><code>A</code> 或 ε</td></tr><tr><td><code>A | B</code></td><td><code>A</code> 或 <code>B</code></td></tr><tr><td><code>( … )</code></td><td>分组</td></tr></tbody></table><p>コラム:  列：BNF 和 EBNF</p><p>普通的非扩展 BNF 没有简洁的符号，例如 <code>*</code> 、 <code>?</code> 、 <code>|</code> 、 <code>( … )</code> 但是，可以用 BNF 生成的和用 EBNF 生成的是一样的。这是因为 EBNF 可以通过如下重写来转换为 BNF。</p><table><thead><tr><th>EBNF</th><th>对应的 BNF</th></tr></thead><tbody><tr><td><code>A = α*</code></td><td><code>A = αA</code> 和 <code>A = ε</code></td></tr><tr><td><code>A = α?</code></td><td><code>A = α</code> 和 <code>A = ε</code></td></tr><tr><td><code>A = α | β</code></td><td><code>A = α</code> 和 <code>A = β</code></td></tr><tr><td><code>A = α (β₁β₂⋯) γ</code></td><td><code>A = α B γ</code> 和 <code>B = β₁β₂⋯</code></td></tr></tbody></table><p>例如，当使用产生规则 <code>A = αA</code> 和 <code>A = ε</code> 从 <code>A</code> 生成句子 <code>ααα</code> 时， <code>A → αA → ααA → αααA → ααα</code></p><p>这样，诸如 <code>*</code> 和 <code>?</code> 之类的符号只是快捷方式，但简短的符号更容易理解和理想，因此如果可以使用简短的符号，通常会使用简洁的方式编写符号。</p><h3 id="简单的生产规则"><a href="#简单的生产规则" class="headerlink" title="简单的生产规则"></a><a href="#%E5%8D%98%E7%B4%94%E3%81%AA%E7%94%9F%E6%88%90%E8%A6%8F%E5%89%87">简单的生产规则</a></h3><p>作为使用 EBNF 编写语法的示例，请考虑以下产生式规则。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expr = num (&quot;+&quot; num | &quot;-&quot; num)*</span><br></pre></td></tr></table></figure><p>假设 <code>num</code> 在某处定义为表示数值的符号。在此语法中， <code>expr</code> 以一个 <code>num</code> 开头，后跟零个或多个 <code>+</code> 和 <code>num</code> ，或 <code>-</code> 和 <code>num</code> 。这个规则实际上代表了加法和减法表达式的语法。</p><p>从 expr 开始，展开它，你可以创建任意的加减字符串，比如 <code>1</code> 、 <code>10+5</code> 、 <code>42-30+2</code> ，我可以。请检查下面的扩展结果。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expr → num → &quot;1&quot;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">expr → num &quot;+&quot; num</span><br><span class="line">     → &quot;10&quot; &quot;+&quot; &quot;5&quot;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">expr → num &quot;-&quot; num &quot;+&quot; num</span><br><span class="line">     → &quot;42&quot; &quot;-&quot; &quot;30&quot; &quot;+&quot; &quot;2&quot;</span><br></pre></td></tr></table></figure><p>这些扩展步骤除了用箭头来表示各个扩展顺序外，还可以用树形结构来表示。上述表达式的语法树如下所示。</p><p><img src="/../../../img/blog/aaf311461c6b329a0ccdfd808821d635_MD5.svg"></p><p>  <code>10+5</code> 的语法树</p><p><img src="/../../../img/blog/387ac6f8e9d9ebdea8ebf94f904b0928_MD5.svg"></p><p>  <code>42-30+2</code> 的语法树</p><p>通过以树结构表示它，现在更容易理解哪个非终结符扩展为哪个符号。</p><p>像上面所示的语法树包含输入中的所有标记，并且与语法具有完美的一对一匹配，有时被称为 “ 具体语法树 “。该术语通常用于与抽象语法树进行对比。</p><p>注意，在上面的具体语法树中，从左边开始计算加减法的规则并没有以树的形式表达。在这里解释的语法中，这样的规则不是使用 EBNF 来表达，而是作为附加条件写在语言规范中 “ 加法和减法首先从左边开始计算。” 成为。解析器同时考虑 EBNF 和免责声明，读取表示表达式的标记序列，并构造一个适当表示表达式求值顺序的抽象语法树。</p><p>因此，在上述语法中，EBNF 表示的具体语法树和解析器输出的抽象语法树只是大致匹配。可以定义一个语法，使抽象语法树和具体语法树具有尽可能多的相同结构，但这会使语法变得多余，并且很难理解如何编写解析器。上述语法是一种易于使用的语法表达方法，它在形式语法描述的严谨性和辅以自然语言的易懂性之间取得了平衡。</p><h3 id="使用产生式规则表达运算符优先级"><a href="#使用产生式规则表达运算符优先级" class="headerlink" title="使用产生式规则表达运算符优先级"></a><a href="#%E7%94%9F%E6%88%90%E8%A6%8F%E5%89%87%E3%81%AB%E3%82%88%E3%82%8B%E6%BC%94%E7%AE%97%E5%AD%90%E3%81%AE%E5%84%AA%E5%85%88%E9%A0%86%E4%BD%8D%E3%81%AE%E8%A1%A8%E7%8F%BE">使用产生式规则表达运算符优先级</a></h3><p>产生式规则是表达语法的非常强大的工具。运算符优先级也可以通过设计语法用产生式规则来表达。其语法如下所示。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">expr = mul (&quot;+&quot; mul | &quot;-&quot; mul)*</span><br><span class="line">mul  = num (&quot;*&quot; num | &quot;/&quot; num)*</span><br></pre></td></tr></table></figure><p>在之前的规则中， <code>expr</code> 直接扩展为 <code>num</code> ，但现在 <code>expr</code> 通过 <code>mul</code> 扩展。该规则现在扩展为&lt; b4&gt;。 <code>mul</code> 是乘法和除法的产生规则， <code>expr</code> 执行加法和减法，使用 <code>mul</code> 作为一个组件。在这个语法中，乘法和除法在先的规则自然地表达在语法树中。让我们看一些具体的例子。</p><p><img src="/../../../img/blog/e9f9a4626ec6ae0f456452cab303f495_MD5.svg"></p><p>  <code>1*2+3</code> 的语法树</p><p><img src="/../../../img/blog/d800ab78360ae2589f0281aee0f7dd16_MD5.svg"></p><p>  <code>1*2+3*4*5</code> 的语法树</p><p>在上面的树结构中，乘法总是比加法更靠近树的末尾。实际上，没有从 <code>mul</code> 返回到 <code>expr</code> 的规则，所以没有办法创建一个加法低于乘法的树，但即便如此，也没有办法创建一个加法低于乘法的树。使用简单的规则可以像树结构一样很好地表达优先级，这似乎很奇怪。鼓励读者通过实际比较产生式规则与语法树来检查语法树是否正确。</p><h3 id="涉及递归的产生式"><a href="#涉及递归的产生式" class="headerlink" title="涉及递归的产生式"></a><a href="#%E5%86%8D%E5%B8%B0%E3%82%92%E5%90%AB%E3%82%80%E7%94%9F%E6%88%90%E8%A6%8F%E5%89%87">涉及递归的产生式</a></h3><p>有了生成语法，递归语法也可以正常编写。下面是一个语法生成规则，它将优先括号添加到四个算术运算中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">expr    = mul (&quot;+&quot; mul | &quot;-&quot; mul)*</span><br><span class="line">mul     = primary (&quot;*&quot; primary | &quot;/&quot; primary)*</span><br><span class="line">primary = num | &quot;(&quot; expr &quot;)&quot;</span><br></pre></td></tr></table></figure><p>将上面的语法与前一个语法进行比较，我们发现以前允许使用 <code>num</code> 的地方，允许使用 <code>primary</code> ，即 <code>num</code> 或 <code>&quot;(&quot; expr &quot;)&quot;</code> 来。换句话说，在这个新语法中，括号中的表达式将被视为与单个数字相同的 “ 粘性 “。让我们看一个例子。</p><p> 下面的树是 <code>1*2</code> 的语法树。</p><p><img src="/../../../img/blog/8114ebf4c18be2df3a0b24ee6850356c_MD5.svg"></p><p>  <code>1*2</code> 的语法树</p><p> 下面的树是 <code>1*(2+3)</code> 的语法树。</p><p><img src="/../../../img/blog/d93b6fba5f156656ce4809182328b661_MD5.svg"></p><p>  <code>1*(2+3)</code> 的语法树</p><p>比较两棵树，可以看到只有 <code>mul</code> 右分支上 <code>primary</code> 的展开结果不同。展开结果末尾出现的 <code>primary</code> 可以展开为单个数字或者括号内的任意表达式的规则就是树结构的规则，里面体现的很清楚。您还可以使用如此简单的产生式规则来处理括号的优先级，这不是令人印象深刻吗？</p><h3 id="递归降序解析"><a href="#递归降序解析" class="headerlink" title="递归降序解析"></a><a href="#%E5%86%8D%E5%B8%B0%E4%B8%8B%E9%99%8D%E6%A7%8B%E6%96%87%E8%A7%A3%E6%9E%90">递归降序解析</a></h3><p>如果给定 C 语言的产生式规则，通过将它们逐一展开，就可以机械地生成任何从产生式规则来看是正确的 C 程序。但我们想要用 9cc 做的事情实际上是相反的。我从外部源获得一个作为字符串的 C 程序，我想知道展开时产生输入字符串的展开过程，或者产生与以下字符串相同的语法树的结构输入。</p><p>事实上，对于某些类型的产生式规则，如果给定一个规则，就可以机械地编写代码来找到与该规则生成的句子相匹配的语法树。这里描述的 “ 递归下降解析方法 “ 就是这样一种技术。</p><p>作为示例，让我们考虑四种算术运算的语法。我将重新发布四种算术运算的语法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">expr    = mul (&quot;+&quot; mul | &quot;-&quot; mul)*</span><br><span class="line">mul     = primary (&quot;*&quot; primary | &quot;/&quot; primary)*</span><br><span class="line">primary = num | &quot;(&quot; expr &quot;)&quot;</span><br></pre></td></tr></table></figure><p>使用递归下降解析编写解析器时的基本策略是将每个非终结符直接映射到每个函数。因此解析器将具有三个函数： <code>expr</code> 、 <code>mul</code> 和 <code>primary</code> 。正如其名称所示，每个函数都会解析一系列标记。</p><p>让我们具体地考虑一下。传递给解析器的输入是一系列标记。由于我们想要从解析器创建并返回一个抽象语法树，因此让我们定义抽象语法树中的节点类型。节点类型如下所示。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象语法树的节点类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">  ND_ADD, <span class="comment">// +</span></span><br><span class="line">  ND_SUB, <span class="comment">// -</span></span><br><span class="line">  ND_MUL, <span class="comment">// *</span></span><br><span class="line">  ND_DIV, <span class="comment">// /</span></span><br><span class="line">  ND_NUM, <span class="comment">// 整数</span></span><br><span class="line">&#125; NodeKind;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> <span class="title">Node</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象语法树的节点类型</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">  NodeKind kind; <span class="comment">// 节点类型</span></span><br><span class="line">  Node *lhs;     <span class="comment">// 左侧</span></span><br><span class="line">  Node *rhs;     <span class="comment">// 右侧</span></span><br><span class="line">  <span class="type">int</span> val;       <span class="comment">// 仅在kind为ND_NUM时使用</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>lhs</code> 和 <code>rhs</code> 分别表示左侧和右侧。</p><p>我们还定义一个函数来创建新节点。该语法中有两种类型的算术运算：接受左侧和右侧的二元运算符以及数字，因此我们将为这两种类型分别准备两个函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Node *<span class="title function_">new_node</span><span class="params">(NodeKind kind, Node *lhs, Node *rhs)</span> &#123;</span><br><span class="line">  Node *node = <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="keyword">sizeof</span>(Node));</span><br><span class="line">  node-&gt;kind = kind;</span><br><span class="line">  node-&gt;lhs = lhs;</span><br><span class="line">  node-&gt;rhs = rhs;</span><br><span class="line">  <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Node *<span class="title function_">new_node_num</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">  Node *node = <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="keyword">sizeof</span>(Node));</span><br><span class="line">  node-&gt;kind = ND_NUM;</span><br><span class="line">  node-&gt;val = val;</span><br><span class="line">  <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，让我们使用这些函数和数据类型编写一个解析器。 <code>+</code> 和 <code>-</code> 是左结合运算符。解析左结合运算符的函数被编写为如下模式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Node *<span class="title function_">expr</span><span class="params">()</span> &#123;</span><br><span class="line">  Node *node = mul();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    <span class="keyword">if</span> (consume(<span class="string">&#x27;+&#x27;</span>))</span><br><span class="line">      node = new_node(ND_ADD, node, mul());</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (consume(<span class="string">&#x27;-&#x27;</span>))</span><br><span class="line">      node = new_node(ND_SUB, node, mul());</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="keyword">return</span> node;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>consume</code> 是上一步中定义的函数，它向前读取输入中的一个标记，如果输入流中的下一个标记与参数匹配，则返回 true。</p><p><code>expr</code> 请仔细阅读该函数。您可以看到产生式 <code>expr = mul (&quot;+&quot; mul | &quot;-&quot; mul)*</code> 直接映射到函数调用和循环。在上面 <code>expr</code> 函数返回的抽象语法树中，运算符是左关联的，这意味着返回节点左侧的分支更深。</p><p>我们还定义 <code>expr</code> 函数使用的 <code>mul</code> 函数。 <code>*</code> 和 <code>/</code> 也是左结合运算符，因此可以使用相同的模式编写它们。该函数如下所示。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Node *<span class="title function_">mul</span><span class="params">()</span> &#123;</span><br><span class="line">  Node *node = primary();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    <span class="keyword">if</span> (consume(<span class="string">&#x27;*&#x27;</span>))</span><br><span class="line">      node = new_node(ND_MUL, node, primary());</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (consume(<span class="string">&#x27;/&#x27;</span>))</span><br><span class="line">      node = new_node(ND_DIV, node, primary());</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="keyword">return</span> node;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中的函数调用关系直接对应于 <code>mul = primary (&quot;*&quot; primary | &quot;/&quot; primary)*</code> 产生式规则。</p><p>最后，让我们定义 <code>primary</code> 函数。 <code>primary</code> 不会读取左结合运算符，因此上面的代码并不遵循上面的模式，但是可以按原样使用产生式规则 <code>primary = &quot;(&quot; expr &quot;)&quot; | num</code> 来对应于函数调用。, <code>primary</code> 函数可以写成如下。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Node *<span class="title function_">primary</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="comment">// 如果下一个令牌是&quot;(&quot;，那么应该是&quot;(&quot; expr &quot;)&quot;的结构</span></span><br><span class="line">  <span class="keyword">if</span> (consume(<span class="string">&#x27;(&#x27;</span>)) &#123;</span><br><span class="line">    Node *node = expr();</span><br><span class="line">    expect(<span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 否则应该是一个数字</span></span><br><span class="line">  <span class="keyword">return</span> new_node_num(expect_number());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们已经有了所有的功能，我们真的可以解析令牌字符串吗？尽管乍一看可能并不明显，但您可以使用这组函数来正确解析令牌序列。例如，考虑表达式 <code>1+2*3</code> 。</p><p>第一个调用的是 <code>expr</code> 。它开始读取输入，假设整个表达式为 <code>expr</code> （在本例中确实如此）。然后，函数调用如下： <code>expr</code> → <code>mul</code> → <code>primary</code> ，读取令牌 <code>1</code> ，并读取令牌&lt; b6 &gt; 返回一个语法树，表示 1 作为返回值。</p><p>接下来， <code>expr</code> 中的表达式 <code>consume(&#39;+&#39;)</code> 变为 true，因此令牌 <code>+</code> 被消耗并返回 <code>mul</code> 将被调用。此阶段剩余的输入是 <code>2*3</code> 。</p><p>从 <code>mul</code> 开始，和之前一样调用了 <code>primary</code> ，并且读取了令牌 <code>2</code> ，但是这次 <code>mul</code> 是不会立即返回的。 <code>mul</code> 中的表达式 <code>consume(&#39;*&#39;)</code> 变为 true，因此 <code>mul</code> 再次调用 <code>primary</code> 并 <code>3</code> 将返回表示 <code>2*3</code> 的语法树。</p><p>在返回的目的地 <code>expr</code> 处，将表示 1 的语法树和表示 <code>2*3</code> 的语法树组合起来，构造表示 <code>1+2*3</code> 的语法树，即为返回 <code>expr</code> 的值。换句话说， <code>1+2*3</code> 被正确解析。</p><p>下图展示了函数调用关系以及每个函数读取的 token。下图中，整个 <code>1+2*3</code> 有一层 <code>expr</code> ，它代表对读取整个输入的 <code>expr</code> 的调用。 <code>expr</code> 上方有两个 <code>mul</code> ，但它们还有另一个 <code>mul</code> &gt; 表示调用。</p><p><img src="/../../../img/blog/ed3375792da2e2a04ad0dd81b3bb1500_MD5.svg"></p><p>解析 <code>1+2*3</code> 时的函数调用关系</p><p>下面显示了一个稍微复杂的示例。下图展示了解析 <code>1*2+(3+4)</code> 时的函数调用关系。</p><p><img src="/../../../img/blog/3c90870f3dae5e03d8aa63ce050caba4_MD5.svg"></p><p>解析 <code>1*2+(3+4)</code> 时的函数调用关系</p><p>对于不熟悉递归的程序员来说，像上面这样的递归函数可能会让人感到困惑。老实说，即使对于我这个应该非常熟悉递归的人来说，这种代码的工作也感觉像是一种魔法。即使您知道递归代码是如何工作的，它还是有一些奇怪的地方，而这可能就是它的本质。尝试一遍又一遍地在脑海中跟踪代码，以确保其正常工作。</p><p>如上所述将一个产生式规则映射到一个函数的解析方法称为 “ 递归降序解析 “。在上面的解析器中，只预读一个标记来决定调用或返回哪个函数。 (1) 称为解析器。另外，可以由 LL(1) 解析器编写的语法称为 LL(1) 语法。</p><h2 id="堆叠机"><a href="#堆叠机" class="headerlink" title="堆叠机"></a><a href="#%E3%82%B9%E3%82%BF%E3%83%83%E3%82%AF%E3%83%9E%E3%82%B7%E3%83%B3">堆叠机</a></h2><p>在上一章中，我们解释了将标记序列转换为抽象语法树的算法。通过选择考虑运算符优先级的语法， <code>*</code> 和 <code>/</code> 比 <code>+</code> 和 <code>-</code> 更好。现在我们可以创建一个抽象语法树的分支总是在树的顶部，但是我们如何将这棵树转换为汇编呢？本章解释了如何进行。</p><p>首先我们考虑一下为什么不能像加减法一样转换为汇编。可以执行加法和减法的编译器使用 RAX 作为结果寄存器并在那里执行加法和减法。也就是说，编译后的程序只保留了一个中间计算结果。</p><p>但涉及乘法和除法时，不保证中间计算结果只有一个。以 2_3+4_5 为例。为了进行加法，两边都必须计算，所以 2_3 和 4_5 必须在加法之前计算。换句话说，在这种情况下，除非能够存储两个中间计算结果，否则无法执行整个计算。</p><p>称为 “ 堆栈机 “ 的计算机可以轻松地执行这样的计算。让我们远离解析器创建的抽象语法树并了解堆栈机。</p><h3 id="编译到堆栈机"><a href="#编译到堆栈机" class="headerlink" title="编译到堆栈机"></a><a href="#%E3%82%B9%E3%82%BF%E3%83%83%E3%82%AF%E3%83%9E%E3%82%B7%E3%83%B3%E3%81%B8%E3%81%AE%E3%82%B3%E3%83%B3%E3%83%91%E3%82%A4%E3%83%AB">编译到堆栈机</a></h3><p>本节介绍如何将抽象语法树转换为堆栈机器码。如果你能做到这一点，你将能够解析由四个算术运算组成的表达式，组装抽象语法树，使用 x86-64 指令将其编译成堆栈机，并执行它。换句话说，将有可能编写一个可执行四种算术运算的编译器。</p><p>在堆栈机中，当计算子表达式时，结果的一个值（无论它是什么）都保留在堆栈顶部。例如，考虑下面的树。</p><p><img src="/../../../img/blog/b5a50cee05b8bcf8a30d76f472634ed2_MD5.svg"></p><p> 表示加法的抽象语法树</p><p><code>A</code> 和 <code>B</code> 是子树的抽象表示，实际上表示某种类型的节点。然而，在编译整个树时，树的具体类型或形状并不重要。要编译此树，请执行以下操作：</p><ol><li><p> 编译左子树</p></li><li><p> 编译右子树</p></li><li><p>输出将堆栈上的两个值替换为将它们相加的结果的代码</p></li></ol><p>执行完#1 中的代码后，无论具体代码是什么，栈顶都应该有一个值代表左子树的结果。类似地，运行 2 中的代码后，堆栈顶部应该有一个代表右子树结果的值。因此，为了计算整棵树的值，我们只需要将这两个值替换为它们的总值即可。</p><p>这样，当将抽象语法树编译到堆栈机时，我们会递归地思考并在树下降时输出程序集。尽管对于不熟悉递归概念的读者来说，这似乎有点困难，但它是处理树等自相似数据结构时的标准技术。</p><p> 让我们考虑下面的例子。</p><p><img src="/../../../img/blog/c6820209048de0d36fab3c94c1acd096_MD5.svg"></p><p> 表示加法和乘法的抽象语法树</p><p>执行代码生成的函数接收树的根节点。</p><p>按照上述步骤，该函数所做的第一件事是编译左子树。换句话说，我们将编译数字 2。 2 的计算结果是 2，所以该子树的编译结果是 <code>PUSH 2</code> 。</p><p>然后代码生成函数尝试编译右子树。这将递归地编译子树的左侧，从而输出 <code>PUSH 3</code> 。接下来我们将编译子树的右侧，它将输出 <code>PUSH 4</code> 。</p><p>然后代码生成函数返回到递归调用并输出与子树运算符的类型匹配的代码。第一个输出是将堆栈顶部的两个元素替换为它们的乘积的代码。接下来，输出用它们的和替换栈顶两个元素的代码。结果将是下面的组件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PUSH 2</span><br><span class="line">PUSH 3</span><br><span class="line">PUSH 4</span><br><span class="line">MUL</span><br><span class="line">ADD</span><br></pre></td></tr></table></figure><p>使用这种方法，抽象语法树可以机械地简化为汇编。</p><h3 id="如何在-x86-64-上创建堆栈机器"><a href="#如何在-x86-64-上创建堆栈机器" class="headerlink" title="如何在 x86-64 上创建堆栈机器"></a><a href="#x86-64%E3%81%AB%E3%81%8A%E3%81%91%E3%82%8B%E3%82%B9%E3%82%BF%E3%83%83%E3%82%AF%E3%83%9E%E3%82%B7%E3%83%B3%E3%81%AE%E5%AE%9F%E7%8F%BE%E6%96%B9%E6%B3%95">如何在 x86-64 上创建堆栈机器</a></h3><p>到目前为止，我们一直在讨论虚拟堆栈机。实际的 x86-64 是寄存器机，而不是堆栈机。 x86-64 操作通常被定义为在两个寄存器之间操作，而不是在堆栈顶部的两个值之间操作。因此，为了在 x86-64 上使用堆栈机技术，您需要使用寄存器机在某种意义上模拟堆栈机。</p><p>用寄存器机模拟堆栈机相对容易。堆栈机上的一条指令可以使用多条指令来实现。</p><p> 让我们解释一下具体的方法。</p><p>首先，准备一个指向堆栈顶部元素的寄存器。该寄存器称为堆栈指针。如果要弹出堆栈顶部的两个值，请取出堆栈指针指向的两个元素，并将它们更改为您从中删除堆栈指针的元素的数量。同样，压入时，您所要做的就是更改堆栈指针的值并写入它指向的内存区域。</p><p>x86-64 RSP 寄存器设计用作堆栈指针。 x86-64 上的 <code>push</code> 和 <code>pop</code> 等指令隐式使用 RSP 作为堆栈指针，修改其值，并访问 RSP 指向的内存，这是一个命令要做的事情。因此，当像堆栈机一样使用 x86-64 指令集时，可以直接使用 RSP 作为堆栈指针。现在，让我们使用 x86-64 作为堆栈机来编译表达式 <code>1+2</code> 。下面是 x86-64 程序集。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 将左操作数和右操作数推入栈中</span><br><span class="line">push 1</span><br><span class="line">push 2// 弹出左操作数和右操作数到RAX和RDI中，然后执行加法</span><br><span class="line">pop rdi</span><br><span class="line">pop rax</span><br><span class="line">add rax, rdi// 将相加的结果推入栈中</span><br><span class="line">push rax</span><br></pre></td></tr></table></figure><p>由于 x86-64 没有指令 “ 将 RSP 指向的两个元素相加 “，因此您需要将它们加载到寄存器中，执行加法，然后将结果推回堆栈。这就是上面的 <code>add</code> 命令的作用。</p><p>同样，在 x86-64 上实现 <code>2*3+4*5</code> 时，它看起来像这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 计算2*3并将结果推入栈中</span><br><span class="line">push 2</span><br><span class="line">push 3</span><br><span class="line">pop rdi</span><br><span class="line">pop rax</span><br><span class="line">mul rax, rdi</span><br><span class="line">push rax// 计算4*5并将结果推入栈中</span><br><span class="line">push 4</span><br><span class="line">push 5</span><br><span class="line">pop rdi</span><br><span class="line">pop rax</span><br><span class="line">mul rax, rdi</span><br><span class="line">push rax// 对栈顶的两个值进行相加</span><br><span class="line">// 即计算2*3+4*5</span><br><span class="line">pop rdi</span><br><span class="line">pop rax</span><br><span class="line">add rax, rdi</span><br><span class="line">push rax</span><br></pre></td></tr></table></figure><p>这样，通过使用 x86-64 堆栈操作指令，即使在 x86-64 上也可以运行与堆栈机非常相似的代码。</p><p>以下 <code>gen</code> 函数将此技术实现为 C 函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">gen</span><span class="params">(Node *node)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (node-&gt;kind == ND_NUM) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;  push %d\n&quot;</span>, node-&gt;val);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  gen(node-&gt;lhs);</span><br><span class="line">  gen(node-&gt;rhs);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;  pop rdi\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;  pop rax\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span> (node-&gt;kind) &#123;</span><br><span class="line">  <span class="keyword">case</span> ND_ADD:</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;  add rax, rdi\n&quot;</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> ND_SUB:</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;  sub rax, rdi\n&quot;</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> ND_MUL:</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;  imul rax, rdi\n&quot;</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> ND_DIV:</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;  cqo\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;  idiv rdi\n&quot;</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;  push rax\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然它在解析或代码生成中并不是特别重要，但上面的代码使用了 <code>idiv</code> 指令，该指令的规范很棘手，所以让我们解释一下。</p><p><code>idiv</code> 是执行有符号除法的指令。如果 x86-64 的 <code>idiv</code> 有一个简单的规范，上面的代码就会写成 <code>idiv rax, rdi</code> ，但是如果两个这样的寄存器是 则所采用的除法指令在 x86-64 上不存在。相反， <code>idiv</code> 隐式采用 RDX 和 RAX，将它们一起视为 128 位整数，将其除以参数寄存器的 64 位值，然后返回设置在 RAX 中，余数设置在黑索金。使用 <code>cqo</code> 指令，可以将 RAX 中的 64 位值扩展为 128 位，并在 RDX 和 RAX 中设置，因此在上面的代码中， <code>idiv</code> 在调用 <code>cqo</code> 。</p><p>好了，关于堆栈机的解释就到此结束了。到目前为止，您应该能够执行复杂的解析并将生成的抽象语法树转换为机器代码。让我们回去编写一个编译器来运用这些知识！</p><p>コラム:  专栏：优化编译器</p><p>我用来说明本章的 x86-64 程序集可能看起来效率很低。例如，将数字放入堆栈 <code>push</code> 然后 <code>pop</code> 的指令可以通过编写将值直接写入寄存器的指令作为 <code>mov</code> 。是。有些人可能会发现自己想要通过删除冗余来优化这些程序集。但不要屈服于这种诱惑。在代码生成的一开始，希望输出冗余代码以利于编译器的实现。</p><p>如果有必要，可以在以后将优化通行证添加到 9cc 中。重新扫描生成的程序集并将以特定模式出现的指令替换为其他指令并不困难。例如， <code>push</code> 之后的 “ <code>pop</code> 立即替换为 <code>mov</code> “ 或 “ 连续 <code>add</code> “ 具有立即值。如果您创建一个规则，例如 “ 如果它们被添加到同一个寄存器，请将它们替换为单个 <code>add</code> ，该 <code>add</code> 添加它们立即值的总和 “ 并机械地应用它，您可以减少冗余代码并使其有意义，你可以用更高效的代码替换它而不需要改变它。</p><p>混合代码生成和优化会使编译器变得复杂。如果代码从一开始就很困难，那么以后添加优化过程就相当困难。正如 Donald Knuth 所说，” 过早的优化是万恶之源。” 在您编写的编译器中，请仅考虑实现的难易程度。不必担心输出中明显的冗长内容；您可以稍后将其删除。</p><h2 id="第-5-步：创建一种可以执行四种算术运算的语言"><a href="#第-5-步：创建一种可以执行四种算术运算的语言" class="headerlink" title="第 5 步：创建一种可以执行四种算术运算的语言"></a><a href="#%E3%82%B9%E3%83%86%E3%83%83%E3%83%975%E5%9B%9B%E5%89%87%E6%BC%94%E7%AE%97%E3%81%AE%E3%81%A7%E3%81%8D%E3%82%8B%E8%A8%80%E8%AA%9E%E3%81%AE%E4%BD%9C%E6%88%90">第 5 步：创建一种可以执行四种算术运算的语言</a></h2><p>在本章中，我们将修改前面章节中创建的编译器并对其进行扩展，以便它可以处理包含优先括号的四种算术运算的表达式。所有必要的部分都已包含在内，因此只需编写少量新代码。尝试更改编译器的 <code>main</code> 函数以使用新创建的解析器和代码生成器。该代码应如下所示。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">    error(<span class="string">&quot;参数数量不正确&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 对输入进行词法分析和语法分析</span></span><br><span class="line">  user_input = argv[<span class="number">1</span>];</span><br><span class="line">  token = tokenize(user_input);</span><br><span class="line">  Node *node = expr();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 输出汇编的前半部分</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;.intel_syntax noprefix\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;.globl main\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;main:\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 遍历抽象语法树并生成代码</span></span><br><span class="line">  gen(node);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 栈顶应该保留整个表达式的值</span></span><br><span class="line">  <span class="comment">// 将其加载到RAX中并作为函数的返回值</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;  pop rax\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;  ret\n&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时，由加法、减法、乘法和优先级括号组成的表达式应该可以正确编译。让我们添加一些测试。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">assert 47 &#x27;5+6*7&#x27;</span><br><span class="line">assert 15 &#x27;5*(9-6)&#x27;</span><br><span class="line">assert 4 &#x27;(3+5)/2&#x27;</span><br></pre></td></tr></table></figure><p>请注意，为了便于解释，到目前为止的故事流程就好像 <code>*</code> 、 <code>/</code> 和 <code>()</code> 一次性全部实现。事实上，最好避免一次全部实施。由于最初有一个可以执行加法和减法的函数，因此首先尝试引入一个抽象语法树和一个使用它的代码生成器，而不破坏该函数。由于我们当时没有添加新功能，因此不需要新的测试。之后，请实施 <code>*</code> 、 <code>/</code> 和 <code>()</code> ，包括测试。</p><p> 参考实现</p><ul><li><a href="https://github.com/rui314/chibicc/commit/3c1e3831009edff2ea237d3e59680ba9d4bb2e14">3c1e3831009edff2</a></li></ul><p>コラム:  专栏：9cc 中的内存管理</p><p>如果您已经读完本书，您可能想知道内存管理在这个编译器中是如何工作的。到目前为止我们看到的代码使用了 calloc（malloc 的一个变体），但它没有调用 free。换句话说，分配的内存不会被释放。这不是有点疏忽吗？</p><p>事实上，这种 “ 不进行内存管理作为内存管理策略 “ 的设计是作者在考虑了各种权衡后有意选择的。</p><p>这种设计的优点是，通过不释放内存，您可以像编写具有垃圾收集器的语言一样编写代码。这不仅消除了编写内存管理代码的需要，还消除了与手动内存管理相关的神秘错误。</p><p>另一方面，考虑到它像普通 PC 一样在计算机上运行，​​实际上不存在因不释放而引起的问题。编译器是一个短暂的程序，它只读取单个 C 文件并输出汇编代码。当程序结束时，操作系统会自动释放所有分配的内存。因此，唯一的问题是总共分配多少内存，但根据我的实际测量，即使编译相当大的 C 文件，内存占用也只有 100 MiB 左右。</p><p>因此，不释放是一个现实有效的策略。例如，D 语言编译器 DMD 基于同样的思想，采用只分配不释放的策略。 </p><h2 id="步骤-6：一元加和一元减"><a href="#步骤-6：一元加和一元减" class="headerlink" title="步骤 6：一元加和一元减"></a><a href="#%E3%82%B9%E3%83%86%E3%83%83%E3%83%976%E5%8D%98%E9%A0%85%E3%83%97%E3%83%A9%E3%82%B9%E3%81%A8%E5%8D%98%E9%A0%85%E3%83%9E%E3%82%A4%E3%83%8A%E3%82%B9">步骤 6：一元加和一元减</a></h2><p>执行减法的 <code>-</code> 运算符不仅可以在两个术语之间使用，例如 <code>5-3</code> ，也可以在单个术语之间使用，例如 <code>-3</code> 您可以写在前面。类似地， <code>+</code> 运算符可以通过省略左侧而写为 <code>+3</code> 。像这样只使用一项的运算符称为 “ 一元运算符 “。另一方面，采用两项的运算符称为二元运算符。</p><p>除了 <code>+</code> 和 <code>-</code> 之外，C 还具有一元运算符，例如用于获取指针的 <code>&amp;</code> 和用于取消引用指针的 <code>*</code> 。 ，但在这一步中我们将只实现 <code>+</code> 和 <code>-</code> 。</p><p>一元 <code>+</code> 和一元 <code>-</code> 与二元 <code>+</code> 和 <code>-</code> 是相同的符号，但它们的定义不同。二进制 <code>-</code> 被定义为从左侧减去右侧的运算，但由于一元 <code>-</code> 本来就没有左侧，因此二进制 <code>-</code> 该定义本身没有任何意义。在 C 语言中，一元 <code>-</code> 被定义为反转右侧符号的运算。一元 <code>+</code> 是一个运算符，它返回右侧不变。这是一个并不真正需要使用的运算符，但它除了一元 <code>-</code> 之外还存在。</p><p>可以适当地将 <code>+</code> 和 <code>-</code> 视为具有相同名称、具有相似但不同定义的多个运算符：一元和二元。它是一元还是二元取决于上下文。包含一元 <code>+</code> &#x2F; <code>-</code> 的新语法如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">expr    = mul (&quot;+&quot; mul | &quot;-&quot; mul)*</span><br><span class="line">mul     = unary (&quot;*&quot; unary | &quot;/&quot; unary)*</span><br><span class="line">unary   = (&quot;+&quot; | &quot;-&quot;)? primary</span><br><span class="line">primary = num | &quot;(&quot; expr &quot;)&quot;</span><br></pre></td></tr></table></figure><p>上面的新语法添加了一个新的非终结符号 <code>unary</code> ，并且 <code>mul</code> 现在使用 <code>unary</code> 而不是 <code>primary</code> 。我是。 <code>X?</code> 是可选元素的 EBNF 语法，即 <code>X</code> 出现零次或一次。根据规则 <code>unary = (&quot;+&quot; | &quot;-&quot;)? primary</code> ，非终结符号 <code>unary</code> 可能有一个 <code>+</code> 或 <code>-</code> ，或者没有。它后面是 <code>primary</code> 。</p><p>检查 <code>-3</code> 、 <code>-(3+5)</code> 和 <code>-3*+5</code> 等表达式是否与此新语法匹配。 <code>-3*+5</code> 的语法树如下所示。</p><p><img src="/../../../img/blog/6f66164ff96d5c4c63b6023b64e7b911_MD5.svg"></p><p>让我们更改解析器以遵循这个新语法。像往常一样，解析器的更改应该通过将语法直接映射到函数调用来完成。解析 <code>unary</code> 的函数如下所示。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Node *<span class="title function_">unary</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (consume(<span class="string">&#x27;+&#x27;</span>))</span><br><span class="line">    <span class="keyword">return</span> primary();</span><br><span class="line">  <span class="keyword">if</span> (consume(<span class="string">&#x27;-&#x27;</span>))</span><br><span class="line">    <span class="keyword">return</span> new_node(ND_SUB, new_node_num(<span class="number">0</span>), primary());</span><br><span class="line">  <span class="keyword">return</span> primary();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里，我决定在解析阶段将 <code>+x</code> 替换为 <code>x</code> ，将 <code>-x</code> 替换为 <code>0-x</code> 。因此，此步骤不需要更改代码生成器。</p><p>您可以通过编写一些测试并将它们与添加一元 <code>+</code> &#x2F; <code>-</code> 的代码一起签入来完成此步骤。编写测试时，尽量将测试结果保持在 0-255 范围内。像 <code>-10+20</code> 这样的表达式使用一元 <code>-</code> 但整体值为正数，因此使用此测试。</p><p> 参考实现</p><ul><li><a href="https://github.com/rui314/chibicc/commit/bb5fe99dbad62c9516ec6a4bc64e444d09115e6d">bb5fe99dbad62c95</a></li></ul><h2 id="第-7-步：比较运算符"><a href="#第-7-步：比较运算符" class="headerlink" title="第 7 步：比较运算符"></a><a href="#%E3%82%B9%E3%83%86%E3%83%83%E3%83%977-%E6%AF%94%E8%BC%83%E6%BC%94%E7%AE%97%E5%AD%90">第 7 步：比较运算符</a></h2><p>在本节中： <code>&lt;</code> 、 <code>&lt;=</code> 、 <code>&gt;</code> 、 <code>&gt;=</code> 、 <code>==</code> 、 <code>!=</code> 实施。虽然这些比较运算符看起来有特殊含义，但它们实际上是将两个整数合并为一个，就像 <code>+</code> 和 <code>-</code> 一样，它是一个返回两个整数的普通二元运算符。就像 <code>+</code> 返回两边相加的结果一样，例如 <code>==</code> 如果两边相同则返回 1，如果不同则返回 0。</p><h3 id="分词器更改"><a href="#分词器更改" class="headerlink" title="分词器更改"></a><a href="#%E3%83%88%E3%83%BC%E3%82%AF%E3%83%8A%E3%82%A4%E3%82%B6%E3%81%AE%E5%A4%89%E6%9B%B4">分词器更改</a></h3><p>到目前为止我们处理的符号标记的长度都是一个字符，我们在代码中也假设了这一点，但是为了处理诸如 <code>==</code> 这样的比较运算符，我们对代码进行了泛化，需要这样做。让我们在 <code>Token</code> 结构中存储一个名为 <code>len</code> 的成员，以便我们可以将字符串的长度存储在令牌中。新的结构类型如下所示。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Token</span> &#123;</span></span><br><span class="line">  TokenKind kind; <span class="comment">// 令牌的类型</span></span><br><span class="line">  Token *next;    <span class="comment">// 下一个输入令牌</span></span><br><span class="line">  <span class="type">int</span> val;        <span class="comment">// 仅当kind为TK_NUM时使用，表示数值</span></span><br><span class="line">  <span class="type">char</span> *str;      <span class="comment">// 令牌字符串</span></span><br><span class="line">  <span class="type">int</span> len;        <span class="comment">// 令牌的长度</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>此更改还需要更改 <code>consume</code> 和 <code>expect</code> 等函数来改进它们，以便它们接受字符串而不是字符。这是一个进行了一些更改的示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">consume</span><span class="params">(<span class="type">char</span> *op)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (token-&gt;kind != TK_RESERVED ||</span><br><span class="line">      <span class="built_in">strlen</span>(op) != token-&gt;len ||</span><br><span class="line">      <span class="built_in">memcmp</span>(token-&gt;str, op, token-&gt;len))</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  token = token-&gt;next;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当对由多个字符组成的符号进行标记时，必须首先对较长的标记进行标记。例如，如果字符串的其余部分以 <code>&gt;</code> 开头，则可以使用 &lt; b3 如果您检查它以 &gt; 开头的可能性， <code>&gt;=</code> 将被错误地标记为两个标记， <code>&gt;</code> 和 <code>=</code> 。完毕。</p><h3 id="新语法"><a href="#新语法" class="headerlink" title="新语法"></a><a href="#%E6%96%B0%E3%81%97%E3%81%84%E6%96%87%E6%B3%95">新语法</a></h3><p>要向解析器添加对比较运算符的支持，请考虑添加比较运算符后语法会是什么样子。如果按照优先级从低到高的顺序编写到目前为止出现的运算符，它将如下所示：</p><ol><li><p><code>==</code> <code>!=</code></p></li><li><p><code>&lt;</code> <code>&lt;=</code> <code>&gt;</code> <code>&gt;=</code></p></li><li><p><code>+</code> <code>-</code></p></li><li><p><code>*</code> <code>/</code></p></li><li><p>一元 <code>+</code> 一元 <code>-</code></p></li><li><p><code>()</code></p></li></ol><p>优先级可以用生成语法来表达，其中具有不同优先级的运算符映射到不同的非终结符。如果我们以与 <code>expr</code> 和 <code>mul</code> 相同的方式考虑语法，则添加比较运算符的新语法如下。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">expr       = equality</span><br><span class="line">equality   = relational (&quot;==&quot; relational | &quot;!=&quot; relational)*</span><br><span class="line">relational = add (&quot;&lt;&quot; add | &quot;&lt;=&quot; add | &quot;&gt;&quot; add | &quot;&gt;=&quot; add)*</span><br><span class="line">add        = mul (&quot;+&quot; mul | &quot;-&quot; mul)*</span><br><span class="line">mul        = unary (&quot;*&quot; unary | &quot;/&quot; unary)*</span><br><span class="line">unary      = (&quot;+&quot; | &quot;-&quot;)? primary</span><br><span class="line">primary    = num | &quot;(&quot; expr &quot;)&quot;</span><br></pre></td></tr></table></figure><p><code>equality</code> 有 <code>==</code> 和 <code>!=</code> ， <code>relational</code> 有 <code>&lt;</code> ， <code>&lt;=</code> ， &lt; 它代表 b6&gt;和 <code>&gt;=</code> 。这些非终结符可以使用解析左关联运算符的模式直接映射到函数。</p><p>注意，在上面的语法中， <code>expr</code> 和 <code>equality</code> 被分开，表示整个表达式是 <code>equality</code> 。我本来可以将 <code>equality</code> 的右侧直接写在 <code>expr</code> 的右侧，但我认为上面的语法可能更容易阅读。</p><p>コラム: 专栏：简单而冗长的代码与高级而简洁的代码</p><p>在递归降序解析中，您编写的代码几乎完全对应于产生式规则，因此解析相似规则的函数看起来是相同的。您到目前为止编写的 <code>relational</code> 、 <code>equality</code> 、 <code>add</code> 和 <code>mul</code> 也应该具有类似的功能。</p><p>人们很自然地会想到如何使用元编程技术（例如 C 宏、C++ 模板、高阶函数和代码生成）更好地抽象这些函数的常见模式。事实上，这样的事情是可以做的。然而，本书并不是有意这样做的。理由如下。</p><p>简单的代码很容易理解，即使有些冗长。如果您稍后最终对类似的功能进行类似的更改，那么实际上没什么大不了的。另一方面，高度抽象的代码可能很难理解，因为您首先需要了解抽象机制，然后再了解如何使用它。例如，如果我在本书开始时编写了一个使用元编程生成递归下降解析函数的函数，那么这本书就会困难得多。</p><p>您不必总是以编写优雅而简洁的代码为目标。当你的目标是这样的时候，你往往会让代码变得更难，以至于不能再难了。</p><p>编写代码的人成为该代码的专家，因此他们倾向于认为从专家的角度来看简洁、精益的代码就是好代码，但大多数代码读者与作者有相同的感觉。没有必要这样。首先要精通它，所以你需要在某种程度上质疑自己作为代码编写者的感觉。创建易于理解和维护的程序的一项重要技术是有意编写简单的代码，必要时可以写得更好。</p><h3 id="汇编代码生成"><a href="#汇编代码生成" class="headerlink" title="汇编代码生成"></a><a href="#%E3%82%A2%E3%82%BB%E3%83%B3%E3%83%96%E3%83%AA%E3%82%B3%E3%83%BC%E3%83%89%E3%81%AE%E7%94%9F%E6%88%90">汇编代码生成</a></h3><p>在 x86-64 上，使用 cmp 指令进行比较。从堆栈中弹出两个整数，执行比较，如果它们相同则将 RAX 设置为 1，否则设置为 0，代码如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pop rdi</span><br><span class="line">pop rax</span><br><span class="line">cmp rax, rdi</span><br><span class="line">sete al</span><br><span class="line">movzb rax, al</span><br></pre></td></tr></table></figure><p>对于一个简短的程序集来说，代码有点冗长，所以让我们一步一步地完成它。</p><p>前两行将值从堆栈中弹出。第三行比较弹出的值。比较结果去哪儿了？在 x86-64 上，比较指令的结果设置在特殊的 “ 标志寄存器 “ 中。标志寄存器是每次执行整数运算或比较运算指令时更新的寄存器，包含指示结果是否为 0 的位、指示是否发生溢出的位、指示结果是否小于的位 0 等都有。</p><p>标志寄存器不是普通的整数寄存器，因此如果要将比较结果设置到 RAX 中，则需要将标志寄存器的特定位复制到 RAX 中。 <code>sete</code> 指令执行此操作。如果前一个 <code>cmp</code> 指令检查的两个寄存器中的值相同，则 <code>sete</code> 指令将指定寄存器（此处为 AL）设置为 1。否则设置为 0。</p><p>AL 是本书中尚未出现的新寄存器名称，但 AL 实际上只是另一个指向 RAX 低 8 位的寄存器。因此，当 <code>sete</code> 将值设置为 AL 时，RAX 也会自动更新。然而，当通过 AL 更新 RAX 时，高 56 位保持其原始值，因此如果要将整个 RAX 设置为 0 或 1，则必须将高 56 位清零。 <code>movzb</code> 指令执行此操作。如果 <code>sete</code> 指令可以直接写入 RAX 就好了，但是 <code>sete</code> 被设计为只接受 8 位寄存器作为参数，所以比较指令可以这样写我们将使用两条指令来设置 RAX 中的值。</p><p><img src="/../../../img/blog/06de9cc7e6089d326d9aa40e45c6a426_MD5.svg"></p><p>其他比较运算符可以使用其他指令代替 <code>sete</code> 来实现。使用 <code>setl</code> 表示 <code>&lt;</code> ，使用 <code>setle</code> 表示 <code>&lt;=</code> ，使用 <code>setne</code> 表示 <code>!=</code> 。请。</p><p><code>&gt;</code> 和 <code>&gt;=</code> 不需要代码生成器支持。请在解析器中切换两边并将其读取为 <code>&lt;</code> 或 <code>&lt;=</code> 。</p><p> 参考实现</p><ul><li><a href="https://github.com/rui314/chibicc/commit/6ddba4be5f63388607fc77fd786267b9ddcb14c9">6ddba4be5f633886</a></li></ul><hr><h1 id="单独编译和链接"><a href="#单独编译和链接" class="headerlink" title="单独编译和链接"></a><a href="#%E5%88%86%E5%89%B2%E3%82%B3%E3%83%B3%E3%83%91%E3%82%A4%E3%83%AB%E3%81%A8%E3%83%AA%E3%83%B3%E3%82%AF">单独编译和链接</a></h1><p>在此阶段之前，开发一直采用仅由一个 C 文件和一个测试 shell 脚本组成的文件结构。这个结构并没有什么问题，但是由于源代码越来越长，我决定将其拆分为多个 C 文件，以便于阅读。在这一步中，我们将把一个文件 9cc.c 拆分为以下五个文件。</p><ul><li><code>9cc.h</code> ：头文件</li><li><code>main.c</code> : <code>main</code> 功能</li><li><code>parse.c</code> ：解析器</li><li><code>codegen.c</code> ：代码生成器</li></ul><p>由于 <code>main</code> 函数很小，我可以将它放在另一个 C 文件中，但从语义上讲，它不属于 <code>parse.c</code> 或 <code>codegen.c</code> ，所以我会将其分成一个单独的文件。</p><p>本章解释了单独编译的概念及其意义，然后说明了具体步骤。</p><h2 id="什么是单独编译？"><a href="#什么是单独编译？" class="headerlink" title="什么是单独编译？"></a><a href="#%E5%88%86%E5%89%B2%E3%82%B3%E3%83%B3%E3%83%91%E3%82%A4%E3%83%AB%E3%81%A8%E3%81%AF">什么是单独编译？</a></h2><h3 id="单独编译及其必要性"><a href="#单独编译及其必要性" class="headerlink" title="单独编译及其必要性"></a><a href="#%E5%88%86%E5%89%B2%E3%82%B3%E3%83%B3%E3%83%91%E3%82%A4%E3%83%AB%E3%81%A8%E3%81%9D%E3%81%AE%E5%BF%85%E8%A6%81%E6%80%A7">单独编译及其必要性</a></h3><p>单独编译是指将程序分成多个源文件并分别编译来编写。通过分割编译，编译器读取程序的片段并输出相应的片段，而不是整个程序。包含不能单独执行的程序片段的文件称为 “ 目标文件 “（扩展名为 <code>.o</code> ）。在分割编译中，目标文件最终被连接在一起以创建单个文件。将目标文件组合成一个可执行文件的程序称为链接器。</p><p>让我们理解为什么我们需要单独编译。实际上，从技术上讲，没有必要拆分源。如果一次性向编译器提供所有源代码，理论上编译器可以在不借助链接器的情况下输出完整的可执行文件。</p><p>然而，这种方法要求编译器真正了解程序使用的所有代码。例如，诸如 <code>printf</code> 之类的标准库函数通常是标准库作者用 C 语言编写的函数，但为了避免链接步骤，此类函数的源代码每次都必须经过编译器运行.您需要将其提供给以下输入一遍又一遍地编译相同的函数通常只是浪费时间。因此，标准库通常以预编译目标文件的形式分发，因此不必每次都重新编译它们。也就是说，即使是由一份源代码组成的程序，只要使用了标准库，实际上也是采用单独编译的。</p><p>如果不单独编译，只更改一行就需要重新编译整个代码。编译几万行的代码可能需要几十秒的时间。一个大型项目可能有超过 1000 万行源代码，因此如果将其作为一个单元进行编译，则需要一天以上的时间。还需要以 100 GiB 为单位的内存。这样的构建过程是不现实的。</p><p>另一个问题是，简单地将所有函数和变量写在一个文件中会使人类难以管理。</p><p>由于上述原因，需要单独编译。</p><h3 id="头文件及其内容的必要性"><a href="#头文件及其内容的必要性" class="headerlink" title="头文件及其内容的必要性"></a><a href="#%E3%83%98%E3%83%83%E3%83%80%E3%83%95%E3%82%A1%E3%82%A4%E3%83%AB%E3%81%AE%E5%BF%85%E8%A6%81%E6%80%A7%E3%81%A8%E3%81%9D%E3%81%AE%E5%86%85%E5%AE%B9">头文件及其内容的必要性</a></h3><p>通过分割编译，编译器只能看到程序代码的一部分，但编译器甚至无法编译程序的最小部分。例如，考虑以下代码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">print_bar</span><span class="params">(<span class="keyword">struct</span> Foo *obj)</span> &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, obj-&gt;bar);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中，如果知道 <code>struct Foo</code> 的类型，就可以输出这段代码对应的程序集，否则将无法编译这个函数。</p><p>单独编译时，每个 C 文件必须包含足够的信息来编译每个单独的 C 文件。但是，如果您将所有代码编写在单独的文件中，则它将不再是单独的编译，因此您需要在某种程度上对信息进行选择性。</p><p>例如，考虑需要包含哪些信息才能输出调用另一个 C 文件中的函数的代码。编译器需要以下信息：</p><ul><li>首先，我们需要这样的信息：标识符是函数的名称。</li><li>编译器输出的函数调用代码按照一定的顺序在寄存器中设置参数，并使用 <code>call</code> 指令跳转到另一个函数的开头。根据参数类型，它还可以将整数转换为浮点数。如果参数的类型或数量不正确，您还应该显示错误消息。因此，我们需要函数的参数数量以及每个参数的类型。</li><li>被调用函数中发生的任何事情最终都会简单地返回给调用者，因此在编译调用函数时不需要被调用函数的代码。</li><li><code>call</code> 跳转到的地址在单独编译时是未知的，但是汇编器会输出一条跳转到地址 0 的 <code>call</code> 指令，并将其存储在目标文件中。保留信息 “ 用名为 Y 的函数的地址修改目标文件的 X 字节 “。链接器查看这些信息，确定可执行文件的布局，然后对程序片段进行二进制修补以修改跳转目标地址（此操作称为 “ 重定位 “）。因此，单独编译时虽然需要函数名，但不需要函数地址。</li></ul><p>综合以上需求，只要省略函数体中的 <code>&#123; … &#125;</code> ，就有足够的信息来调用函数了。没有函数体的函数称为函数的 “ 声明 “。声明仅告诉编译器类型和名称；它不包含函数的代码。例如，下面是 <code>strncmp</code> 的声明。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">strncmp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s1, <span class="type">const</span> <span class="type">char</span> *s2, <span class="type">size_t</span> n)</span>;</span><br></pre></td></tr></table></figure><p>通过查看上面的行，编译器可以知道 <code>strncmp</code> 是否存在及其类型。包含函数代码的声明称为 “ 定义 “。</p><p>将声明关键字 <code>extern</code> 添加到函数声明中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">strncmp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s1, <span class="type">const</span> <span class="type">char</span> *s2, <span class="type">size_t</span> n)</span>;</span><br></pre></td></tr></table></figure><p>但是，对于函数来说，可以通过省略函数体来区分声明和定义，因此不需要添加 <code>extern</code> 。</p><p>请注意，您只需要知道参数的类型，因此可以在声明中省略名称，但通常将名称写在声明中以使人们更容易理解。</p><p>将结构类型作为另一个示例。如果有两个或多个 C 文件使用相同的结构，则必须在每个 C 文件中为相同的结构编写声明。如果一种结构仅在一个 C 文件中使用，则其他 C 文件不需要知道它的存在。</p><p>在 C 中，编译其他 C 文件时需要的声明一起写在一个头文件中（扩展名为 <code>.h</code> ）。如果您在 <code>foo.h</code> 中编写声明，然后在另一个需要它的 C 文件中编写类似 <code>#include &quot;foo.h&quot;</code> 的内容，则行 <code>#include</code> 将被替换为 <code>foo.h</code> 文件的内容。</p><p><code>typedef</code> 等也用来告诉编译器类型信息。如果这些在多个 C 文件中使用，则必须将它们写入头文件中。</p><p>编译器在读取声明时不会输出任何程序集。声明是使用另一个文件中包含的函数或变量所需的信息，它本身并不定义该函数或变量。</p><p>根据到目前为止对单独编译的讨论，” 当使用 <code>printf</code> 时，将 <code>#include &lt;stdio.h&gt;</code> 写成咒语 “ 是什么意思？我想你可以理解。 C 标准库被隐式传递给链接器，因此链接器可以将包含函数调用的目标文件链接到 <code>printf</code> 以创建可执行文件。另一方面，默认情况下，编译器没有关于 <code>printf</code> 的特殊知识。 <code>printf</code> 不是内置函数，也没有规定自动加载标准库头文件，因此编译器在启动后对 <code>printf</code> 的情况一无所知。从这个状态开始，通过包含 C 标准库自带的头文件，编译器就可以知道 <code>printf</code> 的存在及其类型，并可以编译 <code>printf</code> 的函数调用了变成这样。</p><h3 id="链接错误"><a href="#链接错误" class="headerlink" title="链接错误"></a><a href="#%E3%83%AA%E3%83%B3%E3%82%AF%E3%82%A8%E3%83%A9%E3%83%BC">链接错误</a></h3><p>当目标文件最终被组装并传递给链接器时，它们必须包含足够的信息来构造整个程序。</p><p>如果程序只包含函数 <code>foo</code> 的声明而没有定义，则各个 C 文件都可以正常编译，包括调用 <code>foo</code> 的代码。然而，当链接器最终尝试创建一个完整的程序时，由于缺少 <code>foo</code> ， <code>foo</code> 的地址无法修改，因此出现错误。</p><p> 链接时发生的错误称为链接错误。</p><p>如果多个目标文件包含相同的函数或变量，也会发生链接错误。作为一名链接器，如果有重复，我真的不知道该选择哪一个。当您在头文件中写入错误的定义时，经常会发生此类重复错误。这是因为头文件包含在多个 C 文件中，所以如果一个头文件有定义，那么它将处于与在多个 C 文件中写入重复定义相同的状态。要解决这种错误，只需在头文件中写入声明，并将内容移至一个 C 文件中。</p><p>コラム:  列：重复定义和链接错误</p><p>当存在重复的定义时，链接器可以选择一个并忽略其余的定义。使用这样的链接器，重复的定义不会导致错误。</p><p>即使在实际的目标文件中，也可以选择是否允许每个定义重复，并且内联函数和 C++ 模板扩展结果以允许重复的方式包含在目标文件中。目标文件格式和链接器操作异常复杂，并且有很多例外，但这些操作只是例外。默认情况下，重复的定义通常会导致错误。</p><h3 id="全局变量的声明和定义"><a href="#全局变量的声明和定义" class="headerlink" title="全局变量的声明和定义"></a><a href="#%E3%82%B0%E3%83%AD%E3%83%BC%E3%83%90%E3%83%AB%E5%A4%89%E6%95%B0%E3%81%AE%E5%AE%A3%E8%A8%80%E3%81%A8%E5%AE%9A%E7%BE%A9">全局变量的声明和定义</a></h3><p>我们的编译器还没有全局变量，因此我们还没有它们的汇编示例，但全局变量与汇编级别的函数几乎相同。因此，和函数一样，全局变量也有定义和声明的区别。如果变量的主体在多个 C 文件中重复，通常会导致链接错误。</p><p>全局变量默认分配在不可执行的内存中，因此跳转到那里会导致程序因分段错误而崩溃，但除此之外，数据和代码之间本质上没有区别。在运行时，您可以像全局变量一样将函数作为数据读取，也可以通过更改内存属性以允许执行并跳转到数据来将数据作为代码执行。</p><p>让我们用一些实际代码来验证函数和全局变量本质上只是驻留在内存中的数据。在下面的代码中，标识符 <code>main</code> 被定义为全局变量。 <code>main</code> 的内容是 x86-64 机器语言。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> main[] = <span class="string">&quot;\x48\xc7\xc0\x2a\x00\x00\x00\xc3&quot;</span>;</span><br></pre></td></tr></table></figure><p>让我们将上面的 C 代码保存在名为 <code>foo.c</code> 的文件中，编译它，并使用 <code>objdump</code> 检查内容。默认情况下， <code>objdump</code> 仅以十六进制显示全局变量的内容，但您可以通过传递 <code>-D</code> 选项强制将数据反汇编为代码。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ cc -c foo.c</span><br><span class="line">$ objdump -D -M intel foo.o</span><br><span class="line">Disassembly of section .data:0000000000000000 &lt;main&gt;:</span><br><span class="line">   0:   48 c7 c0 2a 00 00 00    mov    rax,0x2a</span><br><span class="line">   7:   c3                      ret</span><br></pre></td></tr></table></figure><p>映射到非可执行区域的数据的默认行为可以通过在编译时传递选项 <code>-Wl,--omagic</code> 来更改。让我们使用此选项生成一个可执行文件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cc -static -Wl,--omagic -o foo foo.o</span><br></pre></td></tr></table></figure><p>函数和变量只是汇编中的标签，属于同一个命名空间，因此链接器在组合多个目标文件时并不关心哪些是函数，哪些是数据。因此，即使 <code>main</code> 在 C 级别被定义为数据，链接也会成功，就像 <code>main</code> 是一个函数一样。</p><p> 让我们运行生成的文件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ./foo</span><br><span class="line">$ echo $?</span><br><span class="line">42</span><br></pre></td></tr></table></figure><p>如上所示，正确返回值 42。全局变量 <code>main</code> 的内容作为代码执行。</p><p>在 C 语法中，对于全局变量，添加 <code>extern</code> 就成为声明。下面是 int 类型的全局变量 <code>foo</code> 的声明。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">extern int foo;</span><br></pre></td></tr></table></figure><p>如果你想编写一个包含 <code>foo</code> 的程序，你需要在头文件中写入上面的行。然后，您将在其中一个 C 文件中定义 <code>foo</code> 。下面是 <code>foo</code> 的定义。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int foo;</span><br></pre></td></tr></table></figure><p>注意，在 C 中，没有给出初始化表达式的全局变量被初始化为 0，因此此类变量可以设置为 0、 <code>&#123;0, 0, …&#125;</code> 、 <code>&quot;\0\0\0\0…&quot;</code></p><p>当编写像 <code>int foo = 3</code> 这样的初始化表达式时，只在定义中编写初始化表达式。声明仅告诉编译器变量的类型，因此不需要特定的初始化表达式。由于编译器在看到全局变量的声明时不会专门输出汇编，因此它不需要知道其内容是如何当场初始化的。</p><p>如果省略初始化表达式，则全局变量的声明和定义只是有或没有 <code>extern</code> ，因此它们看起来相似，但声明和定义不同。在此请您清楚地理解这一点。</p><h2 id="步骤8：分割文件并更改Makefile"><a href="#步骤8：分割文件并更改Makefile" class="headerlink" title="步骤8：分割文件并更改Makefile"></a><a href="#%E3%82%B9%E3%83%86%E3%83%83%E3%83%978-%E3%83%95%E3%82%A1%E3%82%A4%E3%83%AB%E5%88%86%E5%89%B2%E3%81%A8makefile%E3%81%AE%E5%A4%89%E6%9B%B4">步骤8：分割文件并更改Makefile</a></h2><h3 id="分割文件"><a href="#分割文件" class="headerlink" title="分割文件"></a><a href="#%E3%83%95%E3%82%A1%E3%82%A4%E3%83%AB%E3%81%AE%E5%88%86%E5%89%B2">分割文件</a></h3><p>尝试使用本章开头所示的配置来拆分文件。 <code>9cc.h</code> 是一个头文件。根据程序的结构，每个 <code>.c</code> 文件可能有一个 <code>.h</code> 文件，但额外的声明不会造成任何特定的危害。，没有必要管理这样的详细的依赖关系在这里。准备一个名为 <code>9cc.h</code> 的文件，并将其作为 <code>#include &quot;9cc.h&quot;</code> 包含在所有 C 文件中。</p><h3 id="生成文件更改"><a href="#生成文件更改" class="headerlink" title="生成文件更改"></a><a href="#makefile%E3%81%AE%E5%A4%89%E6%9B%B4">生成文件更改</a></h3><p>现在我们已经将程序更改为多个文件，让我们也更新 <code>Makefile</code> 。下面的 <code>Makefile</code> 编译并链接当前目录中的所有 .c 文件，以创建一个名为 9cc 的可执行文件。假设只有一个文件 9cc.h 作为项目头文件，并且所有 .c 文件都包含该头文件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">CFLAGS=-std=c11 -g -static</span><br><span class="line">SRCS=$(wildcard *.c)</span><br><span class="line">OBJS=$(SRCS:.c=.o)</span><br><span class="line"></span><br><span class="line">9cc: $(OBJS)</span><br><span class="line">        $(CC) -o 9cc $(OBJS) $(LDFLAGS)</span><br><span class="line"></span><br><span class="line">$(OBJS): 9cc.h</span><br><span class="line"></span><br><span class="line">test: 9cc</span><br><span class="line">        ./test.sh</span><br><span class="line"></span><br><span class="line">clean:</span><br><span class="line">        rm -f 9cc *.o *~ tmp*</span><br><span class="line"></span><br><span class="line">.PHONY: test clean</span><br></pre></td></tr></table></figure><p>注意 <code>Makefile</code> 的缩进必须是制表符。</p><p>在 <code>Makefile</code> 中，由冒号分隔的行和由制表符缩进的零个或多个命令行构成了一条规则。冒号之前的名称称为 “ 目标 “。冒号后的零个或多个文件名称为从属文件。</p><p>当您运行 <code>make foo</code> 时， <code>make</code> 尝试创建一个名为 <code>foo</code> 的文件。如果指定的目标文件已存在，则仅当目标文件早于依赖文件时， <code>make</code> 才会重新运行目标规则。这使得仅当源代码更改时才可以重新生成二进制文件等行为。</p><p><code>.PHONY</code> 是一个特殊名称，用于表示虚拟目标。 <code>make test</code> 和 <code>make clean</code> 不会执行来创建 <code>test</code> 和 <code>clean</code> 等文件，但通常 <code>make</code> 不会执行不知道这一点，所以如果碰巧存在名为 <code>test</code> 或 <code>clean</code> 的文件，它将使用 <code>make test</code> 或 <code>make clean</code> 不再做任何事。通过用 <code>.PHONY</code> 指定这样一个虚拟目标，你并不真的想创建一个具有该名称的文件，但是无论指定的目标文件是否存在，规则都会被执行。你可以告诉 <code>make</code> 应该执行命令。</p><p><code>CFLAGS</code> 、 <code>SRCS</code> 和 <code>OBJS</code> 是变量。</p><p><code>CFLAGS</code> 是 make 的内置规则识别的变量，包含要传递给 C 编译器的命令行选项。在这里我们传递以下标志：</p><ul><li><code>-std=c11</code> ：告诉源代码是用最新的 C 标准 C11 编写的。</li><li><code>-g</code> ：输出调试信息</li><li><code>-static</code> ：静态链接</li></ul><p><code>SRCS</code> 右侧使用的 <code>wildcard</code> 是 make 提供的函数，扩展为与函数参数匹配的文件名。 <code>$(wildcard *.c)</code> 目前扩展为 <code>main.c parse.c codegen.c</code> 。</p><p><code>OBJS</code> 右侧使用变量替换规则生成一个值，将 SRC 中的.c 替换为.o。 <code>SRCS</code> 变为 <code>main.c parse.c codegen.c</code> ，因此 <code>OBJS</code> 变为 <code>main.o parse.o codegen.o</code> 。</p><p>考虑到这些事情，让我们跟踪一下执行 <code>make 9cc</code> 时发生的情况。该命令的最终目标是创建 <code>9cc</code> 文件，因为 make 尝试生成指定为参数的目标（如果没有参数，则选择第一个规则，因此在本例中，9cc 执行无需指定）。 make 通过遍历依赖项并尝试构建丢失或过时的文件来实现此目的。</p><p><code>9cc</code> 的依赖文件是当前目录中与 <code>.c</code> 文件对应的 <code>.o</code> 文件。如果 <code>.o</code> 文件在上次运行 make 时保留下来，并且它的时间戳比相应的 <code>.c</code> 文件更新，那么 make 会费心重新运行相同的命令。我不这样做那。仅当 <code>.o</code> 文件不存在或 <code>.c</code> 文件较新时才运行编译器生成 <code>.o</code> 文件。</p><p>规则 <code>$(OBJS): 9cc.h</code> 表示所有 <code>.o</code> 文件依赖于 <code>9cc.h</code> 。因此，如果更改 <code>9cc.h</code> ，所有 <code>.o</code> 文件都将重新编译。</p><p>コラム:  专栏：static 关键字的各种含义</p><p>C 中的 <code>static</code> 关键字有两个主要用途：</p><ol><li><p>将 <code>static</code> 添加到局部变量，以便即使退出函数后它们的值也能保存</p></li><li><p>在全局变量和函数中添加 <code>static</code> ，使变量和函数的作用域成为文件作用域。</p></li></ol><p>虽然这两种用法没有什么共同点，但是它们使用了相同的关键字，这是学习 C 时的困惑点之一。理想情况下，他们应该使用不同的关键字，例如用于用法 1 的 <code>persistent</code> 和用于用法 2 的 <code>private</code> 。更理想的情况是，对于用法 2，最好使用 <code>private</code> 作为默认值并将 <code>public</code> 附加到全局范围内的变量和函数。</p><p>C 重用关键字的原因是为了与过去编写的代码资产兼容。如果向语言添加新关键字（例如 <code>private</code> ），则使用该关键字作为变量或函数名称的现有程序将不再编译。 C 不喜欢这样，因此他决定在不同的上下文中重用现有的关键字，而不是添加更多关键字。</p><p>如果我在 20 世纪 70 年代的某个时候决定添加新关键字而不是重复使用 <code>static</code> 关键字，我可能可以节省大量的代码更改。如果您考虑到那时该怎么做，那就是相当困难的问题。</p><hr><h1 id="函数和局部变量"><a href="#函数和局部变量" class="headerlink" title="函数和局部变量"></a><a href="#%E9%96%A2%E6%95%B0%E3%81%A8%E3%83%AD%E3%83%BC%E3%82%AB%E3%83%AB%E5%A4%89%E6%95%B0">函数和局部变量</a></h1><p>在本章中，我们将实现函数和局部变量。我们还实现了一个简单的控制结构。完成本章后，您将能够编译如下代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// mからnまでを足す</span><br><span class="line">sum(m, n) &#123;</span><br><span class="line">  acc = 0;</span><br><span class="line">  for (i = m; i &lt;= n; i = i + 1)</span><br><span class="line">    acc = acc + i;</span><br><span class="line">  return acc;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main() &#123;</span><br><span class="line">  return sum(1, 10); // 55を返す</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然上面的代码和 C 还有差距，但我想可以说已经相当接近 C 了。</p><h2 id="第9步：单字符局部变量"><a href="#第9步：单字符局部变量" class="headerlink" title="第9步：单字符局部变量"></a><a href="#%E3%82%B9%E3%83%86%E3%83%83%E3%83%9791%E6%96%87%E5%AD%97%E3%81%AE%E3%83%AD%E3%83%BC%E3%82%AB%E3%83%AB%E5%A4%89%E6%95%B0">第9步：单字符局部变量</a></h2><p>到上一章为止，我们已经能够为可以执行四种算术运算的语言创建编译器。在本节中，我们将向该语言添加功能以允许使用变量。具体来说，目标是能够编译包含变量的多个语句，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = 3;</span><br><span class="line">b = 5 * 6 - 8;</span><br><span class="line">a + b / 2;</span><br></pre></td></tr></table></figure><p>我们用最后一个表达式的结果作为整个程序的计算结果。我认为你可以说这种语言比只使用四个算术运算的语言具有更 “ 真实的语言 “ 感觉。</p><p>在本章中，我们将首先解释如何实现变量，然后我们将逐步实现变量。</p><h3 id="栈上的变量区"><a href="#栈上的变量区" class="headerlink" title="栈上的变量区"></a><a href="#%E3%82%B9%E3%82%BF%E3%83%83%E3%82%AF%E4%B8%8A%E3%81%AE%E5%A4%89%E6%95%B0%E9%A0%98%E5%9F%9F">栈上的变量区</a></h3><p>C 中的变量存在于内存中。您可以说变量是带有名称的内存地址。通过命名内存地址，您可以表达诸如 “ 访问变量 <code>a</code> “ 之类的内容，而不是 “ 访问内存地址 0x6080”。它会的。</p><p>但是，函数的局部变量对于每个函数调用都必须单独存在。仅考虑实现的方便性，固定地址似乎很容易，例如 “ 函数 <code>f</code> 的局部变量 <code>a</code> 放在地址 0x6080。”，那就赢了如果递归调用 <code>f</code> 则不起作用。在 C 中，局部变量放置在堆栈上，以便每个函数调用都有一个单独的局部变量。</p><p>让我们用一个具体的例子来考虑堆栈的内容。假设您有一个带有局部变量 <code>a</code> 和 <code>b</code> 的函数 <code>f</code> ，以及一些其他函数调用 <code>f</code> 。函数调用的 <code>call</code> 指令将返回地址放入堆栈中，因此调用 <code>f</code> 时的堆栈顶部将包含该返回地址。除此之外，还假设堆栈最初包含一些值。具体值在这里并不重要，所以我们用 “…” 来表示。如果你制作一个图表，它将如下所示：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>…</td><td></td></tr><tr><td>返回地址</td><td>← RSP</td></tr></tbody></table><p>这里，我们将使用符号 “← RSP” 来表示当前的 RSP 寄存器值指向该地址。 <code>a</code> 和 <code>b</code> 的大小各为 8 字节。</p><p>堆栈向下增长。为了从该状态确保 <code>a</code> 和 <code>b</code> 的空间，需要将 RSP 减少两个变量，总共 16 字节。当你这样做时，它看起来像这样：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>…</td><td></td></tr><tr><td>返回地址</td><td></td></tr><tr><td>a</td><td></td></tr><tr><td>b</td><td>← RSP</td></tr></tbody></table><p>通过上述布局，您可以使用 RSP+8 值访问 <code>a</code> ，使用 RSP 值访问 <code>b</code> 。为每个函数调用保留的存储区域称为 “ 函数帧 “ 或 “ 激活记录 “。</p><p>RSP 中要更改的字节数以及以这种方式保护的区域中变量的放置顺序对于其他函数来说是不可见的，因此它们是根据编译器实现适当确定的。没关系。</p><p>基本上，局部变量的实现就像这样简单的事情。</p><p>然而，这种方法有一个缺点，因此实际实现时会多使用一个寄存器。回想一下，在我们的编译器（以及其他编译器）中，RSP 可能会在函数运行时发生变化。 9cc 使用 RSP 将公式中间的计算结果压入&#x2F;弹出到堆栈上，因此 RSP 值经常变化。因此， <code>a</code> 和 <code>b</code> 无法以 RSP 的固定偏移量进行访问。</p><p>解决此问题的常见方法是使用一个与 RSP 分开的寄存器，该寄存器始终指向当前函数帧的开头。这样的寄存器称为 “ 基址寄存器 “，其中包含的值称为 “ 基址指针 “。按照惯例，x86-64 使用 RBP 寄存器作为基址寄存器。</p><p>基指针在函数执行期间不得更改（这就是我们有基指针的原因）。你不能只从一个函数调用另一个函数并在返回时具有不同的值，因此你需要保存每个函数调用的原始基指针并在返回之前将其写回。</p><p>下图显示了使用基指针调用函数时堆栈的状态。假设带有局部变量 <code>x</code> 和 <code>y</code> 的函数 <code>g</code> 调用 <code>f</code> 。当 <code>g</code> 运行时，堆栈如下所示：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>…</td><td></td></tr><tr><td>g 的返回地址</td><td></td></tr><tr><td>呼叫 g 时的 RBP</td><td>← RBP</td></tr><tr><td>x</td><td></td></tr><tr><td>y</td><td>← RSP</td></tr></tbody></table><p>从此处调用 <code>f</code> 会导致以下状态：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>…</td><td></td></tr><tr><td>g 的返回地址</td><td></td></tr><tr><td>呼叫 g 时的 RBP</td><td></td></tr><tr><td>x</td><td></td></tr><tr><td>y</td><td></td></tr><tr><td>f 的返回地址</td><td></td></tr><tr><td>呼叫 f 时的 RBP</td><td>← RBP</td></tr><tr><td>a</td><td></td></tr><tr><td>b</td><td>← RSP</td></tr></tbody></table><p>这样， <code>a</code> 总是可以用地址 RBP-8 访问，而 <code>b</code> 则可以用地址 RBP-16 访问。如果我们专门考虑创建此堆栈状态的程序集，则编译器应在每个函数的开头输出以下程序集。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">push rbp</span><br><span class="line">mov rbp, rsp</span><br><span class="line">sub rsp, 16</span><br></pre></td></tr></table></figure><p>编译器在函数开头输出的标准指令称为 “ 序言 “。请注意，16 实际上需要是与每个函数的变量数量和大小相匹配的值。</p><p>让我们确认一下，当我们使用指向返回地址的 RSP 执行上述代码时，会创建预期的函数框架。每条指令的堆栈状态如下所示。</p><p> 使用 <code>call</code> 调用 <code>f</code> 后立即堆栈</p><table><thead><tr><th>-</th><th>-</th></tr></thead><tbody><tr><td>…</td><td></td></tr><tr><td>g 的返回地址</td><td></td></tr><tr><td>呼叫 g 时的 RBP</td><td>← RBP</td></tr><tr><td>x</td><td></td></tr><tr><td>y</td><td></td></tr><tr><td>f 的返回地址</td><td>← RSP</td></tr></tbody></table><p>  运行 <code>push rbp</code> 后的堆栈</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>…</td><td></td></tr><tr><td>g 的返回地址</td><td></td></tr><tr><td>呼叫 g 时的 RBP</td><td>← RBP</td></tr><tr><td>x</td><td></td></tr><tr><td>y</td><td></td></tr><tr><td>f 的返回地址</td><td></td></tr><tr><td>呼叫 f 时的 RBP</td><td>← RSP</td></tr></tbody></table><p>  运行 <code>mov rbp, rsp</code> 后的堆栈</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>…</td><td></td></tr><tr><td>g 的返回地址</td><td></td></tr><tr><td>呼叫 g 时的 RBP</td><td></td></tr><tr><td>x</td><td></td></tr><tr><td>y</td><td></td></tr><tr><td>f 的返回地址</td><td></td></tr><tr><td>呼叫 f 时的 RBP</td><td>← RSP、RBP</td></tr></tbody></table><p> 运行 <code>sub rsp, 16</code> 后的堆栈</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>…</td><td></td></tr><tr><td>g 的返回地址</td><td></td></tr><tr><td>呼叫 g 时的 RBP</td><td></td></tr><tr><td>x</td><td></td></tr><tr><td>y</td><td></td></tr><tr><td>f 的返回地址</td><td></td></tr><tr><td>呼叫 f 时的 RBP</td><td>← RBP</td></tr><tr><td>a</td><td></td></tr><tr><td>b</td><td>← RSP</td></tr></tbody></table><p>从函数返回时，将原值写回 RBP，使 RSP 指向返回地址，并调用 <code>ret</code> 指令（ <code>ret</code> 指令（这是一条弹出指令）来自并跳转到它的地址。）执行此操作的代码可以简单地编写如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov rsp, rbp</span><br><span class="line">pop rbp</span><br><span class="line">ret</span><br></pre></td></tr></table></figure><p>编译器在函数末尾输出的标准指令称为 “ 尾声 “。</p><p>运行尾声时堆栈的状态如下所示。 RSP 指向的地址以下的堆栈区域不再被认为是无效数据，因此在图中被省略。</p><p> 执行 <code>mov rsp, rbp</code> 之前堆栈</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>…</td><td></td></tr><tr><td>g 的返回地址</td><td></td></tr><tr><td>呼叫 g 时的 RBP</td><td></td></tr><tr><td>x</td><td></td></tr><tr><td>y</td><td></td></tr><tr><td>f 的返回地址</td><td></td></tr><tr><td>呼叫 f 时的 RBP</td><td>← RBP</td></tr><tr><td>a</td><td></td></tr><tr><td>b</td><td>← RSP</td></tr></tbody></table><p>  运行 <code>mov rsp, rbp</code> 后的堆栈</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>…</td><td></td></tr><tr><td>g 的返回地址</td><td></td></tr><tr><td>呼叫 g 时的 RBP</td><td></td></tr><tr><td>x</td><td></td></tr><tr><td>y</td><td></td></tr><tr><td>f 的返回地址</td><td></td></tr><tr><td>呼叫 f 时的 RBP</td><td>← RSP、RBP</td></tr></tbody></table><p> 运行 <code>pop rbp</code> 后的堆栈</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>…</td><td></td></tr><tr><td>g 的返回地址</td><td></td></tr><tr><td>呼叫 g 时的 RBP</td><td>← RBP</td></tr><tr><td>x</td><td></td></tr><tr><td>y</td><td></td></tr><tr><td>f 的返回地址</td><td>← RSP</td></tr></tbody></table><p>  运行 <code>ret</code> 后的堆栈</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>…</td><td></td></tr><tr><td>g 的返回地址</td><td></td></tr><tr><td>呼叫 g 时的 RBP</td><td>← RBP</td></tr><tr><td>x</td><td></td></tr><tr><td>y</td><td>← RSP</td></tr></tbody></table><p>因此，通过执行尾声，调用函数 <code>g</code> 的堆栈状态被恢复。 <code>call</code> 指令将 <code>call</code> 指令本身后面的指令的地址压入堆栈。尾声中的 <code>ret</code> 弹出该地址并跳转到那里，因此函数 <code>g</code> 的执行从 <code>call</code> 后面的指令继续执行。这种行为与我们所知的函数的行为完全一致。</p><p>这就是函数调用和函数局部变量的实现方式。</p><h3 id="分词器更改-1"><a href="#分词器更改-1" class="headerlink" title="分词器更改"></a><a href="#%E3%83%88%E3%83%BC%E3%82%AF%E3%83%8A%E3%82%A4%E3%82%B6%E3%81%AE%E5%A4%89%E6%9B%B4-1">分词器更改</a></h3><p>现在您已经知道如何实现变量了，让我们开始实现它们吧。然而，支持任意数量的变量很快就变得太困难了，所以我们决定在这一步中将变量限制为单个小写字母，因此变量 <code>a</code> 是 RBP-8，变量 <code>b</code> 是 RBP-16，变量 <code>c</code> 是 RBP-24，依此类推。由于字母表中有 26 个字符，如果我们决定将 RSP 下推 26 x 8，即 208 个字节，那么在调用该函数时，我们将能够为所有单字符变量保留空间。</p><p>我们现在就来实现它。首先，让我们修改分词器，使其除了前面的语法元素之外还可以对单字符变量进行分词。为此，我们需要添加新的令牌类型。由于可以从 <code>str</code> 成员中读取变量名，因此无需向 <code>Token</code> 类型添加新成员。因此，令牌类型为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">  TK_RESERVED, <span class="comment">// 符号</span></span><br><span class="line">  TK_IDENT,    <span class="comment">// 标识符</span></span><br><span class="line">  TK_NUM,      <span class="comment">// 整数令牌</span></span><br><span class="line">  TK_EOF,      <span class="comment">// 表示输入结束的令牌</span></span><br><span class="line">&#125; TokenKind;</span><br></pre></td></tr></table></figure><p>修改标记生成器，为字母表中的小写字母创建 <code>TK_IDENT</code> 类型的标记。您应该将以下 <code>if</code> 语句添加到标记生成器中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="string">&#x27;a&#x27;</span> &lt;= *p &amp;&amp; *p &lt;= <span class="string">&#x27;z&#x27;</span>) &#123;</span><br><span class="line">  cur = new_token(TK_IDENT, cur, p++);</span><br><span class="line">  cur-&gt;len = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="解析器的变化"><a href="#解析器的变化" class="headerlink" title="解析器的变化"></a><a href="#%E3%83%91%E3%83%BC%E3%82%B5%E3%81%AE%E5%A4%89%E6%9B%B4">解析器的变化</a></h3><p>通过递归下降解析，如果您知道语法，则可以将其机械地映射到函数调用。因此，为了考虑应该对解析器进行更改，有必要考虑添加变量名（标识符）时新语法将是什么样子。</p><p>我们将标识符称为 <code>ident</code> 。这是一个终结符，就像 <code>num</code> 一样。任何可以使用数字的地方都可以使用变量，因此将 <code>num</code> 替换为 <code>num | ident</code> 创建的语法允许在与数字相同的位置使用变量。</p><p>除此之外，我们还需要在语法中添加一个赋值表达式。由于无法分配变量，我们希望创建一种允许 <code>a=1</code> 等表达式的语法。在这里，我们使用可以写成 <code>a=b=1</code> 的语法来匹配 C。</p><p>此外，我希望能够编写用分号分隔的多个语句，因此生成的新语法如下。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">program    = stmt*</span><br><span class="line">stmt       = expr &quot;;&quot;</span><br><span class="line">expr       = assign</span><br><span class="line">assign     = equality (&quot;=&quot; assign)?</span><br><span class="line">equality   = relational (&quot;==&quot; relational | &quot;!=&quot; relational)*</span><br><span class="line">relational = add (&quot;&lt;&quot; add | &quot;&lt;=&quot; add | &quot;&gt;&quot; add | &quot;&gt;=&quot; add)*</span><br><span class="line">add        = mul (&quot;+&quot; mul | &quot;-&quot; mul)*</span><br><span class="line">mul        = unary (&quot;*&quot; unary | &quot;/&quot; unary)*</span><br><span class="line">unary      = (&quot;+&quot; | &quot;-&quot;)? primary</span><br><span class="line">primary    = num | ident | &quot;(&quot; expr &quot;)&quot;</span><br></pre></td></tr></table></figure><p>首先，检查 <code>42;</code> 和 <code>a=b=2; a+b;</code> 等程序是否符合此语法。之后，修改您到目前为止创建的解析器，以便它可以解析上述语法。在这个阶段，像 <code>a+1=5</code> 这样的表达式也可以被解析，这是正确的。消除此类语义上无效的表达式将在下一步中完成。修改解析器没有什么特别棘手的，您应该能够像以前一样通过将语法元素映射到函数调用来完成此操作。</p><p>由于我们通过用分号分隔来乘以多个表达式，因此我们需要将多个节点作为解析结果保存在某处。现在，请准备以下全局数组并按顺序存储解析结果节点。如果用 NULL 填充最后一个节点，您将能够看到它的结束位置。下面显示了一些要添加的新代码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Node *code[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line">Node *<span class="title function_">assign</span><span class="params">()</span> &#123;</span><br><span class="line">  Node *node = equality();</span><br><span class="line">  <span class="keyword">if</span> (consume(<span class="string">&quot;=&quot;</span>))</span><br><span class="line">    node = new_node(ND_ASSIGN, node, assign());</span><br><span class="line">  <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Node *<span class="title function_">expr</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> assign();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Node *<span class="title function_">stmt</span><span class="params">()</span> &#123;</span><br><span class="line">  Node *node = expr();</span><br><span class="line">  expect(<span class="string">&quot;;&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">program</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (!at_eof())</span><br><span class="line">    code[i++] = stmt();</span><br><span class="line">  code[i] = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>抽象语法树需要能够表达一个新的 “ 代表局部变量的节点 “。为此，我们为局部变量添加一个新类型，为节点添加一个新成员。例如，它应该如下所示：此数据结构使解析器为标识符标记创建并返回类型为 <code>ND_LVAR</code> 的节点。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">  ND_ADD,    <span class="comment">// +</span></span><br><span class="line">  ND_SUB,    <span class="comment">// -</span></span><br><span class="line">  ND_MUL,    <span class="comment">// *</span></span><br><span class="line">  ND_DIV,    <span class="comment">// /</span></span><br><span class="line">  ND_ASSIGN, <span class="comment">// =</span></span><br><span class="line">  ND_LVAR,   <span class="comment">// 局部变量</span></span><br><span class="line">  ND_NUM,    <span class="comment">// 整数</span></span><br><span class="line">&#125; NodeKind;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> <span class="title">Node</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象语法树节点</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">  NodeKind kind; <span class="comment">// 节点类型</span></span><br><span class="line">  Node *lhs;     <span class="comment">// 左操作数</span></span><br><span class="line">  Node *rhs;     <span class="comment">// 右操作数</span></span><br><span class="line">  <span class="type">int</span> val;       <span class="comment">// 仅在kind为ND_NUM时使用</span></span><br><span class="line">  <span class="type">int</span> offset;    <span class="comment">// 仅在kind为ND_LVAR时使用</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>offset</code> 是一个成员，表示距局部变量基指针的偏移量。目前，局部变量处于由名称决定的固定位置，例如 RBP-8 中的变量 <code>a</code> 、RBP-16 中的 <code>b</code> 等，因此偏移量为语法这样可以在分析阶段确定。下面的代码读取标识符并返回 <code>ND_LVAR</code> 类型的节点。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Node *<span class="title function_">primary</span><span class="params">()</span> &#123;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  Token *tok = consume_ident();</span><br><span class="line">  <span class="keyword">if</span> (tok) &#123;</span><br><span class="line">    Node *node = <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="keyword">sizeof</span>(Node));</span><br><span class="line">    node-&gt;kind = ND_LVAR;</span><br><span class="line">    node-&gt;offset = (tok-&gt;str[<span class="number">0</span>] - <span class="string">&#x27;a&#x27;</span> + <span class="number">1</span>) * <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ...</span><br></pre></td></tr></table></figure><h3 id="左值和右值"><a href="#左值和右值" class="headerlink" title="左值和右值"></a><a href="#%E5%B7%A6%E8%BE%BA%E5%80%A4%E3%81%A8%E5%8F%B3%E8%BE%BA%E5%80%A4">左值和右值</a></h3><p>与其他二元运算符不同，赋值表达式需要对左侧的值进行特殊处理，所以我们在这里解释一下。</p><p>赋值表达式的左侧不仅仅允许任何表达式。例如，1 不能是 2，如 <code>1=2</code> 。像 <code>a=2</code> 这样的赋值是允许的，但是像 <code>(a+1)=2</code> 这样的语句是非法的。 9cc 中还没有指针或结构，但如果它们确实存在，您将能够分配给像 <code>*p=2</code> 或 <code>a.b=2</code></p><p>这个问题有一个简单的答案。在 C 语言中，只有指定内存地址的表达式才能出现在赋值表达式的左侧。</p><p>变量存在于内存中并且有地址，因此变量可以写在赋值语句的左边。同样，像 <code>*p</code> 这样的指针引用也可以写在左侧，因为 <code>p</code> 的值是一个地址。像 <code>a.b</code> 这样的结构的成员访问也在内存中执行，内存中的成员访问距离现有结构 <code>a</code> 的起始位置提前了成员 <code>b</code> 的偏移量在内存中，由于它指向一个地址，所以可以把它写在左边。</p><p>另一方面，像 <code>a+1</code> 这样的表达式的结果不是变量，因此它不能用作指定内存地址的表达式。这些临时值实际上可能只存在于寄存器中，而不存在于内存中，而且即使它们确实存在于内存中，也无法以已知变量的固定偏移量来访问它们。通常情况下是不能的。因此，即使你写成 <code>&amp;(a+1)</code> ，也无法获取 <code>a+1</code> 结果的地址，会导致编译错误。这些表达式不能写在赋值语句的左侧。</p><p>左边可写的值称为左值，不可写的值称为右值。左值和右值也分别称为左值和右值。在我们今天的语言中，只有变量是左值；所有其他值都是右值。</p><p>为变量生成代码时，可以从左值开始。如果变量出现在赋值的左侧，则将该变量的地址计算为左侧的值，并将右侧的计算结果存储在该地址处。这允许您实现赋值表达式。如果该变量出现在任何其他上下文中，请通过以相同方式计算变量的地址，然后从该地址加载值，将左值转换为右值。这允许您获取变量的值。</p><h3 id="如何从任意地址加载值"><a href="#如何从任意地址加载值" class="headerlink" title="如何从任意地址加载值"></a><a href="#%E4%BB%BB%E6%84%8F%E3%81%AE%E3%82%A2%E3%83%89%E3%83%AC%E3%82%B9%E3%81%8B%E3%82%89%E5%80%A4%E3%82%92%E3%83%AD%E3%83%BC%E3%83%89%E3%81%99%E3%82%8B%E6%96%B9%E6%B3%95">如何从任意地址加载值</a></h3><p>到目前为止，代码生成仅访问了堆栈顶部的内存，但局部变量需要访问堆栈上的任何位置。本节介绍如何访问内存。</p><p>CPU 可以从内存中的任何地址加载和存储值，而不仅仅是栈顶。</p><p>从内存加载值时，请使用 <code>mov dst, [src]</code> 语法。该指令的意思是 “ 将 src 寄存器的值视为地址，从那里加载该值并将其保存到 dst。” 例如， <code>mov rdi, [rax]</code> 表示从 RAX 中的地址加载该值并在 RDI 中设置。</p><p>存储时，使用 <code>mov [dst], src</code> 语法。该指令的意思是 “ 假设 dst 寄存器的值作为地址，并将 src 寄存器的值存储在那里。” 例如， <code>mov [rdi], rax</code> 表示 RAX 的值将存储在 RDI 中包含的地址处。</p><p><code>push</code> 和 <code>pop</code> 是隐式将 RSP 视为地址和访问内存的指令，因此实际上可以使用普通内存访问指令使用多个指令重写这些指令。我可以。例如 <code>pop rax</code> 是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov rax, [rsp]</span><br><span class="line">add rsp, 8</span><br></pre></td></tr></table></figure><p>两条指令相同， <code>push rax</code> 是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sub rsp, 8</span><br><span class="line">mov [rsp], rax</span><br></pre></td></tr></table></figure><p> 这与两个命令相同。</p><h3 id="代码生成器更改"><a href="#代码生成器更改" class="headerlink" title="代码生成器更改"></a><a href="#%E3%82%B3%E3%83%BC%E3%83%89%E3%82%B8%E3%82%A7%E3%83%8D%E3%83%AC%E3%83%BC%E3%82%BF%E3%81%AE%E5%A4%89%E6%9B%B4">代码生成器更改</a></h3><p>使用我们到目前为止所学到的知识，让我们修改代码生成器以处理包含变量的表达式。此更改添加了一个将表达式计算为左值的函数。下面代码中的函数 <code>gen_lval</code> 就是这样做的。 <code>gen_lval</code> 当给定节点指向变量时计算变量的地址并将其推入堆栈。否则显示错误。这将消除像 <code>(a+1)=2</code> 这样的表达式。</p><p>当使用变量作为右值时，首先将其计算为左值，然后将堆栈顶部的计算结果视为地址，并从该地址加载值。代码如下所示。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">gen_lval</span><span class="params">(Node *node)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (node-&gt;kind != ND_LVAR)</span><br><span class="line">    error(<span class="string">&quot;赋值操作左值不是变量&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;  mov rax, rbp\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;  sub rax, %d\n&quot;</span>, node-&gt;offset);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;  push rax\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">gen</span><span class="params">(Node *node)</span> &#123;</span><br><span class="line">  <span class="keyword">switch</span> (node-&gt;kind) &#123;</span><br><span class="line">  <span class="keyword">case</span> ND_NUM:</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;  push %d\n&quot;</span>, node-&gt;val);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">case</span> ND_LVAR:</span><br><span class="line">    gen_lval(node);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;  pop rax\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;  mov rax, [rax]\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;  push rax\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">case</span> ND_ASSIGN:</span><br><span class="line">    gen_lval(node-&gt;lhs);</span><br><span class="line">    gen(node-&gt;rhs);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;  pop rdi\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;  pop rax\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;  mov [rax], rdi\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;  push rdi\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  gen(node-&gt;lhs);</span><br><span class="line">  gen(node-&gt;rhs);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;  pop rdi\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;  pop rax\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span> (node-&gt;kind) &#123;</span><br><span class="line">  <span class="keyword">case</span> ND_ADD:</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;  add rax, rdi\n&quot;</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> ND_SUB:</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;  sub rax, rdi\n&quot;</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> ND_MUL:</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;  imul rax, rdi\n&quot;</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> ND_DIV:</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;  cqo\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;  idiv rdi\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;  push rax\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="主要功能变化"><a href="#主要功能变化" class="headerlink" title="主要功能变化"></a><a href="#%E3%83%A1%E3%82%A4%E3%83%B3%E9%96%A2%E6%95%B0%E3%81%AE%E5%A4%89%E6%9B%B4">主要功能变化</a></h3><p>现在我们已经拥有了所有部分，让我们更改 <code>main</code> 函数并实际运行编译器。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">    error(<span class="string">&quot;参数数量不正确&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 对输入进行词法分析和语法分析</span></span><br><span class="line">  <span class="comment">// 结果存储在code中</span></span><br><span class="line">  user_input = argv[<span class="number">1</span>];</span><br><span class="line">  tokenize();</span><br><span class="line">  program();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 输出汇编的前半部分</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;.intel_syntax noprefix\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;.globl main\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;main:\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 函数开头</span></span><br><span class="line">  <span class="comment">// 分配26个变量的内存空间</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;  push rbp\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;  mov rbp, rsp\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;  sub rsp, 208\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 顺序生成代码从第一个表达式开始</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; code[i]; i++) &#123;</span><br><span class="line">    gen(code[i]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 表达式的计算结果应该留在栈中</span></span><br><span class="line">    <span class="comment">// 因此为了避免栈溢出，我们在这里弹出计算结果</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;  pop rax\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 函数结尾</span></span><br><span class="line">  <span class="comment">// 最后一个表达式的结果保存在RAX中，作为返回值</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;  mov rsp, rbp\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;  pop rbp\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;  ret\n&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第10步：多字符局部变量"><a href="#第10步：多字符局部变量" class="headerlink" title="第10步：多字符局部变量"></a><a href="#%E3%82%B9%E3%83%86%E3%83%83%E3%83%9710%E8%A4%87%E6%95%B0%E6%96%87%E5%AD%97%E3%81%AE%E3%83%AD%E3%83%BC%E3%82%AB%E3%83%AB%E5%A4%89%E6%95%B0">第10步：多字符局部变量</a></h2><p>在上一章中，我们将变量名固定为一个字母，并将其视为从 a 到 z 的 26 个局部变量始终存在。本节提供对名称长于一个字符的标识符的支持，允许编译如下代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">foo = 1;</span><br><span class="line">bar = 2 + 3;</span><br><span class="line">return foo + bar; </span><br></pre></td></tr></table></figure><p>变量无需定义即可使用。因此，解析器必须确定每个标识符以前是否见过，如果是新的，则自动在堆栈区域中分配一个变量。</p><p>首先，更改标记生成器以将多字符标识符读取为 <code>TK_IDENT</code> 类型标记。</p><p>我们将把变量表示为链表。让我们使用名为 <code>LVar</code> 的结构来表示一个变量，并将第一个元素保存为名为 <code>locals</code> 的指针。用代码表达的话，看起来像这样：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LVar</span> <span class="title">LVar</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 局部变量的类型</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LVar</span> &#123;</span></span><br><span class="line">  LVar *next; <span class="comment">// 下一个变量或NULL</span></span><br><span class="line">  <span class="type">char</span> *name; <span class="comment">// 变量的名称</span></span><br><span class="line">  <span class="type">int</span> len;    <span class="comment">// 名称的长度</span></span><br><span class="line">  <span class="type">int</span> offset; <span class="comment">// 从RBP的偏移量</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 局部变量链表</span></span><br><span class="line">LVar *locals;</span><br></pre></td></tr></table></figure><p>在解析器中，当出现 <code>TK_IDENT</code> 类型的标记时，它会检查该标识符是否曾经出现过。您可以通过跟随 <code>locals</code> 并查看变量名称来判断变量是否已存在。如果该变量之前出现过，则按原样使用该变量的 <code>offset</code> 。对于新变量，创建新的 <code>LVar</code> ，设置新的偏移量，然后使用该偏移量。</p><p> 下面是一个按名称搜索变量的函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过名称搜索变量。如果找不到，则返回NULL。</span></span><br><span class="line">LVar *<span class="title function_">find_lvar</span><span class="params">(Token *tok)</span> &#123;</span><br><span class="line">  <span class="keyword">for</span> (LVar *var = locals; var; var = var-&gt;next)</span><br><span class="line">    <span class="keyword">if</span> (var-&gt;len == tok-&gt;len &amp;&amp; !<span class="built_in">memcmp</span>(tok-&gt;str, var-&gt;name, var-&gt;len))</span><br><span class="line">      <span class="keyword">return</span> var;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在你的解析器中，你应该只添加如下代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Token *tok = consume_ident();</span><br><span class="line"><span class="keyword">if</span> (tok) &#123;</span><br><span class="line">  Node *node = <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="keyword">sizeof</span>(Node));</span><br><span class="line">  node-&gt;kind = ND_LVAR;</span><br><span class="line"></span><br><span class="line">  LVar *lvar = find_lvar(tok);</span><br><span class="line">  <span class="keyword">if</span> (lvar) &#123;</span><br><span class="line">    node-&gt;offset = lvar-&gt;offset;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    lvar = <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="keyword">sizeof</span>(LVar));</span><br><span class="line">    lvar-&gt;next = locals;</span><br><span class="line">    lvar-&gt;name = tok-&gt;str;</span><br><span class="line">    lvar-&gt;len = tok-&gt;len;</span><br><span class="line">    lvar-&gt;offset = locals-&gt;offset + <span class="number">8</span>;</span><br><span class="line">    node-&gt;offset = lvar-&gt;offset;</span><br><span class="line">    locals = lvar;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第11步：返回语句"><a href="#第11步：返回语句" class="headerlink" title="第11步：返回语句"></a><a href="#%E3%82%B9%E3%83%86%E3%83%83%E3%83%9711return%E6%96%87">第11步：返回语句</a></h2><p>在本章中，我们将添加 <code>return</code> 语句，以便我们可以编译如下代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = 3;</span><br><span class="line">b = 5 * 6 - 8;</span><br><span class="line">return a + b / 2;</span><br></pre></td></tr></table></figure><p>假设 <code>return</code> 语句可以写在程序中间。与普通 C 一样，程序执行将在第一个 <code>return</code> 处中止，并且函数将返回。例如，下面的程序返回第一个 <code>return</code> 的值，即 5。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">return 5;</span><br><span class="line">return 8;</span><br></pre></td></tr></table></figure><p>为了实现这个功能，我们首先考虑一下添加了 <code>return</code> 的语法会发生什么。到目前为止，语句只是一个表达式，但新语法允许 <code>return &lt;式&gt;;</code> 。所以新的语法是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">program = stmt*</span><br><span class="line">stmt    = expr &quot;;&quot;</span><br><span class="line">        | &quot;return&quot; expr &quot;;&quot;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>为了实现这一点，分词器、解析器和代码生成器都需要进行一些调整。</p><p>首先，让标记生成器识别 <code>return</code> 标记并用 <code>TK_RETURN</code> 类型标记表示它。只有有限数量的标记（称为关键字）在语法中具有特殊含义，例如 <code>return</code> 、 <code>while</code> 和 <code>int</code> 。让每个令牌都有不同的类型，就像这样。</p><p>要确定下一个标记是否是 <code>return</code> ，似乎您所要做的就是检查标记器的剩余输入字符串是否以 <code>return</code> 开头，但在这种情况下，<code>returnx</code> 这样的标记会被错误地标记为 <code>return</code> 和 <code>x</code> 。所以这里我们需要确保输入以 <code>return</code> 开头，并且下一个字符不是令牌字符。</p><p>下面是一个函数，用于确定给定字符是否是标记字符，即字母数字字符或下划线。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">is_alnum</span><span class="params">(<span class="type">char</span> c)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (<span class="string">&#x27;a&#x27;</span> &lt;= c &amp;&amp; c &lt;= <span class="string">&#x27;z&#x27;</span>) ||</span><br><span class="line">         (<span class="string">&#x27;A&#x27;</span> &lt;= c &amp;&amp; c &lt;= <span class="string">&#x27;Z&#x27;</span>) ||</span><br><span class="line">         (<span class="string">&#x27;0&#x27;</span> &lt;= c &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>) ||</span><br><span class="line">         (c == <span class="string">&#x27;_&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用此函数，您可以将以下代码添加到 <code>tokenize</code> 将 <code>return</code> 标记为 <code>TK_RETURN</code> 。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">strncmp</span>(p, <span class="string">&quot;return&quot;</span>, <span class="number">6</span>) == <span class="number">0</span> &amp;&amp; !is_alnum(p[<span class="number">6</span>])) &#123;</span><br><span class="line">  tokens[i].ty = TK_RETURN;</span><br><span class="line">  tokens[i].str = p;</span><br><span class="line">  i++;</span><br><span class="line">  p += <span class="number">6</span>;</span><br><span class="line">  <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来，让我们修改解析器，以便它可以解析包含 TK_RETURN 的标记序列。为此，首先添加节点类型 <code>ND_RETURN</code> 来表示 <code>return</code> 语句。接下来，修改读取语句的函数，使其能够解析 <code>return</code> 语句。像往常一样，您可以通过将语法直接映射到函数调用来解析语法。新的 <code>stmt</code> 函数如下所示。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Node *<span class="title function_">stmt</span><span class="params">()</span> &#123;</span><br><span class="line">  Node *node;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (consume(TK_RETURN)) &#123;</span><br><span class="line">    node = <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="keyword">sizeof</span>(Node));</span><br><span class="line">    node-&gt;kind = ND_RETURN;</span><br><span class="line">    node-&gt;lhs = expr();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    node = expr();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!consume(<span class="string">&#x27;;&#x27;</span>))</span><br><span class="line">    error_at(tokens[pos].str, <span class="string">&quot;&#x27;;&#x27;不是令牌&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ND_RETURN</code> 类型节点仅在此处生成，因此我决定使用 <code>malloc</code> 来当场设置值，而不是创建新函数。</p><p>最后，修改代码生成器，使其为 <code>ND_RETURN</code> 类型的节点输出适当的汇编代码。新 <code>gen</code> 函数的一部分如下所示。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">gen</span><span class="params">(Node *node)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (node-&gt;kind == ND_RETURN) &#123;</span><br><span class="line">    gen(node-&gt;lhs);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;  pop rax\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;  mov rsp, rbp\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;  pop rbp\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;  ret\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure><p>在上面的代码中，函数调用 <code>gen(node-&gt;lhs)</code> 输出的表达式的代码是 <code>return</code> 的返回值。该代码应在堆栈顶部留下一个值。 <code>gen(node-&gt;lhs)</code> 之后的程序集从堆栈中弹出值，将其设置到 RAX 中，然后从函数返回。</p><p>上一章之前实现的函数始终在函数末尾输出一条 <code>ret</code> 指令。按照本章所述实现 <code>return</code> 语句将导致为每个 <code>return</code> 语句输出额外的 <code>ret</code> 指令。这些指令可以组合在一起，但为了简单起见，我们决定允许输出多个 <code>ret</code> 指令。此时无需担心这些细节，因此优先考虑实现简单性非常重要。能够编写困难的代码是一项有用的技能，但有时更有用的技能并不是一开始就让代码变得太难。</p><p>コラム:  专栏：语法层次结构</p><p>“ 正则表达式 “ 通常用于判断输入是否匹配某种规则，但更复杂的语法无法使用正则表达式来表达。例如，原则上不可能编写一个正则表达式来确定字符串中括号是否平衡。</p><p>上下文无关语法（可以用 BNF 表示的语法）比正则表达式更强大；例如，它们只能表示带有平衡括号的字符串（BNF 中的 <code>S → SS | &quot;(&quot; S &quot;)&quot; | ε</code> ）。然而，与正则表达式一样，上下文无关语法也有其局限性，上下文无关语法无法表达普通编程语言中出现的复杂规则。例如，规则 “ 变量必须在使用之前声明 “ 是 C 语法的一部分，但这样的规则不能使用上下文无关语法来表达。</p><p>如果你编写一个 C 语言编译器，你可以说编译器接受的输入是有效的 C 程序，而它不接受的输入是无效的 C 程序，除非编译器有 bug。也就是说，如果你有普通计算机的能力，就可以判断问题是否符合 C 语法，而编译器整体上可以说是比上下文无关语法更强大的语法判断器。这样，总能用 YES&#x2F;NO 判断是否与该文法匹配的文法称为 Decidable。</p><p>您还可以考虑不可判定的语法。例如，问题 “ 当给定一个计算机程序作为输入并执行时，该程序最终执行 <code>exit</code> 函数并退出，还是继续无限期地运行？” 已被证明一般是不可能的在不实际运行程序的情况下确定是&#x2F;否（假设您在具有无限内存的虚拟计算机上运行它）。换句话说，对于程序是否会停止的问题，如果程序停止，你可以回答 “ 是 “，但不能回答 “ 否 “，因为如果程序不停止，它就会无限期地继续运行。</p><p>这样，决策机不仅有可能返回 YES&#x2F;NO，而且决策机没有完成执行的一类文法称为图灵可识别的。</p><p>换句话说，存在语法层次结构：正则表达式 &lt; 上下文无关语法 &lt; 可判定 &lt; 图灵可识别。这些语法层次结构作为计算机科学的一部分得到了广泛的研究。著名的未解决问题 P≟NP 也是一个与语法层次结构相关的问题。</p><h2 id="1973年C编译器"><a href="#1973年C编译器" class="headerlink" title="1973年C编译器"></a><a href="#%E5%B9%B4%E3%81%AEc%E3%82%B3%E3%83%B3%E3%83%91%E3%82%A4%E3%83%A9">1973年C编译器</a></h2><p>到目前为止，我们一直在逐步构建编译器。从某种意义上来说，这个发展过程可以说是追随了 C 的历史。</p><p>如果你看看当前版本的 C，你会发现有些部分没有多大意义或者不必要地复杂，但如果不回顾历史就无法理解这些东西。当您阅读早期的 C 代码并查看 C 的早期形式以及该语言和编译器的后续发展时，当前 C 的许多令人困惑的方面开始变得有意义。</p><p>C 于 1972 年作为 Unix 语言开发。 1972 年或 1973 年（C 历史上非常早期的时期）的源代码保留在磁带上，从中读取的文件发布在 Internet 上。我们看一下当时 C 编译器的代码。下面是一个函数，它接收 <code>printf</code> 格式的消息并将其打印为编译错误消息。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">error(s, p1, p2) &#123;</span><br><span class="line">  <span class="keyword">extern</span> <span class="built_in">printf</span>, line, fout, flush, <span class="built_in">putchar</span>, nerror;</span><br><span class="line">  <span class="type">int</span> f;</span><br><span class="line"></span><br><span class="line">  nerror++;</span><br><span class="line">  flush();</span><br><span class="line">  f = fout;</span><br><span class="line">  fout = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d: &quot;</span>, line);</span><br><span class="line">  <span class="built_in">printf</span>(s, p1, p2);</span><br><span class="line">  <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">  fout = f;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它看起来有点奇怪，类似 C，非 C 语言。那时的 C 就是这样一种语言。当你阅读这段代码时，你首先注意到的是，就像我们创建的编译器的早期版本一样，函数返回值或参数没有类型。这里，s 是一个指向字符串的指针， <code>p1</code> 和 <code>p2</code> 应该是整数，但在当时的机器上它们的大小都是相同的，所以像这样的变量是没有类型。</p><p>第二行包含 <code>error</code> 引用的全局变量和函数的声明。当时，C 编译器没有头文件或 C 预处理器，因此程序员必须通过这种方式告诉编译器变量和函数的存在。</p><p>与我们当前的编译器一样，函数仅检查名称是否存在，而不检查参数的类型或数量是否匹配。将预期数量的参数放入堆栈后，他们可以跳转到函数体，函数调用就会成功，所以他们可能认为这样就可以了。</p><p><code>fout</code> 是一个全局变量，保存输出文件描述符的编号。此时， <code>fprintf</code> 还不存在，为了将字符串写入标准错误而不是标准输出，需要通过全局变量切换输出目的地。</p><p>在 <code>error</code> 内部， <code>printf</code> 被调用两次。第二个 printf 除了格式字符串之外还传递两个值。那么，当显示仅包含一个值的错误消息时，您该怎么办？</p><p>事实上，即使您只是强制它使用更少的参数，这个 <code>error</code> 函数也可以正常工作。回想一下，此时函数参数检查还不存在。像 <code>s</code> 、 <code>p1</code> 、 <code>p2</code> 这样的参数只是指向堆栈指针中的第 1 个、第 2 个和第 3 个字，但实际上 <code>p2</code> 的值。 <code>printf</code> 访问的额外参数等于第一个参数字符串中包含的 <code>%d</code> 和 <code>%s</code> 的数量，因此 <code>%d</code> 永远不会被访问。因此，即使参数数量不匹配也没有问题。</p><p>这样看来，早期的 C 编译器与现在的 9cc 有很多相似之处。</p><p>让我们看另一个代码示例。下面的代码是一个函数，它将传递的字符串复制到静态分配的区域中，并返回指向该区域开头的指针。换句话说，这是一个像 <code>strdup</code> 这样使用静态空间的函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">copy(s)</span><br><span class="line"><span class="type">char</span> s[]; &#123;</span><br><span class="line">  <span class="keyword">extern</span> tsp;</span><br><span class="line">  <span class="type">char</span> tsp[], otsp[];</span><br><span class="line"></span><br><span class="line">  otsp = tsp;</span><br><span class="line">  <span class="keyword">while</span>(*tsp++ = *s++);</span><br><span class="line">  <span class="keyword">return</span>(otsp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当时，还没有设计出 <code>int *p</code> 形式的声明语法。相反，指针类型被声明为 <code>int p[]</code> 。函数参数列表和函数体之间有类似变量定义的东西，但这是将 <code>s</code> 声明为指针类型。</p><p>关于这个早期的 C 编译器，还有一些值得一提的事情。</p><ul><li>此时该结构还不存在。</li><li><code>&amp;&amp;</code> 和 <code>||</code> 等运算符尚不可用。此时， <code>&amp;</code> 和 <code>|</code> 是上下文相关的，因为它们仅在 <code>if</code> 等条件表达式中才成为逻辑运算符。</li><li><code>+=</code> 等运算符被写为 <code>=+</code> 。在此语法中，如果您打算将 -1 分配给 <code>i</code> 并写入不带空格的 <code>i=-1</code> ，它将被解释为 <code>i =- 1</code> 。存在一个问题： <code>i</code> 将会递减，这是一种意外行为。</li><li>唯一的整数类型是 char 和 int；short 和 long 不存在。没有用于声明类型（例如 “ 函数指针数组 “）的语法，并且不可能编写复杂类型。</li></ul><p>除了上述之外，20 世纪 70 年代初期的 C 还缺乏各种特性。然而，这个 C 编译器是用 C 编写的，从上面的源代码可以看出。在结构出现之前，C 就已经是自托管的了。</p><p>通过查看旧的源代码，您还可以推断出为什么 C 的某些令人困惑的语法最终会变成当前的形式。如果变量名称始终位于 <code>extern</code> 或 <code>auto</code> 或 <code>int</code> 或 <code>char</code> 之后，则解析变量定义很容易。 <code>[]</code> 代表一个指针，如果它简单地跟在变量名后面，也很容易解析。然而，很明显，如果这种语法沿着早期编译器中看到的路线发展，它最终会以目前不必要的复杂形式出现。</p><p>嗯，Unix 和 C 的共同发明者 Dennis Ritchie 在 1973 年左右所做的事情是真正的增量开发。他一边开发 C 语言本身，一边使用 C 语言编写编译器。当前版本的 C 并不是某种随着语言不断添加功能而达到特殊点的成品，而只是在丹尼斯·里奇 (Dennis Ritchie) 认为该语言具有足够功能时作为一种语言完成的。这就是发生的事情。</p><p>即使有了我们的编译器，我们也从一开始就没有追求完整的版本。 C 的完整形式没有任何特殊含义，因此可能没有必要专门追求它。在任何时间点继续开发一种具有合理特性集的语言，并最终将其转换为 C，是原始 C 编译器使用的历史悠久的开发方法。让我们满怀信心、继续发展！</p><p>コラム: 专栏：Rob Pike 的 5 条编程规则</p><p>9cc 受到 Rob Pike 编程哲学的影响。 Rob Pike 是 Dennis Ritchie 的前同事，Dennis Ritchie 是 C 语言的创建者、Go 语言的创建者，并且与 Unix 的创建者 Ken Thompson 共同创建了 Unicode 的 UTF-8。</p><p>我引用 Rob Pike 的 5 条编程规则。</p><ol><li><p>无法预测程序的哪些部分将占用时间。瓶颈出现在令人惊讶的地方，因此在知道它们在哪里之前，不要试图猜测它们在哪里并添加性能技巧。</p></li><li><p>测量一下。在测量之前不要尝试优化。另外，即使您测量了它，也不要尝试优化代码中速度极慢的部分以外的任何内容。</p></li><li><p>当 n 很小时，花哨的算法会很慢，而且 n 通常也很小。复杂的算法有大量的常数部分。除非您知道 n 通常很大，否则不要变得复杂。 （即使 n 很大，也先应用规则 2。）</p></li><li><p>复杂的算法比简单的算法更容易出现错误并且更难实现。应使用简单的算法和数据结构。</p></li><li><p>数据才是最重要的。如果您选择正确的数据结构并很好地表示您的数据，您的算法几乎总是微不足道的。编程的核心是数据结构，而不是算法。</p></li></ol><h2 id="第-12-步：添加控制结构"><a href="#第-12-步：添加控制结构" class="headerlink" title="第 12 步：添加控制结构"></a><a href="#%E3%82%B9%E3%83%86%E3%83%83%E3%83%9712-%E5%88%B6%E5%BE%A1%E6%A7%8B%E6%96%87%E3%82%92%E8%B6%B3%E3%81%99">第 12 步：添加控制结构</a></h2><p>在本节中，我们将向语言添加以下控制结构： <code>if</code> 、 <code>if … else</code> 、 <code>while</code> 和 <code>for</code> 。尽管这些控制结构乍一看似乎很复杂，但当直接编译成汇编时，它们相对容易实现。</p><p>由于汇编中没有与 C 控制结构相对应的内容，因此 C 控制结构在汇编中由分支指令和标签表示。从某种意义上来说，这与使用 <code>goto</code> 重写控制结构是一样的。正如人类可以手动将控制结构重写为 <code>goto</code> 语句一样，只需根据模式生成代码即可轻松实现控制结构。</p><p>还有各种其他控制语法，例如 <code>do … while</code> 、 <code>goto</code> 、 <code>continue</code> 和 <code>break</code> ，但它们不需要实现现在还没有。</p><p>添加了 <code>if</code> 、 <code>while</code> 和 <code>for</code> 的新语法如下所示。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">program = stmt*</span><br><span class="line">stmt    = expr &quot;;&quot;</span><br><span class="line">        | &quot;if&quot; &quot;(&quot; expr &quot;)&quot; stmt (&quot;else&quot; stmt)?</span><br><span class="line">        | &quot;while&quot; &quot;(&quot; expr &quot;)&quot; stmt</span><br><span class="line">        | &quot;for&quot; &quot;(&quot; expr? &quot;;&quot; expr? &quot;;&quot; expr? &quot;)&quot; stmt</span><br><span class="line">        | ...</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>在读取 <code>expr? &quot;;&quot;</code> 时，我们向前看一个 token，并假设如果下一个 token 是 <code>;</code> 则 <code>expr</code> 不存在，否则 &lt; 可以读取 b3&gt;&lt; &#x2F;b3&gt; 等等。</p><p><code>if (A) B</code> 编译成如下所示的程序集：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  A编译后的代码 // スタックトップに結果が入っているはず</span><br><span class="line">  pop rax</span><br><span class="line">  cmp rax, 0</span><br><span class="line">  je  .LendXXX</span><br><span class="line">  B编译后的代码</span><br><span class="line">.LendXXX:</span><br></pre></td></tr></table></figure><p> 所以 <code>if (A) B</code> 是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  if (A == 0)</span><br><span class="line">    goto end;</span><br><span class="line">  B;</span><br><span class="line">end:</span><br></pre></td></tr></table></figure><p>将以同样的方式进行扩展。确保 <code>XXX</code> 是序列号或类似的内容，以便所有标签都是唯一的。</p><p><code>if (A) B else C</code> 编译成如下所示的程序集：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">  A编译后的代码 // スタックトップに結果が入っているはず</span><br><span class="line">  pop rax</span><br><span class="line">  cmp rax, 0</span><br><span class="line">  je  .LelseXXX</span><br><span class="line">  B编译后的代码</span><br><span class="line">  jmp .LendXXX</span><br><span class="line">.LelseXXX</span><br><span class="line">  C编译后的代码</span><br><span class="line">.LendXXX</span><br></pre></td></tr></table></figure><p>即， <code>if (A) B else C</code> 展开如下。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  if (A == 0)</span><br><span class="line">    goto els;</span><br><span class="line">  B;</span><br><span class="line">  goto end;</span><br><span class="line">els:</span><br><span class="line">  C;</span><br><span class="line">end:</span><br></pre></td></tr></table></figure><p>读取 <code>if</code> 语句时，先读一个标记并检查 <code>else</code> 是否存在，如果存在 <code>else</code> ，则检查 <code>if … else</code> ，否则编译为 <code>if</code> ，不带 <code>else</code> 。</p><p>像这样编译 <code>while (A) B</code> ：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.LbeginXXX:</span><br><span class="line">  A编译后的代码</span><br><span class="line">  pop rax</span><br><span class="line">  cmp rax, 0</span><br><span class="line">  je  .LendXXX</span><br><span class="line">  B编译后的代码</span><br><span class="line">  jmp .LbeginXXX</span><br><span class="line">.LendXXX:</span><br></pre></td></tr></table></figure><p>换句话说， <code>while (A) B</code> 被扩展为如下代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">begin:</span><br><span class="line">  if (A == 0)</span><br><span class="line">    goto end;</span><br><span class="line">  B;</span><br><span class="line">  goto begin;</span><br><span class="line">end:</span><br></pre></td></tr></table></figure><p>像这样编译 <code>for (A; B; C) D</code> ：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">  A编译后的代码</span><br><span class="line">.LbeginXXX:</span><br><span class="line">  B编译后的代码</span><br><span class="line">  pop rax</span><br><span class="line">  cmp rax, 0</span><br><span class="line">  je  .LendXXX</span><br><span class="line">  D编译后的代码</span><br><span class="line">  C编译后的代码</span><br><span class="line">  jmp .LbeginXXX</span><br><span class="line">.LendXXX:</span><br></pre></td></tr></table></figure><p><code>for (A; B; C) D</code> 对应的 C 代码如下所示。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  A;</span><br><span class="line">begin:</span><br><span class="line">  if (B == 0)</span><br><span class="line">    goto end;</span><br><span class="line">  D;</span><br><span class="line">  C;</span><br><span class="line">  goto begin;</span><br><span class="line">end:</span><br></pre></td></tr></table></figure><p>请注意，以 <code>.L</code> 开头的标签会被汇编器特别识别，并自动成为文件范围。文件范围标签可以从同一文件内引用，但不能从其他文件引用。因此，如果使 <code>if</code> 和 <code>for</code> 的编译器生成的标签从 <code>.L</code> 开始，则其他文件中包含的标签就无需担心冲突。</p><p>使用 cc 编译一个小循环并使用程序集作为参考。</p><p>コラム:  专栏：编译器检测运行时错误</p><p>当用 C 语言编写程序时，通常会在数组末尾写入数据，或者由于指针错误而损坏不相关的数据结构。这些错误也可能成为安全漏洞，因此我们的想法是在编译器的帮助下在运行时主动检测错误。</p><p>例如，如果将 <code>-fstack-protector</code> 选项传递给 GCC，则编译后的函数将向序言中的函数框架输出一个称为 “ 金丝雀 “ 的随机指针大小的整数，并且金丝雀将打印在尾声。这将确认该值没有改变。这样，如果堆栈的内容由于数组缓冲区溢出而在不知不觉中被覆盖，则金丝雀值几乎肯定会发生变化，因此可以在函数返回时检测到错误。如果检测到错误，程序通常会立即终止。</p><p>LLVM 有一个叫做 TSan (ThreadSanitizer) 的东西，它可以输出代码，在运行时检测多个线程在没有正确保护锁的情况下访问共享数据结构。此外，LLVM 的 UBSan (UndefinedBehaviorSanitizer) 可以输出代码，在运行时检测您是否无意中踩到了 C 中的未定义行为。例如，有符号整数溢出在 C 中是未定义的行为，因此如果发生有符号整数溢出，UBSan 将报告错误。</p><p>由于 TSan 等会使程序速度变慢数倍，因此将其添加到经常使用的程序的编译选项中是不合理的，但诸如堆栈金丝雀之类的运行成本相对较低的功能可以根据环境使用。默认情况下它可能处于打开状态。</p><p>近年来，借助此类编译器的动态错误检测得到了积极的研究，并且为使用 C 和 C++ 等非内存安全语言编写相当安全的程序做出了巨大贡献。</p><h2 id="第13步：块"><a href="#第13步：块" class="headerlink" title="第13步：块"></a><a href="#%E3%82%B9%E3%83%86%E3%83%83%E3%83%9713-%E3%83%96%E3%83%AD%E3%83%83%E3%82%AF">第13步：块</a></h2><p>此步骤支持 “ 块 “，允许您在 <code>&#123; … &#125;</code> 之间编写多个语句。块的正式名称是复合语句，但由于它的单词很长，所以通常简称为块。</p><p>块具有将多个语句组合成单个语句的作用。上面步骤中实现的 <code>if</code> 和 <code>while</code> 只允许在条件表达式为 true 时执行一条语句，但是在这一步中你可以通过实现它，你将能够像在 C 语言中一样，编写用 <code>&#123;&#125;</code> 括起来的多个语句。</p><p>函数体实际上也是一个块。语法上要求函数体必须是一个块。函数定义中的 <code>&#123; … &#125;</code> 实际上在语法上与 <code>if</code> 或 <code>while</code> 之后编写的 <code>&#123; … &#125;</code> 相同。</p><p> 添加块的语法如下所示。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">program = stmt*</span><br><span class="line">stmt    = expr &quot;;&quot;</span><br><span class="line">        | &quot;&#123;&quot; stmt* &quot;&#125;&quot;</span><br><span class="line">        | ...</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>在此语法中，如果 <code>stmt</code> 以 <code>&quot;&#123;&quot;</code> 开头，则将出现零个或多个 <code>stmt</code> ，直到 <code>&quot;&#125;&quot;</code> 出现。这是一件好事。要解析 <code>stmt* &quot;&#125;&quot;</code> ，请在 <code>while</code> 语句中重复调用 <code>stmt</code> ，直到出现 <code>&quot;&#125;&quot;</code> ，并将结果存储在向量中。请返回它作为</p><p>要实现块，请添加代表该块的节点类型 <code>ND_BLOCK</code> 。表示节点的结构 <code>Node</code> 必须使用包含块中包含的表达式的向量进行填充。如果节点的类型为 <code>ND_BLOCK</code> ，则代码生成器应按顺序为节点中包含的语句生成代码。请注意，每个语句都会在堆栈上留下一个值，因此不要忘记每次都将其弹出。</p><h2 id="第14步：响应函数调用"><a href="#第14步：响应函数调用" class="headerlink" title="第14步：响应函数调用"></a><a href="#%E3%82%B9%E3%83%86%E3%83%83%E3%83%9714-%E9%96%A2%E6%95%B0%E3%81%AE%E5%91%BC%E3%81%B3%E5%87%BA%E3%81%97%E3%81%AB%E5%AF%BE%E5%BF%9C%E3%81%99%E3%82%8B">第14步：响应函数调用</a></h2><p>此步骤的目标是能够识别没有参数的函数调用，例如 <code>foo()</code> 并将其编译为 <code>call foo</code> 。</p><p> 函数调用的新语法如下所示。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">primary = num</span><br><span class="line">        | ident (&quot;(&quot; &quot;)&quot;)?</span><br><span class="line">        | &quot;(&quot; expr &quot;)&quot;</span><br></pre></td></tr></table></figure><p>读取 <code>ident</code> 后向前看一个标记，您可以判断 <code>ident</code> 是变量名还是函数名。</p><p>为了进行测试，请准备一个包含 <code>int foo() &#123; printf(&quot;OK\n&quot;); &#125;</code> 等内容的 C 文件，将其编译为包含 <code>cc -c</code> 的目标文件，并将其与编译器的输出链接。通过这样做，您应该能够在整体上正确链接，并且您应该能够确认您要调用的函数被正确调用。</p><p>一旦成功，下一步就是能够编写像 <code>foo(3, 4)</code> 这样的函数调用。无需检查参数的数量或类型。通过简单地按顺序评估参数，将在堆栈上创建要传递给函数的参数，因此我们可以按照 x86-64 ABI 指定的顺序将它们复制到寄存器并调用该函数。不需要支持超过 6 个参数。</p><p>为了进行测试，就像上面一样，您应该能够准备一个像 <code>int foo(int x, int y) &#123; printf(&quot;%d\n&quot;, x + y); &#125;</code> 这样的函数，并通过链接它来检查它的操作。</p><p>x86-64 函数调用 ABI 很简单（只要遵循上面的方法），但有一个警告。在调用函数之前，RSP 必须是 16 的倍数。由于 <code>push</code> 和 <code>pop</code> 以 8 字节为单位改变 RSP，因此在发出 <code>call</code> 指令时 RSP 不一定必须是 16 的倍数。限制。如果不遵守这一承诺，假设 RSP 为 16 的倍数的函数将遭受一种神秘现象，即它们只有一半的时间会失败。确保在调用该函数之前调整 RSP，使其成为 16 的倍数。</p><h2 id="第-15-步：解决函数定义问题"><a href="#第-15-步：解决函数定义问题" class="headerlink" title="第 15 步：解决函数定义问题"></a><a href="#%E3%82%B9%E3%83%86%E3%83%83%E3%83%9715-%E9%96%A2%E6%95%B0%E3%81%AE%E5%AE%9A%E7%BE%A9%E3%81%AB%E5%AF%BE%E5%BF%9C%E3%81%99%E3%82%8B">第 15 步：解决函数定义问题</a></h2><p>完成此操作后，我们现在可以定义该函数。然而，C 函数定义很难解析，所以我不会一次全部实现它们。目前，我们的语言只有 int 类型，因此我们实现了 <code>foo(x, y) &#123; … &#125;</code> 语法，而不是 <code>int foo(int x, int y) &#123; … &#125;</code> 语法，该语法省略了类型名称。</p><p>被调用方需要能够使用 <code>x</code> 和 <code>y</code> 等名称来访问参数，但目前还无法通过名称直接访问寄存器中传递的值。 。要做的就是像 <code>x</code> 和 <code>y</code> 这样的局部变量存在一样进行编译，并在函数的序言中设置该局部变量的寄存器值。将其写入堆栈上的区域。之后，您应该能够毫无区别地处理参数和局部变量。</p><p>到目前为止，行为与用 <code>main() &#123; … &#125;</code> 隐式包围整个事物相同，但这种情况将被废除，所有代码都将编写在某个函数内。然后，在解析顶层时，当您首先读取标记时，它始终是函数名称，然后是参数列表，然后是函数体。易于阅读。</p><p>完成此步骤后，您将能够使用递归计算并显示斐波那契数列，这应该会使其变得更有趣。</p><h2 id="二进制级接口"><a href="#二进制级接口" class="headerlink" title="二进制级接口"></a><a href="#%E3%83%90%E3%82%A4%E3%83%8A%E3%83%AA%E3%83%AC%E3%83%99%E3%83%AB%E3%81%AE%E3%82%A4%E3%83%B3%E3%82%BF%E3%83%BC%E3%83%95%E3%82%A7%E3%82%A4%E3%82%B9">二进制级接口</a></h2><p>C 语言规范定义了源代码级别的规范。例如，语言规范指定如何定义函数，以及应包含哪些文件来声明哪些函数。另一方面，语言规范并没有规定为符合标准而编写的源代码将被转换成哪种机器语言。这是有道理的，因为 C 语言标准并不是根据任何特定的指令集来确定的。</p><p>因此，乍一看似乎没有必要明确确定机器语言级别的规范，但实际上，每个平台在某种程度上都确定了规范。该规范称为 ABI（应用程序二进制接口）。</p><p>到目前为止，本书中调用函数的方式意味着参数以特定顺序放置在寄存器中。此外，返回值承诺设置为 RAX。这些如何调用函数的规则称为 “ 函数调用约定 “。函数调用约定是 ABI 的一部分。</p><p>除了如何传递参数和返回值之外，C 语言 ABI 还包括以下内容：</p><ul><li>被函数调用改变的寄存器和没有改变的寄存器（RBP 等在返回前都恢复到原来的值，但有些寄存器不需要恢复到原来的值）</li><li><code>int</code> 和 <code>long</code> 等类型的大小</li><li>结构布局规则（结构成员在内存中实际排列的规则）</li><li>位域布局规则（例如，位域应该从最低有效位开始排列还是从最高有效位开始排列？）</li></ul><p>ABI 只是软件层面的约定，所以有可能想到与本书中解释的不同的东西，但是不兼容 ABI 的代码不能互相调用和使用，所以基本上，CPU 供应商和 OS 供应商定义平台标准 ABI。有两种广泛使用的 x86-64 系统：System V ABI（用于 Unix 和 macOS）和 Microsoft ABI（用于 Windows）。请注意，这两个调用约定并不是必然分开的，而只是不同的人创建了单独的约定。</p><p>到目前为止，在本书中，我们已经使用自己的编译器来调用用另一个编译器编译的函数。这是可能的，因为我们的 C 编译器和另一个编译器具有相同的 ABI。</p><hr><h1 id="指针和字符串文字"><a href="#指针和字符串文字" class="headerlink" title="指针和字符串文字"></a><a href="#%E3%83%9D%E3%82%A4%E3%83%B3%E3%82%BF%E3%81%A8%E6%96%87%E5%AD%97%E5%88%97%E3%83%AA%E3%83%86%E3%83%A9%E3%83%AB">指针和字符串文字</a></h1><p>在前面的章节中，我们开发了一种可以执行有意义的计算的语言，但是我们的语言仍然无法显示 <code>Hello world</code> 。是时候添加一些字符串以便程序可以输出有意义的消息了。</p><p>C 字符串文字与 <code>char</code> 类型、全局变量和数组密切相关。以以下函数为例。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Hello, world!\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码将以与下面的代码相同的方式编译。但是， <code>msg</code> 是一个唯一标识符，不会与其他标识符重叠。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> msg[<span class="number">15</span>] = <span class="string">&quot;Hello, world!\n&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> &#123;</span><br><span class="line">  <span class="built_in">printf</span>(msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们的编译器仍然缺乏一些支持字符串文字的功能。在本章中，我们将按顺序实现以下函数，以便我们可以支持字符串文字并使用 <code>printf</code> 等显示消息。</p><ol><li><p>一元 <code>&amp;</code> 和一元 <code>*</code></p></li><li><p> 指针</p></li><li><p> 大批</p></li><li><p> 全局变量</p></li><li><p> 字符类型</p></li><li><p> 字符串字面量</p></li></ol><p>我们还将在本章中添加测试上述功能所需的功能。</p><h2 id="步骤-16：一元-amp-和一元"><a href="#步骤-16：一元-amp-和一元" class="headerlink" title="步骤 16：一元 &amp; 和一元 *"></a><a href="#%E3%82%B9%E3%83%86%E3%83%83%E3%83%9716-%E5%8D%98%E9%A0%85%E3%81%A8%E5%8D%98%E9%A0%85">步骤 16：一元 &amp; 和一元 *</a></h2><p>在此步骤中，实现指针的第一步是实现返回地址的一元 <code>&amp;</code> 和引用地址的一元 <code>*</code> 。</p><p>这些运算符最初是返回或获取指针类型值的运算符，但由于我们的编译器还没有除整数之外的任何类型，因此我们用整数类型替换指针类型。我会决定。也就是说， <code>&amp;x</code> 将变量 <code>x</code> 的地址仅作为整数返回。另外， <code>*x</code> 是将 <code>x</code> 的值视为地址并从该地址读取值的操作。</p><p>实现这样的运算符允许如下代码工作：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x = 3;</span><br><span class="line">y = &amp;x;</span><br><span class="line">return *y; // 3を返す</span><br></pre></td></tr></table></figure><p>此外，利用局部变量在内存中连续分配的事实，还可以通过指针间接强制访问堆栈上的变量。下面的代码假设变量 <code>x</code> 位于堆栈上变量 <code>y</code> 上方 8 个字节。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x = 3;</span><br><span class="line">y = 5;</span><br><span class="line">z = &amp;y + 8;</span><br><span class="line">return *z; // 3を返す</span><br></pre></td></tr></table></figure><p>在这种不区分指针类型和整数类型的实现中，例如，表达式 <code>*4</code> 将是从地址 4 读取值的表达式，但我们假设现在这样就可以了。</p><p>实施相对容易。添加一元 <code>&amp;</code> 和一元 <code>*</code> 的语法如下所示。根据此语法修改解析器，将一元 <code>&amp;</code> 和一元 <code>*</code> 分别读取为 <code>ND_ADDR</code> 和 <code>ND_DEREF</code> 类型的节点。请如此。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">unary = &quot;+&quot;? primary</span><br><span class="line">      | &quot;-&quot;? primary</span><br><span class="line">      | &quot;*&quot; unary</span><br><span class="line">      | &quot;&amp;&quot; unary</span><br></pre></td></tr></table></figure><p>代码生成器的更改很少。下面列出了这些更改。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> ND_ADDR:</span><br><span class="line">  gen_lval(node-&gt;lhs);</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">case</span> ND_DEREF:</span><br><span class="line">  gen(node-&gt;lhs);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;  pop rax\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;  mov rax, [rax]\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;  push rax\n&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span>;</span><br></pre></td></tr></table></figure><h2 id="第十七步：消除隐式变量定义并引入-int-关键字"><a href="#第十七步：消除隐式变量定义并引入-int-关键字" class="headerlink" title="第十七步：消除隐式变量定义并引入 int 关键字"></a><a href="#%E3%82%B9%E3%83%86%E3%83%83%E3%83%9717-%E6%9A%97%E9%BB%99%E3%81%AE%E5%A4%89%E6%95%B0%E5%AE%9A%E7%BE%A9%E3%82%92%E5%BB%83%E6%AD%A2%E3%81%97%E3%81%A6int%E3%81%A8%E3%81%84%E3%81%86%E3%82%AD%E3%83%BC%E3%83%AF%E3%83%BC%E3%83%89%E3%82%92%E5%B0%8E%E5%85%A5%E3%81%99%E3%82%8B">第十七步：消除隐式变量定义并引入 int 关键字</a></h2><p>到目前为止，所有变量和函数返回值都隐式设置为 int。因此，我们没有麻烦地用类型名称来定义变量，例如 <code>int x;</code> ，并假设所有新标识符都是新的变量名称。你不能再做出这样的假设。那么，我们首先修改这一点。请实现以下功能。</p><ul><li>不要将新标识符视为变量名，并将未定义的变量标记为错误。</li><li>请务必以 <code>int x;</code> 格式定义变量。无需支持 <code>int x = 3;</code> 等初始化表达式。同样，我们不需要像 <code>int x, y;</code> 这样的东西。只实施最简单的事情。</li><li>到目前为止，函数都是以 <code>foo(x, y)</code> 的形式编写的，但我们将它们修改为 <code>int foo(int x, int y)</code> 的形式。目前，顶层应该只有函数定义，因此解析器首先读取 <code>int</code> ，然后按应有的方式读取函数名称，然后读取列 <code>int &lt;引数の名前&gt;</code> 。意味着阅读。不需要支持任何更困难的语法，也不需要做任何事情只是为了 “ 为未来的扩展做准备 “。只需编写足够的代码来读取 “int &lt;函数名称&gt;(&lt;由重复 int &lt;变量名称组成的参数列表&gt;&gt;)”。</li></ul><h2 id="第18步：引入指针类型"><a href="#第18步：引入指针类型" class="headerlink" title="第18步：引入指针类型"></a><a href="#%E3%82%B9%E3%83%86%E3%83%83%E3%83%9718-%E3%83%9D%E3%82%A4%E3%83%B3%E3%82%BF%E5%9E%8B%E3%82%92%E5%B0%8E%E5%85%A5%E3%81%99%E3%82%8B">第18步：引入指针类型</a></h2><h3 id="定义一个表示指针的类型"><a href="#定义一个表示指针的类型" class="headerlink" title="定义一个表示指针的类型"></a><a href="#%E3%83%9D%E3%82%A4%E3%83%B3%E3%82%BF%E3%82%92%E8%A1%A8%E3%81%99%E5%9E%8B%E3%82%92%E5%AE%9A%E7%BE%A9%E3%81%99%E3%82%8B">定义一个表示指针的类型</a></h3><p>在此步骤中，以前仅允许在类型名称中使用 <code>int</code> ，但现在允许在 <code>int</code> 后跟零个或多个 <code>*</code> 作为类型名称。也就是说，它允许解析诸如 <code>int *x</code> 和 <code>int ***x</code> 之类的定义。</p><p>当然，诸如 “ 指向 int 的指针 “ 之类的类型必须由编译器处理。例如，如果变量 <code>x</code> 是指向 int 的指针，则编译器必须知道表达式 <code>*x</code> 的类型为 int。由于类型可以像您想要的那样复杂，例如 “ 指向 int 的指针的指针 “，因此不能仅用固定大小的类型来表达。</p><p>所以我们要做的就是使用指针。到目前为止，通过映射与变量关联的唯一信息是距堆栈上基指针 (RBP) 的偏移量。更改此设置以便您可以拥有变量类型。粗略地说，变量类型应该是如下结构。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Type</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">enum</span> &#123;</span> INT, PTR &#125; ty;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Type</span> *<span class="title">ptr_to</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里 <code>ty</code> 可以有两个值之一：int 类型或 “ 指向 “ 类型的指针。仅当 <code>ty</code> 的类型为 “ 指向 “ 的指针时， <code>ptr_to</code> 才是有意义的成员，在这种情况下，它包含指向 “ Put 所指向的 Type 对象的指针 “。例如，对于 “ 指向 int 的指针 “，表示该类型的数据结构内部如下。</p><p><img src="/../../../img/blog/a646a0bc04bdbaea4703ac333d649f82_MD5.svg"></p><p> 表示指向 int 的指针的数据结构</p><p>如果它是一个 “ 指向 int 指针的指针 “，它将如下所示：</p><p><img src="/../../../img/blog/ab8b4213a762b079860fb603db4db2b0_MD5.svg"></p><p> 表示指向 int 的指针的数据结构</p><p>通过这种方式，可以在编译器内表达任意数量的困难类型。</p><h3 id="赋值给指针所指向的值"><a href="#赋值给指针所指向的值" class="headerlink" title="赋值给指针所指向的值"></a><a href="#%E3%83%9D%E3%82%A4%E3%83%B3%E3%82%BF%E3%81%8C%E6%8C%87%E3%81%97%E3%81%A6%E3%81%84%E3%82%8B%E5%80%A4%E3%81%AB%E4%BB%A3%E5%85%A5%E3%81%99%E3%82%8B">赋值给指针所指向的值</a></h3><p>如何编译赋值表达式左侧不是简单变量名（例如 <code>*p=3</code> ）的表达式？这些表达式的基本概念与左侧为简单变量时相同。在这种情况下，您可以将 <code>*p</code> 编译为左值，以便生成 <code>p</code> 的地址。</p><p>当编译表示 <code>*p=3</code> 的语法树时，代码会沿着树递归生成，但首先调用的是 <code>*p</code> 作为左值。用于编译的代码生成器。</p><p>代码生成器将根据给定语法树的类型进行分支。对于一个简单的变量，如上所述，我们将输出输出该变量地址的代码，但这里我们给出了一个解引用运算符，所以我们需要做一些不同的事情。如果给出了解引用运算符，则将其中的语法树编译为 “ 右值 “。然后它应该编译成计算某个地址的代码（否则您无法取消引用该结果）。然后你可以将该地址留在堆栈上。</p><p>完成此步骤后，您应该能够编译如下语句：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x;</span><br><span class="line"><span class="type">int</span> *y;</span><br><span class="line">y = &amp;x;</span><br><span class="line">*y = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">return</span> x; <span class="comment">// → 3</span></span><br></pre></td></tr></table></figure><h2 id="第19步：实现指针加法和减法"><a href="#第19步：实现指针加法和减法" class="headerlink" title="第19步：实现指针加法和减法"></a><a href="#%E3%82%B9%E3%83%86%E3%83%83%E3%83%9719-%E3%83%9D%E3%82%A4%E3%83%B3%E3%82%BF%E3%81%AE%E5%8A%A0%E7%AE%97%E3%81%A8%E6%B8%9B%E7%AE%97%E3%82%92%E5%AE%9F%E8%A3%85%E3%81%99%E3%82%8B">第19步：实现指针加法和减法</a></h2><p>在此步骤中，我们将能够为指针值 <code>p</code> 编写诸如 <code>p+1</code> 和 <code>p-5</code> 之类的表达式。虽然这看起来像是简单的整数加法，但实际上是完全不同的运算。 <code>p+1</code> 并不意味着将 <code>p</code> 所保存的地址加 1，而是使其成为指向 <code>p</code> 的下一个元素的指针。这意味着必须将指针指向的数据类型添加到 <code>p</code> 中。例如，如果 <code>p</code> 指向 int，根据我们的 ABI， <code>p+1</code> 将添加 4 作为地址中的字节数。另一方面，如果 <code>p</code> 是指向 int 的指针，则 <code>p+1</code> 将加 8。</p><p>因此，在添加或减去指针时，您需要一种方法来知道类型的大小，但目前 int 为 4，指针为 8，所以请这样编写代码。</p><p>由于现阶段我们还没有办法分配连续内存（我们的编译器还没有数组），因此编写测试有点困难。您可以简单地寻求外部编译器的帮助，在那里进行 malloc，并使用编译器输出中的帮助器函数编写测试。例如，您可以像这样测试它。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int *p;</span><br><span class="line">alloc4(&amp;p, 1, 2, 4, 8);</span><br><span class="line">int *q;</span><br><span class="line">q = p + 2;</span><br><span class="line">*q;  // → 4</span><br><span class="line">q = p + 3;</span><br><span class="line">return *q;  // → 8</span><br></pre></td></tr></table></figure><p>コラム:  列：int 或 long 的大小</p><p>像 x86-64 System V ABI 这样的数据模型（其中 int 为 32 位、long 和指针为 64 位）称为 LP64。这意味着长整型和指针都是 64 位。即使在 x86-64 上具有相同的 ABI，Windows 也使用 LLP64，这是一种数据模型，其中 int 和 long 为 32 位，long long 和指针为 64 位。</p><p>LP64 和 LLP64 不兼容 ABI，因为它们的长度不同。例如，如果您创建一个包含长成员的结构体，将整个结构体按原样写入文件，然后通过将文件中的数据直接转换为该结构体来读取它，则可以在 Unix 和 Windows 中写入该文件。不能互相传递阅读。</p><p>C 规范规定 int 是 “ 普通 “int 对象，具有执行环境体系结构建议的自然大小。当你这么说的时候，感觉就像你必须在 64 位机器上将 int 变成 64 位，但什么是自然的是一个主观问题，而且即使是 64 位机器通常也可以自然地处理 32 位操作，它不是即使在 64 位机器上，将 int 设为 32 位也必然是错误的。</p><p>如果你现实地考虑一下，将 int 设为 64 位会导致以下问题：</p><ul><li>在极少数情况下，int 需要大到 64 位，因此将 int 设为 64 位只会浪费内存。</li><li>如果 short 是 16 位，int 和 long 是 64 位，那么就没有代表 32 位整数的类型。</li></ul><p>由于上述原因，int 在大多数现有 64 位机器上都是 32 位。然而，具有 64 位 int 的 ILP64 也存在。例如，旧的 Cray 超级计算机是 ILP64。</p><h2 id="第20步：sizeof运算符"><a href="#第20步：sizeof运算符" class="headerlink" title="第20步：sizeof运算符"></a><a href="#%E3%82%B9%E3%83%86%E3%83%83%E3%83%9720-sizeof%E6%BC%94%E7%AE%97%E5%AD%90">第20步：sizeof运算符</a></h2><p><code>sizeof</code> 看起来像一个函数，但从语法上讲它是一个一元运算符。在 C 中，大多数运算符都是符号，但从语法上讲，没有特殊原因说明运算符必须是符号，事实上 <code>sizeof</code> 是一个例外。</p><p>让我们回顾一下 <code>sizeof</code> 运算符的行为。 <code>sizeof</code> 是一个运算符，返回参数表达式类型在内存中的字节数。例如，在我们的 ABI 中，如果 <code>x</code> 是 <code>int</code> ，则 <code>sizeof(x)</code> 返回 4；如果 <code>x</code> 是指针，则返回 8。 <code>sizeof</code> 的参数中可以写任何表达式，例如，如果表达式 <code>x+3</code> 的类型整体为 int，则 <code>sizeof(x+3)</code> 为 4，如果是一个指针，它将返回 8。</p><p>我们的编译器还没有数组，但如果 <code>x</code> 是数组， <code>sizeof(x)</code> 将返回 <code>x</code> 的整个大小（以字节为单位）。例如，如果 <code>x</code> 定义为 <code>int x[10]</code> ，则 <code>sizeof(x)</code> 将返回 40。如果 <code>x</code> 定义为 <code>int x[5][10]</code> ，则 <code>sizeof(x)</code> 为 200， <code>sizeof(x[0])</code> 为 40， <code>sizeof(x[0][0])</code> 变为 4。</p><p><code>sizeof</code> 运算符的参数只是为了告诉您类型而编写的；它们并不是要执行的实际表达式。例如，即使您编写表达式 <code>sizeof(x[3])</code> ，实际上也不会发生对 <code>x[3]</code> 的访问。表达式 <code>x[3]</code> 的总体类型在编译时已知，因此表达式 <code>sizeof(x[3])</code> 在编译时被替换为该类型的大小。因此，赋予 <code>sizeof</code> 的具体表达式例如 <code>x[3]</code> 在运行时不再存在。</p><p>  <code>sizeof</code> 的行为如下所示。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">int x;</span><br><span class="line">int *y;</span><br><span class="line"></span><br><span class="line">sizeof(x); // 4</span><br><span class="line">sizeof(y); // 8</span><br><span class="line"></span><br><span class="line">sizeof(x + 3); // 4</span><br><span class="line">sizeof(y + 3); // 8</span><br><span class="line">sizeof(*y);    // 4</span><br><span class="line"></span><br><span class="line">// sizeofに渡す式は何でもよい</span><br><span class="line">sizeof(1); // 4</span><br><span class="line"></span><br><span class="line">// sizeofの結果は現在int型なのでsizeof(int)と同じ</span><br><span class="line">sizeof(sizeof(1)); // 4</span><br></pre></td></tr></table></figure><p>现在，让我们实现这个 <code>sizeof</code> 运算符。实现 <code>sizeof</code> 运算符涉及修改分词器和解析器。</p><p>首先，修改标记生成器以将关键字 <code>sizeof</code> 识别为 <code>TK_SIZEOF</code> 类型的标记。</p><p>接下来，我们修改解析器以将 <code>sizeof</code> 替换为 <code>int</code> 类型的常量。添加了 <code>sizeof</code> 运算符的语法如下所示。在下面的语法中， <code>sizeof</code> 被定义为一元运算符，其优先级与一元加和一元减相同。这与 C 的语法相同。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">unary = &quot;sizeof&quot; unary</span><br><span class="line">      | (&quot;+&quot; | &quot;-&quot;)? primary</span><br></pre></td></tr></table></figure><p>在这个语法中，不仅允许 <code>sizeof(x)</code> ，也允许 <code>sizeof x</code> ，在实际的 C 中也是如此。</p><p>在解析器中，当 <code>sizeof</code> 运算符出现时，作为其参数的表达式会像往常一样被解析，与结果语法树关联的类型为 <code>int</code> 如果是，则将其替换为数字 4，如果是指针，则替换为数字 8。由于解析器将其替换为常量，因此无需对代码生成树进行任何更改。</p><h2 id="第21步：实现数组"><a href="#第21步：实现数组" class="headerlink" title="第21步：实现数组"></a><a href="#%E3%82%B9%E3%83%86%E3%83%83%E3%83%9721-%E9%85%8D%E5%88%97%E3%82%92%E5%AE%9F%E8%A3%85%E3%81%99%E3%82%8B">第21步：实现数组</a></h2><h3 id="定义数组类型"><a href="#定义数组类型" class="headerlink" title="定义数组类型"></a><a href="#%E9%85%8D%E5%88%97%E5%9E%8B%E3%82%92%E5%AE%9A%E7%BE%A9%E3%81%99%E3%82%8B">定义数组类型</a></h3><p>在这一步中我们将实现数组。到目前为止，我们只处理了足以容纳寄存器的数据，但这是我们第一次处理比这个大的数据。</p><p>然而，当涉及到数组时，C 的语法是有限制的。您不能将数组作为函数参数传递或将数组作为函数返回值返回。如果您出于此目的编写代码，则数组本身不会按值传递，但会自动创建并传递指向该数组的指针。也不支持直接对数组进行赋值和复制（必须使用 memcpy）。</p><p>因此，无需在函数和变量之间传递不适合寄存器的数据。能够在堆栈上分配大于一个字的内存区域就足够了。</p><p>请允许读取如下变量定义。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int a[10];</span><br></pre></td></tr></table></figure><p>上面 a 的类型是一个数组，数组长度为 10，元素类型为 int。与指针类型一样，数组类型可以像您想要的那样复杂，因此就像步骤 7 中一样，使用 ptr_to 指向数组元素的类型。表示类型的结构应如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Type</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">enum</span> &#123;</span> INT, PTR, ARRAY &#125; ty;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Type</span> *<span class="title">ptr_to</span>;</span></span><br><span class="line">  <span class="type">size_t</span> array_size;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里， <code>array_size</code> 是一个仅对数组类型有意义的字段，是一个保存数组中元素数量的变量。</p><p>完成此操作后，您应该能够轻松地为堆栈上的数组分配空间。要查找数组的大小（以字节为单位），只需将数组元素的大小（以字节为单位）乘以数组中元素的数量即可。到目前为止，堆栈区域应该为所有变量保留为一个字，但请更改这一点并确保数组具有所需的大小。</p><h3 id="实现从数组到指针的隐式类型转换"><a href="#实现从数组到指针的隐式类型转换" class="headerlink" title="实现从数组到指针的隐式类型转换"></a><a href="#%E9%85%8D%E5%88%97%E3%81%8B%E3%82%89%E3%83%9D%E3%82%A4%E3%83%B3%E3%82%BF%E3%81%B8%E3%81%AE%E6%9A%97%E9%BB%99%E3%81%AE%E5%9E%8B%E5%A4%89%E6%8F%9B%E3%82%92%E5%AE%9F%E8%A3%85%E3%81%99%E3%82%8B">实现从数组到指针的隐式类型转换</a></h3><p>数组和指针经常结合使用，所以 C 的语法允许它在不区分指针和数组的情况下工作，但是这适得其反，让我们很难理解数组和指针之间的关系，似乎变得越来越困难让程序员能够理解。因此，这里我们来解释一下数组和指针的关系。</p><p>首先，在 C 中，数组和指针是完全不同的类型。</p><p>指针（在 x86-64 上）是 8 字节值类型。正如 + 和 - 等运算符是为整数定义的一样，+ 和 - 也为指针定义（形式略有不同）。此外，指针还定义了一元 <code>*</code> 运算符，它允许您引用指针所指向的内容。除了一元 <code>*</code> 之外，指针没有什么特别的。换句话说，指针是像 int 一样的普通类型。</p><p>另一方面，数组是一种可以是任意字节数的类型。与指针不同，为数组定义的运算符很少。唯一定义的运算符是 <code>sizeof</code> 运算符（它返回数组的大小）和 &amp; 运算符（它返回指向数组第一个元素的指针）。没有其他运算符可以应用于数组。</p><p>那么为什么像 <code>a[3]</code> 这样的表达式可以编译呢？在 C 中， <code>a[3]</code> 被定义为等同于 <code>*(a+3)</code> 。数组中不是没有定义 + 运算符吗？</p><p>这就是将数组隐式转换为指针的语法发挥作用的地方。数组会隐式转换为指向数组第一个元素的指针，除非用作 <code>sizeof</code> 或一元 <code>&amp;</code> 的操作数。因此， <code>*(a+3)</code> 是一个将数组 a 第一个元素的指针解引用加 3 的表达式，相当于访问数组的第三个元素，意义相同。</p><p>在 C 中，没有用于数组访问的 <code>[]</code> 运算符。 C 中的 <code>[]</code> 只是通过指针访问数组元素的简写符号。</p><p>类似地，如果将数组作为函数参数传递，它就会成为指向数组第一个元素的指针，或者您可以像直接将数组分配给指针一样编写它，但这也是可能的，如上所示。这取决于原因。</p><p>因此，编译器在实现大多数运算符时必须将数组转换为指针。这应该不会太难实施。除非您正在实现 <code>sizeof</code> 和一元 <code>&amp;</code> ，否则当您解析运算符的操作数时，如果它是 T 类型的数组，它将被解释为指向 T 的指针。 ，应该足够了。对于数组类型值，代码生成器应生成将值的地址压入堆栈的代码。</p><p>完成此操作后，您应该能够运行如下代码。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int a[2];</span><br><span class="line">*a = 1;</span><br><span class="line">*(a + 1) = 2;</span><br><span class="line">int *p;</span><br><span class="line">p = a;</span><br><span class="line">return *p + *(p + 1)  // → 3</span><br></pre></td></tr></table></figure><p>本书有意避免深入研究 C 语言规范的细节，直到编译器更加成熟。这是有原因的。在实现有规范的编程语言时，在某种程度上成为语言律师是必要的，但从一开始就过多关注细节并不是一种可取的开发方式。就像当你画一幅画时，你首先完成整个事物的粗略草图，而不是只详细地绘制一个部分，当你在实现一种编程语言时，尝试平衡它，这样你就不会变得太多首先是语言律师，我们需要维护和发展它。</p><h2 id="第22步：实现数组下标"><a href="#第22步：实现数组下标" class="headerlink" title="第22步：实现数组下标"></a><a href="#%E3%82%B9%E3%83%86%E3%83%83%E3%83%9722-%E9%85%8D%E5%88%97%E3%81%AE%E6%B7%BB%E5%AD%97%E3%82%92%E5%AE%9F%E8%A3%85%E3%81%99%E3%82%8B">第22步：实现数组下标</a></h2><p>在 C 中， <code>x[y]</code> 被定义为等同于 <code>*(x+y)</code> 。因此，实现下标相对简单。只需在解析器中将 <code>x[y]</code> 读取为 <code>*(x+y)</code> 即可。例如， <code>a[3]</code> 变为 <code>*(a+3)</code> 。</p><p>在这个语法中， <code>3[a]</code> 被扩展为 <code>*(3+a)</code> ，所以如果 <code>a[3]</code> 有效， <code>3[a]</code> 也应该有效，但在 C 中所以一个表达式像 <code>3[a]</code> 实际上是合法的。尝试一下。</p><h2 id="第23步：实现全局变量"><a href="#第23步：实现全局变量" class="headerlink" title="第23步：实现全局变量"></a><a href="#%E3%82%B9%E3%83%86%E3%83%83%E3%83%9723-%E3%82%B0%E3%83%AD%E3%83%BC%E3%83%90%E3%83%AB%E5%A4%89%E6%95%B0%E3%82%92%E5%AE%9F%E8%A3%85%E3%81%99%E3%82%8B">第23步：实现全局变量</a></h2><p>我希望很快就能在程序中编写文字字符串。在 C 中，文字字符串是一个字符数组。这很好，因为我们已经实现了数组，但不同的是文字字符串不是存在于堆栈上的值。字符串文字驻留在内存中的固定位置，而不是堆栈上。因此，要实现字符串文字，我们首先添加一个全局变量。</p><p>到目前为止，顶层只允许函数定义。让我们更改该语法，以便我们可以在顶层编写全局变量。</p><p>变量定义解析起来有些棘手，因为它们看起来与函数定义相似。例如，比较以下四个定义。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *foo;</span><br><span class="line"><span class="type">int</span> foo[<span class="number">10</span>];</span><br><span class="line"><span class="type">int</span> *<span class="title function_">foo</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">foo</span><span class="params">()</span> &#123;&#125;</span><br></pre></td></tr></table></figure><p>上面的两个 foo 是变量定义，下面的两个是函数定义，但是直到找到成为函数名或变量名的标识符并读取下一个标记之前，您无法区分它们。因此，您需要首先调用 “ 读取类型名称的前半部分 “ 函数，读取后面应该出现的标识符，然后尝试向前读取一个标记。如果预读标记为 “(“，则表示正在读取函数定义；否则，表示正在读取变量定义。</p><p>将已解析的全局变量的名称放入映射中，以便您可以按名称查找它们。仅当变量名称无法解析为局部变量时，才会尝试将其解析为全局变量。这允许以自然的方式让局部变量隐藏同名的全局变量。</p><p>解析器将局部变量引用和全局变量引用转换为抽象语法树中的单独节点。由于名称可以在解析阶段解析，因此类型也可以在该阶段分离。</p><p>到目前为止，所有变量都应该位于堆栈上，因此变量的读写是相对于 RBP（基指针）的。全局变量不是堆栈上的值，而是内存中的固定位置，因此编译时可以直接访问该地址。请参考实际的 gcc 输出。</p><p>一旦你实现了它，你会惊讶地发现局部变量和全局变量有很大的不同。之所以可以写得没有视觉上的区别，是因为 C 语言抽象得很好。局部变量和全局变量实际上在内部实现完全不同。</p><h2 id="第24步：实现字符类型"><a href="#第24步：实现字符类型" class="headerlink" title="第24步：实现字符类型"></a><a href="#%E3%82%B9%E3%83%86%E3%83%83%E3%83%9724-%E6%96%87%E5%AD%97%E5%9E%8B%E3%82%92%E5%AE%9F%E8%A3%85%E3%81%99%E3%82%8B">第24步：实现字符类型</a></h2><p>数组是一种可以大于一个单词的类型，但字符是一种可以小于一个单词的类型。要完成此步骤，您可能需要编写一个函数，该函数接受表示类型的对象并返回该类型的大小（以字节为单位）。首先，添加一个字符类型，然后修改该函数，使其为该字符类型返回 1。</p><p>在此步骤中无需实现文字字符（用单引号括起来的字符）。避免一次性实施所有事情的冲动，并保持变化尽可能小。</p><p>所以在这一步中，字符实际上只是一个小整数类型。 <code>movsx ecx, BYTE PTR [rax]</code> 可以从 RAX 指向的地址中读取一个字节并将其放入 ECX 中。如果不需要符号扩展，请使用 <code>movzx</code> 指令，如 <code>movzx ecx, BYTE PTR [rax]</code> 。写入时，使用 8 位寄存器作为源寄存器，如 <code>mov [rax], cl</code> 。</p><p>  请参考实际的编译输出。</p><p>实现此步骤后，您应该能够运行如下代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">char x[3];</span><br><span class="line">x[0] = -1;</span><br><span class="line">x[1] = 2;</span><br><span class="line">int y;</span><br><span class="line">y = 4;</span><br><span class="line">return x[0] + y;  // → 3</span><br></pre></td></tr></table></figure><h2 id="第-25-步：实现字符串文字"><a href="#第-25-步：实现字符串文字" class="headerlink" title="第 25 步：实现字符串文字"></a><a href="#%E3%82%B9%E3%83%86%E3%83%83%E3%83%9725-%E6%96%87%E5%AD%97%E5%88%97%E3%83%AA%E3%83%86%E3%83%A9%E3%83%AB%E3%82%92%E5%AE%9F%E8%A3%85%E3%81%99%E3%82%8B">第 25 步：实现字符串文字</a></h2><p>此步骤解析用双引号括起来的字符串，以便可以对其进行编译。现在我们已经有了必要的部分：数组、全局变量和字符类型，我认为实现起来会相对容易。</p><p>首先，修改标记生成器，以便当找到双引号时，读取到下一个双引号以创建字符串标记。这一步不需要实现反斜杠转义等。一步一步来很重要，所以即使看起来很容易实现，也尽量不要这样做。</p><p>在生成要在 CPU 上执行的机器代码时，无法输出表示字符串文字数据的汇编代码。在输出汇编中，全局数据和代码必须不混合地编写。换句话说，在输出代码时，我们希望首先输出代码中出现的所有字符串文字，但是通过语法树来做到这一点是很痛苦的。执行此操作的一个简单方法是拥有一个包含您见过的所有字符串文字的向量，并在每次解析器看到字符串时简单地添加到它。</p><p>  请参考实际的编译输出。</p><p>此时，您应该能够使用 <code>printf</code> 输出字符串。这是一个很好的机会，可以使用自己的编程语言来编写比测试代码等显而易见的东西更复杂的东西。例如，是否可以用您自己的语言编写 8 皇后问题的求解器？人类花了几十年的时间才开发出一种编程语言，使我们能够轻松地编写这个级别的代码。对于人类和你们来说，这都是一个巨大的进步，它可以在几周内实施。</p><p>（当调用带有可变长度参数的函数时，浮点参数的数量存储在 AL 中。我们的编译器还没有浮点数。因此，在调用函数时，（在执行之前始终将 AL 设置为 0 所以。）</p><h2 id="步骤-26：从文件中读取输入"><a href="#步骤-26：从文件中读取输入" class="headerlink" title="步骤 26：从文件中读取输入"></a><a href="#%E3%82%B9%E3%83%86%E3%83%83%E3%83%9726-%E5%85%A5%E5%8A%9B%E3%82%92%E3%83%95%E3%82%A1%E3%82%A4%E3%83%AB%E3%81%8B%E3%82%89%E8%AA%AD%E3%82%80">步骤 26：从文件中读取输入</a></h2><p>到目前为止，我一直将 C 代码直接传递给参数字符串，但由于输入逐渐变长，我认为是时候修改它，以便它像普通 C 编译器一样将文件名作为命令行参数.让我们吧。打开给定文件、读取其内容并返回以 <code>&#39;\0&#39;</code> 结尾的字符串的函数可以简明地编写如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定されたファイルの内容を返す</span></span><br><span class="line"><span class="type">char</span> *<span class="title function_">read_file</span><span class="params">(<span class="type">char</span> *path)</span> &#123;</span><br><span class="line">  <span class="comment">// ファイルを開く</span></span><br><span class="line">  FILE *fp = fopen(path, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (!fp)</span><br><span class="line">    error(<span class="string">&quot;cannot open %s: %s&quot;</span>, path, strerror(errno));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ファイルの長さを調べる</span></span><br><span class="line">  <span class="keyword">if</span> (fseek(fp, <span class="number">0</span>, SEEK_END) == <span class="number">-1</span>)</span><br><span class="line">    error(<span class="string">&quot;%s: fseek: %s&quot;</span>, path, strerror(errno));</span><br><span class="line">  <span class="type">size_t</span> size = ftell(fp);</span><br><span class="line">  <span class="keyword">if</span> (fseek(fp, <span class="number">0</span>, SEEK_SET) == <span class="number">-1</span>)</span><br><span class="line">    error(<span class="string">&quot;%s: fseek: %s&quot;</span>, path, strerror(errno));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ファイル内容を読み込む</span></span><br><span class="line">  <span class="type">char</span> *buf = <span class="built_in">calloc</span>(<span class="number">1</span>, size + <span class="number">2</span>);</span><br><span class="line">  fread(buf, size, <span class="number">1</span>, fp);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ファイルが必ず&quot;\n\0&quot;で終わっているようにする</span></span><br><span class="line">  <span class="keyword">if</span> (size == <span class="number">0</span> || buf[size - <span class="number">1</span>] != <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">    buf[size++] = <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  buf[size] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">  fclose(fp);</span><br><span class="line">  <span class="keyword">return</span> buf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于编译器的实现，每行以换行符结尾的数据比以换行符或 EOF 结尾的数据更容易处理，因此如果文件的最后一个字节不是 <code>\n</code> ，我决定自动添加 <code>\n</code> 。</p><p>严格来说，如果给您一个无法随机访问的特殊文件，此功能将无法正常工作。例如，如果您指定表示标准输入的设备文件 <code>/dev/stdin</code> 或命名管道作为文件名，则您应该会看到显示诸如 <code>/dev/stdin: fseek: Illegal seek</code> 之类的错误消息。不过，实际上这个功能应该没问题。修改您的代码以使用此函数读取文件的内容并将其视为输入。</p><p>由于输入文件通常包含多行，因此您还应该增强显示错误消息的功能。发生错误时，如果您决定显示输入文件名、出错行的行号以及该行的内容，则错误消息将如下所示。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">foo.c:10: x = y + + 5;</span><br><span class="line">                  ^ 式ではありません</span><br></pre></td></tr></table></figure><p>显示此类错误消息的函数如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 入力ファイル名</span></span><br><span class="line"><span class="type">char</span> *filename;</span><br><span class="line"></span><br><span class="line"><span class="comment">// エラーの起きた場所を報告するための関数</span></span><br><span class="line"><span class="comment">// 下のようなフォーマットでエラーメッセージを表示する</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// foo.c:10: x = y + + 5;</span></span><br><span class="line"><span class="comment">//                   ^ 式ではありません</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">error_at</span><span class="params">(<span class="type">char</span> *loc, <span class="type">char</span> *msg)</span> &#123;</span><br><span class="line">  <span class="comment">// locが含まれている行の開始地点と終了地点を取得</span></span><br><span class="line">  <span class="type">char</span> *line = loc;</span><br><span class="line">  <span class="keyword">while</span> (user_input &lt; line &amp;&amp; line[<span class="number">-1</span>] != <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">    line--;</span><br><span class="line"></span><br><span class="line">  <span class="type">char</span> *end = loc;</span><br><span class="line">  <span class="keyword">while</span> (*end != <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">    end++;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 見つかった行が全体の何行目なのかを調べる</span></span><br><span class="line">  <span class="type">int</span> line_num = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">char</span> *p = user_input; p &lt; line; p++)</span><br><span class="line">    <span class="keyword">if</span> (*p == <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">      line_num++;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 見つかった行を、ファイル名と行番号と一緒に表示</span></span><br><span class="line">  <span class="type">int</span> indent = <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;%s:%d: &quot;</span>, filename, line_num);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;%.*s\n&quot;</span>, (<span class="type">int</span>)(end - line), line);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// エラー箇所を&quot;^&quot;で指し示して、エラーメッセージを表示</span></span><br><span class="line">  <span class="type">int</span> pos = loc - line + indent;</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;%*s&quot;</span>, pos, <span class="string">&quot;&quot;</span>); <span class="comment">// pos個の空白を出力</span></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;^ %s\n&quot;</span>, msg);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然这个错误信息输出例程相当简单，但可以说它以相当专业的格式输出错误。</p><p>コラム:  专栏：错误恢复</p><p>如果输入代码在语法上不正确，许多编译器将尝试跳过错误并继续解析其余代码。目标是找到尽可能多的错误，而不仅仅是一个。从解析器错误中恢复并继续解析的能力称为 “ 错误恢复 “。</p><p>错误恢复是旧编译器的一个非常重要的功能。在 20 世纪 60 年代和 1970 年代，程序员在计算机中心使用大型计算机进行分时，要求他们带入要编译的代码并等待，有时甚至是一整夜，然后才能得到编译结果。在这样的环境下，编译器的重要任务之一就是指出尽可能多的可能的错误。在较旧的编译器教科书中，错误恢复是解析的主要主题之一。</p><p>如今，使用编译器进行开发更具交互性，因此错误恢复不再是一个重要的话题。我们开发的编译器只打印第一条错误消息。在现代，这在很多情况下就足够了。</p><h2 id="第-27-步：行注释和块注释"><a href="#第-27-步：行注释和块注释" class="headerlink" title="第 27 步：行注释和块注释"></a><a href="#%E3%82%B9%E3%83%86%E3%83%83%E3%83%9727-%E8%A1%8C%E3%82%B3%E3%83%A1%E3%83%B3%E3%83%88%E3%81%A8%E3%83%96%E3%83%AD%E3%83%83%E3%82%AF%E3%82%B3%E3%83%A1%E3%83%B3%E3%83%88">第 27 步：行注释和块注释</a></h2><p>我们的编译器逐渐发展，编写成熟的代码已经成为可能。在这种情况下，您想要的是注释。本章实现了注释。</p><p>C 中的注释有两种类型。一条注释称为行注释，注释从 <code>//</code> 开始到行尾。另一种类型称为块注释，其中 <code>/*</code> 是开始符号， <code>*/</code> 是结束符号。除了两个字符序列 <code>*/</code> 之外，块注释中的所有字符都会被跳过。</p><p>从语法上讲，注释被视为与单个空格字符相同。因此，分词器很自然地会像空格一样跳过注释。跳过注释的代码如下所示。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">tokenize</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">char</span> *p = user_input;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (*p) &#123;</span><br><span class="line">    <span class="comment">// 空白文字をスキップ</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isspace</span>(*p)) &#123;</span><br><span class="line">      p++;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 行コメントをスキップ</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strncmp</span>(p, <span class="string">&quot;//&quot;</span>, <span class="number">2</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">      p += <span class="number">2</span>;</span><br><span class="line">      <span class="keyword">while</span> (*p != <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">        p++;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ブロックコメントをスキップ</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strncmp</span>(p, <span class="string">&quot;/*&quot;</span>, <span class="number">2</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="type">char</span> *q = <span class="built_in">strstr</span>(p + <span class="number">2</span>, <span class="string">&quot;*/&quot;</span>);</span><br><span class="line">      <span class="keyword">if</span> (!q)</span><br><span class="line">        error_at(p, <span class="string">&quot;コメントが閉じられていません&quot;</span>);</span><br><span class="line">      p = q + <span class="number">2</span>;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>这里我们使用 C 标准库中的 <code>strstr</code> 函数来查找块注释的结尾。 <code>strstr</code> 在字符串中搜索字符串，如果找到则返回指向所传递字符串开头的指针，如果未找到则返回 NULL。</p><p>コラム:  专栏：块注释和嵌套</p><p>块注释不能嵌套。 <code>/*</code> 在注释中没有特殊含义，因此注释掉现有的块注释。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/* /* ... */ */</span><br></pre></td></tr></table></figure><p>第一个 <code>*/</code> 将结束注释，第二个 <code>*/</code> 将导致语法错误。</p><p>如果要注释掉所有可能包含块注释的行，请使用 C 预处理器。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#if 0</span><br><span class="line">...</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><p>一种方法是将其包装在 <code>#if 0</code> 中，如下所示。</p><h2 id="步骤-28：用-C-重写测试"><a href="#步骤-28：用-C-重写测试" class="headerlink" title="步骤 28：用 C 重写测试"></a><a href="#%E3%82%B9%E3%83%86%E3%83%83%E3%83%9728-%E3%83%86%E3%82%B9%E3%83%88%E3%82%92c%E3%81%A7%E6%9B%B8%E3%81%8D%E7%9B%B4%E3%81%99">步骤 28：用 C 重写测试</a></h2><p>在此步骤中，我们将重写测试以使 <code>make test</code> 更快。当您执行此步骤时，您可能已经在 shell 脚本中编写了 100 多个测试。 Shell 脚本测试为每个测试启动多个进程。换句话说，对于每个测试，我都会启动自己的编译器、汇编器、链接器并测试自身。</p><p>即使对于小程序来说，启动进程也不是那么快。因此，如果您执行数百次，总共将花费相当长的时间。您的测试脚本可能需要几秒钟才能运行。</p><p>我首先在 shell 脚本中编写测试的原因是因为否则我无法进行正确的测试。在计算器级语言中，没有 <code>if</code> 或 <code>==</code> ，因此无法验证该语言内计算结果的准确性。但现在可以验证了。现在可以比较结果以查看它们是否正确，如果不正确，则显示错误消息（作为字符串）并退出。</p><p>因此，在这一步中，将用 shell 脚本编写的测试重写为 C 文件。</p><h1 id="程序执行示意图及初始化公式"><a href="#程序执行示意图及初始化公式" class="headerlink" title="程序执行示意图及初始化公式"></a><a href="#program">程序执行示意图及初始化公式</a></h1><p>现在，通过这些步骤，我们的编译器现在支持所有主要编程元素：函数、全局变量和局部变量。此外，通过学习拆分编译和链接，您现在了解如何分段编译程序，然后最后将它们组合成一个文件。</p><p>本章介绍操作系统如何执行可执行文件。通过阅读本章，您将能够了解可执行文件中包含哪些类型的数据以及调用 main 函数之前发生了什么。</p><p>本章还解释了变量初始化表达式，如何编译下面的代码，并向我们的编译器添加对初始化表达式的支持。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int x = 3;</span><br><span class="line">int y[3] = &#123;1, 2, 3&#125;;</span><br><span class="line">char *msg1 = &quot;foo&quot;;</span><br><span class="line">char msg2[] = &quot;bar&quot;;</span><br></pre></td></tr></table></figure><p>为了支持初始化表达式，这可能会令人惊讶，但了解程序在到达 main 之前如何运行是至关重要的。</p><p>本章介绍一种简单的可执行格式，其中在一个可执行文件中包含所有代码和数据。这样的可执行文件称为 “ 静态链接 “ 可执行文件。与静态链接相反，一种称为 “ 动态链接 “ 的可执行格式也被广泛使用，其中一个程序的片段被分成多个文件，当它们被执行时，它们在内存中组合并执行。我将解释这在一个单独的章节中。首先，我们来了解一下静态链接的基本模型。</p><h2 id="可执行文件结构"><a href="#可执行文件结构" class="headerlink" title="可执行文件结构"></a><a href="#%E5%AE%9F%E8%A1%8C%E3%83%95%E3%82%A1%E3%82%A4%E3%83%AB%E3%81%AE%E6%A7%8B%E9%80%A0">可执行文件结构</a></h2><p>可执行文件由文件头和一个或多个称为段的区域组成。可执行文件通常至少有两个段，每个段包含单独的可执行代码和数据。包含可执行代码的段称为 “ 文本段 “，包含其他数据的段称为 “ 数据段 “。实际的可执行文件还包含其他段，但它们不是理解机制所需要的，因此这里省略。</p><p>关于术语，请注意，虽然文本与文本文件中的文本是相同的单词，但它具有不同的含义。传统上，在较低层中，表示机器语言的数据称为 “ 文本 “。另外，机器语言只是一串字节，文本也是一种数据，但当我们谈论 “ 文本和数据 “ 时，” 数据 “ 通常指的是 “ 文本以外的数据 “。在本章中，当我们提到数据时，我们指的是文本以外的数据。</p><p>输入到链接器的目标文件分别包含文本和数据。链接器将从多个目标文件读取的文本连接起来并将其放入一个文本段中，并且类似地连接从多个目标文件中读取的数据并将其放入一个数据段中。</p><p>可执行文件的文件头包含执行期间每个段应放置的内存地址。当您运行可执行文件时，称为操作系统 “ 程序加载器 “ 或简称 “ 加载器 “ 的程序根据该信息将可执行文件中的文本和数据复制到内存中。</p><p>下图显示了一个可执行文件以及加载器如何将其加载到内存中。</p><p><img src="/../../../img/blog/f0562af6547749b6d7c436aae37b3fbc_MD5.svg"></p><p> 可执行文件和内存映像</p><p>在如图所示的可执行文件中，我们假设文件头包含加载 0x41000 处的文本段和 0x50000 处的数据段的信息。</p><p>文件头还包含有关应开始执行的地址的信息。例如，如果写入了从 0x41040 开始执行的信息，则加载器如上图所示将可执行文件加载到内存中，并将堆栈指针设置为 0x7fff_ffff_ffff_ffff，然后跳转到 0x41040，这将开始执行用户程序。</p><h2 id="数据段内容"><a href="#数据段内容" class="headerlink" title="数据段内容"></a><a href="#%E3%83%87%E3%83%BC%E3%82%BF%E3%82%BB%E3%82%B0%E3%83%A1%E3%83%B3%E3%83%88%E3%81%AE%E5%86%85%E5%AE%B9">数据段内容</a></h2><p>文本段的内容显然是机器代码，但是数据段里有什么呢？答案是数据段包含全局变量和文字字符串。</p><p>局部变量不直接包含在文本段或数据段中。局部变量是由程序在堆栈区域动态创建的，因此它们在可执行文件加载到内存后并不立即存在。</p><p>在 C 执行模型中，程序只需将可执行文件几乎不变地加载到内存中即可开始执行主函数。因此，必须将全局变量设置为适当的初始值，只需将它们从可执行文件的数据段复制到内存即可。</p><p>由于此限制，例如在 C 中，以下使用函数调用的初始化表达式不能用于全局变量。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int foo = bar();</span><br></pre></td></tr></table></figure><p>如果你有一个像上面这样需要动态初始化的全局变量，那么有人需要在执行 main 函数之前执行上面的表达式。然而，C 没有在 main 之前激活的初始化机制，因此这样的初始化是不可能的。</p><p>换句话说，全局变量的值必须在链接时完成，并作为字节序列存储在可执行文件中。此类值仅限于以下表达式：</p><ul><li>常量表达式</li><li>全局变量和函数的地址</li><li>全局变量或函数的地址加上常量</li></ul><p>显然，诸如文字数字或字符串之类的常量表达式可以在文本段中设置为固定值。</p><p>全局变量和函数的地址通常不是在编译时确定的，而是通常在链接器完成可执行文件时确定。因此，像 <code>int *x = &amp;y;</code> 这样用另一个全局变量的地址初始化指针类型全局变量的值的定义是合法的。链接器自行决定程序段的布局，当然也知道加载函数和全局变量的地址，因此可以在链接时填充 <code>x</code> 的内容。</p><p>此外，链接器支持向标签地址添加常量，因此像 <code>int *x = &amp;y + 3;</code> 这样的定义也是合法的。</p><p>初始化表达式中不能写入上述模式以外的表达式。例如，不能在初始化表达式中使用全局变量的值（而不是地址）。计算两个全局变量地址差异的表达式，如 <code>ptrdiff_t x = &amp;y - &amp;z;</code> ，原则上是可以在链接时计算其值的表达式，但是计算两个标签之间差异的操作是你无法在初始化表达式中写入这样的表达式，因为链接器不支持它。全局变量初始化表达式仅允许上面列出的有限模式。</p><p>可以在 C 中编写为全局变量初始化表达式的表达式示例如下。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int a = 3;</span><br><span class="line">char b[] = &quot;foobar&quot;;</span><br><span class="line">int *c = &amp;a;</span><br><span class="line">char *d = b + 3;</span><br></pre></td></tr></table></figure><p>每个表达式对应的程序集如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">a:</span><br><span class="line">  .long 3</span><br><span class="line">b:</span><br><span class="line">  .byte 0x66 // &#x27;f&#x27;</span><br><span class="line">  .byte 0x6f // &#x27;o&#x27;</span><br><span class="line">  .byte 0x6f // &#x27;o&#x27;</span><br><span class="line">  .byte 0x62 // &#x27;b&#x27;</span><br><span class="line">  .byte 0x61 // &#x27;a&#x27;</span><br><span class="line">  .byte 0x72 // &#x27;r&#x27;</span><br><span class="line">  .byte 0    // &#x27;\0&#x27;</span><br><span class="line">c:</span><br><span class="line">  .quad a</span><br><span class="line">d:</span><br><span class="line">  .quad b + 3</span><br></pre></td></tr></table></figure><p>连续的 <code>.byte</code> 也可以使用符号 <code>.ascii</code> 写为 <code>.ascii &quot;foobar\0&quot;</code> 。</p><p>コラム:  专栏：全局变量的动态初始化</p><p>在 C 中，全局变量的内容必须是静态确定的，但在 C++ 中，全局变量可以使用任意表达式进行初始化。换句话说，在 C++ 中，全局变量初始化表达式在调用 main 函数之前执行。它通过以下机制起作用。</p><ul><li>C++ 编译器将全局变量初始化表达式捆绑到函数中，并将函数指针打印到名为 <code>.init_array</code> 的特殊部分</li><li>链接器将多个输入文件的 <code>.init_array</code> 部分连接起来，并在 <code>.init_array</code> 段中输出它们（因此 <code>.init_array</code> 段包含函数指针数组）。</li><li>加载程序首先循环访问 <code>.init_array</code> 段中的函数指针，然后将控制权转移到 <code>main</code> 。</li></ul><p>这样，通过编译器、链接器和程序加载器的配合，就可以实现全局变量的动态初始化。</p><p>C 可以使用与 C++ 相同的机制来支持全局变量的动态初始化，但此类功能已被有意排除在 C 语言规范之外。</p><p>C 语言规范的设计选择对于那些编写程序的人来说限制性更大，但是对于那些在加载器较差或没有加载器的环境中运行程序的人（例如计算机启动时直接从 ROM 执行的代码）来说限制性更大。 ，意味着可以完全满足语言规范。因此，这是一个划分的问题，而不是谁谁谁谁的问题。</p><h2 id="初始化表达式语法"><a href="#初始化表达式语法" class="headerlink" title="初始化表达式语法"></a><a href="#%E5%88%9D%E6%9C%9F%E5%8C%96%E5%BC%8F%E3%81%AE%E6%96%87%E6%B3%95">初始化表达式语法</a></h2><p>乍一看，初始化表达式似乎只是一个赋值表达式，但实际上，初始化表达式和赋值表达式在语法上有很大不同，并且有一些特殊的写法只允许初始化表达式。让我们确保我们理解这种特殊的写作方式。</p><p>首先，初始化表达式可以初始化数组。例如，以下表达式初始化 <code>x</code> ，以便 <code>x[0]</code> 、 <code>x[1]</code> 和 <code>x[2]</code> 分别为 0、1 和 2。我是。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int x[3] = &#123;0, 1, 2&#125;;</span><br></pre></td></tr></table></figure><p>如果给出初始化表达式，则可以省略数组的长度，因为可以通过查看右侧元素的数量来确定数组的长度。例如，上面的表达式和下面的表达式具有相同的含义。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int x[] = &#123;0, 1, 2&#125;;</span><br></pre></td></tr></table></figure><p>如果显式给出了数组长度并且仅给出了部分初始化表达式，则其余元素必须初始化为零。因此，以下两个表达式具有相同的含义。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int x[5] = &#123;1, 2, 3, 0, 0&#125;;</span><br><span class="line">int x[5] = &#123;1, 2, 3&#125;;</span><br></pre></td></tr></table></figure><p>另外，作为 <code>char</code> 数组的初始化表达式的特殊语法，允许以下使用文字字符串作为初始化表达式的编写方式。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">char msg[] = &quot;foo&quot;;</span><br></pre></td></tr></table></figure><p> 上面的表达式与下面的表达式具有相同的含义。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">char msg[4] = &#123;&#x27;f&#x27;, &#x27;o&#x27;, &#x27;o&#x27;, &#x27;\0&#x27;&#125;;</span><br></pre></td></tr></table></figure><h2 id="全局变量初始化表达式"><a href="#全局变量初始化表达式" class="headerlink" title="全局变量初始化表达式"></a><a href="#%E3%82%B0%E3%83%AD%E3%83%BC%E3%83%90%E3%83%AB%E5%A4%89%E6%95%B0%E3%81%AE%E5%88%9D%E6%9C%9F%E5%8C%96%E5%BC%8F">全局变量初始化表达式</a></h2><p>全局变量的初始化表达式必须在编译时计算。计算的结果要么是简单的字节序列，要么是指向函数或全局变量的指针。对于指针，您可以使用一个整数来表示该指针的偏移量。</p><p>未给出任何初始化表达式的全局变量必须初始化为将所有位设置为 0。这是由 C 语法决定的。</p><p>如果初始化表达式没有导致上述计算，则将其视为编译错误。</p><h2 id="局部变量初始化表达式"><a href="#局部变量初始化表达式" class="headerlink" title="局部变量初始化表达式"></a><a href="#%E3%83%AD%E3%83%BC%E3%82%AB%E3%83%AB%E5%A4%89%E6%95%B0%E3%81%AE%E5%88%9D%E6%9C%9F%E5%8C%96%E5%BC%8F">局部变量初始化表达式</a></h2><p>局部变量初始化表达式看起来与全局变量初始化表达式相同，但它们的含义却截然不同。局部变量初始化表达式是当场执行的表达式。因此，不需要在编译时确定其内容。</p><p>基本上，像 <code>int x = 5;</code> 这样的语句将以与 <code>int x; x = 5;</code> 这样两个单独的语句相同的方式进行编译。</p><p>像 <code>int x[] = &#123;1, 2, foo()&#125;;</code> 这样的语句编译后与以下语句相同：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int x[3];</span><br><span class="line">x[0] = 1;</span><br><span class="line">x[1] = 2;</span><br><span class="line">x[2] = foo();</span><br></pre></td></tr></table></figure><p>未给出初始化表达式的局部变量的内容是未定义的。因此此类变量不需要初始化。</p><p>コラム:  列：字大小</p><p>在 x86-64 上，术语 “ 字 “ 表示 16 位和 64 位数据。这是一个复杂的情况，但有历史原因。</p><p>术语 “ 字 “ 最初是指计算机可以自然处理的最大整数或地址的大小。这就是 64 位在 64 位处理器 x86-64 中被称为 1 个字的地方。</p><p>另一方面，”16 位 “ 一词来自术语 “8086”，即 16 位处理器。当 Intel 工程师将 8086 扩展到 32 位以创建 386 处理器时，他们决定将 32 位称为双字或双字，以避免改变字的大小。类似地，x86-64 将 386 扩展为 64 位，并决定将 64 位称为四字或 qword。这种对兼容性的考虑导致了该词的两种不同含义。</p><h1 id="静态和动态链接"><a href="#静态和动态链接" class="headerlink" title="静态和动态链接"></a><a href="#dynamic-linking">静态和动态链接</a></h1><p>到目前为止，在本书中，我们只使用了称为静态链接的功能。静态链接是一种简单的执行模型，因此通过关注该模型，我能够以易于理解的方式解释诸如可执行文件的汇编代码和内存映像之类的内容。静态链接在创建文件时并没有广泛使用。实际上，广泛使用一种称为动态链接的功能来代替静态链接。</p><p>本章介绍静态链接和动态链接。</p><p>默认情况下，编译器和链接器尝试输出执行动态链接的可执行文件。读者可能已经发现，如果忘记在 <code>cc</code> 中添加 <code>-static</code> 选项，则会出现以下错误。如果没有，请尝试从 <code>Makefile</code> 选项&gt; 并运行 <code>make</code> ）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cc -o tmp tmp.s</span><br><span class="line">/usr/bin/ld: /tmp/ccaRuuub.o: relocation R_X86_64_32S against `.data&#x27; can not be used when making a PIE object; recompile with -fPIC</span><br><span class="line">/usr/bin/ld: final link failed: Nonrepresentable section on output</span><br></pre></td></tr></table></figure><p>默认情况下，链接器尝试动态链接，但为了动态链接，编译器必须输出可以执行此操作的汇编代码。 9cc 目前不输出此类代码，因此如果您忘记添加 <code>-static</code> ，您将收到类似上面的错误。阅读本章后，您应该能够理解上述错误的含义以及需要采取哪些措施来解决这些错误。</p><h2 id="静态链接"><a href="#静态链接" class="headerlink" title="静态链接"></a><a href="#%E3%82%B9%E3%82%BF%E3%83%86%E3%82%A3%E3%83%83%E3%82%AF%E3%83%AA%E3%83%B3%E3%82%AF">静态链接</a></h2><p>静态链接的可执行文件是一个独立的可执行文件，不需要任何其他文件来运行。例如， <code>printf</code> 之类的函数不是用户编写的函数，而是包含在 <code>libc</code> 标准库中的，但是如果使用静态链接创建可执行文件， <code>printf</code> 复制到可执行文件。运行静态链接程序时不需要 <code>libc</code> 。这是因为 <code>libc</code> 中必要的代码和数据已经被复制到可执行文件中。</p><p>让我们实际看看下面的简单程序 <code>hello.c</code> 是如何成为静态链接的可执行文件的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Hello world!\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要编译此 <code>hello.c</code> 文件并将其链接到名为 <code>hello</code> 的可执行文件，请输入以下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cc -c hello.c</span><br><span class="line">$ cc -o hello hello.o</span><br></pre></td></tr></table></figure><p>在上面的命令中，第一行编译 <code>hello.c</code> 以创建目标文件 <code>hello.o</code> ，第二行链接它使其成为可执行文件。也可以将这两个命令写在一起为 <code>cc -o hello hello.c</code> ，但是即使这样启动编译器，内部也会完成与上面两个命令相同的事情。</p><p><code>hello.c</code> 包含 <code>stdio.h</code> ，但正如我们到目前为止在本书中所看到的，头文件不包含函数体的代码本身。因此，在创建 <code>hello.o</code> 文件时，编译器知道 <code>stdio.h</code> 中声明的 <code>printf</code> 函数的存在和类型，但是&lt;我对 b5 一无所知&gt; 的实际代码。因此， <code>printf</code> 的代码不能包含在 <code>hello.o</code> 文件中。实际上， <code>hello.o</code> 仅包含 <code>main</code> 的定义。链接器负责组合 <code>hello.o</code> 和包含 <code>printf</code> 的目标文件来创建可执行文件。</p><p>当通过第二行 <code>cc</code> 启动链接器时，它不仅会使用命令行中传递的文件 <code>hello.o</code> ，还会使用系统标准库路径 <code>/usr/lib/x86_64-linux-gnu/libc.a</code> b2&gt; 也传递给链接器。 <code>printf</code> 函数包含在此 <code>libc.a</code> 函数中。 <code>.a</code> 是类似于 <code>.tar</code> 和 <code>.zip</code> 的归档文件。我们来看看里面吧。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ ar t /usr/lib/x86_64-linux-gnu/libc.a</span><br><span class="line">...</span><br><span class="line">printf_size.o</span><br><span class="line">fprintf.o</span><br><span class="line">printf.o</span><br><span class="line">snprintf.o</span><br><span class="line">sprintf.o</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>  <a href="https://github.com/rui314/musl/blob/master/src/stdio/printf.c">musl printf.c</a></p><p> 存档文件包含</p><p>静态链接的可执行文件的执行模型很简单。在运行时，内存中只存在可执行文件，因此可执行文件的每个段都可以加载到内存中的任何位置。当尝试加载到链接时确定的默认地址时，加载将不再失败。这是因为在加载可执行文件之前内存中没有任何内容。因此，通过静态链接，可以在链接时确定所有全局变量和函数的地址。</p><p> 静态链接有以下优点：</p><ul><li>简单快速的加载</li><li>没有依赖文件，因此只需复制可执行文件即可工作。</li><li>即使不同版本的库的行为略有不同，使用静态链接复制时库代码和数据也是固定的，因此相同的可执行文件在任何环境中都将以相同的方式工作。</li></ul><p> 静态链接有以下缺点：</p><ul><li>可执行文件使用的库函数和代码被复制，这会浪费一些磁盘和内存。</li><li>如果库中的错误得到修复，则需要重新链接现有的可执行文件以反映更改。</li></ul><p>另一方面，动态链接的可执行文件需要其他 <code>.so</code> （在 Unix 上）或 <code>.dll</code> （在 Windows 上）文件才能运行。 <code>.so</code> 和 <code>.dll</code> 包含函数代码（例如 <code>printf</code> ）和全局变量（例如 <code>errno</code> ）。诸如 <code>.so</code> 和 <code>.dll</code> 之类的文件称为动态库，或简称为库，或 DSO（动态共享对象）。</p><h1 id="C-类型语法"><a href="#C-类型语法" class="headerlink" title="C 类型语法"></a><a href="#type">C 类型语法</a></h1><p>本章介绍如何阅读 C 类型语法。到本章结束时，读者将能够按照逐步的方法解码诸如 <code>void (*x)(int)</code> 和 <code>void (*signal(int, void (*)(int)))(int)</code> 之类的复杂类型。应该是这样。</p><h2 id="代表类型的图表"><a href="#代表类型的图表" class="headerlink" title="代表类型的图表"></a><a href="#%E5%9E%8B%E3%82%92%E8%A1%A8%E3%81%99%E5%9B%B3">代表类型的图表</a></h2><p>C 语言可以表达的类型比较简单。为了将类型语法的复杂性与类型本身的复杂性分开，让我们暂时将语法放在一边，只考虑类型。</p><p>诸如指针和数组之类的复杂类型可以通过用箭头连接简单类型的图表来表示。例如，下图显示了表示 “ 指向 int 的指针 “ 的类型。</p><p><img src="/../../../img/blog/4c3a749491fed60036e8c70840e3c681_MD5.svg"></p><p>在日语中，从箭头的终点到起点读作 “int 指针的指针 “。在英语中，发音相反：指向 int 指针的指针，遵循箭头的方向。</p><p>假设变量 <code>x</code> 具有上图所示的类型。对于 “ <code>x</code> 的类型是什么？” 这个问题，最简单的答案是 “ 它是一个指针 “。这是因为第一个箭头指向的类型是指针类型。注意， <code>x</code> 首先是一个指针，而不是 <code>int</code> 这样的类型。 “ 该指针指向什么类型？” 这个问题的答案是 “ 它是一个指针 “。这是因为跟随一个箭头的指针也是一种指针类型。最后，” 该指针指向什么类型？” 这个问题的答案是 “int”。</p><p>下图显示了一个 “int 指针数组 “。数组的长度是 20。在实际的编译器中，数组的长度也表示为代表数组的类型的成员，如下图所示。</p><p><img src="/../../../img/blog/28a0d0b33ca1290558c334017d93013f_MD5.svg"></p><p>如果变量 <code>x</code> 具有上图所示的类型，则 <code>x</code> 是长度为 20 的数组类型，并且该数组的元素是指针，该指针指向的变为&lt; b2&gt;。</p><p>函数类型也可以用图形表示。下图显示了带有两个参数（一个 int 和一个指向 int 的指针）并返回一个 void 指针的函数类型。</p><p><img src="/../../../img/blog/3ff805c41a8cd70412adac62e7e4088e_MD5.svg"></p><p>最后，让我们看一个更复杂的例子。下图显示了一种称为函数指针的类型，它采用 int 作为参数，并返回一个指向返回 int 的函数的指针。用文字表达很复杂，但用图表表达时，你会发现它很长，结构也很简单。</p><p><img src="/../../../img/blog/a31ebf2dc070eaf5a531a5e847963463_MD5.svg"></p><p>如果变量 <code>x</code> 具有上图所示的类型，则 <code>x</code> 是指针类型，该指针指向一个函数，该函数的参数类型为 In <code>int</code> ，返回类型为指针类型，指针指向一个函数，该函数的返回值类型为 <code>int</code> 。</p><p>在内部，编译器使用与上图相同的方法来表示类型。换句话说，涉及指针、数组和函数的复杂类型在编译器内部表示为由指针连接的简单类型结构组成的数据结构，其顺序与上图所示的顺序相同。因此，毫不夸张地说，这张图就是型的真实形态。</p><h2 id="表示类型的符号"><a href="#表示类型的符号" class="headerlink" title="表示类型的符号"></a><a href="#%E5%9E%8B%E3%82%92%E8%A1%A8%E3%81%99%E8%A8%98%E6%B3%95">表示类型的符号</a></h2><p>尽管用如上所示的图表表示类型时更容易理解类型的含义，但每次都画图表来理解类型是很乏味的。在本节中，我们将考虑一种可以写得更紧凑而又不影响图表清晰度的符号。</p><p>除非包含功能类型，否则所有框都将以菊花链形式排列在图中，没有任何分支。因此，如果类型只有指针或数组，您应该能够通过在图中从左到右书写类型的名称来用文本表达图。</p><p>我们来考虑一下具体的记法。代表指针的框将由符号 <code>*</code> 表示。另外，规则是在表示长度为 n 的数组的框中写入 <code>[n]</code> ，并在表示内置类型（例如 int）的框中写入类型名称。那么，下图就可以用字符串 <code>* * int</code> 来表示。</p><p><img src="/../../../img/blog/4c3a749491fed60036e8c70840e3c681_MD5.svg"></p><p>从箭头起点开始依次出现 pointer、pointer、int，因此表示法为 <code>* * int</code> 。相反，如果我们给出符号 <code>* * int</code> ，我们也可以画出上面的图。换句话说，这种文本表示是一种符号，允许您以文本形式紧凑地写下与图表相同的信息。</p><p>下图可以用字符串 <code>[20] * int</code> 来表示。</p><p><img src="/../../../img/blog/28a0d0b33ca1290558c334017d93013f_MD5.svg"></p><p>对于函数，我们将其写为 “ <code>func(引数の型, …) 返り値の型</code> “。例如下图所示的类型写为 <code>func(int, * int) * void</code> 。鼓励读者检查该符号是否与图表相符。</p><p><img src="/../../../img/blog/3ff805c41a8cd70412adac62e7e4088e_MD5.svg"></p><p>最后，如下图所示的类型是 <code>* func(int) * func() int</code> 。</p><p><img src="/../../../img/blog/a31ebf2dc070eaf5a531a5e847963463_MD5.svg"></p><p>到目前为止描述的符号可能是类型的最直接和最简单的文本表示。事实上，Go 编程语言中的类型语法与这里描述的表示法完全相同。 Go 是一门由 C 的创建者参与开发的语言，Go 中的类型语法通过吸取 C 的经验教训而得到了巧妙的改进。 </p><h1 id="综上所述"><a href="#综上所述" class="headerlink" title="综上所述"></a><a href="#%E3%81%8A%E3%82%8F%E3%82%8A%E3%81%AB">综上所述</a></h1><p>本书正文以 Markdown 格式编写。我使用 Pandoc 将 Markdown 转换为 HTML，使用 Graphviz 创建语法树图，使用 draw.io 创建其他图表。</p><hr><h1 id="附录：使用Docker创建开发环境"><a href="#附录：使用Docker创建开发环境" class="headerlink" title="附录：使用Docker创建开发环境"></a><a href="#docker">附录：使用Docker创建开发环境</a></h1><p>本附录介绍了如何使用 Docker 在 macOS 上构建和运行 Linux 应用程序。</p><p>Docker 是提供 Linux 虚拟环境的软件。全功能虚拟机模拟 PC 硬件并在其上运行常规操作系统，而 Docker 直接在虚拟环境中提供（仅）Linux 系统调用，这是有区别的。与全功能虚拟化相比，这种差异使 Docker 具有启动速度更快、整体重量更轻的优势。将应用程序部署到云中的计算机时经常使用 Docker。</p><p>使用 Docker 在 macOS 上开发 Linux 应用程序时，可以考虑以下两种系统配置。</p><ol><li><p>在开发 Linux 应用程序时，Docker 内部的环境和外部的环境被认为是完全不同的，所有工作都在 Docker 内部完成。</p></li><li><p>一种配置，其中正常的独立于平台的开发工作（例如源代码编辑和 git 操作）在 Docker 外部执行，并且仅在 Docker 内执行构建和测试命令。</p></li></ol><p>前面的配置中，配置很简单，因为和 Mac 分开准备一台 Linux 机器进行开发是一样的，但是设置有点复杂，因为需要在 Linux 上准备一个开发环境，包括编辑器。另一方面，在后面的配置中，你并不 “ 居住 “ 在 Docker 内部，因此你不必担心环境的设置，但是在 Docker 内部和外部都使用有点麻烦。</p><p>虽然您可以选择上述两种配置中的任何一种，但在本书中我们将选择后一种配置，以避免描述 Linux 环境的设置步骤。因此，只有你想在 Linux 环境中运行的命令才会在 Docker 中显式执行。</p><h2 id="设置说明"><a href="#设置说明" class="headerlink" title="设置说明"></a><a href="#%E3%82%BB%E3%83%83%E3%83%88%E3%82%A2%E3%83%83%E3%83%97%E6%89%8B%E9%A0%86">设置说明</a></h2><p>要使用 Docker 设置 Linux 开发环境，请首先下载并安装 Docker Desktop for Mac。然后，您可以通过运行以下命令创建名为 <code>compilerbook</code> 的 Docker 映像：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker build -t compilerbook https://www.sigbus.info/compilerbook/Dockerfile</span><br></pre></td></tr></table></figure><p>“Docker 镜像 “ 或 “ 镜像 “ 是 Linux 环境所需的所有文件和设置的集合。实际启动 Docker 镜像的称为 “Docker 容器 “ 或简称为 “ 容器 “（与可执行文件和进程之间的关系相同）。</p><p>要创建容器并在其中运行命令，请将映像名称和命令作为参数传递给 <code>docker run</code> 命令。以下是在 <code>compilerbook</code> 容器内执行 <code>ls /</code> 命令的示例。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ docker run --rm compilerbook ls /</span><br><span class="line">bin</span><br><span class="line">root</span><br><span class="line">dev</span><br><span class="line">etc</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>保持容器在后台运行是可以的，但是由于我们只需要交互使用，所以我们可以指定 <code>--rm</code> 选项，这样命令完成后容器就会退出。我决定这样做。因此，每次输入上述命令时，都会创建和销毁一个容器。</p><h2 id="使用容器构建"><a href="#使用容器构建" class="headerlink" title="使用容器构建"></a><a href="#%E3%82%B3%E3%83%B3%E3%83%86%E3%83%8A%E3%82%92%E4%BD%BF%E3%81%A3%E3%81%9F%E3%83%93%E3%83%AB%E3%83%89">使用容器构建</a></h2><p>为了在容器内运行 <code>make</code> 并编译源文件，您需要使您在 Docker 外部编辑的源文件对容器可见。</p><p><code>docker run</code> 允许您在 Docker 中指定外部环境路径 <code>&lt;source&gt;</code> ，通过给 <code>-v &lt;source&gt;:&lt;dest&gt;</code> 到 <code>&lt;dest&gt;</code> 形式的选项即可看起来像这样。您还可以在执行命令时使用 <code>-w</code> 选项指定当前目录。使用这些选项，您可以运行 <code>make</code> ，并将包含源文件的目录设置为当前目录。</p><p>假设您的源文件位于主目录中名为 <code>9cc</code> 的子目录中。要从容器内针对该目录运行 <code>make test</code> ，请运行以下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run --rm -v $HOME/9cc:/9cc -w /9cc compilerbook make test</span><br></pre></td></tr></table></figure><p>请如上所述运行构建和测试命令。</p><p>如果您想在容器内启动 shell 并以交互方式使用它，请使用 <code>-it</code> 选项运行 <code>docker run</code> ，如下所示。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run --rm -it -v $HOME/9cc:/9cc compilerbook</span><br></pre></td></tr></table></figure><h2 id="将新应用程序添加到容器"><a href="#将新应用程序添加到容器" class="headerlink" title="将新应用程序添加到容器"></a><a href="#%E3%82%B3%E3%83%B3%E3%83%86%E3%83%8A%E3%81%AB%E6%96%B0%E3%81%9F%E3%81%AA%E3%82%A2%E3%83%97%E3%83%AA%E3%82%B1%E3%83%BC%E3%82%B7%E3%83%A7%E3%83%B3%E3%82%92%E8%BF%BD%E5%8A%A0">将新应用程序添加到容器</a></h2><p>您在上面创建的 Docker 容器附带安装了一组开发工具，但您可能需要安装其他应用程序。就是这样。</p><p>Docker 容器是临时对象。即使您创建容器并从其中的 shell 安装应用程序，这些更改也不会写回原始映像。 Docker 的这一属性可确保应用程序每次都从相同的新鲜状态启动，但当您想要更改映像时，此属性是一种负担。</p><p>如果您对容器进行了更改并希望将其写回到映像中，则必须显式运行 <code>docker commit</code> 命令。</p><p>例如，假设您要安装 <code>curl</code> 命令。在这种情况下，首先按如下方式创建一个容器。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -it compilerbook</span><br></pre></td></tr></table></figure><p>请注意，我们没有传递 <code>--rm</code> 选项。然后，在容器内的 shell 中使用 <code>apt</code> 安装 <code>curl</code> ，并使用 <code>exit</code> 命令退出容器。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt update</span><br><span class="line">$ sudo apt install -y curl</span><br><span class="line">$ exit</span><br></pre></td></tr></table></figure><p>由于我们在执行 <code>docker run</code> 时没有指定 <code>--rm</code> 选项，因此即使从容器 shell 退出后，容器仍保持挂起状态。您可以使用 <code>docker container ls -a</code> 命令显示挂起的容器，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker container ls -a</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS                     PORTS               NAMES</span><br><span class="line">a377e570d1da        compilerbook        &quot;/bin/bash&quot;         7 seconds ago       Exited (0) 5 seconds ago                       pedantic_noyce</span><br></pre></td></tr></table></figure><p>您应该看到有一个 ID 为 <code>a377e570d1da</code> 的容器正在运行映像 <code>compilerbook</code> 。 <code>docker commit</code> 命令允许您将容器写回映像。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker commit a377e570d1da compilerbook</span><br></pre></td></tr></table></figure><p>您可以使用上述步骤更改图像。</p><p>挂起的容器或旧镜像没有什么特别的问题，因为它们只消耗一些磁盘空间，但如果您担心它们，可以通过运行 <code>docker system prune</code> 来删除它们。</p><hr><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a><a href="#%E5%8F%82%E8%80%83%E8%B3%87%E6%96%99">参考资料</a></h1><ul><li>Compiler Explorer：方便的在线编译器</li><li>N1570 [PDF]：C11 语言规范最终草案（与官方标准内容相同）</li><li>N1570：C11 语言规范的 HTML 版本</li><li>X4J11&#x2F;86-196 [PDF]：C 预处理器宏展开算法说明</li><li>美国国家信息系统标准的基本原理 - 编程语言 - C：解释标准委员会在决定 C89 语言规范时考虑的内容的文本。</li><li>8cc：作者的 C 编译器</li><li>9cc：作者的 C 编译器</li><li><a href="https://qiita.com/ruiu/items/4d471216b71ab48d8b74">我尝试从头开始开发 C 编译器（日记）</a></li><li>An Incremental Approach to Compiler Construction [PDF]：一篇论文让我产生了增量编译器开发的想法。</li><li>手工翻译：罗伯特·尼斯特罗姆 (Robert Nystrom) 撰写的在线书籍</li><li>可重定向 C 编译器：设计和实现。David R. Hanson 和 Christopher W. Fraser：实现简单 C 编译器 lcc 的指南。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> 编译汇编 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Python应用</title>
      <link href="/posts/%E5%BA%94%E7%94%A8/%E8%AF%AD%E8%A8%80/Python/Python%E5%BA%94%E7%94%A8.html"/>
      <url>/posts/%E5%BA%94%E7%94%A8/%E8%AF%AD%E8%A8%80/Python/Python%E5%BA%94%E7%94%A8.html</url>
      
        <content type="html"><![CDATA[<h1 id="解方程"><a href="#解方程" class="headerlink" title="解方程"></a>解方程</h1><p><strong>Brent 方法</strong></p><p>Brent 方法是一种数值寻根算法，用于解方程 f(x)&#x3D;0,它结合了二分法（bisection）、弦截法（secant）以及反复同步这两者的过程来实现高效的迭代。</p><p>简要介绍 Brent 方法的思想：</p><ul><li>首先使用二分法确定一个包含根的初始区间 [a,b]。</li><li>在每一次迭代中，通过比较二分法和弦截法的结果来决定采取哪种方法更接近根。</li><li>反复同步二分法和弦截法，并不断缩小区间，直至找到满足精度要求的根。</li><li>相比于其他常见的寻根方法，如 Newton-Raphson 方法和割线法，Brent 方法具有高精度、全局收敛和鲁棒性等优点。在大多数情况下，Brent 方法都比其他算法更快地收敛，尤其是当方程存在多个根或根附近存在奇点时。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> scipy.optimize</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> x**<span class="number">3</span> + np.cos(x) - np.exp(x)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定求解区间 [0, 1]</span></span><br><span class="line">x_values = np.linspace(-<span class="number">1</span>, <span class="number">1</span>, num=<span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 找到所有满足条件的 x 解</span></span><br><span class="line">solutions = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(x_values)-<span class="number">1</span>):</span><br><span class="line">    start, end = x_values[i:i+<span class="number">2</span>]</span><br><span class="line">    <span class="keyword">if</span> func(start) * func(end) &lt; <span class="number">0</span>:</span><br><span class="line">        sol = scipy.optimize.root_scalar(func, bracket=[start, end], method=<span class="string">&#x27;brentq&#x27;</span>, rtol=<span class="number">1e-6</span>)</span><br><span class="line">        solutions.append(sol.root)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印解的个数和具体值</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Found <span class="subst">&#123;<span class="built_in">len</span>(solutions)&#125;</span> solutions: <span class="subst">&#123;solutions&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><p>参考：<a href="https://mp.weixin.qq.com/s/oxe26KwAUihtZHZgbhbb_Q">python之求解非线性方程 (qq.com)</a></p><h1 id="Python-Fire：自动生成命令行接口"><a href="#Python-Fire：自动生成命令行接口" class="headerlink" title="Python Fire：自动生成命令行接口"></a>Python Fire：自动生成命令行接口</h1><p><a href="https://mp.weixin.qq.com/s/Rp7yghuqujeTnzaV4K9xgw">Python Fire：自动生成命令行接口 (qq.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> 应用 </category>
          
          <category> 语言 </category>
          
          <category> Python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Python安装配置</title>
      <link href="/posts/%E5%BA%94%E7%94%A8/%E9%85%8D%E7%BD%AE/%E8%AF%AD%E8%A8%80%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/Python%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE.html"/>
      <url>/posts/%E5%BA%94%E7%94%A8/%E9%85%8D%E7%BD%AE/%E8%AF%AD%E8%A8%80%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/Python%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE.html</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.python.org/">Welcome to Python.org</a></p><h1 id="pip-下载配置"><a href="#pip-下载配置" class="headerlink" title="pip 下载配置"></a>pip 下载配置</h1><h2 id="临时替换下载源：假设现在我要下载-selenium-这个第三方模块"><a href="#临时替换下载源：假设现在我要下载-selenium-这个第三方模块" class="headerlink" title="临时替换下载源：假设现在我要下载 selenium 这个第三方模块"></a>临时替换下载源：假设现在我要下载 selenium 这个第三方模块</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install -i https://pypi.douban.com/simple/ selenium </span><br></pre></td></tr></table></figure><p>-i 参数表示这一次下载指定某个下载源，下次不再生效</p><h2 id="使用-pip-config-set-永久替换下载源"><a href="#使用-pip-config-set-永久替换下载源" class="headerlink" title="使用 pip config set 永久替换下载源"></a>使用 pip config set 永久替换下载源</h2><ul><li>在命令行中执行以下两条指令（win10 是 cmd），pip 版本需要&gt;&#x3D;10.0.0</li></ul><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip config set global.index-url https://mirrors.aliyun.com/pypi/simple</span><br><span class="line">pip config set install.trusted-host mirrors.aliyun.com</span><br></pre></td></tr></table></figure><h1 id="更改-Python-的-pip-install-默认使用的-pip-库以及默认安装路径"><a href="#更改-Python-的-pip-install-默认使用的-pip-库以及默认安装路径" class="headerlink" title="更改 Python 的 pip install 默认使用的 pip 库以及默认安装路径"></a>更改 Python 的 pip install 默认使用的 pip 库以及默认安装路径</h1><p><a href="https://blog.csdn.net/C_chuxin/article/details/82962797">更改 Python 的 pip install 默认使用的pip库以及默认安装路径_更改pip安装路径-CSDN博客</a></p><h1 id="Anaconda-安装和使用指南"><a href="#Anaconda-安装和使用指南" class="headerlink" title="Anaconda 安装和使用指南"></a>Anaconda 安装和使用指南</h1><p><a href="https://zhuanlan.zhihu.com/p/36398337">[Python]Anaconda 安装和使用指南 - 知乎 (zhihu. com)</a></p>]]></content>
      
      
      <categories>
          
          <category> 应用 </category>
          
          <category> 配置 </category>
          
          <category> 语言环境配置 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>使用Nushell</title>
      <link href="/posts/%E5%BA%94%E7%94%A8/%E9%85%8D%E7%BD%AE/%E7%BB%88%E7%AB%AF/%E4%BD%BF%E7%94%A8Nushell.html"/>
      <url>/posts/%E5%BA%94%E7%94%A8/%E9%85%8D%E7%BD%AE/%E7%BB%88%E7%AB%AF/%E4%BD%BF%E7%94%A8Nushell.html</url>
      
        <content type="html"><![CDATA[<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p><a href="https://www.nushell.sh/zh-CN/book/installation.html">安装 Nu | Nushell</a></p><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><p><a href="https://www.nushell.sh/zh-CN/book/configuration.html">配置 | Nushell</a></p><h2 id="Oh-my-posh-主题配置"><a href="#Oh-my-posh-主题配置" class="headerlink" title="Oh-my-posh 主题配置"></a>Oh-my-posh 主题配置</h2><ol><li><p><a href="https://ohmyposh.dev/docs/installation/windows">安装 Oh My Posh</a></p></li><li><p>在 Nushell 下运行</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">oh-my-posh init nu --config D:\Scoop\apps\oh-my-posh\current\themes\powerlevel10k_rainbow.omp.json --print | save D:\powerlevel10k_rainbow.nu --force</span><br></pre></td></tr></table></figure><p>编辑 Nushell 配置文件 ( <code>$nu.config-path</code> ) 并在底部添加以下行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source D:\powerlevel10k_rainbow.nu</span><br></pre></td></tr></table></figure><blockquote><p>参考：<a href="https://ohmyposh.dev/docs/installation/customize">Customize | Oh My Posh</a></p></blockquote><h2 id="Vscode-高亮插件"><a href="#Vscode-高亮插件" class="headerlink" title="Vscode 高亮插件"></a>Vscode 高亮插件</h2><p><a href="https://github.com/nushell/vscode-nushell-lang">nushell&#x2F;vscode-nushell-lang: A Nushell grammar for Visual Studio Code with IDE support (github.com)</a></p><h2 id="配置-nushell"><a href="#配置-nushell" class="headerlink" title="配置 nushell"></a>配置 nushell</h2><p>进入 <code>nu</code> 环境 (直接输入 <code>nu</code> 回车即可), 遇到选择直接默认回车即可</p><h3 id="不显示-banner"><a href="#不显示-banner" class="headerlink" title="不显示 banner"></a>不显示 <code>banner</code></h3><ol><li><p>运行 <code>$nu.config-path</code> 查看配置文件地址, 或你安装了 <code>neovim</code> 直接 <code>nvim $nu.config-path</code> 亦可</p></li><li><p>查找 <code>show_banner</code> 并修改为 <code>false</code></p></li></ol><h3 id="starship"><a href="#starship" class="headerlink" title="starship"></a>starship</h3><p>此处配置与官方和大部分教程不同, 提前让 nushell 支持 右侧提示 编辑 <code>~\.config\nu\fnm.nu</code> 文件 将 <code>替换为你starship.exe的位置</code> 替换你懂的意思, 以及不要动它旁边的单引号</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">let-env STARSHIP_SHELL = &quot;nu&quot;</span><br><span class="line">let-env STARSHIP_SESSION_KEY = (random chars -l 16)</span><br><span class="line">let-env PROMPT_MULTILINE_INDICATOR = (^&#x27;替换为你starship.exe的位置&#x27; prompt --continuation)</span><br><span class="line"></span><br><span class="line"># Does not play well with default character module.</span><br><span class="line"># TODO: Also Use starship vi mode indicators?</span><br><span class="line">let-env PROMPT_INDICATOR = &quot;&quot;</span><br><span class="line"></span><br><span class="line">let-env PROMPT_COMMAND = &#123;</span><br><span class="line">    # jobs are not supported</span><br><span class="line">    let width = (term size).columns</span><br><span class="line">    ^&#x27;替换为你starship.exe的位置&#x27; prompt $&quot;--cmd-duration=($env.CMD_DURATION_MS)&quot; $&quot;--status=($env.LAST_EXIT_CODE)&quot; $&quot;--terminal-width=($width)&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># Not well-suited for `starship prompt --right`.</span><br><span class="line"># Built-in right prompt is equivalent to $fill$right_format in the first prompt line.</span><br><span class="line"># Thus does not play well with default `add_newline = True`.</span><br><span class="line">let-env PROMPT_COMMAND_RIGHT = &#123;</span><br><span class="line">    let width = (term size).columns</span><br><span class="line">    ^&#x27;替换为你starship.exe的位置&#x27; prompt --right $&quot;--cmd-duration=($env.CMD_DURATION_MS)&quot; $&quot;--status=($env.LAST_EXIT_CODE)&quot; $&quot;--terminal-width=($width)&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在 <code>nu</code> 的配置文件中激活 , 在 <code>$nu.config-path</code> 末尾添加 <code>source ~/.cache/starship/init.nu</code></p><p>此时 <code>starship</code> 的 <code>right_format</code> 配置就能使用了</p><p>附上我的配置文件, 很简洁, 位置为 <code>~\.config\starship.toml</code></p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">add_newline</span> = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="attr">format</span> = <span class="string">&quot;&quot;&quot;$character&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># move the rest of the prompt to the right</span></span><br><span class="line"><span class="attr">right_format</span> = <span class="string">&quot;&quot;&quot;$all&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><h3 id="代理脚本"><a href="#代理脚本" class="headerlink" title="代理脚本"></a>代理脚本</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alias nuproxy = (let-env http_proxy = &quot;http://127.0.0.1:7890&quot; ; let-env https_proxy = &quot;http://127.0.0.1:7890&quot;)</span><br><span class="line">alias unproxy = (unlet-env http_proxy ; unlet-env https_proxy ; )</span><br></pre></td></tr></table></figure><h3 id="alias"><a href="#alias" class="headerlink" title="alias"></a>alias</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">alias l = (ls)</span><br><span class="line">alias ll = (ls -al)</span><br><span class="line">alias c = (clear)</span><br><span class="line">alias pwd = ($env.PWD)</span><br><span class="line">def b [file] &#123;bat -p $file&#125;</span><br><span class="line">def n [file] &#123;nvim $file&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 应用 </category>
          
          <category> 配置 </category>
          
          <category> 终端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux故障定位小技巧</title>
      <link href="/posts/%E5%BA%94%E7%94%A8/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux/Linux%E6%95%85%E9%9A%9C%E5%AE%9A%E4%BD%8D%E5%B0%8F%E6%8A%80%E5%B7%A7.html"/>
      <url>/posts/%E5%BA%94%E7%94%A8/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux/Linux%E6%95%85%E9%9A%9C%E5%AE%9A%E4%BD%8D%E5%B0%8F%E6%8A%80%E5%B7%A7.html</url>
      
        <content type="html"><![CDATA[<h1 id="接入层问题故障定位"><a href="#接入层问题故障定位" class="headerlink" title="接入层问题故障定位"></a><a href="https://www.jianshu.com/p/0bbac570fa4c">接入层问题故障定位</a></h1><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>有时候会遇到一些疑难杂症，并且监控插件并不能一眼立马发现问题的根源。这时候就需要登录服务器进一步深入分析问题的根源。那么分析问题需要有一定的技术经验积累，并且有些问题涉及到的领域非常广，才能定位到问题。所以，分析问题和踩坑是非常锻炼一个人的成长和提升自我能力。如果我们有一套好的分析工具，那将是事半功倍，能够帮助大家快速定位问题，节省大家很多时间做更深入的事情。</p><h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>本篇文章主要介绍各种问题定位的工具以及会结合案例分析问题。</p><h1 id="分析问题的方法论"><a href="#分析问题的方法论" class="headerlink" title="分析问题的方法论"></a>分析问题的方法论</h1><p>套用 5 W 2 H 方法，可以提出性能分析的几个问题</p><ul><li>What- 现象是什么样的</li><li>When- 什么时候发生</li><li>Why- 为什么会发生</li><li>Where- 哪个地方发生的问题</li><li>How much- 耗费了多少资源</li><li>How to do- 怎么解决问题</li></ul><h1 id="Cpu"><a href="#Cpu" class="headerlink" title="Cpu"></a>Cpu</h1><h2 id="说明-1"><a href="#说明-1" class="headerlink" title="说明"></a>说明</h2><p>针对应用程序，我们通常关注的是内核 CPU 调度器功能和性能。</p><p>线程的状态分析主要是分析线程的时间用在什么地方，而线程状态的分类一般分为：</p><p>a. on-CPU：执行中，执行中的时间通常又分为用户态时间 user 和系统态时间 sys。<br>b. off-CPU：等待下一轮上 CPU，或者等待 I&#x2F;O、锁、换页等等，其状态可以细分为可执行、匿名换页、睡眠、锁、空闲等状态。</p><p>如果大量时间花在 CPU 上，对 CPU 的剖析能够迅速解释原因；如果系统时间大量处于 off-cpu 状态，定位问题就会费时很多。但是仍然需要清楚一些概念：</p><ul><li>处理器</li><li>核</li><li>硬件线程</li><li>CPU 内存缓存</li><li>时钟频率</li><li>每指令周期数 CPI 和每周期指令数 IPC</li><li>CPU 指令</li><li>使用率</li><li>用户时间／内核时间</li><li>调度器</li><li>运行队列</li><li>抢占</li><li>多进程</li><li>多线程</li><li>字长</li></ul><h2 id="分析工具"><a href="#分析工具" class="headerlink" title="分析工具"></a>分析工具</h2><table><thead><tr><th>工具</th><th>描述</th></tr></thead><tbody><tr><td>uptime</td><td>平均负载</td></tr><tr><td>vmstat</td><td>包括系统范围的 cpu 平均负载</td></tr><tr><td>mpstat</td><td>查看所有 cpu 核信息</td></tr><tr><td>top</td><td>监控每个进程 cpu 用量</td></tr><tr><td>sar -u</td><td>查看 cpu 信息</td></tr><tr><td>pidstat</td><td>每个进程 cpu 用量分解</td></tr><tr><td>perf</td><td>cpu 剖析和跟踪，性能计数分析</td></tr></tbody></table><p>说明:</p><ul><li>Uptime, vmstat, mpstat, top, pidstat 只能查询到 cpu 及负载的的使用情况。</li><li>Perf 可以跟着到进程内部具体函数耗时情况，并且可以指定内核函数进行统计，指哪打哪。</li></ul><h2 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//查看系统 cpu 使用情况</span><br><span class="line">top</span><br><span class="line"></span><br><span class="line">//查看所有 cpu 核信息</span><br><span class="line">mpstat -P ALL 1</span><br><span class="line"></span><br><span class="line">//查看 cpu 使用情况以及平均负载</span><br><span class="line">vmstat 1</span><br><span class="line"></span><br><span class="line">//进程 cpu 的统计信息</span><br><span class="line">pidstat -u 1 -p pid</span><br><span class="line"></span><br><span class="line">//跟踪进程内部函数级 cpu 使用情况</span><br><span class="line">perf top -p pid -e cpu-clock</span><br></pre></td></tr></table></figure><h1 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h1><h2 id="说明-2"><a href="#说明-2" class="headerlink" title="说明"></a>说明</h2><p>内存是为提高效率而生，实际分析问题的时候，内存出现问题可能不只是影响性能，而是影响服务或者引起其他问题。同样对于内存有些概念需要清楚：</p><ul><li>主存</li><li>虚拟内存</li><li>常驻内存</li><li>地址空间</li><li>OOM</li><li>页缓存</li><li>缺页</li><li>换页</li><li>交换空间</li><li>交换</li><li>用户分配器 libc、glibc、libmalloc 和 mtmalloc</li><li>LINUX 内核级 SLUB 分配器</li></ul><h2 id="分析工具-1"><a href="#分析工具-1" class="headerlink" title="分析工具"></a>分析工具</h2><table><thead><tr><th>工具</th><th>描述</th></tr></thead><tbody><tr><td>free</td><td>缓存容量统计信息</td></tr><tr><td>vmstat</td><td>虚拟内存统计信息</td></tr><tr><td>top</td><td>监视每个进程的内存使用情况</td></tr><tr><td>pidstat</td><td>显示活动进程的内存使用统计</td></tr><tr><td>pmap</td><td>查看进程的内存映像信息</td></tr><tr><td>sar -r</td><td>查看内存</td></tr><tr><td>dtrace</td><td>动态跟踪</td></tr><tr><td>valgrind</td><td>分析程序性能及程序中的内存泄露错误</td></tr></tbody></table><p><strong>说明</strong>：</p><ul><li>Free, vmstat, top, pidstat, pmap 只能统计内存信息以及进程的内存使用情况。</li><li>Valgrind 可以分析内存泄漏问题。</li><li>Dtrace 动态跟踪。需要对内核函数有很深入的了解，通过 D 语言编写脚本完成跟踪。</li></ul><h2 id="使用方式-1"><a href="#使用方式-1" class="headerlink" title="使用方式"></a>使用方式</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//查看系统内存使用情况</span><br><span class="line">free -m</span><br><span class="line"></span><br><span class="line">//虚拟内存统计信息</span><br><span class="line">vmstat 1</span><br><span class="line"></span><br><span class="line">//查看系统内存情况</span><br><span class="line">top</span><br><span class="line"></span><br><span class="line">//1s 采集周期，获取内存的统计信息</span><br><span class="line">pidstat -p pid -r 1</span><br><span class="line"></span><br><span class="line">//查看进程的内存映像信息</span><br><span class="line">pmap -d pid</span><br><span class="line"></span><br><span class="line">//检测程序内存问题</span><br><span class="line">valgrind --tool=memcheck --leak-check=full --log-file=./log.txt ./程序名</span><br></pre></td></tr></table></figure><h1 id="磁盘-IO"><a href="#磁盘-IO" class="headerlink" title="磁盘 IO"></a>磁盘 IO</h1><h2 id="说明-3"><a href="#说明-3" class="headerlink" title="说明"></a>说明</h2><p>磁盘通常是计算机最慢的子系统，也是最容易出现性能瓶颈的地方，因为磁盘离 CPU 距离最远而且 CPU 访问磁盘要涉及到机械操作，比如转轴、寻轨等。访问硬盘和访问内存之间的速度差别是以数量级来计算的，就像 1 天和 1 分钟的差别一样。要监测 IO 性能，有必要了解一下基本原理和 Linux 是如何处理硬盘和内存之间的 IO 的。</p><p>在理解磁盘 IO 之前，同样我们需要理解一些概念，例如：</p><ul><li>文件系统</li><li>VFS</li><li>文件系统缓存</li><li>页缓存 page cache</li><li>缓冲区高速缓存 buffer cache</li><li>目录缓存</li><li>Inode</li><li>Inode 缓存</li><li>Noop 调用策略</li></ul><h2 id="分析工具-2"><a href="#分析工具-2" class="headerlink" title="分析工具"></a>分析工具</h2><table><thead><tr><th>工具</th><th>描述</th></tr></thead><tbody><tr><td>iostat</td><td>磁盘详细统计信息</td></tr><tr><td>iotop</td><td>按进程查看磁盘 IO 的使用情况</td></tr><tr><td>pidstat</td><td>按进程查看磁盘 IO 的使用情况</td></tr><tr><td>perf</td><td>动态跟踪工具</td></tr></tbody></table><h2 id="使用方式-2"><a href="#使用方式-2" class="headerlink" title="使用方式"></a>使用方式</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//查看系统 io 信息</span><br><span class="line">iotop</span><br><span class="line"></span><br><span class="line">//统计 io 详细信息</span><br><span class="line">iostat -d -x -k 1 10</span><br><span class="line"></span><br><span class="line">//查看进程级 io 的信息</span><br><span class="line">pidstat -d 1 -p pid</span><br><span class="line"></span><br><span class="line">//查看系统 IO 的请求，比如可以在发现系统 IO 异常时，可以使用该命令进行调查，就能指定到底是什么原因导致的 IO 异常</span><br><span class="line">perf record -e block:block_rq_issue -ag</span><br><span class="line">^C</span><br><span class="line">perf report</span><br></pre></td></tr></table></figure><h1 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h1><h2 id="说明-4"><a href="#说明-4" class="headerlink" title="说明"></a>说明</h2><p>网络的监测是所有 Linux 子系统里面最复杂的，有太多的因素在里面，比如：延迟、阻塞、冲突、丢包等，更糟的是与 Linux 主机相连的路由器、交换机、无线信号都会影响到整体网络并且很难判断是因为 Linux 网络子系统的问题还是别的设备的问题，增加了监测和判断的复杂度。现在我们使用的所有网卡都称为自适应网卡，意思是说能根据网络上的不同网络设备导致的不同网络速度和工作模式进行自动调整。</p><h2 id="分析工具-3"><a href="#分析工具-3" class="headerlink" title="分析工具"></a>分析工具</h2><table><thead><tr><th>工具</th><th>描述</th></tr></thead><tbody><tr><td>ping</td><td>主要透过 ICMP 封包来进行整个网络的状况报告</td></tr><tr><td>traceroute</td><td>用来检测发出数据包的主机到目标主机之间所经过的网关数量的工具</td></tr><tr><td>netstat</td><td>用于显示与 IP、TCP、UDP 和 ICMP 协议相关的统计数据，一般用于检验本机各端口的网络连接情况</td></tr><tr><td>ss</td><td>可以用来获取 socket 统计信息，而且比 netstat 更快速更高效</td></tr><tr><td>host</td><td>可以用来查出某个主机名的 IP, 跟 nslookup 作用一样</td></tr><tr><td>tcpdump</td><td>是以包为单位进行输出的，阅读起来不是很方便</td></tr><tr><td>tcpflow</td><td>是面向 tcp 流的, 每个 tcp 传输会保存成一个文件, 很方便的查看</td></tr><tr><td>sar -n DEV</td><td>网卡流量情况</td></tr><tr><td>sar -n SOCK</td><td>查询网络以及 tcp，udp 状态信息</td></tr></tbody></table><h2 id="使用方式-3"><a href="#使用方式-3" class="headerlink" title="使用方式"></a>使用方式</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">//显示网络统计信息</span><br><span class="line">netstat -s</span><br><span class="line"></span><br><span class="line">//显示当前 UDP 连接状况</span><br><span class="line">netstat -nu</span><br><span class="line"></span><br><span class="line">//显示 UDP 端口号的使用情况</span><br><span class="line">netstat -apu</span><br><span class="line"></span><br><span class="line">//统计机器中网络连接各个状态个数</span><br><span class="line">netstat -a | awk <span class="string">&#x27;/^tcp/ &#123;++S[$NF]&#125; END &#123;for(a in S) print a, S[a]&#125;&#x27;</span></span><br><span class="line"></span><br><span class="line">//显示 TCP 连接</span><br><span class="line">ss -t -a</span><br><span class="line"></span><br><span class="line">//显示 sockets 摘要信息</span><br><span class="line">ss -s</span><br><span class="line"></span><br><span class="line">//显示所有 udp sockets</span><br><span class="line">ss -u -a</span><br><span class="line"></span><br><span class="line">//tcp,etcp 状态</span><br><span class="line">sar -n TCP,ETCP 1</span><br><span class="line"></span><br><span class="line">//查看网络 IO</span><br><span class="line">sar -n DEV 1</span><br><span class="line"></span><br><span class="line">//抓包以包为单位进行输出</span><br><span class="line">tcpdump -i eth1 host  and port 80</span><br><span class="line"></span><br><span class="line">//抓包以流为单位显示数据内容</span><br><span class="line">tcpflow -<span class="built_in">cp</span> host </span><br></pre></td></tr></table></figure><h1 id="系统负载"><a href="#系统负载" class="headerlink" title="系统负载"></a>系统负载</h1><h2 id="说明-5"><a href="#说明-5" class="headerlink" title="说明"></a>说明</h2><p>Load 就是对计算机干活多少的度量（WikiPedia：the system Load is a measure of the amount of work that a compute system is doing）简单的说是进程队列的长度。Load Average 就是一段时间（1 分钟、5 分钟、15 分钟）内平均 Load。</p><h2 id="分析工具-4"><a href="#分析工具-4" class="headerlink" title="分析工具"></a>分析工具</h2><table><thead><tr><th>工具</th><th>描述</th></tr></thead><tbody><tr><td>top</td><td>查看系统负载情况</td></tr><tr><td>uptime</td><td>查看系统负载情况</td></tr><tr><td>strace</td><td>统计跟踪内核态信息</td></tr><tr><td>vmstat</td><td>查看负载情况</td></tr><tr><td>dmesg</td><td>查看内核日志信息</td></tr></tbody></table><h2 id="使用方式-4"><a href="#使用方式-4" class="headerlink" title="使用方式"></a>使用方式</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//查看负载情况</span><br><span class="line">uptime</span><br><span class="line"></span><br><span class="line">top</span><br><span class="line"></span><br><span class="line">vmstat</span><br><span class="line"></span><br><span class="line">//统计系统调用耗时情况</span><br><span class="line">strace -c -p pid</span><br><span class="line"></span><br><span class="line">//跟踪指定的系统操作例如 epoll_wait</span><br><span class="line">strace -T -e epoll_wait -p pid</span><br><span class="line"></span><br><span class="line">//查看内核日志信息</span><br><span class="line">dmesg</span><br></pre></td></tr></table></figure><h1 id="火焰图"><a href="#火焰图" class="headerlink" title="火焰图"></a>火焰图</h1><h2 id="说明-6"><a href="#说明-6" class="headerlink" title="说明"></a>说明</h2><p><a href="https://www.brendangregg.com/flamegraphs.html">火焰图（Flame Graph)</a> 是 Bredan Gregg 创建的一种性能分析图表，因为它的样子近似 ?而得名。</p><p>火焰图主要是用来展示 CPU 的调用栈。</p><p>Y 轴表示调用栈，每一层都是一个函数。调用栈越深，火焰就越高，顶部就是正在执行的函数，下方都是它的父函数。</p><p>X 轴表示抽样数，如果一个函数在 x 轴占据的宽度越宽，就表示它被抽到的次数多，即执行的时间长。注意，x 轴不代表时间，而是所有的调用栈合并后，按字母顺序排列的。</p><p>火焰图就是看顶层的哪个函数占据的宽度最大。只要有 “ 平顶 “（plateaus），就表示该函数可能存在性能问题。颜色没有特殊含义，因为火焰图表示的是 CPU 的繁忙程度，所以一般选择暖色调。</p><p>常见的火焰图类型有 <a href="https://www.brendangregg.com/FlameGraphs/cpuflamegraphs.html">On-CPU</a>、<a href="https://www.brendangregg.com/FlameGraphs/offcpuflamegraphs.html">Off-CPU</a>、<a href="https://www.brendangregg.com/FlameGraphs/memoryflamegraphs.html">Memory</a>、<a href="https://www.brendangregg.com/FlameGraphs/hotcoldflamegraphs.html">Hot&#x2F;Cold</a>、<a href="https://www.brendangregg.com/blog/2014-11-09/differential-flame-graphs.html">Differential</a> 等等。</p><h2 id="安装依赖库"><a href="#安装依赖库" class="headerlink" title="安装依赖库"></a>安装依赖库</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//安装 systemtap，默认系统已安装</span><br><span class="line">yum install systemtap systemtap-runtime</span><br><span class="line"></span><br><span class="line">//内核调试库必须跟内核版本对应，例如：uname -r -el5</span><br><span class="line">kernel-debuginfo--elx86_rpm</span><br><span class="line">kernel-devel--elx86_rpm</span><br><span class="line">kernel-debuginfo-common--elx86_rpm</span><br><span class="line"></span><br><span class="line">//安装内核调试库</span><br><span class="line">debuginfo-install --enablerepo=debuginfo search kernel</span><br><span class="line">debuginfo-install --enablerepo=debuginfo search glibc</span><br></pre></td></tr></table></figure><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/lidaohang/quick_location.git</span><br><span class="line">cd quick_location</span><br></pre></td></tr></table></figure><h2 id="CPU-级别火焰图"><a href="#CPU-级别火焰图" class="headerlink" title="CPU 级别火焰图"></a>CPU 级别火焰图</h2><p>Cpu 占用过高，或者使用率提不上来，你能快速定位到代码的哪块有问题吗？<br>一般的做法可能就是通过日志等方式去确定问题。现在我们有了火焰图，能够非常清晰的发现哪个函数占用 cpu 过高，或者过低导致的问题。</p><h3 id="on-CPU"><a href="#on-CPU" class="headerlink" title="on-CPU"></a>on-CPU</h3><p>Cpu 占用过高，执行中的时间通常又分为用户态时间 user 和系统态时间 sys。</p><p><strong>使用方式：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//on-CPU user</span><br><span class="line">sh ngx_on_cpu_u.sh pid</span><br><span class="line"></span><br><span class="line">//进入结果目录</span><br><span class="line">cd ngx_on_cpu_u</span><br><span class="line"></span><br><span class="line">//on-CPU kernel</span><br><span class="line">sh ngx_on_cpu_k.sh pid</span><br><span class="line"></span><br><span class="line">//进入结果目录</span><br><span class="line">cd ngx_on_cpu_k</span><br><span class="line"></span><br><span class="line">//开一个临时端口 8088</span><br><span class="line">python -m SimpleHTTPServer 8088</span><br><span class="line"></span><br><span class="line">//打开浏览器输入地址</span><br><span class="line">:8088/pid.svg</span><br></pre></td></tr></table></figure><p><strong>DEMO：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">foo3</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">foo2</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span> ; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">foo3();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">foo1</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i&lt; <span class="number">1000</span>; i++)</span><br><span class="line">foo3();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="keyword">for</span>( i = <span class="number">0</span>; i&lt; <span class="number">1000000000</span>; i++) &#123;</span><br><span class="line">foo1();</span><br><span class="line">foo2();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>DEMO 火焰图：</strong></p><p><img src="/../../../../img/blog/0db5ae7b2be5b744645e650605a0bdfd_MD5.webp"></p><h3 id="off-CPU"><a href="#off-CPU" class="headerlink" title="off-CPU"></a>off-CPU</h3><p>Cpu 过低，利用率不高。等待下一轮 CPU，或者等待 I&#x2F;O、锁、换页等等，其状态可以细分为可执行、匿名换页、睡眠、锁、空闲等状态。</p><p><strong>使用方式：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// off-CPU user</span><br><span class="line">sh ngx_off_cpu_u.sh pid</span><br><span class="line"></span><br><span class="line">//进入结果目录</span><br><span class="line">cd ngx_off_cpu_u</span><br><span class="line"></span><br><span class="line">//off-CPU kernel</span><br><span class="line">sh ngx_off_cpu_k.sh pid</span><br><span class="line"></span><br><span class="line">//进入结果目录</span><br><span class="line">cd ngx_off_cpu_k</span><br><span class="line"></span><br><span class="line">//开一个临时端口 8088</span><br><span class="line">python -m SimpleHTTPServer 8088</span><br><span class="line"></span><br><span class="line">//打开浏览器输入地址</span><br><span class="line">:8088/pid.svg</span><br></pre></td></tr></table></figure><p><strong>官网 DEMO：</strong></p><p><img src="/../../../../img/blog/1847661e7b1ce43a10ced20533589299_MD5.webp"></p><h2 id="内存级别火焰图"><a href="#内存级别火焰图" class="headerlink" title="内存级别火焰图"></a>内存级别火焰图</h2><p>如果线上程序出现了内存泄漏，并且只在特定的场景才会出现。这个时候我们怎么办呢？有什么好的方式和工具能快速的发现代码的问题呢？同样内存级别火焰图帮你快速分析问题的根源。</p><p><strong>使用方式：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">sh ngx_on_memory.sh pid</span><br><span class="line"></span><br><span class="line">//进入结果目录</span><br><span class="line">cd ngx_on_memory</span><br><span class="line"></span><br><span class="line">//开一个临时端口 8088</span><br><span class="line">python -m SimpleHTTPServer 8088</span><br><span class="line"></span><br><span class="line">//打开浏览器输入地址</span><br><span class="line">:8088/pid.svg​</span><br></pre></td></tr></table></figure><p><strong>官网 DEMO：</strong></p><p><img src="/../../../../img/blog/61e14eb78118d023a9cf2de50357628b_MD5.webp"></p><h2 id="性能回退-红蓝差分火焰图"><a href="#性能回退-红蓝差分火焰图" class="headerlink" title="性能回退 - 红蓝差分火焰图"></a>性能回退 - 红蓝差分火焰图</h2><p>你能快速定位 CPU 性能回退的问题么？ 如果你的工作环境非常复杂且变化快速，那么使用现有的工具是来定位这类问题是很具有挑战性的。当你花掉数周时间把根因找到时，代码已经又变更了好几轮，新的性能问题又冒了出来。主要可以用到每次构建中，每次上线做对比看，如果损失严重可以立马解决修复。</p><p>通过抓取了两张普通的火焰图，然后进行对比，并对差异部分进行标色：红色表示上升，蓝色表示下降。差分火焰图是以当前（” 修改后 “）的 profile 文件作为基准，形状和大小都保持不变。因此你通过色彩的差异就能够很直观的找到差异部分，且可以看出为什么会有这样的差异。</p><p><strong>使用方式：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">cd quick_location</span><br><span class="line"></span><br><span class="line">//抓取代码修改前的 profile 1 文件</span><br><span class="line">perf record -F 99 -p pid -g -- sleep 30</span><br><span class="line">perf script &gt; out.stacks1</span><br><span class="line"></span><br><span class="line">//抓取代码修改后的 profile 2 文件</span><br><span class="line">perf record -F 99 -p pid -g -- sleep 30</span><br><span class="line">perf script &gt; out.stacks2</span><br><span class="line"></span><br><span class="line">//生成差分火焰图:</span><br><span class="line">./FlameGraph/stackcollapse-perf.pl ../out.stacks1 &gt; out.folded1</span><br><span class="line">./FlameGraph/stackcollapse-perf.pl ../out.stacks2 &gt; out.folded2</span><br><span class="line">./FlameGraph/difffolded.pl out.folded1 out.folded2 | ./FlameGraph/flamegraph.pl &gt; diffsvg</span><br></pre></td></tr></table></figure><p><strong>DEMO：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//test.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">foo3</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">foo2</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span> ; i &lt; <span class="number">10</span>; i++)</span><br><span class="line"> foo3();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">foo1</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i&lt; <span class="number">1000</span>; i++)</span><br><span class="line"> foo3();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="keyword">for</span>( i =<span class="number">0</span>; i&lt; <span class="number">1000000000</span>; i++) &#123;</span><br><span class="line">foo1();</span><br><span class="line">foo2();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//testc</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">foo3</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">foo2</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span> ; i &lt; <span class="number">10</span>; i++)</span><br><span class="line"> foo3();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">foo1</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i&lt; <span class="number">1000</span>; i++)</span><br><span class="line"> foo3();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">add</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i&lt; <span class="number">10000</span>; i++)</span><br><span class="line"> foo3();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="keyword">for</span>( i =<span class="number">0</span>; i&lt; <span class="number">1000000000</span>; i++) &#123;</span><br><span class="line">foo1();</span><br><span class="line">foo2();</span><br><span class="line">add();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>DEMO 红蓝差分火焰图：</strong></p><p><img src="/../../../../img/blog/bf06907f78595c4750246de4e8e3cb8a_MD5.webp"></p><h1 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h1><h2 id="接入层-Nginx-集群异常现象"><a href="#接入层-Nginx-集群异常现象" class="headerlink" title="接入层 Nginx 集群异常现象"></a>接入层 Nginx 集群异常现象</h2><p>通过监控插件发现在 19 点 nginx 集群请求流量出现大量的 499，5 xx 状态码。并且发现机器 cpu 使用率升高，目前一直持续中。</p><h2 id="分析-Nginx-相关指标"><a href="#分析-Nginx-相关指标" class="headerlink" title="分析 Nginx 相关指标"></a>分析 Nginx 相关指标</h2><p><strong>a) 分析 nginx 请求流量：</strong></p><p><img src="/../../../../img/blog/ad5f454ed494b6d666e26cf4489af096_MD5.webp"></p><p><strong>结论：</strong></p><p>通过上图发现流量并没有突增，反而下降了，跟请求流量突增没关系。</p><p><strong>b) 分析 nginx 响应时间</strong></p><p><img src="/../../../../img/blog/5a83253e3d1469a026b9f5b0bc3ee13a_MD5.webp"></p><p><strong>结论：</strong></p><p>通过上图发现 nginx 的响应时间有增加可能跟 nginx 自身有关系或者跟后端 upstream 响应时间有关系。</p><p><strong>c) 分析 nginx upstream 响应时间</strong></p><p><img src="/../../../../img/blog/5692748fc8695ef575f5bda7306abe55_MD5.webp"></p><p><strong>结论：</strong></p><p>通过上图发现 nginx upstream 响应时间有增加，目前猜测可能后端 upstream 响应时间拖住 nginx，导致 nginx 出现请求流量异常。</p><h2 id="分析系统-Cpu-情况"><a href="#分析系统-Cpu-情况" class="headerlink" title="分析系统 Cpu 情况"></a>分析系统 Cpu 情况</h2><p><strong>a) 通过 top 观察系统指标</strong></p><p><code>Top</code></p><p><img src="/../../../../img/blog/ac3f5d8648d96f5e53a03c19f23b6ece_MD5.webp"></p><p><strong>结论：</strong></p><p>发现 nginx worker cpu 比较高</p><p><strong>b) 分析 nginx 进程内部 cpu 情况</strong></p><p><code>Perf top -p pid</code></p><p><img src="/../../../../img/blog/540aa5753a370a6d76cb4564700ef178_MD5.webp"></p><p><strong>结论：</strong></p><p>发现主要开销在 free, malloc, json 解析上面</p><h2 id="火焰图分析-Cpu"><a href="#火焰图分析-Cpu" class="headerlink" title="火焰图分析 Cpu"></a>火焰图分析 Cpu</h2><p><strong>a) 生成用户态 cpu 火焰图</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//on-CPU user</span><br><span class="line">sh ngx_on_cpu_u.sh pid</span><br><span class="line"></span><br><span class="line">//进入结果目录</span><br><span class="line">cd ngx_on_cpu_u</span><br><span class="line"></span><br><span class="line">//开一个临时端口 8088</span><br><span class="line">python -m SimpleHTTPServer 8088</span><br><span class="line"></span><br><span class="line">//打开浏览器输入地址</span><br><span class="line">:8088/pid.svg</span><br></pre></td></tr></table></figure><p><img src="/../../../../img/blog/949a77099ee3127f2f2c7ea43ce1b3d2_MD5.webp"></p><p><strong>结论：</strong></p><p>发现代码里面有频繁的解析 json 操作，并且发现这个 json 库性能不高，占用 cpu 挺高。</p><h2 id="案例总结"><a href="#案例总结" class="headerlink" title="案例总结"></a>案例总结</h2><p>**a) **分析请求流量异常，得出 nginx upstream 后端机器响应时间拉长</p><p>**b) **分析 nginx 进程 cpu 高，得出 nginx 内部模块代码有耗时的 json 解析以及内存分配回收操作</p><h3 id="深入分析"><a href="#深入分析" class="headerlink" title="深入分析"></a>深入分析</h3><p>根据以上两点问题分析的结论，我们进一步深入分析。</p><p>后端 upstream 响应拉长，最多可能影响 nginx 的处理能力。但是不可能会影响 nginx 内部模块占用过多的 cpu 操作。并且当时占用 cpu 高的模块，是在请求的时候才会走的逻辑。不太可能是 upstram 后端拖住 nginx，从而触发这个 cpu 的耗时操作。</p><h3 id="解决方式"><a href="#解决方式" class="headerlink" title="解决方式"></a>解决方式</h3><p>遇到这种问题，我们优先解决已知的，并且非常明确的问题。那就是 cpu 高的问题。解决方式先降级关闭占用 cpu 过高的模块，然后进行观察。经过降级关闭该模块 cpu 降下来了，并且 nginx 请求流量也正常了。之所以会影响 upstream 时间拉长，因为 upstream 后端的服务调用的接口可能是个环路再次走回到 nginx。</p><h1 id="参考仓库"><a href="#参考仓库" class="headerlink" title="参考仓库"></a>参考仓库</h1><ul><li><a href="https://links.jianshu.com/go?to=https://github.com/openresty/openresty-systemtap-toolkit">https://github.com/openresty/openresty-systemtap-toolkit</a></li><li><a href="https://links.jianshu.com/go?to=https://github.com/brendangregg/FlameGraph">https://github.com/brendangregg/FlameGraph</a></li><li><a href="https://github.com/openresty/stapxx">openresty&#x2F;stapxx: Simple macro language extentions to systemtap (github.com)</a></li></ul><h1 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h1><p><a href="https://www.jianshu.com/p/0bbac570fa4c">接入层问题故障定位 - 简书 (jianshu.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> 应用 </category>
          
          <category> 操作系统 </category>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Git常用命令和介绍</title>
      <link href="/posts/%E5%BA%94%E7%94%A8/%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7/Git/Git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%92%8C%E4%BB%8B%E7%BB%8D.html"/>
      <url>/posts/%E5%BA%94%E7%94%A8/%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7/Git/Git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%92%8C%E4%BB%8B%E7%BB%8D.html</url>
      
        <content type="html"><![CDATA[<h1 id="一、Git-介绍"><a href="#一、Git-介绍" class="headerlink" title="一、Git 介绍"></a>一、Git 介绍</h1><h2 id="1-1、Git-的作用"><a href="#1-1、Git-的作用" class="headerlink" title="1.1、Git 的作用"></a>1.1、Git 的作用</h2><p>Git 是一个开源的分布式版本控制系统，用于管理一个或多个文件的整个历史记录。它有助于跟踪文件的变化，同时让多个开发者对同一个文件做出更改，并帮助开发者们在不同时间点进行历史查阅和版本比较。</p><h2 id="1-2、Git-的理念"><a href="#1-2、Git-的理念" class="headerlink" title="1.2、Git 的理念"></a>1.2、Git 的理念</h2><p>Git 拥有一个独特的理念，即分布式版本控制系统。它采用客户端 - 服务器模式，将文件、数据和代码以分布式仓库的形式保存在不同的服务器上，以便用户进行版本控制、代码管理和共享。Git 的分布式版本控制系统可以更快地处理版本控制任务，比传统的集中式版本控制系统更安全、更可靠、更高效。</p><h2 id="1-3、Git-的特点"><a href="#1-3、Git-的特点" class="headerlink" title="1.3、Git 的特点"></a>1.3、Git 的特点</h2><ol><li><p>分布式：每个开发者都拥有完整的代码库，可以离线工作，不需要依赖中央服务器。</p></li><li><p>非线性开发：可以创建多个分支，并行开发多个功能，通过合并分支进行代码整合。</p></li><li><p>高效性：Git 的设计可以快速地进行代码比较和合并，使得开发者可以快速迭代。</p></li><li><p>安全性：Git 使用 SHA-1 散列值来保证代码的完整性，具有防篡改的能力。</p></li><li><p>易于学习和使用：Git 的命令行操作简单，且有大量的可视化工具和第三方工具支持。</p></li><li><p>开放源代码：Git 是自由软件，任何人都可以自由地使用、修改和分发它。</p></li><li><p>大规模协作：Git 可以支持上千人同时协作开发同一项目，通过不同分支的合并和冲突解决保证项目的稳定性和质量。</p></li></ol><h1 id="二、Git-的概念"><a href="#二、Git-的概念" class="headerlink" title="二、Git 的概念"></a>二、Git 的概念</h1><p>想要使用 Git 需要先掌握 Git 的一些基础概念，更好地理解 Git。</p><ol><li><p>仓库（Repository）：仓库是 Git 中最重要的概念之一，它是用来存储项目代码的地方。所有的修改记录都保存在仓库中，包括提交的代码历史、分支信息、标签等。当我们将修改记录提交到仓库后，它们就会成为代码的一部分。</p></li><li><p>提交（Commit）：Git 中的提交是指将文件或代码变更记录下来，并且提交一个说明（commit message）。</p></li><li><p>分支（Branch）：Git 中的分支是指代码版本的不同分支。可以创建新的分支来尝试新的代码，而不会影响到主分支。</p></li><li><p>合并（Merge）：Git 中的合并是指将一个分支中的代码合并到另一个分支中。</p></li><li><p>拉取（Pull）：Git 中的拉取是指将远程仓库中的代码更新到本地仓库中。</p></li><li><p>推送（Push）：Git 中的推送是指将本地仓库中的代码更新到远程仓库中。</p></li><li><p>标签（Tag）：Git 中的标签是指给某一个特定的提交打上一个标签，用于区分这个提交与其他提交的不同。</p></li><li><p>工作区（Working Directory）：工作区是指项目代码所在的目录，也就是我们平时编辑和修改代码的地方，在工作区中，我们可以创建、修改和删除文件等。</p></li><li><p>暂存区（Staging Area）：暂存区是介于工作区和仓库之间的一个缓冲区域。在提交代码之前，我们需要将修改过的文件添加到暂存区中。暂存区中保存了待提交的修改记录，包括哪些文件被修改了，修改了哪些部分，但还没有真正提交到仓库。</p></li></ol><p>可以用下面的图来更好地理解这三个概念之间的关系：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> git add              git commit  </span><br><span class="line">工作区 --------------&gt; 暂存区 --------------&gt; 仓库</span><br></pre></td></tr></table></figure><p>简单来说，我们在工作区中修改代码后，通过 <code>git add</code> 命令将修改的文件添加到暂存区，然后通过 <code>git commit</code> 命令将暂存区中的修改记录提交到仓库中。在提交之前，我们可以通过 <code>git status</code> 命令来查看工作区和暂存区的状态，以及哪些文件被修改过、添加到了暂存区等信息。</p><h1 id="三、Git-的基本操作"><a href="#三、Git-的基本操作" class="headerlink" title="三、Git 的基本操作"></a>三、Git 的基本操作</h1><h2 id="3-1、使用-Git-管理一个代码仓库的流程"><a href="#3-1、使用-Git-管理一个代码仓库的流程" class="headerlink" title="3.1、使用 Git 管理一个代码仓库的流程"></a>3.1、使用 Git 管理一个代码仓库的流程</h2><ol><li><p>初始化仓库：使用 <code>git init</code> 命令在本地创建一个新的 Git 仓库。</p></li><li><p>添加文件：将项目文件添加到仓库中，使用 <code>git add</code> 命令将修改后的文件添加到 Git 的暂存区中。</p></li><li><p>提交代码：使用 <code>git commit</code> 命令提交修改记录到 Git 仓库中。每次提交需要添加一条注释，简要描述修改了哪些内容。</p></li><li><p>创建分支：使用 <code>git branch</code> 命令创建一个新的分支，并切换到该分支。这个分支可以用于开发新的功能或修复错误，不会影响主分支（通常为 <code>master</code>）的代码。</p></li><li><p>合并分支：在开发新功能或修复错误后，需要将分支合并到主分支上，使用 <code>git merge</code> 命令将分支合并到主分支上。</p></li><li><p>拉取代码：在多人协作开发中，需要将远程仓库中的代码拉取到本地进行开发。使用 <code>git pull</code> 命令将远程仓库中的代码更新到本地仓库中。</p></li><li><p>推送代码：在完成开发并且测试通过后，需要将修改的代码推送到远程仓库中。使用 <code>git push</code> 命令将本地仓库中的代码更新到远程仓库中。</p></li><li><p>标记版本：当完成一个里程碑或者发布一个版本时，可以使用 <code>git tag</code> 命令创建一个新的标签，用于标记当前的版本号。</p></li></ol><h2 id="3-2、Git-常用命令介绍"><a href="#3-2、Git-常用命令介绍" class="headerlink" title="3.2、Git 常用命令介绍"></a>3.2、Git 常用命令介绍</h2><p>Git 是一个强大的版本控制工具，提供了众多命令来管理代码仓库，以下是一些常用的 Git 命令介绍：</p><ol><li><p><code>git init</code>：初始化一个新的 Git 仓库。</p></li><li><p><code>git add</code>：将文件或目录添加到 Git 的暂存区中。</p></li><li><p><code>git commit</code>：将暂存区的修改记录提交到 Git 仓库中。</p></li><li><p><code>git clone</code>：从远程 Git 仓库中克隆一个副本到本地。</p></li><li><p><code>git status</code>：查看当前 Git 仓库的状态，包括哪些文件被修改过、添加到了暂存区等信息。</p></li><li><p><code>git log</code>：查看 Git 仓库中的提交历史记录，包括每个提交的作者、时间、注释等信息。</p></li><li><p><code>git branch</code>：查看 Git 仓库中的分支信息，并可以创建、删除、重命名等操作。</p></li><li><p><code>git merge</code>：将一个分支的修改合并到当前分支中。</p></li><li><p><code>git pull</code>：从远程 Git 仓库中拉取最新的代码到本地仓库中。</p></li><li><p><code>git push</code>：将本地 Git 仓库中的修改推送到远程 Git 仓库中。</p></li><li><p><code>git checkout</code>：切换到指定分支或提交。</p></li><li><p><code>git tag</code>：为当前的提交打上一个标签，用于标识当前版本。</p></li><li><p><code>git remote</code>：管理与远程仓库的连接，可以添加、删除、重命名等操作。</p></li><li><p><code>git diff</code>：查看当前修改和之前提交的版本之间的差异。</p></li></ol><p>这些命令只是 Git 提供的众多命令中的一部分，可以根据具体需求进行选择和使用。同时，可以通过 <code>git --help</code> 命令查看 Git 的帮助文档，以获得更多的信息和帮助。</p><h1 id="四、Git-状态的变化"><a href="#四、Git-状态的变化" class="headerlink" title="四、Git 状态的变化"></a>四、Git 状态的变化</h1><p>在 Git 中，有三个主要的概念：工作区、暂存区和仓库。它们分别代表了不同的状态，可以通过 Git 命令进行变化。</p><ol><li><p>工作区（Working Directory）：指的是你在本地电脑上实际修改的文件。当你修改了文件，但没有执行 Git 命令时，这些文件的状态就是 “ 未跟踪 “ 或 “ 已修改 “。</p></li><li><p>暂存区（Staging Area）：也称为索引（Index），是一个临时的存储区域，用于存储即将被提交到 Git 仓库的文件。当你执行 <code>git add</code> 命令时，修改的文件会被添加到暂存区，此时这些文件的状态为 “ 已暂存 “。</p></li><li><p>仓库（Repository）：也称为版本库，是 Git 用来存储历史提交记录的地方。当你执行 <code>git commit</code> 命令时，暂存区中的文件会被提交到仓库中，此时这些文件的状态为 “ 已提交 “。</p></li></ol><p>下面是这些状态如何相互转换的说明：</p><ul><li>将修改的文件添加到暂存区：<code>git add</code>，此时文件的状态由 “ 未跟踪 “ 或 “ 已修改 “ 变为 “ 已暂存 “；</li><li>将暂存区的文件提交到仓库：<code>git commit -m &quot;commit message&quot;</code>，此时文件的状态由 “ 已暂存 “ 变为 “ 已提交 “；</li><li>查看文件状态：<code>git status</code>，此命令可以查看工作区、暂存区和仓库中文件的状态；</li><li>撤销暂存区的修改：<code>git reset</code>，此命令可以将暂存区的文件恢复为未暂存的状态；</li><li>撤销工作区的修改：<code>git checkout --</code>，此命令可以将工作区的文件恢复到上次提交的状态；</li><li>恢复仓库中的文件：<code>git checkout</code>，此命令可以将指定提交中的文件恢复到当前分支上。</li></ul><p>需要注意的是，上述命令在执行时需要指定对应的文件或提交。同时，这些命令还有更多的选项和参数可以使用，可以通过 <code>git help</code> 命令来查看 Git 的文档。</p><h1 id="五、Git-安装和配置"><a href="#五、Git-安装和配置" class="headerlink" title="五、Git 安装和配置"></a>五、Git 安装和配置</h1><h2 id="5-1、Git-的安装"><a href="#5-1、Git-的安装" class="headerlink" title="5.1、Git 的安装"></a>5.1、Git 的安装</h2><p><a href="https://www.runoob.com/git/git-install-setup.html">Git 安装配置 | 菜鸟教程 (runoob.com)</a></p><h2 id="5-2、Git-的配置"><a href="#5-2、Git-的配置" class="headerlink" title="5.2、Git 的配置"></a>5.2、Git 的配置</h2><p>git 提供了 <code>git config</code> 命令用于配置或读取相应的工作环境变量,其主要配置文件分为三层，从上到下分别是：</p><ul><li><code>/etc/gitconfig</code> 文件：系统中对所有用户都普遍适用的配置。若使用 <code>git config</code> 时用 <code>--system</code> 选项，读写的就是这个文件。</li><li><code>~/.gitconfig</code> 文件：用户目录下的配置文件只适用于该用户。若使用 <code>git config</code> 时用 <code>--global</code> 选项，读写的就是这个文件。</li><li><code>.git/config</code> 文件：仅针对当前项目有效，<code>.git/config</code> 里的配置会覆盖 <code>/etc/gitconfig</code> 中的同名变量。</li></ul><p>最重要的配置就是配置用户名和电子邮件，使用以下命令即可：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.name <span class="string">&quot;lucas&quot;</span></span><br><span class="line">$ git config --global user.email lucas@foxmail.com</span><br></pre></td></tr></table></figure><p>如果想要查看已有配置信息，可以使用以下命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git config --list</span><br></pre></td></tr></table></figure><h1 id="六、Git-的高级操作"><a href="#六、Git-的高级操作" class="headerlink" title="六、Git 的高级操作"></a>六、Git 的高级操作</h1><h2 id="6-1、-gitignore-文件的使用"><a href="#6-1、-gitignore-文件的使用" class="headerlink" title="6.1、.gitignore 文件的使用"></a>6.1、.gitignore 文件的使用</h2><p>在使用 Git 管理代码仓库时，有些文件或目录不应该被 Git 进行版本控制，例如编译输出文件、日志文件等。这时可以使用 <code>.gitignore</code> 文件来告诉 Git 忽略这些文件或目录。</p><p><code>.gitignore</code> 文件是一个文本文件，列出了 Git 应该忽略的文件或目录的规则。每一行规则都是一个模式，可以包含通配符、反斜线等符号，表示需要忽略的文件或目录的名称或路径。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 忽略所有 .txt 文件</span><br><span class="line">*.txt</span><br><span class="line"></span><br><span class="line"># 忽略 build 目录及其下的所有内容</span><br><span class="line">/build/</span><br><span class="line"></span><br><span class="line"># 忽略指定的文件</span><br><span class="line">example.log</span><br></pre></td></tr></table></figure><p>在上述例子中，第一行规则使用了通配符 <code>*</code> 来匹配所有 <code>.txt</code> 结尾的文件；第二行规则使用了反斜线 <code>/</code> 来指定需要忽略的目录 <code>build</code>，并在末尾加上了斜线 <code>/</code> 来表示忽略该目录下的所有内容；第三行规则指定了需要忽略的文件名 <code>example.log</code>。</p><p><code>.gitignore</code> 文件可以放置在代码仓库的任何级别上，从仓库根目录到任意子目录都可以。一般建议将其放置在代码仓库的根目录下，以便更方便地管理和维护。</p><p>需要注意的是，如果在 <code>.gitignore</code> 文件中忽略了某个文件或目录，那么 Git 将不会对其进行版本控制，也不会将其包含在提交中，因此需要确保 <code>.gitignore</code> 文件中的规则正确地列出了需要忽略的文件或目录。</p><h2 id="6-2、git-Diff-的使用"><a href="#6-2、git-Diff-的使用" class="headerlink" title="6.2、git Diff 的使用"></a>6.2、git Diff 的使用</h2><p><code>git diff</code> 是一个常用的 Git 命令，用于比较 Git 仓库中的不同版本之间的差异。它可以用于比较两个提交之间的差异，或比较工作目录中的文件与暂存区或最新提交之间的差异。</p><p>下面是 <code>git diff</code> 命令的一些常见用法：</p><ul><li>比较工作目录中的文件与最新提交之间的差异：</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff</span><br></pre></td></tr></table></figure><ul><li>比较工作目录中的文件与暂存区之间的差异：</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff --cached</span><br></pre></td></tr></table></figure><ul><li>比较两个提交之间的差异：</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff &lt;commit1&gt; &lt;commit2&gt;</span><br></pre></td></tr></table></figure><p>其中 <code>&lt;commit1&gt;</code> 和 <code>&lt;commit2&gt;</code> 分别是要比较的两个提交的 SHA-1 标识符，可以使用提交的短标识符或分支名代替。</p><ul><li>比较指定文件或目录的差异：</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff &lt;commit1&gt; &lt;commit2&gt; &lt;file&gt;</span><br></pre></td></tr></table></figure><p>其中 <code>&lt;file&gt;</code> 可以是文件或目录的路径，可以只比较某个文件或目录的差异。</p><ul><li>比较两个分支之间的差异：</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff &lt;branch1&gt;..&lt;branch2&gt;</span><br></pre></td></tr></table></figure><p>其中 <code>&lt;branch1&gt;</code> 和 <code>&lt;branch2&gt;</code> 分别是要比较的两个分支的名称，可以使用分支的短名称或完整名称代替。</p><p>以上是 <code>git diff</code> 命令的一些常见用法，使用这些命令可以帮助开发者比较不同版本之间的差异，从而更好地管理代码仓库。</p><h2 id="6-3、git-如何处理代码冲突"><a href="#6-3、git-如何处理代码冲突" class="headerlink" title="6.3、git 如何处理代码冲突"></a>6.3、git 如何处理代码冲突</h2><p>在多人协作开发时，经常会出现代码冲突的情况。当两个或多个开发者同时修改同一个文件的同一部分时，就会发生冲突。Git 提供了一些命令和工具来帮助开发者处理代码冲突，下面是处理代码冲突的一般步骤：</p><h3 id="6-3-1、更新本地代码库"><a href="#6-3-1、更新本地代码库" class="headerlink" title="6.3.1、更新本地代码库"></a>6.3.1、更新本地代码库</h3><p>在处理代码冲突之前，需要先更新本地代码库。使用 <code>git pull</code> 命令从远程仓库获取最新的代码。</p><h3 id="6-3-2、查找冲突"><a href="#6-3-2、查找冲突" class="headerlink" title="6.3.2、查找冲突"></a>6.3.2、查找冲突</h3><p>在更新代码库之后，如果有冲突，使用 <code>git status</code> 命令查看冲突文件的状态，冲突文件的状态为 <code>both modified</code>。</p><h3 id="6-3-3、手动解决冲突"><a href="#6-3-3、手动解决冲突" class="headerlink" title="6.3.3、手动解决冲突"></a>6.3.3、手动解决冲突</h3><p>手动编辑冲突文件，将冲突部分保留下来，删除其他部分。可以使用编辑器或其他工具来帮助解决冲突。</p><h3 id="6-3-4、添加解决后的文件"><a href="#6-3-4、添加解决后的文件" class="headerlink" title="6.3.4、添加解决后的文件"></a>6.3.4、添加解决后的文件</h3><p>在解决冲突之后，使用 <code>git add</code> 命令将解决后的文件添加到暂存区。</p><h3 id="6-3-5、提交解决后的文件"><a href="#6-3-5、提交解决后的文件" class="headerlink" title="6.3.5、提交解决后的文件"></a>6.3.5、提交解决后的文件</h3><p>在将解决后的文件添加到暂存区后，使用 <code>git commit</code> 命令提交修改。</p><p>如果在解决冲突的过程中遇到问题或错误，可以使用 <code>git merge --abort</code> 命令取消合并操作，返回到合并前的状态。</p><p>需要注意的是，在多人协作开发时，最好避免同时修改同一个文件的同一部分，可以通过拆分任务、分工协作等方式来避免冲突的发生。此外，在处理冲突时，需要保持沟通和协作，及时解决问题。</p><h2 id="6-4、git-Merge-合并代码"><a href="#6-4、git-Merge-合并代码" class="headerlink" title="6.4、git Merge 合并代码"></a>6.4、git Merge 合并代码</h2><p>Git merge 是将两个或多个分支的代码合并到一个分支中的操作。在合并过程中，Git 会自动尝试将两个分支的代码进行比较和合并，以生成一个新的合并提交。</p><p>以下是使用 Git merge 合并代码的一些步骤：</p><ol><li><p>确保你已经切换到需要合并到的目标分支，例如 master 分支：<code>git checkout master</code></p></li><li><p>运行 merge 命令来将目标分支与要合并的分支进行合并：<code>git merge</code></p></li><li><p>Git 会尝试自动合并分支的代码。如果 Git 遇到了冲突，它会提示你手动解决冲突。你需要手动编辑有冲突的文件，以解决冲突。</p></li><li><p>如果合并成功，Git 会生成一个新的合并提交。在这个提交消息中，Git 会包含有关合并的信息，如何合并的分支等等。</p></li><li><p>最后，使用 <code>git push</code> 命令将合并的代码推送到远程仓库。</p></li></ol><p>注意：在进行合并操作之前，建议先从远程仓库获取最新的代码并将其合并到本地分支。这样可以避免不必要的冲突和合并问题。</p><h2 id="6-5、git-代码回退"><a href="#6-5、git-代码回退" class="headerlink" title="6.5、git 代码回退"></a>6.5、git 代码回退</h2><p>在 Git 中，可以使用多种方法回退代码，包括撤销工作区的修改、恢复指定版本的代码等。下面介绍一些常用的回退代码的方法：</p><ol><li><p>撤销工作区的修改：<code>git checkout --</code>，此命令可以将工作区的文件恢复到上次提交的状态。如果你已经使用 <code>git add</code> 将修改的文件添加到暂存区，但还没有提交，可以使用 <code>git reset HEAD</code> 来撤销暂存区的修改。</p></li><li><p>恢复指定版本的代码：<code>git checkout</code>，此命令可以将指定提交中的文件恢复到当前分支上。你可以使用 <code>git log</code> 命令来查看提交历史记录，并选择需要恢复的版本。如果你想恢复到某个历史提交的状态，可以使用 <code>git checkout</code> 命令，这将使得 HEAD 指向这个提交，并将工作区和暂存区都恢复到这个提交的状态。</p></li><li><p>回退提交：<code>git revert</code>，此命令可以创建一个新的提交，用于撤销指定提交的更改。该命令将会生成一个新的提交，包含了回退操作的更改，但是不会删除原始提交。如果你需要完全删除某个提交，可以使用 <code>git reset</code> 命令，但是需要注意，这将会删除该提交及其之后的提交，因此需要谨慎使用。</p></li></ol><p>需要注意的是，在使用 Git 回退代码时，需要注意不要将未提交的修改丢失，并且需要保留历史提交记录。如果你不确定该如何回退代码，可以先创建一个新的分支，进行实验，确保不会对主分支造成不可逆的影响。</p><h1 id="七、Git-的常用命令"><a href="#七、Git-的常用命令" class="headerlink" title="七、Git 的常用命令"></a>七、Git 的常用命令</h1><ol><li><p>Git checkout -b xxx：git checkout xxx 是指切换到 xxx 相当于复制了 remote 的仓库到本地的 xxx 分支上，-b 意味着 branch，即创建新分支，这条指令合起来意思是创建并切换到 xxx。</p></li><li><p>git diff 查看自己对代码做出的改变，也就是查看暂存区与 disk 区文件的差异。</p></li><li><p>git add xxx：将 xxx 文件添加到暂存区。</p></li><li><p>git commit：将暂存区内容添加到 local 区的当前分支中。</p></li><li><p>git push RemoteHostName LocalBranchName：将 local 区的 LocalBranchName 分支推送到 RemoteHostName 主机的同名分支。（若加 -f 表示无视本地与远程分支的差异强行 push）</p></li><li><p>git branch -d xxx 删除本地的 git 分支；git branch -D xxx：不加 -D 表示创建新 local 分支 xxx，加 -D 表示强制删除 local 分支 xxx。</p></li><li><p>git pull RemoteHostName RemoteBranchName：同上，不过改成从远程主机下载远程分支并与本地同名分支合并。</p></li><li><p>git rebase xxx：假设当前分支与 xxx 分支存在共同部分 common，该指令用 xxx 分支包括 common 在内的整体替换当前分支的 common 部分（原先 xxx 分支内容为 common-&gt;diversityA，当前分支内容为 common-&gt;diversityB，执行完该指令后当前分支内容为 common-&gt;diversityA-&gt;diversityB）。</p></li></ol><p>以下 5 条命令适用于在写自己的代码过程中发现远端 GitHub 上代码出现改变的情况，这个时候你可以按照下面这种方式来进行代码推送和合并。</p><ol><li><p>git checkout main 切换回 main 分支</p></li><li><p>git pull origin master(main) 将远端修改过的代码再更新到本地</p></li><li><p>git checkout xxx 回到 xxx 分支</p></li><li><p>git rebase main 我在 xxx 分支上，先把 main 移过来，然后根据我的 commit 来修改成新的内容（中途可能会出现，rebase conflict —–》手动选择保留哪段代码）</p></li><li><p>git push -f origin xxx 把 rebase 后并且更新过的代码再 push 到远端 github 上 （-f —》强行）</p></li></ol><h1 id="八、如何使用-Git-在-Github-上贡献代码"><a href="#八、如何使用-Git-在-Github-上贡献代码" class="headerlink" title="八、如何使用 Git 在 Github 上贡献代码"></a>八、如何使用 Git 在 Github 上贡献代码</h1><ol><li><p>在 GitHub 上创建一个账户并登录。</p></li><li><p>找到要贡献代码的项目，并在项目主页上点击 “Fork” 按钮，将项目复制到自己的账户下。</p></li><li><p>在自己的电脑上安装 Git 工具。</p></li><li><p>使用 Git 将项目克隆到本地计算机中。可以通过在命令行终端中使用以下命令来克隆项目：</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/你的用户名/项目名.git</span><br></pre></td></tr></table></figure><p>在本地修改代码，并使用以下命令将更改提交到本地 Git 仓库：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add .git commit -m &quot; 提交信息 &quot;</span><br></pre></td></tr></table></figure><p>其中，<code>git add .</code> 命令将所有修改添加到暂存区，<code>git commit</code> 命令将提交更改，并在提交信息中描述更改。</p><p>将本地更改推送到自己的 GitHub 账户中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin master</span><br></pre></td></tr></table></figure><p>这将把本地的更改推送到 GitHub 上。</p><ol><li><p>在自己的 GitHub 账户上打开一个 Pull Request (PR) 请求，请求将更改合并到原始项目中。在 GitHub 上点击 “New pull request” 按钮，填写 PR 请求的标题和描述，并选择要合并的分支。</p></li><li><p>等待原始项目的维护者审核并接受你的 PR 请求。如果需要进一步修改，原始项目的维护者可以在 PR 请求中提出评论和建议。</p></li><li><p>当 PR 请求被接受并合并到原始项目后，你的代码贡献就完成了。</p></li></ol><p>以上是在 GitHub 上贡献代码的基本步骤。在此过程中，你需要注意遵循项目的代码风格和贡献规范，避免与其他贡献者冲突，以便顺利地将你的代码贡献到项目中。</p><h1 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h1><p><a href="https://mp.weixin.qq.com/s/I4VIT0aj_WMiEbVfHhhqpA">我看还有谁不动Git (qq.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> 应用 </category>
          
          <category> 编程工具 </category>
          
          <category> Git </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Vim使用</title>
      <link href="/posts/%E5%BA%94%E7%94%A8/%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7/Vim/Vim%E4%BD%BF%E7%94%A8.html"/>
      <url>/posts/%E5%BA%94%E7%94%A8/%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7/Vim/Vim%E4%BD%BF%E7%94%A8.html</url>
      
        <content type="html"><![CDATA[<h1 id="Vim-编辑器"><a href="#Vim-编辑器" class="headerlink" title="Vim 编辑器"></a>Vim 编辑器</h1><h2 id="Vim-常用模式"><a href="#Vim-常用模式" class="headerlink" title="Vim 常用模式"></a>Vim 常用模式</h2><ul><li>交互模式</li><li>插入模式</li><li>命令模式</li><li>可视模式</li></ul><h3 id="插入模式"><a href="#插入模式" class="headerlink" title="插入模式"></a>插入模式</h3><p>这个模式是我们熟悉的文本编辑器的模式，就是可以输入任何你想输入的内容。进入这个模式有几种方法，最常用的方法是按字母键 <code>i</code> （ <code>i、I、a、A、o、O</code> 都可以进入插入模式，只是所处的位置不同），退出这种模式，只需要按下 <code>Esc</code> 键。</p><ul><li><code>i, I</code> 进入输入模式 <code>Insert mode</code> ：<code>i</code> 为 “ 从目前光标所在处输入 “， <code>I</code> 为 “ 在目前所在行的第一个非空格符处开始输入 “；</li><li><code>a, A</code> 进入输入模式 <code>Insert mode</code> ：<code>a</code> 为 “ 从目前光标所在的下一个字符处开始输入 “， <code>A</code> 为 “ 从光标所在行的最后一个字符处开始输入 “；</li><li><code>o, O</code> 进入输入模式 <code>Insert mode</code> ：<code>o</code> 为 “ 在目前光标所在的下一行处输入新的一行 “；<code>O</code> 为在目前光标所在处的上一行<img src="/../../../../img/blog/540137844751841.jpg" alt="图片">mg&#x2F;blog&#x2F;540137844751841.jpg)</li></ul><h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><h3 id="跳至行首和行末"><a href="#跳至行首和行末" class="headerlink" title="跳至行首和行末"></a>跳至行首和行末</h3><ul><li>行首：在交互模式下，为了将光标定位到一行的开始位置，只需要按下数字键 <code>0</code> 即可，键盘上的 <code>Home</code> 键也有相同效果。</li><li>行末：在交互模式下，为了将光标定位到一行的末尾，只需要按下美元符号键 <code>$</code> 即可，键盘上的 <code>End</code> 键也有相同效果。</li></ul><h3 id="按单词移动"><a href="#按单词移动" class="headerlink" title="按单词移动"></a>按单词移动</h3><p>在交互模式下，按字母键 <code>w</code> 可以一个单词一个单词的移动。</p><h3 id="退出文件"><a href="#退出文件" class="headerlink" title="退出文件"></a>退出文件</h3><p>在交互模式下，按下冒号键 <code>:</code> 进入命令模式，再按下 <code>q</code> 键，就可以退出了。</p><p>如果在退出之前又修改了文件，就直接想用 <code>:q</code> 退出 <code>Vim</code> ，那么 <code>Vim</code> 会显示一个红字标明错误信息。此时我们有两个选择：</p><ol><li><p>保存并退出 <code>:wq</code> 或 <code>:x</code> ；</p></li><li><p>不保存且退出 <code>:q!</code> 。</p></li></ol><h2 id="标准操作"><a href="#标准操作" class="headerlink" title="标准操作"></a>标准操作</h2><h3 id="删除字符"><a href="#删除字符" class="headerlink" title="删除字符"></a>删除字符</h3><p>在交互模式下，将光标定位到一个你想要删除的字符上，按下字母键 <code>x</code> 你会发现这个字符被删除了。</p><p>也可以一次性删除多个字符，只需要在按 <code>x</code> 键之前输入数字即可。</p><h3 id="删除（剪切）单词，行"><a href="#删除（剪切）单词，行" class="headerlink" title="删除（剪切）单词，行"></a>删除（剪切）单词，行</h3><ul><li>删除一行：连按两次 <code>d</code> 来删除光标所在的那一行。</li><li>删除多行：例如先输入数字 <code>2</code> ，再按下 <code>dd</code> ，就会删除从光标所在行开始的两行。</li><li>删除一个单词：将光标置于一个单词的首字母处，然后按下 <code>dw</code> 。</li><li>删除多个单词：例如先按数字键 <code>2</code> 再按 <code>dw</code> 就可以删除两个单词了。</li><li>从光标所在位置删除至行首：<code>d0</code> 。</li><li>从光标所在位置删除至行末：<code>d$</code> 。</li></ul><h3 id="复制单词，行"><a href="#复制单词，行" class="headerlink" title="复制单词，行"></a>复制单词，行</h3><ul><li>复制行：按两次 <code>y</code> 会把光标所在行复制到内存中，和 <code>dd</code> 类似， <code>dd</code> 用于 “ 剪切 “ 光标所在行。</li><li>复制单词：<code>yw</code> 会复制一个单词。</li><li>复制到行末：<code>y$</code> 是复制从光标所在处到行末的所有字符。</li><li>复制到行首：<code>y0</code> 是复制光标所在处到行首的所有字符。</li></ul><h3 id="粘贴"><a href="#粘贴" class="headerlink" title="粘贴"></a>粘贴</h3><p>如果之前用 <code>dd</code> 或者 <code>yy</code> 剪切复制过来的，可以使用 <code>p</code> 来粘贴。同样也可以使用 <code>数字+p</code> 来表示复制多次。</p><h3 id="替换一个字符"><a href="#替换一个字符" class="headerlink" title="替换一个字符"></a>替换一个字符</h3><p>在交互模式下，将光标置于想要替换的字符上。按下 <code>r</code> 键，接着输入你要替换的字符即可。</p><h3 id="撤销操作"><a href="#撤销操作" class="headerlink" title="撤销操作"></a>撤销操作</h3><p>如果要撤销最近的修改，只需要按下 <code>u</code> 键，如果想要撤销最近四次修改，可以按下 4，再按下 <code>u</code> 。</p><h3 id="重做"><a href="#重做" class="headerlink" title="重做"></a>重做</h3><p>取消撤销，也就是重做之前的修改使用 <code>ctrl + r</code> 。</p><h3 id="跳转到指定行"><a href="#跳转到指定行" class="headerlink" title="跳转到指定行"></a>跳转到指定行</h3><p><code>Vim</code> 编辑的文件中，每一行都有一个行号，行号从 1 开始，逐一递增。</p><p>行号默认是不显示，如果需要它显示的话，可以进入命令模式，然后输入 <code>set nu</code> ，如果要隐藏行号的话，使用 <code>set nonu</code> 。</p><ul><li>跳转到指定行：<code>数字+gg</code> ，例如 <code>7gg</code> ，表示跳转到第 7 行。</li><li>要跳转到最后一行，按下 <code>G</code> 。</li><li>要跳转到第一行，按下 <code>gg</code> 。</li></ul><h2 id="高级操作"><a href="#高级操作" class="headerlink" title="高级操作"></a>高级操作</h2><h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><p>处于交互模式下，按下 <code>/</code> 键，那么就进入查找模式，输入你要查找的字符串，然后按下回车。光标就会跳转到文件中下一个查找到的匹配处。如果字符串不存在，那么会显示 <code>&quot;pattern not found&quot;</code> 。</p><ul><li><code>n</code> 跳转到下一个匹配项；</li><li><code>N</code> 跳转到上一个匹配项。</li></ul><p>[注意] 用斜杠来进行的查找是从当前光标处开始向文件尾搜索，如果你要从当前光标处开始，向文件头搜索则使用 <code>?</code> ，当然也可以先按下 <code>gg</code> 跳转到第一行在进行全文搜索。</p><h3 id="查找并替换"><a href="#查找并替换" class="headerlink" title="查找并替换"></a>查找并替换</h3><p>替换光标所在行第一个匹配的字符串：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 语法</span><br><span class="line">:s/旧字符串/新字符串</span><br><span class="line"></span><br><span class="line"># 实例</span><br><span class="line">:s/one/two</span><br></pre></td></tr></table></figure><p>替换光标所在行所有旧字符串为新字符串：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 语法</span><br><span class="line">:s/旧字符串/新字符串/g</span><br></pre></td></tr></table></figure><p>替换第几行到第几行中所有字符串：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 语法</span><br><span class="line">:n,m s/旧字符串/新字符串/g</span><br><span class="line"></span><br><span class="line"># 实例</span><br><span class="line">:2,4 s/one/two/g</span><br></pre></td></tr></table></figure><p>最常用的就是全文替换了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 语法</span><br><span class="line">:%s/旧字符串/新字符串/g</span><br></pre></td></tr></table></figure><h3 id="合并文件"><a href="#合并文件" class="headerlink" title="合并文件"></a>合并文件</h3><p>可以用冒号 <code>+r</code> ( <code>:r</code> ) 实现在光标处插入一个文件的内容。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:r filename # 可以用Tab键来自动补全另外一个文件的路径</span><br></pre></td></tr></table></figure><h3 id="分屏"><a href="#分屏" class="headerlink" title="分屏"></a>分屏</h3><p><code>Vim</code> 有一个特别便捷的功能那就是分屏，可以同时打开好几个文件，分屏之后，屏幕每一块被称为一个 <code>viewport</code> ，表示 “ 视口 “。</p><ul><li>横向分屏 <code>:sp 文件名</code></li><li>垂直分屏 <code>:vsp 文件名</code></li></ul><h4 id="分屏模式下的快捷键"><a href="#分屏模式下的快捷键" class="headerlink" title="分屏模式下的快捷键"></a>分屏模式下的快捷键</h4><ul><li><code>Ctrl + w</code> 再加 <code>Ctrl + w</code> ，表示从一个 <code>viewport</code> 移动光标到另外一个 <code>viewport</code> ；</li><li><code>Ctrl + w</code> 再加 “ 方向键 “，就可以移动到这个方向所处的下一个视口了；</li><li><code>Ctrl + w</code> 再加 <code>+</code> 号，表示扩大当前视口；</li><li><code>Ctrl + w</code> 再加 <code>-</code> 号，表示缩小当前视口；</li><li><code>Ctrl + w</code> 再加 <code>=</code> 号，表示平均当前视口；</li><li><code>Ctrl + w</code> 再加 <code>r</code> 键，会反向调换视口位置；</li><li><code>Ctrl + w</code> 再加 <code>q</code> 键，会关闭当前视口；</li><li><code>Ctrl + w</code> 再加 <code>o</code> 键，会关闭除当前视口以外的所有视口；</li></ul><h3 id="运行外部命令"><a href="#运行外部命令" class="headerlink" title="运行外部命令 :!"></a>运行外部命令 :!</h3><p>在 <code>Vim</code> 中可以运行一些终端命令，只要先输入 <code>:!</code> ，然后接命令名称。</p><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:!ls # 在Vim中打开的文件所在的目录运行ls命令</span><br></pre></td></tr></table></figure><h3 id="可视模式"><a href="#可视模式" class="headerlink" title="可视模式"></a>可视模式</h3><p>前面只讲了 <code>Vim</code> 的三种模式，其实还有一种模式叫做可视模式。</p><p>进入它的三种方式（都是从交互模式开始）：</p><ul><li><code>v</code> 字符可视模式，进入后配合方向键选中字符后，然后再按 <code>d</code> 键可以删除选中。</li><li><code>V</code> 行可视模式，进入后光标所在行默认被选中，然后再按 <code>d</code> 键可以删除所在行。</li><li><code>Ctrl + v</code> 块可视模式，它是可视模式最有用的功能了，配合 <code>d</code> 和 <code>I</code> 键可以实现删除选中的内容和插入内容。</li></ul><p>同时选中多行，并在选中行头部插入内容的具体操作步骤：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. ctrl + v 进入块可视模式</span><br><span class="line">2. 使用方向键进行选中（上下左右）假设选中5行</span><br><span class="line">3. 输入 I 键进行多行同时插入操作</span><br><span class="line">4. 插入完成后连续按两下 esc 键，实现多行同时插入相同字符</span><br></pre></td></tr></table></figure><p>进入可视模式之后的操作键：</p><ul><li><code>d</code> 键，表示删除选中；</li><li><code>I</code> 键，表示在选中之前插入；</li><li><code>u</code> 键，表示选中变为小写；</li><li><code>U</code> 键，表示选中变为大写；</li></ul><h2 id="Vim-配置"><a href="#Vim-配置" class="headerlink" title="Vim 配置"></a>Vim 配置</h2><h3 id="选项参数"><a href="#选项参数" class="headerlink" title="选项参数"></a>选项参数</h3><p>在 <code>Vim</code> 被启动后，可以运行一些指令来激活一些选项参数，但是这些选项参数的配置在退出 <code>Vim</code> 时会被忘记，例如前面讲解的激活行号。如果希望所在的配置是永久性的，那么需要在家目录（ <code>cd ~</code> ）创建一个 <code>Vim</code> 的配置文件 <code>.vimrc</code> 。</p><h3 id="vimrc"><a href="#vimrc" class="headerlink" title=".vimrc"></a>.vimrc</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">set number &quot; 显示行号</span><br><span class="line">syntax on &quot; 激活语法高亮</span><br><span class="line">set showcmd &quot; 实时看到输入的命令</span><br><span class="line">set ignorecase &quot; 搜索时不区分大小写</span><br><span class="line">set mouse=a &quot; 激活鼠标，用鼠标选中时相当于进入可视模式</span><br></pre></td></tr></table></figure><p><code>Vim</code> 配置非常丰富，我们可以通过个性化配置把 <code>Vim</code> 打造成属于自己的 <code>IDE</code> 等等。在 <code>github</code> 上也可以搜索到一些强大的 <code>Vim</code> 配置文件。</p>]]></content>
      
      
      <categories>
          
          <category> 应用 </category>
          
          <category> 编程工具 </category>
          
          <category> Vim </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux常用命令和系统总结</title>
      <link href="/posts/%E5%BA%94%E7%94%A8/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%92%8C%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%93.html"/>
      <url>/posts/%E5%BA%94%E7%94%A8/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%92%8C%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%93.html</url>
      
        <content type="html"><![CDATA[<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://mp.weixin.qq.com/s/JJM6eZMUKfgpfU2Kjj__Sw">2.6W字系统总结，带你实现 Linux 自由！ (qq.com)</a></li><li><a href="./https://github.com/jlevy/the-art-of-command-line/blob/master/README-zh">the-art-of-command-line</a></li><li><a href="https://coolshell.cn/articles/19219.html">打造高效的工作环境 – Shell 篇 | 酷 壳 - CoolShell</a></li></ul><h1 id="Linux-基础"><a href="#Linux-基础" class="headerlink" title="Linux 基础"></a>Linux 基础</h1><h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><p>操作系统 <code>Operating System</code> 简称 <code>OS</code> ，是软件的一部分，它是硬件基础上的第一层软件，是硬件和其它软件沟通的桥梁。</p><p>操作系统会控制其他程序运行，管理系统资源，提供最基本的计算功能，如管理及配置内存、决定系统资源供需的优先次序等，同时还提供一些基本的服务程序。</p><p><img src="/../../../../img/blog/3221dbdba0fc551d296565a126a91b4f_MD5.jpg" alt="图片"></p><h2 id="什么是-Linux"><a href="#什么是-Linux" class="headerlink" title="什么是 Linux"></a>什么是 Linux</h2><h3 id="Linux-系统内核与-Linux-发行套件的区别"><a href="#Linux-系统内核与-Linux-发行套件的区别" class="headerlink" title="Linux 系统内核与 Linux 发行套件的区别"></a>Linux 系统内核与 Linux 发行套件的区别</h3><ul><li><code>Linux</code> 系统内核指的是由 <code>Linus Torvalds</code> 负责维护，提供硬件抽象层、硬盘及文件系统控制及多任务功能的系统核心程序。</li><li><code>Linux</code> 发行套件系统是我们常说的 <code>Linux</code> 操作系统，也即是由 <code>Linux</code> 内核与各种常用软件的集合产品。</li></ul><p><strong>总结：真正的 <code>Linux</code> 指的是系统内核，而我们常说的 <code>Linux</code> 指的是 “ 发行版完整的包含一些基础软件的操作系统 “。</strong></p><h3 id="Linux-对比-Windows"><a href="#Linux-对比-Windows" class="headerlink" title="Linux 对比 Windows"></a>Linux 对比 Windows</h3><ol><li><p>稳定且有效率；</p></li><li><p>免费（或少许费用）；</p></li><li><p>漏洞少且快速修补；</p></li><li><p>多任务多用户；</p></li><li><p>更加安全的用户与文件权限策略；</p></li><li><p>适合小内核程序的嵌入系统；</p></li><li><p>相对不耗资源。</p></li></ol><h3 id="Linux-系统种类"><a href="#Linux-系统种类" class="headerlink" title="Linux 系统种类"></a>Linux 系统种类</h3><ul><li>红帽企业版 <code>Linux</code> ：<code>RHEL</code> 是全世界内使用最广泛的 <code>Linux</code> 系统。它具有极强的性能与稳定性，是众多生成环境中使用的（收费的）系统。</li><li><code>Fedora</code> ：由红帽公司发布的桌面版系统套件，用户可以免费体验到最新的技术或工具，这些技术或工具在成熟后会被加入到 <code>RHEL</code> 系统中，因此 <code>Fedora</code> 也成为 <code>RHEL</code> 系统的试验版本。</li><li><code>CentOS</code> ：通过把 <code>RHEL</code> 系统重新编译并发布给用户免费使用的 <code>Linux</code> 系统，具有广泛的使用人群。</li><li><code>Deepin</code> ：中国发行，对优秀的开源成品进行集成和配置。</li><li><code>Debian</code> ：稳定性、安全性强，提供了免费的基础支持，在国外拥有很高的认可度和使用率。</li><li><code>Ubuntu</code> ：是一款派生自 <code>Debian</code> 的操作系统，对新款硬件具有极强的兼容能力。<code>Ubuntu</code> 与 <code>Fedora</code> 都是极其出色的 <code>Linux</code> 桌面系统，而且 <code>Ubuntu</code> 也可用于服务器领域。</li></ul><h2 id="终端连接阿里云服务器"><a href="#终端连接阿里云服务器" class="headerlink" title="终端连接阿里云服务器"></a>终端连接阿里云服务器</h2><p><img src="/../../../../img/blog/4d3b0564bfeae9921b4722195b14f84b_MD5.jpg" alt="图片">通过执行 <code>ssh root@121.42.11.34</code> 命令，然后输入服务器连接密码就可以顺利登陆远程服务器。从现在开始我们就可以在本地电脑操作远程服务器。</p><ol><li><p>这个黑色的面板就是终端也就是 <code>Shell</code> （命令行环境）。</p></li><li><p><code>ssh root@xxx</code> 这是一条命令，必须要在 <code>Shell</code> 中才能执行。</p></li></ol><h2 id="Shell"><a href="#Shell" class="headerlink" title="Shell"></a>Shell</h2><p><code>Shell</code> 这个单词的原意是 “ 外壳 “，跟 <code>kernel</code>（内核）相对应，比喻内核外面的一层，即用户跟内核交互的对话界面。</p><ul><li><code>Shell</code> 是一个程序，提供一个与用户对话的环境。这个环境只有一个命令提示符，让用户从键盘输入命令，所以又称为命令行环境（ <code>command line interface</code> ，简写为 <code>CLI</code> ）。<code>Shell</code> 接收到用户输入的命令，将命令送入操作系统执行，并将结果返回给用户。</li><li><code>Shell</code> 是一个命令解释器，解释用户输入的命令。它支持变量、条件判断、循环操作等语法，所以用户可以用 <code>Shell</code> 命令写出各种小程序，又称为 <code>Shell</code> 脚本。这些脚本都通过 <code>Shell</code> 的解释执行，而不通过编译。</li><li><code>Shell</code> 是一个工具箱，提供了各种小工具，供用户方便地使用操作系统的功能。</li></ul><p><code>Shell</code> 有很多种，只要能给用户提供命令行环境的程序，都可以看作是 <code>Shell</code> 。</p><p>通过执行 <code>echo $SHELL</code> 命令可以查看到当前正在使用的 <code>Shell</code> 。还可以通过 <code>cat /etc/shells</code> 查看当前系统安装的所有 <code>Shell</code> 种类。</p><h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><h3 id="命令行提示符"><a href="#命令行提示符" class="headerlink" title="命令行提示符"></a>命令行提示符</h3><p>进入命令行环境以后，用户会看到 <code>Shell</code> 的提示符。提示符往往是一串前缀，最后以一个美元符号 <code>$</code> 结尾，用户可以在这个符号后面输入各种命令。</p><p>执行一个简单的命令 <code>pwd</code> ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root<span class="meta">@iZm5e8dsxce9ufaic7hi3uZ</span> ~]# pwd</span><br><span class="line">/root</span><br></pre></td></tr></table></figure><p>命令解析：</p><ul><li><code>root</code>：表示用户名；</li><li><code>iZm5e8dsxce9ufaic7hi3uZ</code>：表示主机名；</li><li><code>~</code>：表示目前所在目录为家目录，其中 <code>root</code> 用户的家目录是 <code>/root</code> 普通用户的家目录在 <code>/home</code> 下；</li><li><code>#</code>：指示你所具有的权限（ <code>root</code> 用户为 <code>#</code> ，普通用户为 <code>$</code> ）。</li><li>执行 <code>whoami</code> 命令可以查看当前用户名；</li><li>执行 <code>hostname</code> 命令可以查看当前主机名；</li></ul><p>关于如何创建、切换、删除用户，在后面的用户与权限会具体讲解，这里先使用 <code>root</code> 用户进行演示。</p><p>[备注] <code>root</code> 是超级用户，具备操作系统的一切权限。</p><h3 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">command parameters（命令 参数）</span><br></pre></td></tr></table></figure><h4 id="长短参数"><a href="#长短参数" class="headerlink" title="长短参数"></a>长短参数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">单个参数：ls -a（a 是英文 all 的缩写，表示“全部”）</span><br><span class="line">多个参数：ls -al（全部文件 + 列表形式展示）</span><br><span class="line">单个长参数：ls --all</span><br><span class="line">多个长参数：ls --reverse --all</span><br><span class="line">长短混合参数：ls --all -l</span><br></pre></td></tr></table></figure><h4 id="参数值"><a href="#参数值" class="headerlink" title="参数值"></a>参数值</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">短参数：command -p <span class="number">10</span>（例如：ssh root@<span class="number">121.42</span><span class="number">.11</span><span class="number">.34</span> -p <span class="number">22</span>）</span><br><span class="line">长参数：command --paramters=<span class="number">10</span>（例如：ssh root@<span class="number">121.42</span><span class="number">.11</span><span class="number">.34</span> --port=<span class="number">22</span>）</span><br></pre></td></tr></table></figure><h2 id="快捷方式"><a href="#快捷方式" class="headerlink" title="快捷方式"></a>快捷方式</h2><p>在开始学习 <code>Linux</code> 命令之前，有这么一些快捷方式，是必须要提前掌握的，它将贯穿整个 <code>Linux</code> 使用生涯。</p><ul><li>通过上下方向键 ↑ ↓ 来调取过往执行过的 <code>Linux</code> 命令；</li><li>命令或参数仅需输入前几位就可以用 <code>Tab</code> 键补全；</li><li><code>Ctrl + R</code> ：用于查找使用过的命令（<code>history</code> 命令用于列出之前使用过的所有命令，然后输入 <code>!</code> 命令加上编号 ( <code>!2</code> ) 就可以直接执行该历史命令）；</li><li><code>Ctrl + L</code>：清除屏幕并将当前行移到页面顶部；</li><li><code>Ctrl + C</code>：中止当前正在执行的命令；</li><li><code>Ctrl + U</code>：从光标位置剪切到行首；</li><li><code>Ctrl + K</code>：从光标位置剪切到行尾；</li><li><code>Ctrl + W</code>：剪切光标左侧的一个单词；</li><li><code>Ctrl + Y</code>：粘贴 <code>Ctrl + U | K | Y</code> 剪切的命令；</li><li><code>Ctrl + A</code>：光标跳到命令行的开头；</li><li><code>Ctrl + E</code>：光标跳到命令行的结尾；</li><li><code>Ctrl + D</code>：关闭 <code>Shell</code> 会话；</li></ul><h2 id="文件和目录"><a href="#文件和目录" class="headerlink" title="文件和目录"></a>文件和目录</h2><h3 id="文件的组织"><a href="#文件的组织" class="headerlink" title="文件的组织"></a>文件的组织</h3><p><img src="/../../../../img/blog/11cd0e627f8bd2d76f4946aa81a4b2af_MD5.png"></p><h3 id="查看路径"><a href="#查看路径" class="headerlink" title="查看路径"></a>查看路径</h3><h4 id="pwd"><a href="#pwd" class="headerlink" title="pwd"></a>pwd</h4><p>显示当前目录的路径</p><h4 id="which"><a href="#which" class="headerlink" title="which"></a>which</h4><p>查看命令的可执行文件所在路径， <code>Linux</code> 下，每一条命令其实都对应一个可执行程序，在终端中输入命令，按回车的时候，就是执行了对应的那个程序， <code>which</code> 命令本身对应的程序也存在于 <code>Linux</code> 中。</p><p>总的来说一个命令就是一个可执行程序。</p><p><img src="/../../../../img/blog/396daba53cba87b89e4618b016275e66_MD5.jpg" alt="图片"></p><h3 id="浏览和切换目录"><a href="#浏览和切换目录" class="headerlink" title="浏览和切换目录"></a>浏览和切换目录</h3><h4 id="ls"><a href="#ls" class="headerlink" title="ls"></a>ls</h4><p>列出文件和目录，它是 <code>Linux</code> 最常用的命令之一。</p><p>【常用参数】</p><ul><li><code>-a</code> 显示所有文件和目录包括隐藏的</li><li><code>-l</code> 显示详细列表</li><li><code>-h</code> 适合人类阅读的</li><li><code>-t</code> 按文件最近一次修改时间排序</li><li><code>-i</code> 显示文件的 <code>inode</code> （ <code>inode</code> 是文件内容的标识）</li></ul><p><img src="/../../../../img/blog/230a9c62926772bd628db3143ebc4be9_MD5.jpg" alt="图片"></p><h4 id="cd"><a href="#cd" class="headerlink" title="cd"></a>cd</h4><p><code>cd</code> 是英语 <code>change directory</code> 的缩写，表示切换目录。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cd / --&gt; 跳转到根目录</span><br><span class="line">cd ~ --&gt; 跳转到家目录</span><br><span class="line">cd .. --&gt; 跳转到上级目录</span><br><span class="line">cd ./home --&gt; 跳转到当前目录的home目录下</span><br><span class="line">cd /home/lion --&gt; 跳转到根目录下的home目录下的lion目录</span><br><span class="line">cd --&gt; 不添加任何参数，也是回到家目录</span><br></pre></td></tr></table></figure><p>[注意] 输入 <code>cd /ho</code> + 单次 <code>tab</code> 键会自动补全路径 + 两次 <code>tab</code> 键会列出所有可能的目录列表。</p><h4 id="du"><a href="#du" class="headerlink" title="du"></a>du</h4><p>列举目录大小信息。</p><p>【常用参数】</p><ul><li><code>-h</code> 适合人类阅读的；</li><li><code>-a</code> 同时列举出目录下文件的大小信息；</li><li><code>-s</code> 只显示总计大小，不显示具体信息。</li></ul><h3 id="浏览和创建文件"><a href="#浏览和创建文件" class="headerlink" title="浏览和创建文件"></a>浏览和创建文件</h3><h4 id="cat"><a href="#cat" class="headerlink" title="cat"></a>cat</h4><p>一次性显示文件所有内容，更适合查看小的文件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat cloud-init.log</span><br></pre></td></tr></table></figure><p>【常用参数】</p><ul><li><code>-n</code> 显示行号。</li></ul><h4 id="less"><a href="#less" class="headerlink" title="less"></a>less</h4><p>分页显示文件内容，更适合查看大的文件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">less cloud-init.log</span><br></pre></td></tr></table></figure><p>【快捷操作】</p><ul><li>空格键：前进一页（一个屏幕）；</li><li><code>b</code> 键：后退一页；</li><li>回车键：前进一行；</li><li><code>y</code> 键：后退一行；</li><li>上下键：回退或前进一行；</li><li><code>d</code> 键：前进半页；</li><li><code>u</code> 键：后退半页；</li><li><code>q</code> 键：停止读取文件，中止 <code>less</code> 命令；</li><li><code>=</code> 键：显示当前页面的内容是文件中的第几行到第几行以及一些其它关于本页内容的详细信息；</li><li><code>h</code> 键：显示帮助文档；</li><li><code>/</code> 键：进入搜索模式后，按 <code>n</code> 键跳到一个符合项目，按 <code>N</code> 键跳到上一个符合项目，同时也可以输入正则表达式匹配。</li></ul><h4 id="head"><a href="#head" class="headerlink" title="head"></a>head</h4><p>显示文件的开头几行（默认是 10 行）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">head cloud-init.log</span><br></pre></td></tr></table></figure><p>【参数】</p><ul><li><code>-n</code> 指定行数 <code>head cloud-init.log -n 2</code></li></ul><h4 id="tail"><a href="#tail" class="headerlink" title="tail"></a>tail</h4><p>显示文件的结尾几行（默认是 10 行）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tail cloud-init.log</span><br></pre></td></tr></table></figure><p>【参数】</p><ul><li><code>-n</code> 指定行数 <code>tail cloud-init.log -n 2</code></li><li><code>-f</code> 会每过 1 秒检查下文件是否有更新内容，也可以用 <code>-s</code> 参数指定间隔时间 <code>tail -f -s 4 xxx.log</code></li></ul><h4 id="touch"><a href="#touch" class="headerlink" title="touch"></a>touch</h4><p>创建一个文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch new_file</span><br></pre></td></tr></table></figure><h4 id="mkdir"><a href="#mkdir" class="headerlink" title="mkdir"></a>mkdir</h4><p>创建一个目录</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir new_folder</span><br></pre></td></tr></table></figure><p>【常用参数】</p><ul><li><code>-p</code> 递归的创建目录结构 <code>mkdir -p one/two/three</code></li></ul><h3 id="文件的复制和移动"><a href="#文件的复制和移动" class="headerlink" title="文件的复制和移动"></a>文件的复制和移动</h3><h4 id="cp"><a href="#cp" class="headerlink" title="cp"></a>cp</h4><p>拷贝文件和目录</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cp file file_copy --&gt; file 是目标文件，file_copy 是拷贝出来的文件</span><br><span class="line">cp file one --&gt; 把 file 文件拷贝到 one 目录下，并且文件名依然为 file</span><br><span class="line">cp file one/file_copy --&gt; 把 file 文件拷贝到 one 目录下，文件名为file_copy</span><br><span class="line">cp *.txt folder --&gt; 把当前目录下所有 txt 文件拷贝到 folder 目录下</span><br></pre></td></tr></table></figure><p>【常用参数】</p><ul><li><code>-r</code> 递归的拷贝，常用来拷贝一整个目录</li></ul><h4 id="mv"><a href="#mv" class="headerlink" title="mv"></a>mv</h4><p>移动（重命名）文件或目录，与 cp 命令用法相似。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mv file one --&gt; 将 file 文件移动到 one 目录下</span><br><span class="line">mv new_folder one --&gt; 将 new_folder 文件夹移动到one目录下</span><br><span class="line">mv *.txt folder --&gt; 把当前目录下所有 txt 文件移动到 folder 目录下</span><br><span class="line">mv file new_file --&gt; file 文件重命名为 new_file</span><br></pre></td></tr></table></figure><h3 id="文件的删除和链接"><a href="#文件的删除和链接" class="headerlink" title="文件的删除和链接"></a>文件的删除和链接</h3><h4 id="rm"><a href="#rm" class="headerlink" title="rm"></a>rm</h4><p>删除文件和目录，由于 <code>Linux</code> 下没有回收站，一旦删除非常难恢复，因此需要谨慎操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rm new_file  --&gt; 删除 new_file 文件</span><br><span class="line">rm f1 f2 f3  --&gt; 同时删除 f1 f2 f3 <span class="number">3</span>个文件</span><br></pre></td></tr></table></figure><p>【常用参数】</p><ul><li><code>-i</code> 向用户确认是否删除；</li><li><code>-f</code> 文件强制删除；</li><li><code>-r</code> 递归删除文件夹，著名的删除操作 <code>rm -rf</code> 。</li></ul><h4 id="ln"><a href="#ln" class="headerlink" title="ln"></a>ln</h4><p>英文 <code>Link</code> 的缩写，表示创建链接。</p><p>学习创建链接之前，首先要理解链接是什么，我们先来看看 <code>Linux</code> 的文件是如何存储的：</p><p><code>Linux</code> 文件的存储方式分为 3 个部分，文件名、文件内容以及权限，其中文件名的列表是存储在硬盘的其它地方和文件内容是分开存放的，每个文件名通过 <code>inode</code> 标识绑定到文件内容。</p><p>Linux 下有两种链接类型：硬链接和软链接。</p><h5 id="硬链接"><a href="#硬链接" class="headerlink" title="硬链接"></a>硬链接</h5><p>使链接的两个文件共享同样文件内容，就是同样的 <code>inode</code> ，一旦文件 1 和文件 2 之间有了硬链接，那么修改任何一个文件，修改的都是同一块内容，它的缺点是，只能创建指向文件的硬链接，不能创建指向目录的（其实也可以，但比较复杂）而软链接都可以，因此软链接使用更加广泛。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln file1 file2  --&gt; 创建 file2 为 file1 的硬链接</span><br></pre></td></tr></table></figure><p><img src="/../../../../img/blog/77b554a678c96307761b10b6c489ed0a_MD5.jpg" alt="图片"></p><p>如果我们用 <code>rm file1</code> 来删除 <code>file1</code> ，对 <code>file2</code> 没有什么影响，对于硬链接来说，删除任意一方的文件，共同指向的文件内容并不会从硬盘上删除。只有同时删除了 <code>file1</code> 与 <code>file2</code> 后，它们共同指向的文件内容才会消失。</p><h5 id="软链接"><a href="#软链接" class="headerlink" title="软链接"></a>软链接</h5><p>软链接就类似 <code>windows</code> 下快捷方式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln -s file1 file2</span><br></pre></td></tr></table></figure><p><img src="/../../../../img/blog/3e325a566fb7f92fea10ffff4d8785f3_MD5.jpg" alt="图片"></p><p>执行 <code>ls -l</code> 命名查看当前目录下文件的具体信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">total <span class="number">0</span></span><br><span class="line">-rw-r--r-- <span class="number">1</span> root root <span class="number">0</span> Jan <span class="number">14</span> <span class="number">06</span>:<span class="number">29</span> file1</span><br><span class="line">lrwxrwxrwx <span class="number">1</span> root root <span class="number">5</span> Jan <span class="number">14</span> <span class="number">06</span>:<span class="number">42</span> file2 -&gt; file1  # 表示file2 指向 file1</span><br></pre></td></tr></table></figure><p>其实 <code>file2</code> 只是 <code>file1</code> 的一个快捷方式，它指向的是 <code>file1</code> ，所以显示的是 <code>file1</code> 的内容，但其实 <code>file2</code> 的 <code>inode</code> 与 <code>file1</code> 并不相同。如果我们删除了 <code>file2</code> 的话， <code>file1</code> 是不会受影响的，但如果删除 <code>file1</code> 的话， <code>file2</code> 就会变成死链接，因为指向的文件不见了。</p><h2 id="用户与权限"><a href="#用户与权限" class="headerlink" title="用户与权限"></a>用户与权限</h2><h3 id="用户"><a href="#用户" class="headerlink" title="用户"></a>用户</h3><p><code>Linux</code> 是一个多用户的操作系统。在 <code>Linux</code> 中，理论上来说，我们可以创建无数个用户，但是这些用户是被划分到不同的群组里面的，有一个用户，名叫 <code>root</code> ，是一个很特殊的用户，它是超级用户，拥有最高权限。</p><p><img src="/../../../../img/blog/3f82ca7f43429ccc76e6bbff38538fd8_MD5.jpg" alt="图片"></p><p>自己创建的用户是有限权限的用户，这样大大提高了 <code>Linux</code> 系统的安全性，有效防止误操作或是病毒攻击，但是我们执行的某些命令需要更高权限时可以使用 <code>sudo</code> 命令。</p><h4 id="sudo"><a href="#sudo" class="headerlink" title="sudo"></a>sudo</h4><p>以 <code>root</code> 身份运行命令</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo date  --&gt; 当然查看日期是不需要sudo的这里只是演示，sudo 完之后一般还需要输入用户密码的</span><br></pre></td></tr></table></figure><h4 id="useradd-passwd"><a href="#useradd-passwd" class="headerlink" title="useradd + passwd"></a>useradd + passwd</h4><ul><li><code>useradd</code> 添加新用户</li><li><code>passwd</code> 修改用户密码</li></ul><p>这两个命令需要 <code>root</code> 用户权限</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">useradd lion --&gt; 添加一个lion用户，添加完之后在 /home 路径下可以查看</span><br><span class="line">passwd lion --&gt; 修改lion用户的密码</span><br></pre></td></tr></table></figure><h4 id="userdel"><a href="#userdel" class="headerlink" title="userdel"></a>userdel</h4><p>删除用户，需要 <code>root</code> 用户权限</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">userdel lion --&gt; 只会删除用户名，不会从/home中删除对应文件夹</span><br><span class="line">userdel lion -r --&gt; 会同时删除/home下的对应文件夹</span><br></pre></td></tr></table></figure><h4 id="su"><a href="#su" class="headerlink" title="su"></a>su</h4><p>切换用户，需要 <code>root</code> 用户权限</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo su --&gt; 切换为root用户（exit 命令或 CTRL + D 快捷键都可以使普通用户切换为 root 用户）</span><br><span class="line">su lion --&gt; 切换为普通用户</span><br><span class="line">su - --&gt; 切换为root用户</span><br></pre></td></tr></table></figure><h3 id="群组的管理"><a href="#群组的管理" class="headerlink" title="群组的管理"></a>群组的管理</h3><p><code>Linux</code> 中每个用户都属于一个特定的群组，如果你不设置用户的群组，默认会创建一个和它的用户名一样的群组，并且把用户划归到这个群组。</p><h4 id="groupadd"><a href="#groupadd" class="headerlink" title="groupadd"></a>groupadd</h4><p>创建群组，用法和 <code>useradd</code> 类似。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">groupadd friends</span><br></pre></td></tr></table></figure><h4 id="groupdel"><a href="#groupdel" class="headerlink" title="groupdel"></a>groupdel</h4><p>删除一个已存在的群组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">groupdel foo  --&gt; 删除foo群组</span><br></pre></td></tr></table></figure><h4 id="groups"><a href="#groups" class="headerlink" title="groups"></a>groups</h4><p>查看用户所在群组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">groups lion  --&gt; 查看 lion 用户所在的群组</span><br></pre></td></tr></table></figure><h4 id="usermod"><a href="#usermod" class="headerlink" title="usermod"></a>usermod</h4><p>用于修改用户的账户。</p><p>【常用参数】</p><ul><li><code>-l</code> 对用户重命名。需要注意的是 <code>/home</code> 中的用户家目录的名字不会改变，需要手动修改。</li><li><code>-g</code> 修改用户所在的群组，例如 <code>usermod -g friends lion</code> 修改 <code>lion</code> 用户的群组为 <code>friends</code> 。</li><li><code>-G</code> 一次性让用户添加多个群组，例如 <code>usermod -G friends,foo,bar lion</code> 。</li><li><code>-a</code> <code>-G</code> 会让你离开原先的群组，如果你不想这样做的话，就得再添加 <code>-a</code> 参数，意味着 <code>append</code> 追加的意思。</li></ul><h4 id="chgrp"><a href="#chgrp" class="headerlink" title="chgrp"></a>chgrp</h4><p>用于修改文件的群组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chgrp bar file.txt --&gt; file.txt文件的群组修改为bar</span><br></pre></td></tr></table></figure><h4 id="chown"><a href="#chown" class="headerlink" title="chown"></a>chown</h4><p>改变文件的所有者，需要 <code>root</code> 身份才能运行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chown lion file.txt --&gt; 把其它用户创建的file.txt转让给lion用户</span><br><span class="line">chown lion:bar file.txt --&gt; 把file.txt的用户改为lion，群组改为bar</span><br></pre></td></tr></table></figure><p>【常用参数】</p><ul><li><code>-R</code> 递归设置子目录和子文件， <code>chown -R lion:lion /home/frank</code> 把 <code>frank</code> 文件夹的用户和群组都改为 <code>lion</code> 。</li></ul><h3 id="文件权限管理"><a href="#文件权限管理" class="headerlink" title="文件权限管理"></a>文件权限管理</h3><h4 id="chmod"><a href="#chmod" class="headerlink" title="chmod"></a>chmod</h4><p>修改访问权限。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod <span class="number">740</span> file.txt</span><br></pre></td></tr></table></figure><p>【常用参数】</p><ul><li><code>-R</code> 可以递归地修改文件访问权限，例如 <code>chmod -R 777 /home/lion</code></li></ul><p>修改权限的确简单，但是理解其深层次的意义才是更加重要的。下面我们来系统的学习 <code>Linux</code> 的文件权限。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root<span class="meta">@lion</span> ~]# ls -l</span><br><span class="line">drwxr-xr-x <span class="number">5</span> root root <span class="number">4096</span> Apr <span class="number">13</span>  <span class="number">2020</span> climb</span><br><span class="line">lrwxrwxrwx <span class="number">1</span> root root    <span class="number">7</span> Jan <span class="number">14</span> <span class="number">06</span>:<span class="number">41</span> hello2.c -&gt; hello.c</span><br><span class="line">-rw-r--r-- <span class="number">1</span> root root  <span class="number">149</span> Jan <span class="number">13</span> <span class="number">06</span>:<span class="number">14</span> hello.c</span><br></pre></td></tr></table></figure><p>其中 <code>drwxr-xr-x</code> 表示文件或目录的权限。让我们一起来解读它具体代表什么？</p><ul><li><code>d</code> ：表示目录，就是说这是一个目录，普通文件是 <code>-</code> ，链接是 <code>l</code> 。</li><li><code>r</code> ：<code>read</code> 表示文件可读。</li><li><code>w</code> ：<code>write</code> 表示文件可写，一般有写的权限，就有删除的权限。</li><li><code>x</code> ：<code>execute</code> 表示文件可执行。</li><li><code>-</code> ：表示没有相应权限。</li></ul><p>权限的整体是按用户来划分的，如下图所示：</p><p><img src="/../../../../img/blog/a2c6d556f37b0f4f4673661f47d615cf_MD5.jpg" alt="图片"></p><p>现在再来理解这句权限 <code>drwxr-xr-x</code> 的意思：</p><ul><li>它是一个文件夹；</li><li>它的所有者具有：读、写、执行权限；</li><li>它的群组用户具有：读、执行的权限，没有写的权限；</li><li>它的其它用户具有：读、执行的权限，没有写的权限。</li></ul><p>现在理解了权限，我们使用 <code>chmod</code> 来尝试修改权限。<code>chmod</code> 它不需要是 <code>root</code> 用户才能运行的，只要你是此文件所有者，就可以用 <code>chmod</code> 来修改文件的访问权限。</p><h5 id="数字分配权限"><a href="#数字分配权限" class="headerlink" title="数字分配权限"></a>数字分配权限</h5><table><thead><tr><th>权限</th><th>数字</th></tr></thead><tbody><tr><td>r</td><td>4</td></tr><tr><td>w</td><td>2</td></tr><tr><td>x</td><td>1</td></tr></tbody></table><p>因此要改变权限，只要做一些简单的加法就行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">chmod <span class="number">640</span> hello.c </span><br><span class="line"></span><br><span class="line"># 分析</span><br><span class="line"><span class="number">6</span> = <span class="number">4</span> + <span class="number">2</span> + <span class="number">0</span> 表示所有者具有 rw 权限</span><br><span class="line"><span class="number">4</span> = <span class="number">4</span> + <span class="number">0</span> + <span class="number">0</span> 表示群组用户具有 r 权限</span><br><span class="line"><span class="number">0</span> = <span class="number">0</span> + <span class="number">0</span> + <span class="number">0</span> 表示其它用户没有权限</span><br><span class="line"></span><br><span class="line">对应文字权限为：-rw-r-----</span><br></pre></td></tr></table></figure><h5 id="用字母来分配权限"><a href="#用字母来分配权限" class="headerlink" title="用字母来分配权限"></a>用字母来分配权限</h5><ul><li><code>u</code> ：<code>user</code> 的缩写，用户的意思，表示所有者。</li><li><code>g</code> ：<code>group</code> 的缩写，群组的意思，表示群组用户。</li><li><code>o</code> ：<code>other</code> 的缩写，其它的意思，表示其它用户。</li><li><code>a</code> ：<code>all</code> 的缩写，所有的意思，表示所有用户。</li><li><code>+</code> ：加号，表示添加权限。</li><li><code>-</code> ：减号，表示去除权限。</li><li><code>=</code> ：等于号，表示分配权限。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">chmod u+rx file --&gt; 文件file的所有者增加读和运行的权限</span><br><span class="line">chmod g+r file --&gt; 文件file的群组用户增加读的权限</span><br><span class="line">chmod o-r file --&gt; 文件file的其它用户移除读的权限</span><br><span class="line">chmod g+r o-r file --&gt; 文件file的群组用户增加读的权限，其它用户移除读的权限</span><br><span class="line">chmod go-r file --&gt; 文件file的群组和其他用户移除读的权限</span><br><span class="line">chmod +x file --&gt; 文件file的所有用户增加运行的权限</span><br><span class="line">chmod u=rwx,g=r,o=- file --&gt; 文件file的所有者分配读写和执行的权限，群组其它用户分配读的权限，其他用户没有任何权限</span><br></pre></td></tr></table></figure><h2 id="查找文件"><a href="#查找文件" class="headerlink" title="查找文件"></a>查找文件</h2><h3 id="locate"><a href="#locate" class="headerlink" title="locate"></a>locate</h3><p>搜索包含关键字的所有文件和目录。后接需要查找的文件名，也可以用正则表达式。</p><h4 id="安装-locate"><a href="#安装-locate" class="headerlink" title="安装 locate"></a>安装 locate</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum -y install mlocate --&gt; 安装包</span><br><span class="line">updatedb --&gt; 更新数据库</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">locate file.txt</span><br><span class="line">locate fil*.txt</span><br></pre></td></tr></table></figure><p>[注意] <code>locate</code> 命令会去文件数据库中查找命令，而不是全磁盘查找，因此刚创建的文件并不会更新到数据库中，所以无法被查找到，可以执行 <code>updatedb</code> 命令去更新数据库。</p><h3 id="find"><a href="#find" class="headerlink" title="find"></a>find</h3><p>用于查找文件，它会去遍历你的实际硬盘进行查找，而且它允许我们对每个找到的文件进行后续操作，功能非常强大。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find &lt;何处&gt; &lt;何物&gt; &lt;做什么&gt;</span><br></pre></td></tr></table></figure><ul><li>何处：指定在哪个目录查找，此目录的所有子目录也会被查找。</li><li>何物：查找什么，可以根据文件的名字来查找，也可以根据其大小来查找，还可以根据其最近访问时间来查找。</li><li>做什么：找到文件后，可以进行后续处理，如果不指定这个参数， <code>find</code> 命令只会显示找到的文件。</li></ul><h4 id="根据文件名查找"><a href="#根据文件名查找" class="headerlink" title="根据文件名查找"></a>根据文件名查找</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">find -name <span class="string">&quot;file.txt&quot;</span> --&gt; 当前目录以及子目录下通过名称查找文件</span><br><span class="line">find . -name <span class="string">&quot;syslog&quot;</span> --&gt; 当前目录以及子目录下通过名称查找文件</span><br><span class="line">find / -name <span class="string">&quot;syslog&quot;</span> --&gt; 整个硬盘下查找syslog</span><br><span class="line">find /<span class="keyword">var</span>/log -name <span class="string">&quot;syslog&quot;</span> --&gt; 在指定的目录/<span class="keyword">var</span>/log下查找syslog文件</span><br><span class="line">find /<span class="keyword">var</span>/log -name <span class="string">&quot;syslog*&quot;</span> --&gt; 查找syslog1、syslog2 ... 等文件，通配符表示所有</span><br><span class="line">find /<span class="keyword">var</span>/log -name <span class="string">&quot;*syslog*&quot;</span> --&gt; 查找包含syslog的文件 </span><br></pre></td></tr></table></figure><p>[注意] <code>find</code> 命令只会查找完全符合 “ 何物 “ 字符串的文件，而 <code>locate</code> 会查找所有包含关键字的文件。</p><h4 id="根据文件大小查找"><a href="#根据文件大小查找" class="headerlink" title="根据文件大小查找"></a>根据文件大小查找</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">find /<span class="keyword">var</span> -size +10M --&gt; /<span class="keyword">var</span> 目录下查找文件大小超过 10M 的文件</span><br><span class="line">find /<span class="keyword">var</span> -size -50k --&gt; /<span class="keyword">var</span> 目录下查找文件大小小于 50k 的文件</span><br><span class="line">find /<span class="keyword">var</span> -size +1G --&gt; /<span class="keyword">var</span> 目录下查找文件大小查过 1G 的文件</span><br><span class="line">find /<span class="keyword">var</span> -size 1M --&gt; /<span class="keyword">var</span> 目录下查找文件大小等于 1M 的文件</span><br></pre></td></tr></table></figure><h4 id="根据文件最近访问时间查找"><a href="#根据文件最近访问时间查找" class="headerlink" title="根据文件最近访问时间查找"></a>根据文件最近访问时间查找</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find -name <span class="string">&quot;*.txt&quot;</span> -atime -<span class="number">7</span>  --&gt; 近 <span class="number">7</span>天内访问过的.txt结尾的文件</span><br></pre></td></tr></table></figure><h4 id="仅查找目录或文件"><a href="#仅查找目录或文件" class="headerlink" title="仅查找目录或文件"></a>仅查找目录或文件</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">find . -name <span class="string">&quot;file&quot;</span> -type f  --&gt; 只查找当前目录下的file文件</span><br><span class="line">find . -name <span class="string">&quot;file&quot;</span> -type d  --&gt; 只查找当前目录下的file目录</span><br></pre></td></tr></table></figure><h4 id="操作查找结果"><a href="#操作查找结果" class="headerlink" title="操作查找结果"></a>操作查找结果</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">find -name <span class="string">&quot;*.txt&quot;</span> -printf <span class="string">&quot;%p - %u\n&quot;</span> --&gt; 找出所有后缀为txt的文件，并按照 %p - %u\n 格式打印，其中%p=文件名，%u=文件所有者</span><br><span class="line">find -name <span class="string">&quot;*.jpg&quot;</span> -delete --&gt; 删除当前目录以及子目录下所有.jpg为后缀的文件，不会有删除提示，因此要慎用</span><br><span class="line">find -name <span class="string">&quot;*.c&quot;</span> -exec chmod <span class="number">600</span> &#123;&#125; \; --&gt; 对每个.c结尾的文件，都进行 -exec 参数指定的操作，&#123;&#125; 会被查找到的文件替代，\; 是必须的结尾</span><br><span class="line">find -name <span class="string">&quot;*.c&quot;</span> -ok chmod <span class="number">600</span> &#123;&#125; \; --&gt; 和上面的功能一直，会多一个确认提示</span><br></pre></td></tr></table></figure><h2 id="软件仓库"><a href="#软件仓库" class="headerlink" title="软件仓库"></a>软件仓库</h2><p><code>Linux</code> 下软件是以包的形式存在，一个软件包其实就是软件的所有文件的压缩包，是二进制的形式，包含了安装软件的所有指令。<code>Red Hat</code> 家族的软件包后缀名一般为 <code>.rpm</code> ， <code>Debian</code> 家族的软件包后缀是 <code>.deb</code> 。</p><p><code>Linux</code> 的包都存在一个仓库，叫做软件仓库，它可以使用 <code>yum</code> 来管理软件包， <code>yum</code> 是 <code>CentOS</code> 中默认的包管理工具，适用于 <code>Red Hat</code> 一族。可以理解成 <code>Node.js</code> 的 <code>npm</code> 。</p><h3 id="yum-常用命令"><a href="#yum-常用命令" class="headerlink" title="yum 常用命令"></a>yum 常用命令</h3><ul><li><code>yum update | yum upgrade</code> 更新软件包</li><li><code>yum search xxx</code> 搜索相应的软件包</li><li><code>yum install xxx</code> 安装软件包</li><li><code>yum remove xxx</code> 删除软件包</li></ul><h3 id="切换-CentOS-软件源"><a href="#切换-CentOS-软件源" class="headerlink" title="切换 CentOS 软件源"></a>切换 CentOS 软件源</h3><p>有时候 <code>CentOS</code> 默认的 <code>yum</code> 源不一定是国内镜像，导致 <code>yum</code> 在线安装及更新速度不是很理想。这时候需要将 <code>yum</code> 源设置为国内镜像站点。国内主要开源的镜像站点是网易和阿里云。</p><p>1、首先备份系统自带 <code>yum</code> 源配置文件 <code>mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup</code></p><p>2、下载阿里云的 <code>yum</code> 源配置文件到 <code>/etc/yum.repos.d/CentOS7</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget -O /etc/yum.repos.d/CentOS-Base.repo http:<span class="comment">//mirrors.aliyun.com/repo/Centos-7.repo</span></span><br></pre></td></tr></table></figure><p>3、生成缓存</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum makecache</span><br></pre></td></tr></table></figure><h2 id="阅读手册"><a href="#阅读手册" class="headerlink" title="阅读手册"></a>阅读手册</h2><p><code>Linux</code> 命令种类繁杂，我们凭借记忆不可能全部记住，因此学会查用手册是非常重要的。</p><h3 id="man"><a href="#man" class="headerlink" title="man"></a>man</h3><h4 id="安装更新-man"><a href="#安装更新-man" class="headerlink" title="安装更新 man"></a>安装更新 man</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install -y man-pages --&gt; 安装</span><br><span class="line">sudo mandb --&gt; 更新</span><br></pre></td></tr></table></figure><h4 id="man-手册种类"><a href="#man-手册种类" class="headerlink" title="man 手册种类"></a>man 手册种类</h4><ol><li><p>可执行程序或 <code>Shell</code> 命令；</p></li><li><p>系统调用（ <code>Linux</code> 内核提供的函数）；</p></li><li><p>库调用（程序库中的函数）；</p></li><li><p>文件（例如 <code>/etc/passwd</code> ）；</p></li><li><p>特殊文件（通常在 <code>/dev</code> 下）；</p></li><li><p>游戏；</p></li><li><p>杂项（ <code>man(7)</code> ，<code>groff(7)</code> ）；</p></li><li><p>系统管理命令（通常只能被 <code>root</code> 用户使用）；</p></li><li><p>内核子程序。</p></li></ol><h4 id="man-参数-命令"><a href="#man-参数-命令" class="headerlink" title="man + 参数 + 命令"></a>man + 参数 + 命令</h4><p>输入 man + 数字 + 命令&#x2F;函数，可以查到相关的命令和函数，若不加数字， <code>man</code> 默认从数字较小的手册中寻找相关命令和函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">man <span class="number">3</span> rand  --&gt; 表示在手册的第三部分查找 rand 函数</span><br><span class="line">man ls    --&gt; 查找 ls 用法手册</span><br><span class="line">man -k printf   --&gt; 将关键词 printf 作为正则表达式来搜索对应的手册页概述和手册页名称，并打印所有匹配结果。等效于apropos printf.</span><br><span class="line">man -f smail --&gt; 查找 smail 引用的手册页并输出找到的所有概述。等效于 whatis smail.</span><br></pre></td></tr></table></figure><p>man 手册核心区域解析：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">NAME # 命令名称和简单描述  </span><br><span class="line"></span><br><span class="line">SYNOPSIS # 使用此命令的所有方法</span><br><span class="line"></span><br><span class="line">DESCRIPTION # 包括所有参数以及用法</span><br><span class="line"></span><br><span class="line">SEE ALSO # 扩展阅读相关命令</span><br></pre></td></tr></table></figure><h3 id="cheat"><a href="#cheat" class="headerlink" title="cheat"></a>cheat</h3><p>man 虽然很重要，但有些命令看了帮助还不会用，初学者需要例子，<a href="https://github.com/cheat/cheat">cheat</a> 就是这个身边的小抄。类似的有 <a href="https://github.com/tldr-pages/tldr">tldr-pages&#x2F;tldr：📚控制台命令的协作备忘单</a></p><h3 id="help"><a href="#help" class="headerlink" title="help"></a>help</h3><p><code>man</code> 命令像新华词典一样可以查询到命令或函数的详细信息，但其实我们还有更加快捷的方式去查询， <code>command --help</code> 或 <code>command -h</code> ，它没有 <code>man</code> 命令显示的那么详细，但是它更加易于阅读。</p><h1 id="Linux-进阶"><a href="#Linux-进阶" class="headerlink" title="Linux 进阶"></a>Linux 进阶</h1><h2 id="文本操作"><a href="#文本操作" class="headerlink" title="文本操作"></a>文本操作</h2><h3 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h3><p>全局搜索一个正则表达式，并且打印到屏幕。简单来说就是，在文件中查找关键字，并显示关键字所在行。</p><h4 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">grep text file # text代表要搜索的文本，file代表供搜索的文件</span><br><span class="line"></span><br><span class="line"># 实例</span><br><span class="line">[root<span class="meta">@lion</span> ~]# grep path /etc/profile</span><br><span class="line"><span class="title function_">pathmunge</span> <span class="params">()</span> &#123;</span><br><span class="line">    pathmunge /usr/sbin</span><br><span class="line">    pathmunge /usr/local/sbin</span><br><span class="line">    pathmunge /usr/local/sbin after</span><br><span class="line">    pathmunge /usr/sbin after</span><br><span class="line">unset -f pathmunge</span><br></pre></td></tr></table></figure><h4 id="常用参数"><a href="#常用参数" class="headerlink" title="常用参数"></a>常用参数</h4><ul><li><code>-i</code> 忽略大小写， <code>grep -i path /etc/profile</code></li><li><code>-n</code> 显示行号，<code>grep -n path /etc/profile</code></li><li><code>-v</code> 只显示搜索文本不在的那些行，<code>grep -v path /etc/profile</code></li><li><code>-r</code> 递归查找， <code>grep -r hello /etc</code> ，Linux 中还有一个 rgrep 命令，作用相当于 <code>grep -r</code></li></ul><h4 id="高级用法"><a href="#高级用法" class="headerlink" title="高级用法"></a>高级用法</h4><p><code>grep</code> 可以配合正则表达式使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">grep -E path /etc/profile --&gt; 完全匹配path</span><br><span class="line">grep -E ^path /etc/profile --&gt; 匹配path开头的字符串</span><br><span class="line">grep -E [Pp]ath /etc/profile --&gt; 匹配path或Path</span><br></pre></td></tr></table></figure><h3 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h3><p>对文件的行进行排序。</p><h4 id="基础语法-1"><a href="#基础语法-1" class="headerlink" title="基础语法"></a>基础语法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sort name.txt # 对name.txt文件进行排序</span><br></pre></td></tr></table></figure><h4 id="实例用法"><a href="#实例用法" class="headerlink" title="实例用法"></a>实例用法</h4><p>为了演示方便，我们首先创建一个文件 <code>name.txt</code> ，放入以下内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Christopher</span><br><span class="line">Shawn</span><br><span class="line">Ted</span><br><span class="line">Rock</span><br><span class="line">Noah</span><br><span class="line">Zachary</span><br><span class="line">Bella</span><br></pre></td></tr></table></figure><p>执行 <code>sort name.txt</code> 命令，会对文本内容进行排序。</p><h4 id="常用参数-1"><a href="#常用参数-1" class="headerlink" title="常用参数"></a>常用参数</h4><ul><li><code>-o</code> 将排序后的文件写入新文件， <code>sort -o name_sorted.txt name.txt</code> ；</li><li><code>-r</code> 倒序排序， <code>sort -r name.txt</code> ；</li><li><code>-R</code> 随机排序， <code>sort -R name.txt</code> ；</li><li><code>-n</code> 对数字进行排序，默认是把数字识别成字符串的，因此 138 会排在 25 前面，如果添加了 <code>-n</code> 数字排序的话，则 25 会在 138 前面。</li></ul><h3 id="wc"><a href="#wc" class="headerlink" title="wc"></a>wc</h3><p><code>word count</code> 的缩写，用于文件的统计。它可以统计单词数目、行数、字符数，字节数等。</p><h4 id="基础语法-2"><a href="#基础语法-2" class="headerlink" title="基础语法"></a>基础语法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wc name.txt # 统计name.txt</span><br></pre></td></tr></table></figure><h4 id="实例用法-1"><a href="#实例用法-1" class="headerlink" title="实例用法"></a>实例用法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root<span class="meta">@lion</span> ~]# wc name.txt </span><br><span class="line"><span class="number">13</span> <span class="number">13</span> <span class="number">91</span> name.txt</span><br></pre></td></tr></table></figure><ul><li>第一个 13，表示行数；</li><li>第二个 13，表示单词数；</li><li>第三个 91，表示字节数。</li></ul><h4 id="常用参数-2"><a href="#常用参数-2" class="headerlink" title="常用参数"></a>常用参数</h4><ul><li><code>-l</code> 只统计行数， <code>wc -l name.txt</code> ；</li><li><code>-w</code> 只统计单词数， <code>wc -w name.txt</code> ；</li><li><code>-c</code> 只统计字节数， <code>wc -c name.txt</code> ；</li><li><code>-m</code> 只统计字符数， <code>wc -m name.txt</code> 。</li></ul><h3 id="uniq"><a href="#uniq" class="headerlink" title="uniq"></a>uniq</h3><p>删除文件中的重复内容。</p><h4 id="基础语法-3"><a href="#基础语法-3" class="headerlink" title="基础语法"></a>基础语法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">uniq name.txt # 去除name.txt重复的行数，并打印到屏幕上</span><br><span class="line">uniq name.txt uniq_name.txt # 把去除重复后的文件保存为 uniq_name.txt</span><br></pre></td></tr></table></figure><p>【注意】它只能去除连续重复的行数。</p><h4 id="常用参数-3"><a href="#常用参数-3" class="headerlink" title="常用参数"></a>常用参数</h4><ul><li><code>-c</code> 统计重复行数， <code>uniq -c name.txt</code> ；</li><li><code>-d</code> 只显示重复的行数， <code>uniq -d name.txt</code> 。</li></ul><h3 id="cut"><a href="#cut" class="headerlink" title="cut"></a>cut</h3><p>剪切文件的一部分内容。</p><h4 id="基础语法-4"><a href="#基础语法-4" class="headerlink" title="基础语法"></a>基础语法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cut -c <span class="number">2</span>-<span class="number">4</span> name.txt # 剪切每一行第二到第四个字符</span><br></pre></td></tr></table></figure><h4 id="常用参数-4"><a href="#常用参数-4" class="headerlink" title="常用参数"></a>常用参数</h4><ul><li><code>-d</code> 用于指定用什么分隔符（比如逗号、分号、双引号等等） <code>cut -d , name.txt</code> ；</li><li><code>-f</code> 表示剪切下用分隔符分割的哪一块或哪几块区域， <code>cut -d , -f 1 name.txt</code> 。</li></ul><h2 id="重定向-管道-流"><a href="#重定向-管道-流" class="headerlink" title="重定向 管道 流"></a>重定向 管道 流</h2><p>在 <code>Linux</code> 中一个命令的去向可以有 3 个地方：终端、文件、作为另外一个命令的入参。<br><img src="/../../../../img/blog/39ed50e0aa849edc19fe5baac3dc9fcb_MD5.jpg" alt="图片"><br>命令一般都是通过键盘输入，然后输出到终端、文件等地方，它的标准用语是 <code>stdin</code> 、 <code>stdout</code> 以及 <code>stderr</code> 。</p><ul><li>标准输入 <code>stdin</code> ，终端接收键盘输入的命令，会产生两种输出；</li><li>标准输出 <code>stdout</code> ，终端输出的信息（不包含错误信息）；</li><li>标准错误输出 <code>stderr</code> ，终端输出的错误信息。</li></ul><p><img src="/../../../../img/blog/05f3f6a977d20d9fc0463d50cdde3dda_MD5.jpg" alt="图片"></p><h3 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h3><p>把本来要显示在终端的命令结果，输送到别的地方（到文件中或者作为其他命令的输入）。</p><h4 id="输出重定向-gt"><a href="#输出重定向-gt" class="headerlink" title="输出重定向 &gt;"></a>输出重定向 &gt;</h4><p><code>&gt;</code> 表示重定向到新的文件， <code>cut -d , -f 1 notes.csv &gt; name.csv</code> ，它表示通过逗号剪切 <code>notes.csv</code> 文件（剪切完有 3 个部分）获取第一个部分，重定向到 <code>name.csv</code> 文件。</p><p>我们来看一个具体示例，学习它的使用，假设我们有一个文件 <code>notes.csv</code> ，文件内容如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Mark1,<span class="number">951</span>/<span class="number">100</span>,很不错<span class="number">1</span></span><br><span class="line">Mark2,<span class="number">952</span>/<span class="number">100</span>,很不错<span class="number">2</span></span><br><span class="line">Mark3,<span class="number">953</span>/<span class="number">100</span>,很不错<span class="number">3</span></span><br><span class="line">Mark4,<span class="number">954</span>/<span class="number">100</span>,很不错<span class="number">4</span></span><br><span class="line">Mark5,<span class="number">955</span>/<span class="number">100</span>,很不错<span class="number">5</span></span><br><span class="line">Mark6,<span class="number">956</span>/<span class="number">100</span>,很不错<span class="number">6</span></span><br></pre></td></tr></table></figure><p>执行命令：<code>cut -d , -f 1 notes.csv &gt; name.csv</code> 最后输出如下内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Mark1</span><br><span class="line">Mark2</span><br><span class="line">Mark3</span><br><span class="line">Mark4</span><br><span class="line">Mark5</span><br><span class="line">Mark6</span><br></pre></td></tr></table></figure><p>【注意】使用 <code>&gt;</code> 要注意，如果输出的文件不存在它会新建一个，如果输出的文件已经存在，则会覆盖。因此执行这个操作要非常小心，以免覆盖其它重要文件。</p><h4 id="输出重定向-gt-gt"><a href="#输出重定向-gt-gt" class="headerlink" title="输出重定向 &gt;&gt;"></a>输出重定向 &gt;&gt;</h4><p>表示重定向到文件末尾，因此它不会像 <code>&gt;</code> 命令这么危险，它是追加到文件的末尾（当然如果文件不存在，也会被创建）。</p><p>再次执行 <code>cut -d , -f 1 notes.csv &gt;&gt; name.csv</code> ，则会把名字追加到 <code>name.csv</code> 里面。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Mark1</span><br><span class="line">Mark2</span><br><span class="line">Mark3</span><br><span class="line">Mark4</span><br><span class="line">Mark5</span><br><span class="line">Mark6</span><br><span class="line">Mark1</span><br><span class="line">Mark2</span><br><span class="line">Mark3</span><br><span class="line">Mark4</span><br><span class="line">Mark5</span><br><span class="line">Mark6</span><br></pre></td></tr></table></figure><p>我们平时读的 <code>log</code> 日志文件其实都是用这个命令输出的。</p><h4 id="输出重定向-2-gt"><a href="#输出重定向-2-gt" class="headerlink" title="输出重定向 2&gt;"></a>输出重定向 2&gt;</h4><p>标准错误输出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat not_exist_file.csv &gt; res.txt <span class="number">2</span>&gt; errors.log</span><br></pre></td></tr></table></figure><ul><li>当我们 <code>cat</code> 一个文件时，会把文件内容打印到屏幕上，这个是标准输出；</li><li>当使用了 <code>&gt; res.txt</code> 时，则不会打印到屏幕，会把标准输出写入文件 <code>res.txt</code> 文件中；</li><li><code>2&gt; errors.log</code> 当发生错误时会写入 <code>errors.log</code> 文件中。</li></ul><h4 id="输出重定向-2-gt-gt"><a href="#输出重定向-2-gt-gt" class="headerlink" title="输出重定向 2&gt;&gt;"></a>输出重定向 2&gt;&gt;</h4><p>标准错误输出（追加到文件末尾）同 <code>&gt;&gt;</code> 相似。</p><h4 id="输出重定向-2-gt-amp-1"><a href="#输出重定向-2-gt-amp-1" class="headerlink" title="输出重定向 2&gt;&amp;1"></a>输出重定向 2&gt;&amp;1</h4><p>标准输出和标准错误输出都重定向都一个地方</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cat not_exist_file.csv &gt; res.txt <span class="number">2</span>&gt;&amp;<span class="number">1</span>  # 覆盖输出</span><br><span class="line">cat not_exist_file.csv &gt;&gt; res.txt <span class="number">2</span>&gt;&amp;<span class="number">1</span> # 追加输出</span><br></pre></td></tr></table></figure><p>目前为止，我们接触的命令的输入都来自命令的参数，其实命令的输入还可以来自文件或者键盘的输入。</p><p><img src="/../../../../img/blog/c8c5174435605edd5fc58ce5b2e83705_MD5.jpg" alt="图片"></p><h4 id="输入重定向-lt"><a href="#输入重定向-lt" class="headerlink" title="输入重定向 &lt;"></a>输入重定向 &lt;</h4><p><code>&lt;</code> 符号用于指定命令的输入。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat &lt; name.csv # 指定命令的输入为 name.csv</span><br></pre></td></tr></table></figure><p>虽然它的运行结果与 <code>cat name.csv</code> 一样，但是它们的原理却完全不同。</p><ul><li><code>cat name.csv</code> 表示 <code>cat</code> 命令接收的输入是 <code>notes.csv</code> 文件名，那么要先打开这个文件，然后打印出文件内容。</li><li><code>cat &lt; name.csv</code> 表示 <code>cat</code> 命令接收的输入直接是 <code>notes.csv</code> 这个文件的内容， <code>cat</code> 命令只负责将其内容打印，打开文件并将文件内容传递给 <code>cat</code> 命令的工作则交给终端完成。</li></ul><h4 id="输入重定向-lt-lt"><a href="#输入重定向-lt-lt" class="headerlink" title="输入重定向 &lt;&lt;"></a>输入重定向 &lt;&lt;</h4><p>将键盘的输入重定向为某个命令的输入。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sort -n &lt;&lt; END # 输入这个命令之后，按下回车，终端就进入键盘输入模式，其中END为结束命令（这个可以自定义）</span><br><span class="line"></span><br><span class="line">wc -m &lt;&lt; END # 统计输入的单词</span><br></pre></td></tr></table></figure><h3 id="管道"><a href="#管道" class="headerlink" title="管道 |"></a>管道 |</h3><p>把两个命令连起来使用，一个命令的输出作为另外一个命令的输入，英文是 <code>pipeline</code> ，可以想象一个个水管连接起来，管道算是重定向流的一种。</p><p><img src="/../../../../img/blog/327c6fef8f6726cf6a2f039d26531695_MD5.jpg" alt="图片"></p><p>举几个实际用法案例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">cut -d , -f <span class="number">1</span> name.csv | sort &gt; sorted_name.txt </span><br><span class="line"># 第一步获取到的 name 列表，通过管道符再进行排序，最后输出到sorted_name.txt</span><br><span class="line"></span><br><span class="line">du | sort -nr | head </span><br><span class="line"># du 表示列举目录大小信息</span><br><span class="line"># sort 进行排序,-n 表示按数字排序，-r 表示倒序</span><br><span class="line"># head 前<span class="number">10</span>行文件</span><br><span class="line"></span><br><span class="line">grep log -Ir /<span class="keyword">var</span>/log | cut -d : -f <span class="number">1</span> | sort | uniq</span><br><span class="line"># grep log -Ir /<span class="keyword">var</span>/log 表示在log文件夹下搜索 /<span class="keyword">var</span>/log 文本，-r 表示递归，-I 用于排除二进制文件</span><br><span class="line"># cut -d : -f <span class="number">1</span> 表示通过冒号进行剪切，获取剪切的第一部分</span><br><span class="line"># sort 进行排序</span><br><span class="line"># uniq 进行去重</span><br></pre></td></tr></table></figure><h3 id="流"><a href="#流" class="headerlink" title="流"></a>流</h3><p>流并非一个命令，在计算机科学中，流 <code>stream</code> 的含义是比较难理解的，记住一点即可：<strong>流就是读一点数据, 处理一点点数据。其中数据一般就是二进制格式。</strong> 上面提及的重定向或管道，就是把数据当做流去运转的。</p><p>到此我们就接触了，流、重定向、管道等 <code>Linux</code> 高级概念及指令。其实你会发现关于流和管道在其它语言中也有广泛的应用。<code>Angular</code> 中的模板语法中可以使用管道。<code>Node.js</code> 中也有 <code>stream</code> 流的概念。</p><h2 id="查看进程"><a href="#查看进程" class="headerlink" title="查看进程"></a>查看进程</h2><p>在 <code>Windows</code> 中通过 <code>Ctrl + Alt + Delete</code> 快捷键查看软件进程。</p><h3 id="w"><a href="#w" class="headerlink" title="w"></a>w</h3><p>帮助我们快速了解系统中目前有哪些用户登录着，以及他们在干什么。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[root<span class="meta">@lion</span> ~]# w</span><br><span class="line"> <span class="number">06</span>:<span class="number">31</span>:<span class="number">53</span> up <span class="number">25</span> days,  <span class="number">9</span>:<span class="number">53</span>,  <span class="number">1</span> user,  load average: <span class="number">0.00</span>, <span class="number">0.01</span>, <span class="number">0.05</span></span><br><span class="line">USER     TTY      FROM             LOGIN@   IDLE   JCPU   PCPU WHAT</span><br><span class="line">root     pts/<span class="number">0</span>    <span class="number">118.31</span><span class="number">.243</span><span class="number">.53</span>    <span class="number">05</span>:<span class="number">56</span>    <span class="number">1.</span>00s  <span class="number">0.</span>02s  <span class="number">0.</span>00s w</span><br><span class="line"> </span><br><span class="line"><span class="number">06</span>:<span class="number">31</span>:<span class="number">53</span>：表示当前时间</span><br><span class="line">up <span class="number">25</span> days, <span class="number">9</span>:<span class="number">53</span>：表示系统已经正常运行了“<span class="number">25</span>天<span class="number">9</span>小时<span class="number">53</span>分钟”</span><br><span class="line"><span class="number">1</span> user：表示一个用户</span><br><span class="line">load average: <span class="number">0.00</span>, <span class="number">0.01</span>, <span class="number">0.05</span>：表示系统的负载，<span class="number">3</span>个值分别表示“<span class="number">1</span>分钟的平均负载”，“<span class="number">5</span>分钟的平均负载”，“<span class="number">15</span>分钟的平均负载”</span><br><span class="line"></span><br><span class="line"> USER：表示登录的用于</span><br><span class="line"> TTY：登录的终端名称为pts/<span class="number">0</span></span><br><span class="line"> FROM：连接到服务器的ip地址</span><br><span class="line"> LOGIN@：登录时间</span><br><span class="line"> IDLE：用户有多久没有活跃了</span><br><span class="line"> JCPU：该终端所有相关的进程使用的 CPU 时间，每当进程结束就停止计时，开始新的进程则会重新计时</span><br><span class="line"> PCPU：表示 CPU 执行当前程序所消耗的时间，当前进程就是在 WHAT 列里显示的程序</span><br><span class="line"> WHAT：表示当下用户正运行的程序是什么，这里我运行的是 w</span><br></pre></td></tr></table></figure><h3 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h3><p>用于显示当前系统中的进程， <code>ps</code> 命令显示的进程列表不会随时间而更新，是静态的，是运行 <code>ps</code> 命令那个时刻的状态或者说是一个进程快照。</p><h4 id="基础语法-5"><a href="#基础语法-5" class="headerlink" title="基础语法"></a>基础语法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root<span class="meta">@lion</span> ~]# ps</span><br><span class="line">  PID TTY          TIME CMD</span><br><span class="line"> <span class="number">1793</span> pts/<span class="number">0</span>    <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> bash</span><br><span class="line"> <span class="number">4756</span> pts/<span class="number">0</span>    <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> ps</span><br><span class="line"> </span><br><span class="line"> PID：进程号，每个进程都有唯一的进程号</span><br><span class="line"> TTY：进程运行所在的终端</span><br><span class="line"> TIME：进程运行时间</span><br><span class="line"> CMD：产生这个进程的程序名，如果在进程列表中看到有好几行都是同样的程序名，那么就是同样的程序产生了不止一个进程</span><br></pre></td></tr></table></figure><h4 id="常用参数-5"><a href="#常用参数-5" class="headerlink" title="常用参数"></a>常用参数</h4><ul><li><code>-ef</code> 列出所有进程;</li><li><code>-efH</code> 以乔木状列举出所有进程;</li><li><code>-u</code> 列出此用户运行的进程;</li><li><code>-aux</code> 通过 <code>CPU</code> 和内存使用来过滤进程 <code>ps -aux | less</code> ;</li><li><code>-aux --sort -pcpu</code> 按 <code>CPU</code> 使用降序排列， <code>-aux --sort -pmem</code> 表示按内存使用降序排列;</li><li><code>-axjf</code> 以树形结构显示进程， <code>ps -axjf</code> 它和 <code>pstree</code> 效果类似。</li></ul><h3 id="top"><a href="#top" class="headerlink" title="top"></a>top</h3><p>获取进程的动态列表。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">top - <span class="number">07</span>:<span class="number">20</span>:<span class="number">07</span> up <span class="number">25</span> days, <span class="number">10</span>:<span class="number">41</span>,  <span class="number">1</span> user,  load average: <span class="number">0.30</span>, <span class="number">0.10</span>, <span class="number">0.07</span></span><br><span class="line">Tasks:  <span class="number">67</span> total,   <span class="number">1</span> running,  <span class="number">66</span> sleeping,   <span class="number">0</span> stopped,   <span class="number">0</span> zombie</span><br><span class="line">%Cpu(s):  <span class="number">0.7</span> us,  <span class="number">0.3</span> sy,  <span class="number">0.0</span> ni, <span class="number">99.0</span> id,  <span class="number">0.0</span> wa,  <span class="number">0.0</span> hi,  <span class="number">0.0</span> si,  <span class="number">0.0</span> st</span><br><span class="line">KiB Mem :  <span class="number">1882072</span> total,   <span class="number">552148</span> free,   <span class="number">101048</span> used,  <span class="number">1228876</span> buff/cache</span><br><span class="line">KiB Swap:        <span class="number">0</span> total,        <span class="number">0</span> free,        <span class="number">0</span> used.  <span class="number">1594080</span> avail Mem </span><br><span class="line"></span><br><span class="line">  PID USER      PR  NI    VIRT    RES    SHR S %CPU %MEM     TIME+ COMMAND                                                                                                       </span><br><span class="line">  <span class="number">956</span> root      <span class="number">10</span> -<span class="number">10</span>  <span class="number">133964</span>  <span class="number">15848</span>  <span class="number">10240</span> S  <span class="number">0.7</span>  <span class="number">0.8</span> <span class="number">263</span>:<span class="number">13.01</span> AliYunDun                                                                                                     </span><br><span class="line">    <span class="number">1</span> root      <span class="number">20</span>   <span class="number">0</span>   <span class="number">51644</span>   <span class="number">3664</span>   <span class="number">2400</span> S  <span class="number">0.0</span>  <span class="number">0.2</span>   <span class="number">3</span>:<span class="number">23.63</span> systemd                                                                                                       </span><br><span class="line">    <span class="number">2</span> root      <span class="number">20</span>   <span class="number">0</span>       <span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span> S  <span class="number">0.0</span>  <span class="number">0.0</span>   <span class="number">0</span>:<span class="number">00.05</span> kthreadd                                                                                                      </span><br><span class="line">    <span class="number">4</span> root       <span class="number">0</span> -<span class="number">20</span>       <span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span> S  <span class="number">0.0</span>  <span class="number">0.0</span>   <span class="number">0</span>:<span class="number">00.00</span> kworker/<span class="number">0</span>:0H    </span><br></pre></td></tr></table></figure><ul><li><code>top - 07:20:07 up 25 days, 10:41, 1 user, load average: 0.30, 0.10, 0.07</code> 相当 <code>w</code> 命令的第一行的信息。</li><li>展示的这些进程是按照使用处理器 <code>%CPU</code> 的使用率来排序的。</li></ul><h3 id="kill"><a href="#kill" class="headerlink" title="kill"></a>kill</h3><p>结束一个进程， <code>kill + PID</code> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kill <span class="number">956</span> # 结束进程号为<span class="number">956</span>的进程</span><br><span class="line">kill <span class="number">956</span> <span class="number">957</span> # 结束多个进程</span><br><span class="line">kill -<span class="number">9</span> <span class="number">7291</span> # 强制结束进程</span><br></pre></td></tr></table></figure><h2 id="管理进程"><a href="#管理进程" class="headerlink" title="管理进程"></a>管理进程</h2><h3 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h3><p>主要是切换进程的状态。我们先了解下 <code>Linux</code> 下进程的五种状态：</p><ol><li><p>状态码 <code>R</code> ：表示正在运行的状态；</p></li><li><p>状态码 <code>S</code> ：表示中断（休眠中，受阻，当某个条件形成后或接受到信号时，则脱离该状态）；</p></li><li><p>状态码 <code>D</code> ：表示不可中断（进程不响应系统异步信号，即使用 kill 命令也不能使其中断）；</p></li><li><p>状态码 <code>Z</code> ：表示僵死（进程已终止，但进程描述符依然存在，直到父进程调用 <code>wait4()</code> 系统函数后将进程释放）；</p></li><li><p>状态码 <code>T</code> ：表示停止（进程收到 <code>SIGSTOP</code> 、 <code>SIGSTP</code> 、 <code>SIGTIN</code> 、 <code>SIGTOU</code> 等停止信号后停止运行）。</p></li></ol><h3 id="前台进程-amp-后台进程"><a href="#前台进程-amp-后台进程" class="headerlink" title="前台进程 &amp; 后台进程"></a>前台进程 &amp; 后台进程</h3><p>默认情况下，用户创建的进程都是前台进程，前台进程从键盘读取数据，并把处理结果输出到显示器。例如运行 <code>top</code> 命令，这就是一个一直运行的前台进程。</p><p>后台进程的优点是不必等待程序运行结束，就可以输入其它命令。在需要执行的命令后面添加 <code>&amp;</code> 符号，就表示启动一个后台进程。</p><h3 id="amp"><a href="#amp" class="headerlink" title="&amp;"></a>&amp;</h3><p>启动后台进程，它的缺点是后台进程与终端相关联，一旦关闭终端，进程就自动结束了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp name.csv name-copy.csv &amp;</span><br></pre></td></tr></table></figure><h3 id="nohup"><a href="#nohup" class="headerlink" title="nohup"></a>nohup</h3><p>使进程不受挂断（关闭终端等动作）的影响。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup cp name.csv name-copy.csv</span><br></pre></td></tr></table></figure><p><code>nohup</code> 命令也可以和 <code>&amp;</code> 结合使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup cp name.csv name-copy.csv &amp;</span><br></pre></td></tr></table></figure><h3 id="bg"><a href="#bg" class="headerlink" title="bg"></a>bg</h3><p>使一个 “ 后台暂停运行 “ 的进程，状态改为 “ 后台运行 “。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bg %<span class="number">1</span> # 不加任何参数的情况下，bg命令会默认作用于最近的一个后台进程，如果添加参数则会作用于指定标号的进程</span><br></pre></td></tr></table></figure><p>实际案例 1：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 执行 grep -r <span class="string">&quot;log&quot;</span> / &gt; grep_log <span class="number">2</span>&gt;&amp;<span class="number">1</span> 命令启动一个前台进程，并且忘记添加 &amp; 符号</span><br><span class="line"><span class="number">2.</span> ctrl + z 使进程状态转为后台暂停</span><br><span class="line"><span class="number">3.</span> 执行 bg 将命令转为后台运行</span><br></pre></td></tr></table></figure><p>实际案例 2：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">前端开发时我们经常会执行 yarn start 启动项目</span><br><span class="line">此时我们执行 ctrl + z 先使其暂停</span><br><span class="line">然后执行 bg 使其转为后台运行</span><br><span class="line">这样当前终端就空闲出来可以干其它事情了，如果想要唤醒它就使用 fg 命令即可（后面会讲）</span><br></pre></td></tr></table></figure><h3 id="jobs"><a href="#jobs" class="headerlink" title="jobs"></a>jobs</h3><p>显示当前终端后台进程状态。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root<span class="meta">@lion</span> ~]# jobs</span><br><span class="line">[<span class="number">1</span>]+  Stopped                 top</span><br><span class="line">[<span class="number">2</span>]-  Running                 grep --color=auto -r <span class="string">&quot;log&quot;</span> / &gt; grep_log <span class="number">2</span>&gt;&amp;<span class="number">1</span> &amp;</span><br></pre></td></tr></table></figure><h3 id="fg"><a href="#fg" class="headerlink" title="fg"></a>fg</h3><p><code>fg</code> 使进程转为前台运行，用法和 <code>bg</code> 命令类似。</p><p>我们用一张图来表示前后台进程切换：</p><p><img src="/../../../../img/blog/1eb7f39e04805b5c10e07310cc252ac7_MD5.jpg" alt="图片"></p><p>我们可以使程序在后台运行，成为后台进程，这样在当前终端中我们就可以做其他事情了，而不必等待此进程运行结束。</p><h2 id="守护进程"><a href="#守护进程" class="headerlink" title="守护进程"></a>守护进程</h2><p>一个运行起来的程序被称为进程。在 <code>Linux</code> 中有些进程是特殊的，它不与任何进程关联，不论用户的身份如何，都在后台运行，这些进程的父进程是 <code>PID</code> 为 1 的进程， <code>PID</code> 为 1 的进程只在系统关闭时才会被销毁。它们会在后台一直运行等待分配工作。我们将这类进程称之为守护进程 <code>daemon</code> 。</p><p>守护进程的名字通常会在最后有一个 <code>d</code> ，表示 <code>daemon</code> 守护的意思，例如 <code>systemd</code> 、<code>httpd</code> 。</p><h3 id="systemd"><a href="#systemd" class="headerlink" title="systemd"></a>systemd</h3><p><code>systemd</code> 是一个 <code>Linux</code> 系统基础组件的集合，提供了一个系统和服务管理器，运行为 <code>PID 1</code> 并负责启动其它程序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root<span class="meta">@lion</span> ~]# ps -aux</span><br><span class="line">USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND</span><br><span class="line">root         <span class="number">1</span>  <span class="number">0.0</span>  <span class="number">0.2</span>  <span class="number">51648</span>  <span class="number">3852</span> ?        Ss   Feb01   <span class="number">1</span>:<span class="number">50</span> /usr/lib/systemd/systemd --switched-root --system --deserialize <span class="number">22</span></span><br></pre></td></tr></table></figure><p>通过命令也可以看到 <code>PID</code> 为 1 的进程就是 <code>systemd</code> 的系统进程。</p><p><code>systemd</code> 常用命令（它是一组命令的集合）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">systemctl start nginx # 启动服务</span><br><span class="line">systemctl stop nginx # 停止服务</span><br><span class="line">systemctl restart nginx # 重启服务</span><br><span class="line">systemctl status nginx # 查看服务状态</span><br><span class="line">systemctl reload nginx # 重载配置文件(不停止服务的情况)</span><br><span class="line">systemctl enable nginx # 开机自动启动服务</span><br><span class="line">systemctl disable nginx # 开机不自动启动服务</span><br><span class="line">systemctl is-enabled nginx # 查看服务是否开机自动启动</span><br><span class="line">systemctl list-unit-files --type=service # 查看各个级别下服务的启动和禁用情况</span><br></pre></td></tr></table></figure><h2 id="文件压缩解压"><a href="#文件压缩解压" class="headerlink" title="文件压缩解压"></a>文件压缩解压</h2><ul><li>打包：是将多个文件变成一个总的文件，它的学名叫存档、归档。</li><li>压缩：是将一个大文件（通常指归档）压缩变成一个小文件。</li></ul><p>我们常常使用 <code>tar</code> 将多个文件归档为一个总的文件，称为 <code>archive</code> 。然后用 <code>gzip</code> 或 <code>bzip2</code> 命令将 <code>archive</code> 压缩为更小的文件。</p><p><img src="/../../../../img/blog/00e8bfd088aed9124a583e231a24bb99_MD5.jpg" alt="图片"></p><h3 id="tar"><a href="#tar" class="headerlink" title="tar"></a>tar</h3><p>创建一个 <code>tar</code> 归档。</p><h4 id="基础用法"><a href="#基础用法" class="headerlink" title="基础用法"></a>基础用法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tar -cvf sort.tar sort/ # 将sort文件夹归档为sort.tar</span><br><span class="line">tar -cvf archive.tar file1 file2 file3 # 将 file1 file2 file3 归档为archive.tar</span><br></pre></td></tr></table></figure><h4 id="常用参数-6"><a href="#常用参数-6" class="headerlink" title="常用参数"></a>常用参数</h4><ul><li><code>-cvf</code> 表示 <code>create</code>（创建）+ <code>verbose</code>（细节）+ <code>file</code>（文件），创建归档文件并显示操作细节；</li><li><code>-tf</code> 显示归档里的内容，并不解开归档；</li><li><code>-rvf</code> 追加文件到归档， <code>tar -rvf archive.tar file.txt</code> ；</li><li><code>-xvf</code> 解开归档， <code>tar -xvf archive.tar</code> 。</li></ul><h3 id="gzip-x2F-gunzip"><a href="#gzip-x2F-gunzip" class="headerlink" title="gzip &#x2F; gunzip"></a>gzip &#x2F; gunzip</h3><p>“ 压缩&#x2F;解压 “ 归档，默认用 <code>gzip</code> 命令，压缩后的文件后缀名为 <code>.tar.gz</code> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gzip archive.tar # 压缩</span><br><span class="line">gunzip archive.tar.gz # 解压</span><br></pre></td></tr></table></figure><h3 id="tar-归档-压缩"><a href="#tar-归档-压缩" class="headerlink" title="tar 归档 + 压缩"></a>tar 归档 + 压缩</h3><p>可以用 <code>tar</code> 命令同时完成归档和压缩的操作，就是给 <code>tar</code> 命令多加一个选项参数，使之完成归档操作后，还是调用 <code>gzip</code> 或 <code>bzip2</code> 命令来完成压缩操作。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tar -zcvf archive.tar.gz archive/ # 将archive文件夹归档并压缩</span><br><span class="line">tar -zxvf archive.tar.gz # 将archive.tar.gz归档压缩文件解压</span><br></pre></td></tr></table></figure><h3 id="zcat、zless、zmore"><a href="#zcat、zless、zmore" class="headerlink" title="zcat、zless、zmore"></a>zcat、zless、zmore</h3><p>之前讲过使用 <code>cat less more</code> 可以查看文件内容，但是压缩文件的内容是不能使用这些命令进行查看的，而要使用 <code>zcat、zless、zmore</code> 进行查看。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zcat archive.tar.gz</span><br></pre></td></tr></table></figure><h3 id="zip-x2F-unzip"><a href="#zip-x2F-unzip" class="headerlink" title="zip&#x2F;unzip"></a>zip&#x2F;unzip</h3><p>“ 压缩&#x2F;解压 “ <code>zip</code> 文件（ <code>zip</code> 压缩文件一般来自 <code>windows</code> 操作系统）。</p><h4 id="命令安装"><a href="#命令安装" class="headerlink" title="命令安装"></a>命令安装</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># Red Hat 一族中的安装方式</span><br><span class="line">yum install zip </span><br><span class="line">yum install unzip </span><br></pre></td></tr></table></figure><h4 id="基础用法-1"><a href="#基础用法-1" class="headerlink" title="基础用法"></a>基础用法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">unzip archive.zip # 解压 .zip 文件</span><br><span class="line">unzip -l archive.zip # 不解开 .zip 文件，只看其中内容</span><br><span class="line"></span><br><span class="line">zip -r sort.zip sort/ # 将sort文件夹压缩为 sort.zip，其中-r表示递归</span><br></pre></td></tr></table></figure><h2 id="编译安装软件"><a href="#编译安装软件" class="headerlink" title="编译安装软件"></a>编译安装软件</h2><p>之前我们学会了使用 <code>yum</code> 命令进行软件安装，如果碰到 <code>yum</code> 仓库中没有的软件，我们就需要会更高级的软件安装 “ 源码编译安装 “。</p><h3 id="编译安装"><a href="#编译安装" class="headerlink" title="编译安装"></a>编译安装</h3><p>简单来说，编译就是将程序的源代码转换成可执行文件的过程。大多数 <code>Linux</code> 的程序都是开放源码的，可以编译成适合我们的电脑和操纵系统属性的可执行文件。</p><p>基本步骤如下：</p><ol><li><p>下载源代码</p></li><li><p>解压压缩包</p></li><li><p>配置</p></li><li><p>编译</p></li><li><p>安装</p></li></ol><h4 id="实际案例"><a href="#实际案例" class="headerlink" title="实际案例"></a>实际案例</h4><h5 id="1、下载"><a href="#1、下载" class="headerlink" title="1、下载"></a>1、下载</h5><p>我们来编译安装 <code>htop</code> 软件，首先在它的官网下载源码：<a href="https://bintray.com/htop/source/htop#files">https://bintray.com/htop/source/htop#files</a></p><p>下载好的源码在本机电脑上使用如下命令同步到服务器上：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">scp 文件名 用户名@服务器ip:目标路径</span><br><span class="line"></span><br><span class="line">scp ~/Desktop/htop-<span class="number">3.0</span><span class="number">.0</span>.tar.gz root@<span class="number">121.42</span><span class="number">.11</span><span class="number">.34</span>:.</span><br></pre></td></tr></table></figure><p>也可以使用 <code>wegt</code> 进行下载：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wegt+下载地址</span><br><span class="line"></span><br><span class="line">wegt https:<span class="comment">//bintray.com/htop/source/download_file?file_path=htop-3.0.0.tar.gz</span></span><br></pre></td></tr></table></figure><h5 id="2、解压文件"><a href="#2、解压文件" class="headerlink" title="2、解压文件"></a>2、解压文件</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf htop-<span class="number">3.0</span><span class="number">.0</span>.tar.gz # 解压</span><br><span class="line"></span><br><span class="line">cd htop-<span class="number">3.0</span><span class="number">.0</span> # 进入目录</span><br></pre></td></tr></table></figure><h5 id="3、配置"><a href="#3、配置" class="headerlink" title="3、配置"></a>3、配置</h5><p>执行 <code>./configure</code> ，它会分析你的电脑去确认编译所需的工具是否都已经安装了。</p><h5 id="4、编译"><a href="#4、编译" class="headerlink" title="4、编译"></a>4、编译</h5><p>执行 <code>make</code> 命令</p><h5 id="5、安装"><a href="#5、安装" class="headerlink" title="5、安装"></a>5、安装</h5><p>执行 <code>make install</code> 命令，安装完成后执行 <code>ls /usr/local/bin/</code> 查看是否有 <code>htop</code> 命令。如果有就可以执行 <code>htop</code> 命令查看系统进程了。</p><h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><h3 id="ifconfig"><a href="#ifconfig" class="headerlink" title="ifconfig"></a>ifconfig</h3><p>查看 <code>ip</code> 网络相关信息，如果命令不存在的话， 执行命令 <code>yum install net-tools</code> 安装。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[root<span class="meta">@lion</span> ~]# ifconfig</span><br><span class="line"></span><br><span class="line">eth0: flags=<span class="number">4163</span>&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu <span class="number">1500</span></span><br><span class="line">        inet <span class="number">172.31</span><span class="number">.24</span><span class="number">.78</span>  netmask <span class="number">255.255</span><span class="number">.240</span><span class="number">.0</span>  broadcast <span class="number">172.31</span><span class="number">.31</span><span class="number">.255</span></span><br><span class="line">        ether <span class="number">00</span>:<span class="number">16</span>:3e:<span class="number">04</span>:9c:cd  txqueuelen <span class="number">1000</span>  (Ethernet)</span><br><span class="line">        RX packets <span class="number">1592318</span>  bytes <span class="number">183722250</span> (<span class="number">175.2</span> MiB)</span><br><span class="line">        RX errors <span class="number">0</span>  dropped <span class="number">0</span>  overruns <span class="number">0</span>  frame <span class="number">0</span></span><br><span class="line">        TX packets <span class="number">1539361</span>  bytes <span class="number">154044090</span> (<span class="number">146.9</span> MiB)</span><br><span class="line">        TX errors <span class="number">0</span>  dropped <span class="number">0</span> overruns <span class="number">0</span>  carrier <span class="number">0</span>  collisions <span class="number">0</span></span><br><span class="line"></span><br><span class="line">lo: flags=<span class="number">73</span>&lt;UP,LOOPBACK,RUNNING&gt;  mtu <span class="number">65536</span></span><br><span class="line">        inet <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>  netmask <span class="number">255.0</span><span class="number">.0</span><span class="number">.0</span></span><br><span class="line">        loop  txqueuelen <span class="number">1000</span>  (Local Loopback)</span><br><span class="line">        RX packets <span class="number">0</span>  bytes <span class="number">0</span> (<span class="number">0.0</span> B)</span><br><span class="line">        RX errors <span class="number">0</span>  dropped <span class="number">0</span>  overruns <span class="number">0</span>  frame <span class="number">0</span></span><br><span class="line">        TX packets <span class="number">0</span>  bytes <span class="number">0</span> (<span class="number">0.0</span> B)</span><br><span class="line">        TX errors <span class="number">0</span>  dropped <span class="number">0</span> overruns <span class="number">0</span>  carrier <span class="number">0</span>  collisions <span class="number">0</span></span><br></pre></td></tr></table></figure><p>参数解析：</p><ul><li><code>eth0</code> 对应有线连接（对应你的有线网卡），就是用网线来连接的上网。<code>eth</code> 是 <code>Ethernet</code> 的缩写，表示 “ 以太网 “。有些电脑可能同时有好几条网线连着，例如服务器，那么除了 <code>eht0</code> ，你还会看到 <code>eth1</code> 、 <code>eth2</code> 等。</li><li><code>lo</code> 表示本地回环（ <code>Local Loopback</code> 的缩写，对应一个虚拟网卡）可以看到它的 <code>ip</code> 地址是 <code>127.0.0.1</code> 。每台电脑都应该有这个接口，因为它对应着 “ 连向自己的链接 “。这也是被称之为 “ 本地回环 “ 的原因。所有经由这个接口发送的东西都会回到你自己的电脑。看起来好像并没有什么用，但有时为了某些缘故，我们需要连接自己。例如用来测试一个网络程序，但又不想让局域网或外网的用户查看，只能在此台主机上运行和查看所有的网络接口。例如在我们启动一个前端工程时，在浏览器输入 <code>127.0.0.1:3000</code> 启动项目就能查看到自己的 <code>web</code> 网站，并且它只有你能看到。</li><li><code>wlan0</code> 表示无线局域网（上面案例并未展示）。</li></ul><h3 id="host"><a href="#host" class="headerlink" title="host"></a>host</h3><p><code>ip</code> 地址和主机名的互相转换。</p><h4 id="软件安装"><a href="#软件安装" class="headerlink" title="软件安装"></a>软件安装</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install bind-utils</span><br></pre></td></tr></table></figure><h4 id="基础用法-2"><a href="#基础用法-2" class="headerlink" title="基础用法"></a>基础用法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root<span class="meta">@lion</span> ~]# host github.com</span><br><span class="line">baidu.com has address <span class="number">13.229</span><span class="number">.188</span><span class="number">.59</span></span><br><span class="line"> </span><br><span class="line">[root<span class="meta">@lion</span> ~]# host <span class="number">13.229</span><span class="number">.188</span><span class="number">.59</span></span><br><span class="line"><span class="number">59.188</span><span class="number">.229</span><span class="number">.13</span>.in-addr.arpa domain name pointer ec2-<span class="number">13</span>-<span class="number">229</span>-<span class="number">188</span>-<span class="number">59.</span>ap-southeast-<span class="number">1.</span>compute.amazonaws.com.</span><br></pre></td></tr></table></figure><h3 id="ssh-连接远程服务器"><a href="#ssh-连接远程服务器" class="headerlink" title="ssh 连接远程服务器"></a>ssh 连接远程服务器</h3><p>通过非对称加密以及对称加密的方式（同 <code>HTTPS</code> 安全连接原理相似）连接到远端服务器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ssh 用户<span class="meta">@ip</span>:port</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>、ssh root@<span class="number">172.20</span><span class="number">.10</span><span class="number">.1</span>:<span class="number">22</span> # 端口号可以省略不写，默认是<span class="number">22</span>端口</span><br><span class="line"><span class="number">2</span>、输入连接密码后就可以操作远端服务器了</span><br></pre></td></tr></table></figure><h4 id="配置-ssh"><a href="#配置-ssh" class="headerlink" title="配置 ssh"></a>配置 ssh</h4><p><code>config</code> 文件可以配置 <code>ssh</code> ，方便批量管理多个 <code>ssh</code> 连接。</p><p>配置文件分为以下几种：</p><ul><li>全局 <code>ssh</code> 服务端的配置：<code>/etc/ssh/sshd_config</code> ；</li><li>全局 <code>ssh</code> 客户端的配置：<code>/etc/ssh/ssh_config</code>（很少修改）；</li><li>当前用户 <code>ssh</code> 客户端的配置：<code>~/.ssh/config</code> 。</li></ul><p>【服务端 <code>config</code> 文件的常用配置参数】</p><table><thead><tr><th>服务端 config 参数</th><th>作用</th></tr></thead><tbody><tr><td>Port</td><td>sshd 服务端口号（默认是 22）</td></tr><tr><td>PermitRootLogin</td><td>是否允许以 root 用户身份登录（默认是可以）</td></tr><tr><td>PasswordAuthentication</td><td>是否允许密码验证登录（默认是可以）</td></tr><tr><td>PubkeyAuthentication</td><td>是否允许公钥验证登录（默认是可以）</td></tr><tr><td>PermitEmptyPasswords</td><td>是否允许空密码登录（不安全，默认不可以）</td></tr></tbody></table><p>[注意] 修改完服务端配置文件需要重启服务 <code>systemctl restart sshd</code></p><p>【客户端 <code>config</code> 文件的常用配置参数】</p><table><thead><tr><th>客户端 config 参数</th><th>作用</th></tr></thead><tbody><tr><td>Host</td><td>别名</td></tr><tr><td>HostName</td><td>远程主机名（或 IP 地址）</td></tr><tr><td>Port</td><td>连接到远程主机的端口</td></tr><tr><td>User</td><td>用户名</td></tr></tbody></table><p>配置当前用户的 <code>config</code> ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 创建config</span><br><span class="line">vim ~/.ssh/config</span><br><span class="line"></span><br><span class="line"># 填写一下内容</span><br><span class="line">Host lion # 别名</span><br><span class="line"> HostName <span class="number">172.</span>x.x.x # ip 地址</span><br><span class="line">  Port <span class="number">22</span> # 端口</span><br><span class="line">  User root # 用户</span><br></pre></td></tr></table></figure><p>这样配置完成后，下次登录时，可以这样登录 <code>ssh lion</code> 会自动识别为 <code>root</code> 用户。</p><p>[注意] 这段配置不是在服务器上，而是你自己的机器上，它仅仅是设置了一个别名。</p><h4 id="免密登录"><a href="#免密登录" class="headerlink" title="免密登录"></a>免密登录</h4><p><code>ssh</code> 登录分两种，一种是基于口令（账号密码），另外一种是基于密钥的方式。</p><p>基于口令，就是每次登录输入账号和密码，显然这样做是比较麻烦的，今天主要学习如何基于密钥实现免密登录。</p><h5 id="基于密钥验证原理"><a href="#基于密钥验证原理" class="headerlink" title="基于密钥验证原理"></a>基于密钥验证原理</h5><p>客户机生成密钥对（公钥和私钥），把公钥上传到服务器，每次登录会与服务器的公钥进行比较，这种验证登录的方法更加安全，也被称为 “ 公钥验证登录 “。</p><h5 id="具体实现步骤"><a href="#具体实现步骤" class="headerlink" title="具体实现步骤"></a>具体实现步骤</h5><p>1、在客户机中生成密钥对（公钥和私钥） <code>ssh-keygen</code>（默认使用 RSA 非对称加密算法）</p><p>运行完 <code>ssh-keygen</code> 会在 <code>~/.ssh/</code> 目录下，生成两个文件：</p><ul><li><code>id_rsa.pub</code> ：公钥</li><li><code>id_rsa</code> ：私钥</li></ul><p>2、把客户机的公钥传送到服务</p><p>执行 <code>ssh-copy-id root@172.x.x.x</code>（<code>ssh-copy-id</code> 它会把客户机的公钥追加到服务器 <code>~/.ssh/authorized_keys</code> 的文件中）。</p><p>执行完成后，运行 <code>ssh root@172.x.x.x</code> 就可以实现免密登录服务器了。</p><p>配合上面设置好的别名，直接执行 <code>ssh lion</code> 就可以登录，是不是非常方便。</p><h3 id="wget"><a href="#wget" class="headerlink" title="wget"></a>wget</h3><p>可以使我们直接从终端控制台下载文件，只需要给出文件的 HTTP 或 FTP 地址。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wget [参数][URL地址]</span><br><span class="line"></span><br><span class="line">wget http:<span class="comment">//www.minjieren.com/wordpress-3.1-zh_CN.zip</span></span><br></pre></td></tr></table></figure><p><code>wget</code> 非常稳定，如果是由于网络原因下载失败， <code>wget</code> 会不断尝试，直到整个文件下载完毕。</p><h4 id="常用参数-7"><a href="#常用参数-7" class="headerlink" title="常用参数"></a>常用参数</h4><ul><li><code>-c</code> 继续中断的下载。</li></ul><h2 id="备份"><a href="#备份" class="headerlink" title="备份"></a>备份</h2><h3 id="scp"><a href="#scp" class="headerlink" title="scp"></a>scp</h3><p>它是 <code>Secure Copy</code> 的缩写，表示安全拷贝。<code>scp</code> 可以使我们通过网络，把文件从一台电脑拷贝到另一台电脑。</p><p><code>scp</code> 是基于 <code>ssh</code> 的原理来运作的， <code>ssh</code> 会在两台通过网络连接的电脑之间创建一条安全通信的管道， <code>scp</code> 就利用这条管道安全地拷贝文件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp source_file destination_file # source_file 表示源文件，destination_file 表示目标文件</span><br></pre></td></tr></table></figure><p>其中 <code>source_file</code> 和 <code>destination_file</code> 都可以这样表示：<code>user@ip:file_name</code> ， <code>user</code> 是登录名， <code>ip</code> 是域名或 <code>ip</code> 地址。<code>file_name</code> 是文件路径。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scp file.txt root@<span class="number">192.168</span><span class="number">.1</span><span class="number">.5</span>:/root # 表示把我的电脑中当前文件夹下的 file.txt 文件拷贝到远程电脑</span><br><span class="line">scp root@<span class="number">192.168</span><span class="number">.1</span><span class="number">.5</span>:/root/file.txt file.txt # 表示把远程电脑上的 file.txt 文件拷贝到本机</span><br></pre></td></tr></table></figure><h3 id="rsync"><a href="#rsync" class="headerlink" title="rsync"></a>rsync</h3><p><code>rsync</code> 命令主要用于远程同步文件。它可以同步两个目录，不管它们是否处于同一台电脑。它应该是最常用于 “ 增量备份 “ 的命令了。它就是智能版的 <code>scp</code> 命令。</p><h4 id="软件安装-1"><a href="#软件安装-1" class="headerlink" title="软件安装"></a>软件安装</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install rsync</span><br></pre></td></tr></table></figure><h4 id="基础用法-3"><a href="#基础用法-3" class="headerlink" title="基础用法"></a>基础用法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rsync -arv Images/ backups/ # 将Images 目录下的所有文件备份到 backups 目录下</span><br><span class="line">rsync -arv Images/ root@<span class="number">192.</span>x.x.x:backups/ # 同步到服务器的backups目录下</span><br></pre></td></tr></table></figure><h4 id="常用参数-8"><a href="#常用参数-8" class="headerlink" title="常用参数"></a>常用参数</h4><ul><li><code>-a</code> 保留文件的所有信息，包括权限，修改日期等；</li><li><code>-r</code> 递归调用，表示子目录的所有文件也都包括；</li><li><code>-v</code> 冗余模式，输出详细操作信息。</li></ul><p>默认地， <code>rsync</code> 在同步时并不会删除目标目录的文件，例如你在源目录中删除一个文件，但是用 <code>rsync</code> 同步时，它并不会删除同步目录中的相同文件。如果向删除也可以这么做：<code>rsync -arv --delete Images/ backups/</code> 。</p><h2 id="系统"><a href="#系统" class="headerlink" title="系统"></a>系统</h2><h3 id="halt"><a href="#halt" class="headerlink" title="halt"></a>halt</h3><p>关闭系统，需要 <code>root</code> 身份。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">halt</span><br></pre></td></tr></table></figure><h3 id="reboot"><a href="#reboot" class="headerlink" title="reboot"></a>reboot</h3><p>重启系统，需要 <code>root</code> 身份。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reboot</span><br></pre></td></tr></table></figure><h3 id="poweroff"><a href="#poweroff" class="headerlink" title="poweroff"></a>poweroff</h3><p>直接运行即可关机，不需要 <code>root</code> 身份。</p>]]></content>
      
      
      <categories>
          
          <category> 应用 </category>
          
          <category> 操作系统 </category>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>解决方案</title>
      <link href="/posts/%E5%BA%94%E7%94%A8/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Docker/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88.html"/>
      <url>/posts/%E5%BA%94%E7%94%A8/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Docker/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88.html</url>
      
        <content type="html"><![CDATA[<h1 id="Docker-内程序如何访问宿主机的端口"><a href="#Docker-内程序如何访问宿主机的端口" class="headerlink" title="Docker 内程序如何访问宿主机的端口"></a>Docker 内程序如何访问宿主机的端口</h1><p>请在你的 <code>docker-compose.yml</code> 的服务中加上</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">extra_hosts:</span>  </span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;host.docker.internal:host-gateway&quot;</span></span><br></pre></td></tr></table></figure><p>例如</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3.5&#x27;</span>  </span><br><span class="line">  </span><br><span class="line"><span class="attr">services:</span>  </span><br><span class="line">  <span class="attr">hello-api:</span>  </span><br><span class="line">    <span class="attr">build:</span>  </span><br><span class="line">      <span class="attr">context:</span> <span class="string">.</span>  </span><br><span class="line">      <span class="attr">dockerfile:</span> <span class="string">hello/Dockerfile</span>  </span><br><span class="line">    <span class="attr">environment:</span>  </span><br><span class="line">      <span class="bullet">-</span> <span class="string">TZ=Asia/Shanghai</span>  </span><br><span class="line">    <span class="attr">privileged:</span> <span class="literal">true</span>  </span><br><span class="line">    <span class="attr">volumes:</span>  </span><br><span class="line">      <span class="bullet">-</span> <span class="string">./etc:/app/etc</span>  </span><br><span class="line">    <span class="attr">ports:</span>  </span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;8888:8888&quot;</span>  </span><br><span class="line">    <span class="attr">stdin_open:</span> <span class="literal">true</span>  </span><br><span class="line">    <span class="attr">tty:</span> <span class="literal">true</span>  </span><br><span class="line">    <span class="attr">extra_hosts:</span>  </span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;host.docker.internal:host-gateway&quot;</span></span><br></pre></td></tr></table></figure><p>来源：<a href="https://stackoverflow.com/questions/70505750/lookup-host-docker-internal-no-such-host">mongodb - lookup host.docker.internal: no such host - Stack Overflow</a></p>]]></content>
      
      
      <categories>
          
          <category> 应用 </category>
          
          <category> 操作系统 </category>
          
          <category> Docker </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>资源</title>
      <link href="/posts/%E5%BD%92%E6%A1%A3/%E8%B5%84%E6%BA%90.html"/>
      <url>/posts/%E5%BD%92%E6%A1%A3/%E8%B5%84%E6%BA%90.html</url>
      
        <content type="html"><![CDATA[<h1 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h1><ul><li><a href="https://t.bilibili.com/818168768566919224">电锯人黑白</a></li></ul><h1 id="视频制作"><a href="#视频制作" class="headerlink" title="视频制作"></a>视频制作</h1><ul><li><a href="https://www.lookae.com/">LookAE.com-大众脸影视后期特效</a></li></ul><h1 id="推荐技术-UP-主"><a href="#推荐技术-UP-主" class="headerlink" title="推荐技术 UP 主"></a>推荐技术 UP 主</h1><ul><li>《深入理解计算机系统原理 CSAPP》 <a href="https://space.bilibili.com/4564101/">yaaangmin</a></li><li>C++ 协程 <a href="https://space.bilibili.com/35186937/?spm_id_from=333.999.0.0">等疾风</a></li><li>数据库论文 <a href="https://space.bilibili.com/629605267/">Gauss松鼠会</a></li><li>操作系统 <a href="https://space.bilibili.com/202224425/">绿导师原谅你了</a> 南大老师</li><li>分布式系统 <a href="https://space.bilibili.com/474662253?spm_id_from=333.337.search-card.all.click">算法主义</a> 南大老师</li><li>算法与数据结构 <a href="https://space.bilibili.com/7836741/">大雪菜</a></li><li>LeetCode 周赛 <a href="https://space.bilibili.com/206214/">灵茶山艾府</a></li><li>分布式数据库 <a href="https://space.bilibili.com/30933812/">木鸟杂记</a></li><li>Linux 网络编程 <a href="https://space.bilibili.com/319250589/">jaydenwen123</a></li><li>levelDB、存储、分布式论文 <a href="https://space.bilibili.com/1324259795?spm_id_from=333.337.0.0">硬核课堂</a></li><li>C++11&#x2F;kotlin <a href="https://space.bilibili.com/28615855?spm_id_from=333.337.search-card.all.click">bennyhuo不是算命的</a></li><li>CS 144 计算机网络 lab <a href="https://space.bilibili.com/16765968">阿苏EEer</a></li><li>编程知识 <a href="https://space.bilibili.com/372313671?spm_id_from=333.337.0.0">奇乐编程学院</a></li><li>分布式数据库 <a href="https://space.bilibili.com/61981458?spm_id_from=333.337.0.0">戌米的论文笔记</a></li></ul><h1 id="面经"><a href="#面经" class="headerlink" title="面经"></a>面经</h1><ul><li><a href="https://mp.weixin.qq.com/s/rJDkduDYl2lE0Za4f3GuHg">拿下鹅厂一面！ (qq.com)</a></li><li><a href="https://mp.weixin.qq.com/s/9YNaFDSfKJqF_vmttjHYyg">奇安信C++面经，问的很奇怪。。 (qq.com)</a><br>《【起风了，唯有努力生存】一个本硕非科班码农的后台开发之路》 <a href="https://www.yuque.com/docs/share/37b016b5-4877-4611-bb4b-08ced4e3cc89">https://www.yuque.com/docs/share/37b016b5-4877-4611-bb4b-08ced4e3cc89</a><br>《ACMer 渣铜的秋招总结与经验分享》<br><a href="https://www.yuque.com/docs/share/098ec555-c825-459b-94cd-f150cf6177c6">https://www.yuque.com/docs/share/098ec555-c825-459b-94cd-f150cf6177c6</a><br>《字节校招后端 C 面经》<br><a href="https://www.yuque.com/docs/share/d913dc0d-336c-408e-870e-0ba8fcc648c7">https://www.yuque.com/docs/share/d913dc0d-336c-408e-870e-0ba8fcc648c7</a><br>《国际化电商客户端提前批 1,2,3 面面经 (已凉)》<br><a href="https://www.yuque.com/docs/share/19c50f7e-176b-4dd9-abe9-3d0c4a29fd8e">https://www.yuque.com/docs/share/19c50f7e-176b-4dd9-abe9-3d0c4a29fd8e</a><br>《字节跳动七面面经 (提前批 3 轮，实习 4 轮)》<br><a href="https://www.yuque.com/docs/share/a5753e11-6157-4153-a9c7-af5f18dc6948">https://www.yuque.com/docs/share/a5753e11-6157-4153-a9c7-af5f18dc6948</a><br>《字节跳动 C 系统工程师春招面经》<br><a href="https://www.yuque.com/docs/share/e7bfd04c-8f94-437c-8ea6-d4841693d039">https://www.yuque.com/docs/share/e7bfd04c-8f94-437c-8ea6-d4841693d039</a><br>《字节跳动五轮技术面终于收获意向书（后端开发）》<br><a href="https://www.yuque.com/docs/share/d3337287-f5f7-43b7-b9e7-3318e5675c8c">https://www.yuque.com/docs/share/d3337287-f5f7-43b7-b9e7-3318e5675c8c</a><br> 《字节跳动教育后端春招面经》<br><a href="https://www.yuque.com/docs/share/42dfd66d-b981-4953-8284-bb301c3a15ad">https://www.yuque.com/docs/share/42dfd66d-b981-4953-8284-bb301c3a15ad</a><br>《字节跳动基础架构 C 一面二面三面》<br><a href="https://www.yuque.com/docs/share/def11acb-d36a-462d-9b13-0982be6cfafd">https://www.yuque.com/docs/share/def11acb-d36a-462d-9b13-0982be6cfafd</a><br>《字节后端提前批 - 业务研发（C）1、2、3 面面经，已意向》 <a href="https://www.yuque.com/docs/share/f5203921-d81f-404e-9495-d6d8bd06eaab">https://www.yuque.com/docs/share/f5203921-d81f-404e-9495-d6d8bd06eaab</a><br>《字节跳动后端一二三面 _ 笔经》<br><a href="https://www.yuque.com/docs/share/5ea492b4-964f-4749-9ca8-c52c4ee31074">https://www.yuque.com/docs/share/5ea492b4-964f-4749-9ca8-c52c4ee31074</a><br>《字节跳动 C 客户端一二三面 hr 面 820 已 OC》<br><a href="https://www.yuque.com/docs/share/abdb2590-2a27-4460-9805-dd5a53a7bffc">https://www.yuque.com/docs/share/abdb2590-2a27-4460-9805-dd5a53a7bffc</a><br>《字节提前批国际化电商后端一面二面三面已 oc+ 意向书》<br><a href="https://www.yuque.com/docs/share/17ca820e-76ae-498a-945b-a8bbad5f12bf">https://www.yuque.com/docs/share/17ca820e-76ae-498a-945b-a8bbad5f12bf</a><br>《字节跳动 C 后端今日头条校招》<br><a href="https://www.yuque.com/docs/share/2223791a-ee2a-480a-a046-adcd8f83e97f">https://www.yuque.com/docs/share/2223791a-ee2a-480a-a046-adcd8f83e97f</a><br>《字节跳动电商后端一二三面面经（已意向书）》<br><a href="https://www.yuque.com/docs/share/39693ebe-4eac-4b2c-999e-e515bc3e7d50">https://www.yuque.com/docs/share/39693ebe-4eac-4b2c-999e-e515bc3e7d50</a><br>《字节客户端一二三面（已 OC）》<br><a href="https://www.yuque.com/docs/share/f6d9a46a-8b42-4323-9a26-c9cd772ab154">https://www.yuque.com/docs/share/f6d9a46a-8b42-4323-9a26-c9cd772ab154</a><br>《字节教育 (上海) C++ 一二三面面经 (已 offer)》<br><a href="https://www.yuque.com/docs/share/6aba31b2-f97e-4554-98b5-d1a1390def18">https://www.yuque.com/docs/share/6aba31b2-f97e-4554-98b5-d1a1390def18</a><br>《字节技术中台后端三面面经 (许愿 hr 面)》<br><a href="https://www.yuque.com/docs/share/ccad5e61-003e-400c-94e3-c39953c0bee1">https://www.yuque.com/docs/share/ccad5e61-003e-400c-94e3-c39953c0bee1</a><br>《字节抖音后端一二三面 (已 OC)》<br><a href="https://www.yuque.com/docs/share/ee5ac591-4d9c-4c6f-bc8f-de090f0a8cfc">https://www.yuque.com/docs/share/ee5ac591-4d9c-4c6f-bc8f-de090f0a8cfc</a><br>《春招面经，许愿上岸》<br><a href="https://www.yuque.com/docs/share/3354aa55-b413-4a32-abef-bcee152623c4">https://www.yuque.com/docs/share/3354aa55-b413-4a32-abef-bcee152623c4</a><br>《2022 字节跳动提前批四轮面试 (已完结)》<br><a href="https://www.yuque.com/docs/share/bdade855-779d-4472-b117-26e8f71b348a">https://www.yuque.com/docs/share/bdade855-779d-4472-b117-26e8f71b348a</a><br>《【字节国际化电商后端】123 面》<br><a href="https://www.yuque.com/docs/share/5d68bb91-5488-4cbd-a659-66b563c39ded">https://www.yuque.com/docs/share/5d68bb91-5488-4cbd-a659-66b563c39ded</a></li></ul><h1 id="面试利器"><a href="#面试利器" class="headerlink" title="面试利器"></a>面试利器</h1><h2 id="前短时间分享了一个能在面试中增加面试官印象分的利器，也就是红黑树"><a href="#前短时间分享了一个能在面试中增加面试官印象分的利器，也就是红黑树" class="headerlink" title="前短时间分享了一个能在面试中增加面试官印象分的利器，也就是红黑树"></a>前短时间分享了一个能在面试中增加面试官印象分的利器，也就是红黑树</h2><p><a href="https://www.yuque.com/docs/share/38cc330f-1646-4fb5-96a4-5fad3acad0b3">https://www.yuque.com/docs/share/38cc330f-1646-4fb5-96a4-5fad3acad0b3</a></p><h2 id="今天再分享一个-C-开发者比较适合的一个利器，也是源码系列的研究！并且和-Web-服务器搭配一起使用很好使！"><a href="#今天再分享一个-C-开发者比较适合的一个利器，也是源码系列的研究！并且和-Web-服务器搭配一起使用很好使！" class="headerlink" title="今天再分享一个 C++ 开发者比较适合的一个利器，也是源码系列的研究！并且和 Web 服务器搭配一起使用很好使！"></a>今天再分享一个 C++ 开发者比较适合的一个利器，也是源码系列的研究！并且和 Web 服务器搭配一起使用很好使！</h2><p>要说难，还是有点难的；可绝对值得研究，如果有看过我简历的朋友可能会记得我简历上有这么一句话：对 Linux 下的 I&#x2F;O 复用有深刻理解<br>其实这里说的 IO 多路复用主要指的就是 select、poll、epoll 这几个关键字。<br>以下是文章全部内容：<a href="https://www.yuque.com/docs/share/2a66768a-2fcf-486f-bbd5-37347da69ad5">https://www.yuque.com/docs/share/2a66768a-2fcf-486f-bbd5-37347da69ad5</a></p><h2 id="前人给你留下的-15-条-CS-校招金玉良言"><a href="#前人给你留下的-15-条-CS-校招金玉良言" class="headerlink" title="前人给你留下的 15 条 CS 校招金玉良言"></a>前人给你留下的 15 条 CS 校招金玉良言</h2><p>全文链接：<a href="https://www.yuque.com/docs/share/c2834829-c84b-4c35-9fc6-948a4d06a2eb">https://www.yuque.com/docs/share/c2834829-c84b-4c35-9fc6-948a4d06a2eb</a></p><h2 id="如何设计一个高性能-x2F-高并发-x2F-高可用-x2F-高可靠-x2F-可扩展的系统"><a href="#如何设计一个高性能-x2F-高并发-x2F-高可用-x2F-高可靠-x2F-可扩展的系统" class="headerlink" title="如何设计一个高性能&#x2F;高并发&#x2F;高可用&#x2F;高可靠&#x2F;可扩展的系统?"></a>如何设计一个高性能&#x2F;高并发&#x2F;高可用&#x2F;高可靠&#x2F;可扩展的系统?</h2><p><a href="https://top.interviewguide.cn/issue/736">InterviewGuide大厂面试真题</a></p><h1 id="学习资源"><a href="#学习资源" class="headerlink" title="学习资源"></a>学习资源</h1><h2 id="从-0-教你写好一份属于自己的简历"><a href="#从-0-教你写好一份属于自己的简历" class="headerlink" title="从 0 教你写好一份属于自己的简历"></a>从 0 教你写好一份属于自己的简历</h2><p>一份合格的简历是怎样的？ 已完结链接：<a href="https://www.yuque.com/docs/share/29d989cc-86e1-48cf-b731-d39030388685">https://www.yuque.com/docs/share/29d989cc-86e1-48cf-b731-d39030388685</a><br>个人信息模块要这么写已完结链接：<a href="https://www.yuque.com/docs/share/526aa724-f87b-43bd-b519-6058537891ec">https://www.yuque.com/docs/share/526aa724-f87b-43bd-b519-6058537891ec</a><br>教育背景模块要这么写已完结链接：<a href="https://www.yuque.com/docs/share/6d1698af-6a68-451f-b95e-496527a8f7cb">https://www.yuque.com/docs/share/6d1698af-6a68-451f-b95e-496527a8f7cb</a><br>专业技能模块要这么写已完结链接：<a href="https://www.yuque.com/docs/share/8d71bc4e-6426-4141-9d44-0710b45205bd">https://www.yuque.com/docs/share/8d71bc4e-6426-4141-9d44-0710b45205bd</a><br>实习经历模块要这么写已完结链接：<a href="https://www.yuque.com/docs/share/f44e4e04-35e1-4b63-ac1c-32fa508f7b49">https://www.yuque.com/docs/share/f44e4e04-35e1-4b63-ac1c-32fa508f7b49</a><br>项目经验模块要这么写已完结链接：<a href="https://www.yuque.com/docs/share/30fd8b4c-ce0d-486f-aacd-bc094d6e7a27">https://www.yuque.com/docs/share/30fd8b4c-ce0d-486f-aacd-bc094d6e7a27</a><br>校园经历模块要这么写已完结链接：<a href="https://www.yuque.com/docs/share/e0ecb501-5879-4676-9da2-e5c1d04a39fe">https://www.yuque.com/docs/share/e0ecb501-5879-4676-9da2-e5c1d04a39fe</a><br>奖项证书模块要这么写已完结链接：<a href="https://www.yuque.com/docs/share/26c7c18e-5d59-45a1-a1c7-e8b895cb9b96">https://www.yuque.com/docs/share/26c7c18e-5d59-45a1-a1c7-e8b895cb9b96</a><br>科研论文模块要这么写已完结链接：<a href="https://www.yuque.com/docs/share/4120ccbd-b4fc-4292-8762-d1dd577ce802">https://www.yuque.com/docs/share/4120ccbd-b4fc-4292-8762-d1dd577ce802</a><br>自我评价模块要这么写已完结链接：<a href="https://www.yuque.com/docs/share/a32f6781-5d9a-4286-8db9-35746b082624">https://www.yuque.com/docs/share/a32f6781-5d9a-4286-8db9-35746b082624</a><br>简历优秀文案&amp;叙述分享已完结链接：<a href="https://www.yuque.com/docs/share/bedc9a5b-4eb1-4166-a8ab-5cb1de7c6e7d">https://www.yuque.com/docs/share/bedc9a5b-4eb1-4166-a8ab-5cb1de7c6e7d</a><br>优秀简历模板分享已完结链接：<a href="https://www.yuque.com/docs/share/d51586de-b3c2-44ed-a409-5aac10b233c0">https://www.yuque.com/docs/share/d51586de-b3c2-44ed-a409-5aac10b233c0</a></p><h2 id="校招面试详细解读（一二三轮技术面-HR-面）"><a href="#校招面试详细解读（一二三轮技术面-HR-面）" class="headerlink" title="校招面试详细解读（一二三轮技术面 + HR 面）"></a>校招面试详细解读（一二三轮技术面 + HR 面）</h2><p>校招大厂技术岗面试基本知识已完结链接：<a href="https://www.yuque.com/docs/share/023e3cea-fc87-4823-9e59-9f6cdee3b32d">https://www.yuque.com/docs/share/023e3cea-fc87-4823-9e59-9f6cdee3b32d</a><br>一轮技术面已完结链接：<a href="https://www.yuque.com/docs/share/9f9545e2-4efa-4a95-9f7f-0a4f78de3f51">https://www.yuque.com/docs/share/9f9545e2-4efa-4a95-9f7f-0a4f78de3f51</a><br>二轮技术面已完结链接：<a href="https://www.yuque.com/docs/share/81d7d11b-fcff-4a37-90fd-ae0dec622ccf">https://www.yuque.com/docs/share/81d7d11b-fcff-4a37-90fd-ae0dec622ccf</a><br>三轮技术面已完结链接：<a href="https://www.yuque.com/docs/share/d7264ba9-0d08-4d3e-b248-e9ce13375949">https://www.yuque.com/docs/share/d7264ba9-0d08-4d3e-b248-e9ce13375949</a><br>交叉面已完结链接：<a href="https://www.yuque.com/docs/share/cf8e8fa9-92ed-4a17-be56-a90cf280d431">https://www.yuque.com/docs/share/cf8e8fa9-92ed-4a17-be56-a90cf280d431</a><br>HR 面详细解读已完结（包括常见回答话术） 链接： <a href="https://www.yuque.com/docs/share/bca09dd9-16f8-43a6-b231-79fdfa5ea084">https://www.yuque.com/docs/share/bca09dd9-16f8-43a6-b231-79fdfa5ea084</a></p><h2 id="全国一二线城市知名互联网公司大盘点"><a href="#全国一二线城市知名互联网公司大盘点" class="headerlink" title="全国一二线城市知名互联网公司大盘点"></a>全国一二线城市知名互联网公司大盘点</h2><p>上海互联网公司盘点（已完结，共 225 家）链接：<a href="https://www.yuque.com/docs/share/49d754e1-b868-46e4-ab02-8e2b153799fc">https://www.yuque.com/docs/share/49d754e1-b868-46e4-ab02-8e2b153799fc</a><br>北京互联网公司盘点（已完结，共 82 家) 链接：<a href="https://www.yuque.com/docs/share/239796b1-bca4-4048-a63d-3e421dd10ea4">https://www.yuque.com/docs/share/239796b1-bca4-4048-a63d-3e421dd10ea4</a><br>杭州互联网公司盘点（已完结，共 101 家） 链接：<a href="https://www.yuque.com/docs/share/dd41eee7-6c88-4659-a21c-9fdf11d1b12e">https://www.yuque.com/docs/share/dd41eee7-6c88-4659-a21c-9fdf11d1b12e</a><br>广州互联网盘点（已完结，共 96 家）链接：<a href="https://www.yuque.com/docs/share/69a6d864-7806-4e4c-84c0-506c543dfc93">https://www.yuque.com/docs/share/69a6d864-7806-4e4c-84c0-506c543dfc93</a><br>深圳互联网盘点 (已完结, 共 108 家)    链接：<a href="https://www.yuque.com/docs/share/ed985935-65a7-489e-82b0-c1e2259ede50">https://www.yuque.com/docs/share/ed985935-65a7-489e-82b0-c1e2259ede50</a><br>武汉互联网盘点（已完结，共 68 家） 链接：<a href="https://www.yuque.com/docs/share/09175e89-382a-4a0c-9299-4f2c2d8c32ae">https://www.yuque.com/docs/share/09175e89-382a-4a0c-9299-4f2c2d8c32ae</a><br>西安互联网盘点（已完结，共 45 家）链接：<a href="https://www.yuque.com/docs/share/7a4fcaf2-81fe-42ba-b1a5-5daa64a41d71">https://www.yuque.com/docs/share/7a4fcaf2-81fe-42ba-b1a5-5daa64a41d71</a><br>济南互联网盘点（已完结，共 14 家）链接：<a href="https://www.yuque.com/docs/share/62be2e0b-5e61-4de5-8d90-706519f1c3bc">https://www.yuque.com/docs/share/62be2e0b-5e61-4de5-8d90-706519f1c3bc</a><br>山东互联网盘点（已完结，共 28 家） 链接 <a href="https://www.yuque.com/docs/share/122f8d61-9876-4160-ba2e-ed56047c9080">https://www.yuque.com/docs/share/122f8d61-9876-4160-ba2e-ed56047c9080</a><br>苏州互联网公司盘点（已完结，共 38 家） 链接：<a href="https://www.yuque.com/docs/share/8a010f17-a528-4068-a577-43d4ca6b9256">https://www.yuque.com/docs/share/8a010f17-a528-4068-a577-43d4ca6b9256</a></p><h2 id="学习路线-amp-项目推荐"><a href="#学习路线-amp-项目推荐" class="headerlink" title="学习路线&amp;项目推荐"></a>学习路线&amp;项目推荐</h2><p>学习路线导读（强烈建议看一看）已完结 <a href="https://www.yuque.com/docs/share/c01a4794-9a04-4adb-ba74-965401399e9d">https://www.yuque.com/docs/share/c01a4794-9a04-4adb-ba74-965401399e9d</a><br>阿秀自己自学 CS 过程中的学习心得 （已完结） <a href="https://www.yuque.com/docs/share/e34d01e9-0b23-4f02-ab17-9353d201a357">https://www.yuque.com/docs/share/e34d01e9-0b23-4f02-ab17-9353d201a357</a><br>C 学习路线（小白求职版）（已完结） <a href="https://www.yuque.com/docs/share/2f0fde4a-1ae5-45f3-90b7-21e81dd4fa76">https://www.yuque.com/docs/share/2f0fde4a-1ae5-45f3-90b7-21e81dd4fa76</a><br>C&#x2F;C 项目推荐已完结共 8 个 <a href="https://www.yuque.com/docs/share/55b9d089-37cc-4060-a0f5-40f018befb85">https://www.yuque.com/docs/share/55b9d089-37cc-4060-a0f5-40f018befb85</a></p><h2 id="读书笔记分享"><a href="#读书笔记分享" class="headerlink" title="读书笔记分享"></a>读书笔记分享</h2><p>《深度探索 C++ 对象模型》读书笔记已完结链接：<a href="https://www.yuque.com/docs/share/e3869134-783f-4179-b641-51a4ee018ae6">https://www.yuque.com/docs/share/e3869134-783f-4179-b641-51a4ee018ae6</a><br>《MySQL 必知必会》读书笔记已完结 <a href="https://www.yuque.com/docs/share/208b1355-f5cc-4feb-8fe7-42e4ff3e1e72">https://www.yuque.com/docs/share/208b1355-f5cc-4feb-8fe7-42e4ff3e1e72</a></p><h1 id="考公"><a href="#考公" class="headerlink" title="考公"></a>考公</h1><ul><li><a href="https://www.nowcoder.com/discuss/361219661281738752">一年半我考了11次公务员，内附考试细节，不看血亏_牛客网 (nowcoder.com)</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 归档 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>使用Azure Open AI</title>
      <link href="/posts/%E5%BA%94%E7%94%A8/ai/%E4%BD%BF%E7%94%A8Azure%20Open%20AI.html"/>
      <url>/posts/%E5%BA%94%E7%94%A8/ai/%E4%BD%BF%E7%94%A8Azure%20Open%20AI.html</url>
      
        <content type="html"><![CDATA[<h1 id="申请"><a href="#申请" class="headerlink" title="申请"></a>申请</h1><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://zhuanlan.zhihu.com/p/614242045">分享Azure申请及使用OpenAI的经历 - 知乎 (zhihu.com)</a></p><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>如果是教育邮箱，可以通过 <a href="http://link.zhihu.com/?target=https://azure.microsoft.com/zh-cn/free/students/">这个地址</a> 开通 azure 服务，会多一个 Azure for Students 的订阅，再用这个订阅的 id 再去申请一次 openai 就可以得到 1 年 +100 刀的使用期限，可在该网页查看剩余额度 <a href="https://learn.microsoft.com/zh-cn/azure/cost-management-billing/manage/azurestudents-subscription-disabled">重新激活已禁用的面向学生的 Azure 订阅 - Microsoft Cost Management | Microsoft Learn</a></p><p>此外，可以用微信账号申请一个腾讯企业邮箱，就选最基础的免费版就行了，审批很快，半天时间都不到。</p><h2 id="申请-1"><a href="#申请-1" class="headerlink" title="申请"></a>申请</h2><p>登录 <a href="http://portal.azure.com/">http://portal.azure.com</a> 后，依次查找：所有服务——AI+ 机器学习——认知服务——Azure OpenAI。点击创建，会提示需要提交申请才能使用。<br>可以根据这篇文章来申请<br><a href="https://51.ruyo.net/18402.html">微软Azure申请OpenAI以及部署使用教程 - 如有乐享 (ruyo.net)</a></p><h2 id="开通"><a href="#开通" class="headerlink" title="开通"></a>开通</h2><p>其实早在之前文章中也提到了：<a href="https://51.ruyo.net/18360.html">目前OpenAI账号开通获取高额度方法分享</a></p><p>首先，你需要有一个 Azure。可用是免费试用版，Azure Stu 版，Azure 企业版 等等。</p><p><a href="https://aka.ms/oai/access">申请开通OpenAI</a>&#x2F;<a href="https://aka.ms/oai/get-gpt4">申请GPT-4</a></p><p>第二，申请的时候官方也表明需要用企业邮箱！不用用 gmail，outlook 等</p><p>第三，还需要填写企业官网（官网域名和邮箱域名得一致）</p><p>然后就是看运气了等审核通过了。短的 4 小时，长的可能得几个月。</p><p>部分人审核期间可能需要补充一些资料。也有几个小时就通过的。</p><p>当然了这个申请也是有技巧的。有朋友基本上目前 100% 几小时就通过了。</p><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><h3 id="创建-OpenAI"><a href="#创建-OpenAI" class="headerlink" title="创建 OpenAI"></a>创建 OpenAI</h3><p>1，搜索资源 OpenAI 可找到 Azure OpenAI。点击创建！</p><p>填写信息！名称随意！定价选 S0 区域，可选美国东部（法国和欧洲，看你使用情况可选）</p><p><img src="/../../../img/blog/ad02411904c665a355c1e3dd23cb896c_MD5.jpg" alt="微软Azure申请OpenAI以及部署使用教程"></p><p>2，网络选择所有网络 即可。</p><p>3，标记。没有啥标记的直接下一步！</p><p>4，验证相关信息，验证通过后，直接点击创建即可！</p><p>5，稍等几分钟，部署完成！</p><p><img src="/../../../img/blog/84dfe46ea1f2187b1a81a010c610c775_MD5.jpg" alt="微软Azure申请OpenAI以及部署使用教程"></p><h3 id="记录关键信息"><a href="#记录关键信息" class="headerlink" title="记录关键信息"></a>记录关键信息</h3><p>打开新建的 OpenAI 有几个关键的内容，保存好后面会使用！</p><p>1，终结点 ，如图就是我们专属的接口域名地址</p><p>2，密钥，点击管理密钥可看见密钥内容</p><p><img src="/../../../img/blog/3634349193426f351fb14c307d3dfdc3_MD5.jpg" alt="微软Azure申请OpenAI以及部署使用教程"></p><h3 id="模型部署"><a href="#模型部署" class="headerlink" title="模型部署"></a>模型部署</h3><p>1，点击 模型部署，点击 【管理部署】按钮。浏览器会在当前页面打开模型管理的另一个平台。</p><p><img src="/../../../img/blog/a2079f222dd28cac03e618ae1d756cb2_MD5.jpg" alt="微软Azure申请OpenAI以及部署使用教程"></p><p>2，在 Azure AI 平台中，点击【新建部署】</p><p><img src="/../../../img/blog/178f45db5c416f32e4e5a3df1463113e_MD5.jpg" alt="微软Azure申请OpenAI以及部署使用教程"></p><p>3，这里需要选择模型，以及填写部署名称。</p><p>模型，选择 gpt-35-turbo（如果你有 gpt-4.0，选择这个也行）</p><p><strong>部署名，填写即可。这个部署名后面也会用到！</strong></p><p>高级选项， 可设置 Token 上限，最高支持 240K（酌情选择设置）</p><p>自定义过滤器，按需设置即可</p><p><img src="/../../../img/blog/308ff3dc807d2b80c9321479bd5fe6ef_MD5.jpg" alt="微软Azure申请OpenAI以及部署使用教程"></p><p><img src="/../../../img/blog/29014f630df013de45c8823ed5ed54ec_MD5.jpg" alt="微软Azure申请OpenAI以及部署使用教程"></p><p>4，分分钟创建成功！Azure AI 中也提供了和可以直接聊天的功能，操场设置各类参数。</p><p><img src="/../../../img/blog/4806b1e974ad57d2bb0e0cb4956c4f96_MD5.jpg" alt="微软Azure申请OpenAI以及部署使用教程"></p><p><img src="/../../../img/blog/1a95fb11920c7fa68a55774c5edafac1_MD5.jpg" alt="微软Azure申请OpenAI以及部署使用教程"></p><p>5，体验自带的会话功能。</p><p><img src="/../../../img/blog/50996137e171b1e6a85c596e2f51913f_MD5.jpg" alt="微软Azure申请OpenAI以及部署使用教程"></p><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>Azure OpenAI 和 OpenAI 官方的调用方式基本相似。只有 3 处需要注意。</p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><h3 id="终结点"><a href="#终结点" class="headerlink" title="终结点"></a>终结点</h3><p>OpenAI 官方是 api.openai.com</p><p>Azure OpenAI 则是 ruyo-openai.openai.azure.com （ 每个都不太一样，别直接使用这个哈）</p><h3 id="APIKEY"><a href="#APIKEY" class="headerlink" title="APIKEY"></a>APIKEY</h3><p>OpenAI 官方是是以 sky 开头的一段</p><p>Azure OpenAI 是无规律的一段</p><h3 id="部署名称（Deployment-Name）"><a href="#部署名称（Deployment-Name）" class="headerlink" title="部署名称（Deployment Name）"></a>部署名称（Deployment Name）</h3><p>部署模型时填写的名称</p><h2 id="HTTP-调用"><a href="#HTTP-调用" class="headerlink" title="HTTP 调用"></a>HTTP 调用</h2><p>接口地址：<a href="https://ruyo-openai.openai.azure.com/openai/deployments/ruyo-gpt/chat/completions/?api-version=2023-05-15">https://ruyo-openai.openai.azure.com/openai/deployments/ruyo-gpt/chat/completions/?api-version=2023-05-15</a></p><p>请求方式：POST</p><p>BODY：</p><p>这部分和 OpenAI 基本一致！这里不做太多的介绍！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;messages&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;role&quot;: &quot;system&quot;,</span><br><span class="line">            &quot;content&quot;: &quot;如有乐享博客AI助手&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;role&quot;: &quot;user&quot;,</span><br><span class="line">            &quot;content&quot;: &quot;如有乐享博客怎么样&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/../../../img/blog/2f0d23c4f1057b0dc765bfa04a9cfcd4_MD5.jpg" alt="微软Azure申请OpenAI以及部署使用教程"></p><p>更多其他调用方式，参考官方文档：<a href="https://learn.microsoft.com/zh-cn/azure/cognitive-services/openai/chatgpt-quickstart?tabs=bash&pivots=programming-language-studio">https://learn.microsoft.com/zh-cn/azure/cognitive-services/openai/chatgpt-quickstart?tabs=bash&amp;pivots=programming-language-studio</a></p><h2 id="CloudFlare-代理"><a href="#CloudFlare-代理" class="headerlink" title="CloudFlare 代理"></a>CloudFlare 代理</h2><p>由于大多数互联网产品暂不支持 <code>Azure OpenAI</code> 的调用接口，我们可以使用 <a href="https://link.juejin.cn/?target=https://dash.cloudflare.com/login" title="https://dash.cloudflare.com/login">CloudFlare Workers</a> 进行代理设置。</p><p>首先注册该网站的账户，然后按以下步骤操作：</p><ol><li><p>创建一个 Workers</p></li><li><p>阅读 github 文档 <a href="https://github.com/haibbo/cf-openai-azure-proxy">github.com&#x2F;haibbo&#x2F;cf-o…</a></p></li></ol><h2 id="部署-ChatGPT-Next-Web"><a href="#部署-ChatGPT-Next-Web" class="headerlink" title="部署 ChatGPT-Next-Web"></a>部署 ChatGPT-Next-Web</h2><p><a href="https://github.com/Yidadaa/ChatGPT-Next-Web/issues/371">[Feature] 添加对 Azure OpenAI API 的支持 · Issue #371 · Yidadaa&#x2F;ChatGPT-Next-Web (github.com)</a></p><p>可以根据文档 <a href="https://github.com/Yidadaa/ChatGPT-Next-Web">Yidadaa&#x2F;ChatGPT-Next-Web:   一键拥有你自己的跨平台 ChatGPT 应用。)</a> 在 Vercel 部署 ChatGPT-Next-Web，配置环境变量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BASE_URL：cloudfare worker 部署的URL</span><br><span class="line">OPENAI_API_KEY：在Azure Portal OpenAI 找到 API key，有两个key，用其中一个即可</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>或者搭配 <a href="https://github.com/diemus/azure-openai-proxy">stulzq&#x2F;azure-openai-proxy</a> 使用，可以直接 <code>docker-compose</code> 来启动。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">chatgpt-next-web:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">yidadaa/chatgpt-next-web</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">3000</span><span class="string">:3000</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">OPENAI_API_KEY:</span> <span class="string">&lt;Auzre</span> <span class="string">OpenAI</span> <span class="string">API</span> <span class="string">Key&gt;</span></span><br><span class="line">      <span class="attr">BASE_URL:</span> <span class="string">http://azure-openai:8080</span></span><br><span class="line">      <span class="attr">DISABLE_GPT4:</span> <span class="number">1</span></span><br><span class="line">      <span class="attr">CODE:</span> <span class="string">&quot;password&quot;</span></span><br><span class="line">      <span class="attr">HIDE_BALANCE_QUERY:</span> <span class="number">1</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">azure-openai</span></span><br><span class="line">    <span class="attr">links:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">azure-openai</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">chatgpt-ns</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">azure-openai:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">stulzq/azure-openai-proxy</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">8080</span><span class="string">:8080</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">AZURE_OPENAI_ENDPOINT:</span> <span class="string">&lt;Auzre</span> <span class="string">OpenAI</span> <span class="string">API</span> <span class="string">Endpoint&gt;</span></span><br><span class="line">      <span class="attr">AZURE_OPENAI_MODEL_MAPPER:</span> <span class="string">&lt;Auzre</span> <span class="string">OpenAI</span> <span class="string">API</span> <span class="string">Deployment</span> <span class="string">Mapper&gt;</span></span><br><span class="line">      <span class="attr">AZURE_OPENAI_API_VER:</span> <span class="number">2023-05-15</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">chatgpt-ns</span></span><br><span class="line"></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">chatgpt-ns:</span></span><br><span class="line">    <span class="attr">driver:</span> <span class="string">bridge</span></span><br></pre></td></tr></table></figure><p>启动有 3 个环境变量需要配置：</p><table><thead><tr><th>变量名</th><th>说明</th></tr></thead><tbody><tr><td>OPENAI_API_KEY</td><td>Azure <strong>密钥和终结点</strong> 里提供的 Key</td></tr><tr><td>AZURE_OPENAI_ENDPOINT</td><td>Azure <strong>密钥和终结点</strong> 里提供的终结点</td></tr><tr><td>AZURE_OPENAI_MODEL_MAPPER</td><td>Azure 部署模型名称映射到 OpenAI 官方模型名称</td></tr></tbody></table><p>特别说明一下 <code>AZURE_OPENAI_MODEL_MAPPER</code> 使用 OpenAI 官方标准发起的请求里包含的模型名称是固定的，在这里可以 <a href="https://platform.openai.com/docs/models">查询</a>，而在 Azure OpenAI 模型部署时是可以自定义名称的，请求 Azure yes 需要提供这个部署模型的名称，所以建立了一个映射关系。</p><p>比如我在 Azure 部署了一个 <code>gpt-3.5-turbo</code> 模型，我设置的部署名称为：<code>xc-gpt-35</code>，此时我的设置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">AZURE_OPENAI_MODEL_MAPPER:</span> <span class="string">gpt-3.5-turbo=xc-gpt-35</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 应用 </category>
          
          <category> ai </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>项目软件收藏</title>
      <link href="/posts/%E5%BD%92%E6%A1%A3/%E9%A1%B9%E7%9B%AE%E8%BD%AF%E4%BB%B6%E6%94%B6%E8%97%8F.html"/>
      <url>/posts/%E5%BD%92%E6%A1%A3/%E9%A1%B9%E7%9B%AE%E8%BD%AF%E4%BB%B6%E6%94%B6%E8%97%8F.html</url>
      
        <content type="html"><![CDATA[<h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><h2 id="Github"><a href="#Github" class="headerlink" title="Github"></a>Github</h2><ul><li><a href="https://github.com/localsend/localsend">跨平台无缝传输文件localsend</a></li><li><a href="https://github.com/liyupi/sql-mother">liyupi&#x2F;sql-mother: 免费的闯关式 SQL 自学教程网站</a></li><li><a href="https://www.filebrowser.cn/">filebrowser,功能是可以通过浏览器对服务器上的文件进行管理</a></li><li><a href="https://github.com/vastsa/FileCodeBox/tree/master">vastsa&#x2F;FileCodeBox: 文件快递柜-匿名口令分享文本，文件，像拿快递一样取文件</a></li><li><a href="https://github.com/AppFlowy-IO/appflowy">AppFlowy-IO&#x2F;AppFlowy: AppFlowy is an open-source alternative to Notion.</a></li><li><a href="https://github.com/wmjordan/PDFPatcher">PDF补丁丁——PDF工具箱，可以编辑书签、剪裁旋转页面、解除限制、提取或合并文档，探查文档结构，提取图片、转成图片等等</a></li></ul><h2 id="Gitee"><a href="#Gitee" class="headerlink" title="Gitee"></a>Gitee</h2><ul><li><a href="https://gitee.com/zmister/MrDoc">MrDoc: MrDoc觅思文档，适合于个人和中小型团队的在线文档、知识库管理私有化部署方案，全面支持跨平台（Windows、macOS、Linux）和跨终端（Web、PC、手机）同步 (gitee.com)</a></li><li><a href="https://gitee.com/dromara/zyplayer-doc#https://gitee.com/link?target=http%3A%2F%2Fzyplayer.com">zyplayer-doc: zyplayer-doc是一款适合团队和个人私有化部署使用的知识库、笔记、WIKI文档管理工具，同时还包含数据库管理、Api接口管理等模块 (gitee.com)</a></li></ul><h2 id="网页"><a href="#网页" class="headerlink" title="网页"></a>网页</h2><ul><li><a href="https://tuya.xinxiao.tech/">图压 - 简单易用的图片压缩软件 (xinxiao.tech)</a></li><li><a href="https://www.xunjiepdf.com/shipinzhuanwenzi">视频转文字助手 - 专业的视频语音转文字软件 (xunjiepdf.com)</a></li><li><a href="https://github.com/chatanywhere/GPT_API_free">Free ChatGPT API Key，免费ChatGPT API，支持GPT4 API（低价）</a></li></ul><h2 id="docker"><a href="#docker" class="headerlink" title="docker"></a>docker</h2><ul><li><a href="https://hub.grapps.cn/marketplace/apps/1303">it-tools (grapps.cn)</a></li></ul><h1 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h1><ul><li><a href="https://github.com/sogou/workflow">sogou&#x2F;workflow: C++ Parallel Computing and Asynchronous Networking Engine (github.com)</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 归档 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Rust 安装</title>
      <link href="/posts/%E5%BA%94%E7%94%A8/%E9%85%8D%E7%BD%AE/%E8%AF%AD%E8%A8%80%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/Rust%20%E5%AE%89%E8%A3%85.html"/>
      <url>/posts/%E5%BA%94%E7%94%A8/%E9%85%8D%E7%BD%AE/%E8%AF%AD%E8%A8%80%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/Rust%20%E5%AE%89%E8%A3%85.html</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.rust-lang.org/tools/install">https://www.rust-lang.org/tools/install</a></p>]]></content>
      
      
      <categories>
          
          <category> 应用 </category>
          
          <category> 配置 </category>
          
          <category> 语言环境配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> rust </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>代码格式化和静态分析检查工作流 Cpp Linter</title>
      <link href="/posts/%E5%BA%94%E7%94%A8/%E8%AF%AD%E8%A8%80/Cpp/%E4%BB%A3%E7%A0%81%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%92%8C%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90%E6%A3%80%E6%9F%A5%E5%B7%A5%E4%BD%9C%E6%B5%81%20Cpp%20Linter.html"/>
      <url>/posts/%E5%BA%94%E7%94%A8/%E8%AF%AD%E8%A8%80/Cpp/%E4%BB%A3%E7%A0%81%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%92%8C%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90%E6%A3%80%E6%9F%A5%E5%B7%A5%E4%BD%9C%E6%B5%81%20Cpp%20Linter.html</url>
      
        <content type="html"><![CDATA[<h1 id="Clang-tools-Binaries"><a href="#Clang-tools-Binaries" class="headerlink" title="Clang-tools Binaries"></a>Clang-tools Binaries</h1><p>如果你需要使用 clang-tools binaries，以 Windows 为例，通常下载指定版本的 clang-tools 需要先安装 LLVM 这个大的安装包才能获得 clang-format &amp; clang-tidy 这些工具；在 Linux 上会方便很多，可以使用命令来下载，但如果想下载指定版本的 clang-format &amp; clang-tidy 可能要面临手动下载和安装。</p><p>clang-tools-pip 提供并支持在 Windows，Linux，MacOs 上通过命令行下载任何指定版本的 clang-tools 可执行文件。</p><p>只需要使用 <code>pip</code> 安装 <code>clang-tools</code> （即 <code>pip install clang-tools</code>）后，然后通过 <code>clang-tools</code> 命令就可以安装任何版本的可执行文件了。</p><p>例如，安装 clang-tools 版本 13：<br><code>$ clang-tools --install 13</code><br>也可以将它安装到指定目录下面：<br><code>$ clang-tools --install 13 --directory .</code></p><p><code>clang-tools</code> CLI 还提供了其他选项，比如自动帮你创建链接等，可以查看它的 CLI 文档来获得帮助。<br><a href="https://cpp-linter.github.io/clang-tools-pip/cli_args.html">Command Line Interface Options - clang-tools installer (cpp-linter.github.io)</a></p><h1 id="把-Clang-tools-集成到工作流"><a href="#把-Clang-tools-集成到工作流" class="headerlink" title="把 Clang-tools 集成到工作流"></a>把 Clang-tools 集成到工作流</h1><ol><li><p>cpp-linter-action 提供了通过 CI 进行检查，当发现没有格式化或有诊断错误的代码时 CI 会失败，来防止合并到主分的代码没有通过代码检查；</p></li><li><p>cpp-linter-hooks 通过 git hook 在提交代码的时候自动运行 clang-format 和 clang-tidy，如果不符合规范则提交失败，并提示并自动格式化。</p></li></ol><h1 id="Cpp-linter-action-在代码合并前做自动检查"><a href="#Cpp-linter-action-在代码合并前做自动检查" class="headerlink" title="Cpp-linter-action 在代码合并前做自动检查"></a>Cpp-linter-action 在代码合并前做自动检查</h1><p>如果你使用的是 GitHub，那么非常推荐你使用 cpp-linter-action 这个 GitHub Action。</p><p>以下是它的一些重要特性：</p><ol><li><p>运行结果支持 Annotations 和 Thread Comment 两种方式展示</p></li><li><p>支持 GitHub 的 public 和 private 仓库</p></li><li><p>支持绝大多数 Clang 版本</p></li><li><p>还有很多其他的 optional-inputs<br><a href="https://github.com/cpp-linter/cpp-linter-action#optional-inputs">cpp-linter&#x2F;cpp-linter-action: Lint C&#x2F;C++ code with clang-format and clang-tidy then post annotations, comments, and step summary with results. (github.com)</a></p></li></ol><p>使用这个 Action 只需要在 <code>.github/workflows/</code> 下面创建一个 cpp-linter.yml，内容如下：</p><blockquote><p>当然也可以把下面的配置加到一个已经存在的 Workflow，例如 build。</p></blockquote><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">name:</span> <span class="string">cpp-linter</span>  </span><br><span class="line">  </span><br><span class="line"><span class="attr">on:</span>  </span><br><span class="line">  <span class="attr">pull_request:</span>  </span><br><span class="line">    <span class="string">types:</span> [<span class="string">opened</span>, <span class="string">reopened</span>]  </span><br><span class="line">  <span class="attr">push:</span>  </span><br><span class="line">  </span><br><span class="line"><span class="attr">jobs:</span>  </span><br><span class="line">  <span class="attr">cpp-linter:</span>  </span><br><span class="line">    <span class="string">runs-on:</span> <span class="string">ubuntu-latest</span>  </span><br><span class="line">    <span class="attr">steps:</span>  </span><br><span class="line">      <span class="string">-</span> <span class="string">uses:</span> <span class="string">actions/checkout@v3</span>  </span><br><span class="line">      <span class="string">-</span> <span class="string">uses:</span> <span class="string">cpp-linter/cpp-linter-action@v1</span>  </span><br><span class="line">        <span class="string">id:</span> <span class="string">linter</span>  </span><br><span class="line">        <span class="attr">env:</span>  </span><br><span class="line">          <span class="string">GITHUB_TOKEN:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.GITHUB_TOKEN</span> <span class="string">&#125;&#125;</span>  </span><br><span class="line">        <span class="attr">with:</span>  </span><br><span class="line">          <span class="string">style:</span> <span class="string">file</span>  </span><br><span class="line">  </span><br><span class="line">      <span class="string">-</span> <span class="string">name:</span> <span class="string">Fail</span> <span class="string">fast?!</span>  </span><br><span class="line">        <span class="string">if:</span> <span class="string">steps.linter.outputs.checks-failed</span> <span class="string">&gt;</span> <span class="number">0</span>  </span><br><span class="line">        <span class="string">run:</span> <span class="string">|</span>  </span><br><span class="line">          <span class="string">echo</span> <span class="string">&quot;Some files failed the linting checks!&quot;</span>  </span><br><span class="line">          <span class="string">exit</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><p>如果发现存在没有进行格式化或是静代码态检查，CI workflow 会失败，并且会有如下注释说明，annotations 默认是开启的。</p><p><img src="/../../../../img/blog/d2442aea62f1dfffc472f6a23b2fa035_MD5.png" alt="图片"></p><p>如果开启了 Thread Comment 选项（即 <code>thread-comments: true</code>）就会将在 Pull Request 中自动添加如下错误评论。</p><p><img src="/../../../../img/blog/8b0a2ba3494fffa5c66cc83391964abb_MD5.png" alt="图片"></p><h1 id="Cpp-linter-hooks-在提交代码时自动检查"><a href="#Cpp-linter-hooks-在提交代码时自动检查" class="headerlink" title="Cpp-linter-hooks 在提交代码时自动检查"></a>Cpp-linter-hooks 在提交代码时自动检查</h1><p>cpp-linter-hooks 是通过 git hook 在提交代码时做自动检查，这种方式不限制使用任何 SCM。</p><p>只需要在项目仓库中添加一个 <code>.pre-commit-config.yaml</code> 配置文件，然后将 cpp-linter-hooks 这个 hook 添加到 <code>.pre-commit-config.yaml</code> 中，具体设置如下：</p><blockquote><p><code>.pre-commit-config.yaml</code> 是 <code>pre-commit</code> framework 的默认配置文件。</p></blockquote><p> 安装 pre-commit</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install pre-commit</span><br></pre></td></tr></table></figure><p> 创建配置文件 <code>.pre-commit-config.yaml</code>，设置如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">repos:</span></span><br><span class="line"><span class="string">-</span> <span class="string">repo:</span> <span class="string">https://github.com/cpp-linter/cpp-linter-hooks</span></span><br><span class="line">  <span class="string">rev:</span> <span class="string">v0.2.1</span></span><br><span class="line">  <span class="attr">hooks:</span></span><br><span class="line">    <span class="string">-</span> <span class="string">id:</span> <span class="string">clang-format</span></span><br><span class="line">      <span class="string">args:</span> [<span class="string">--style=file</span>]  <span class="comment"># to load .clang-format</span></span><br><span class="line">    <span class="string">-</span> <span class="string">id:</span> <span class="string">clang-tidy</span></span><br><span class="line">      <span class="string">args:</span> [<span class="string">--checks=.clang-tidy</span>] <span class="comment"># path/to/.clang-tidy</span></span><br></pre></td></tr></table></figure><blockquote><p>这里的 file 是指 <code>.clang-format</code>, clang-format 默认支持的编码格式包括 LLVM, GNU, Google, Chromium, Microsoft, Mozilla, WebKit，如果需要特殊设置可以在仓库的根目录下面创建配置文件 <code>.clang-format</code>。同理，如果默认的静态分析设置不满足要求，可以在仓库的根目录下创建 <code>.clang-tidy</code> 配置文件。</p></blockquote><p>更多配置可以参考 <a href="https://github.com/cpp-linter/cpp-linter-hooks">cpp-linter&#x2F;cpp-linter-hooks: C&#x2F;C++ linter hooks for pre-commit (github.com)</a></p><p> 安装 git hook 脚本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ pre-commit install</span><br><span class="line">pre-commit installed at .git/hooks/pre-commit</span><br></pre></td></tr></table></figure><p> 之后每次 <code>git commit</code> 都会自动执行 clang-format 和 chang-tidy。</p>]]></content>
      
      
      <categories>
          
          <category> 应用 </category>
          
          <category> 语言 </category>
          
          <category> Cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>安装配置</title>
      <link href="/posts/%E5%BA%94%E7%94%A8/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Vmware/%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE.html"/>
      <url>/posts/%E5%BA%94%E7%94%A8/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Vmware/%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE.html</url>
      
        <content type="html"><![CDATA[<h1 id="下载-Ubuntu"><a href="#下载-Ubuntu" class="headerlink" title="下载 Ubuntu"></a>下载 Ubuntu</h1><p><a href="https://mirrors.tuna.tsinghua.edu.cn/ubuntu-releases/">Index of &#x2F;ubuntu-releases&#x2F; | 清华大学开源软件镜像站 | Tsinghua Open Source Mirror</a><br>vmware 安装方法<br><a href="https://blog.csdn.net/trackxiaoxin321/article/details/115591796">(12条消息) 虚拟机ubuntu16.04超详细安装教程（零基础照做即可）_ubuntun16.04 安装虚拟机_LKTracker的博客-CSDN博客</a></p><h1 id="安装-VMware-Tools"><a href="#安装-VMware-Tools" class="headerlink" title="安装 VMware Tools"></a>安装 VMware Tools</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install open-vm-tools-desktop -y</span><br><span class="line">sudo reboot</span><br></pre></td></tr></table></figure><h1 id="换源"><a href="#换源" class="headerlink" title="换源"></a>换源</h1><h2 id="备份文件"><a href="#备份文件" class="headerlink" title="备份文件"></a>备份文件</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo cp /etc/apt/sources.list sources_backup.list</span><br></pre></td></tr></table></figure><h2 id="修改文件"><a href="#修改文件" class="headerlink" title="修改文件"></a>修改文件</h2><p><code>sudo gedit /etc/apt/sources.list</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#清华大学源</span><br><span class="line">deb http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial main restricted</span><br><span class="line">deb http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-updates main restricted</span><br><span class="line">deb http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial universe</span><br><span class="line">deb http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-updates universe</span><br><span class="line">deb http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial multiverse</span><br><span class="line">deb http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-updates multiverse</span><br><span class="line">deb http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-backports main restricted universe multiverse</span><br><span class="line">deb http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-security main restricted</span><br><span class="line">deb http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-security universe</span><br><span class="line">deb http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-security multiverse</span><br></pre></td></tr></table></figure><h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get -f install</span><br><span class="line">sudo apt-get upgrade</span><br></pre></td></tr></table></figure><h1 id="SSH-连接"><a href="#SSH-连接" class="headerlink" title="SSH 连接"></a>SSH 连接</h1><p><a href="https://cloud.tencent.com/developer/article/1679861">windows宿主机如何SSH连接VMware的Linux虚拟机 - 腾讯云开发者社区-腾讯云 (tencent.com)</a></p><h1 id="共享文件夹"><a href="#共享文件夹" class="headerlink" title="共享文件夹"></a>共享文件夹</h1><ol><li><p>在 vmware 中设置共享文件夹<br>即在 VMware workstation 中：虚拟机设置 -》选项 -》共享文件夹，浏览要共享的文件夹，继续按照说明设置即可。</p></li><li><p>在 linux 中链接一下即可<br>第 1 步完成后，共享文件夹已经挂载到了 <code>/mnt/hgfs/share/</code> ,share 是我的共享文件夹的名字，然后在创建一个软连接方便以后访问：</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ln -s /mnt/hgfs/share/ /home/share</span><br></pre></td></tr></table></figure><h2 id="Ubuntu-重启后不显示共享文件夹"><a href="#Ubuntu-重启后不显示共享文件夹" class="headerlink" title="Ubuntu 重启后不显示共享文件夹"></a>Ubuntu 重启后不显示共享文件夹</h2><p>重启 Ubuntu20.04 后，发现共享文件夹进不去也不显示了<br>首先查看共享文件夹是否已经存在并且设置为总是开启<br>使用命令查看当前挂载的共享文件夹</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vmware-hgfsclient</span><br></pre></td></tr></table></figure><p>存在的情况下，然后使用下面命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo /usr/bin/vmhgfs-fuse .host:/ /mnt/hgfs -o subtype=vmhgfs-fuse,allow_other</span><br></pre></td></tr></table></figure><p><a href="https://docs.vmware.com/cn/VMware-Workstation-Pro/17/com.vmware.ws.using.doc/GUID-AB5C80FE-9B8A-4899-8186-3DB8201B1758.html">在 Linux 客户机中装载共享文件夹 (vmware.com)</a></p><p>但是由于上面的方法需要每次重启后都去设置一遍，可以把执行的命令放到&#x2F;etc&#x2F;rc.local 文件下；让它开机自动执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vi /etc/rc.local</span><br></pre></td></tr></table></figure><p>若&#x2F;etc&#x2F;rc.local 是一个空文件则在里面添加</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/sh -e</span><br><span class="line">sudo vmhgfs-fuse .host:/ /mnt/hgfs -o nonempty -o allow_other</span><br></pre></td></tr></table></figure><p>给文件执行权限</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo chmod +x /etc/rc.local</span><br></pre></td></tr></table></figure><p>最后重启虚拟机</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reboot</span><br></pre></td></tr></table></figure><h1 id="无法应用原保存的显示器配置（屏幕显示问题）"><a href="#无法应用原保存的显示器配置（屏幕显示问题）" class="headerlink" title="无法应用原保存的显示器配置（屏幕显示问题）"></a>无法应用原保存的显示器配置（屏幕显示问题）</h1><p><a href="https://blog.csdn.net/a22635798/article/details/103643708">(12条消息) 虚拟机Ubuntu开机后提示：无法应用原保存的显示器配置（屏幕显示问题）_DTU-CFDer的博客-CSDN博客</a></p>]]></content>
      
      
      <categories>
          
          <category> 应用 </category>
          
          <category> 操作系统 </category>
          
          <category> Vmware </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>网站</title>
      <link href="/posts/%E5%BD%92%E6%A1%A3/%E7%BD%91%E7%AB%99.html"/>
      <url>/posts/%E5%BD%92%E6%A1%A3/%E7%BD%91%E7%AB%99.html</url>
      
        <content type="html"><![CDATA[<h1 id="书籍-x2F-资源"><a href="#书籍-x2F-资源" class="headerlink" title="书籍&#x2F;资源"></a>书籍&#x2F;资源</h1><ul><li><a href="https://zh.annas-archive.org/account/">Account - 安娜的档案 (annas-archive.org)</a></li><li><a href="https://chrome.google.com/webstore/category/extensions">Chrome 应用商店 - 扩展程序 (google.com)</a></li><li><a href="https://nuaa.vip/">资源分享 (wolai.com)</a></li><li><a href="https://zlibrary-china.se/">Z-Library – the world’s largest e-book library. Your gateway to knowledge and culture. (zlibrary-china.se)</a></li></ul><h1 id="服务器和网盘"><a href="#服务器和网盘" class="headerlink" title="服务器和网盘"></a>服务器和网盘</h1><ul><li><a href="https://cloud.tencent.com/login?s_url=https://console.cloud.tencent.com/lighthouse/instance/index?rid=1">登录 - 腾讯云 (tencent.com)</a></li><li><a href="https://infini-cloud.net/en/">InfiniCLOUD (infini-cloud.net)</a></li><li><a href="https://aws.amazon.com/cn/campaigns/server-hk/?trk=75645f8c-b0ff-4478-9a68-26a0f81c6da8&sc_channel=ba">免费香港服务器_云服务器vps_亚马逊云科技 (amazon.com)</a></li></ul><h1 id="国外-Lab-相关"><a href="#国外-Lab-相关" class="headerlink" title="国外 Lab 相关"></a>国外 Lab 相关</h1><ul><li><a href="https://mit-public-courses-cn-translatio.gitbook.io/mit6-824/">简介 - MIT6.824 (gitbook.io)</a></li><li><a href="https://gaozhiyuan.net/database/cmu-database-systems-introduction-and-relational-model.html">CMU15-445数据库系统：课程简介与关系模型 - 高志远的个人主页 (gaozhiyuan.net)</a></li><li><a href="https://blog.josejg.com/debugging-pretty/">Debugging by Pretty Printing (josejg.com)</a></li><li><a href="https://blog.eleven.wiki/posts/cmu15-445-project1-buffer-pool-manager/">https://blog.eleven.wiki/posts/cmu15-445-project1-buffer-pool-manager/</a></li></ul><h1 id="官方文档"><a href="#官方文档" class="headerlink" title="官方文档"></a>官方文档</h1><ul><li><a href="https://xmake.io/#/zh-cn/">xmake</a></li><li><a href="https://coffeetea.top/zh/">Obsidian文档咖啡豆版 | obsidian文档咖啡豆版 (coffeetea.top)</a></li><li><a href="https://opensource.guide/zh-hans/">开源软件指南 | Open Source Guides</a></li><li><a href="https://wiki.tttt.ee/wiki/idm.html">📗如何使用IDM | TT快下 (tttt.ee)</a></li></ul><h1 id="学习网站"><a href="#学习网站" class="headerlink" title="学习网站"></a>学习网站</h1><ul><li><a href="https://labuladong.gitee.io/algo/">labuladong 的算法小抄 :: labuladong的算法小抄 (gitee.io)</a></li><li><a href="https://missing-semester-cn.github.io/">计算机教育缺失的一课</a></li><li><a href="https://www.nowcoder.com/study/live/504">课程列表_牛客网 (nowcoder.com)</a></li><li><a href="https://top.interviewguide.cn/">InterviewGuide大厂面试真题</a></li><li><a href="https://conanhujinming.github.io/comments-for-awesome-courses/">名校公开课程评价网 (conanhujinming.github.io)</a></li><li><a href="https://github.com/sindresorhus/awesome">sindresorhus&#x2F;awesome</a></li><li><a href="https://github.com/codecrafters-io/build-your-own-x">codecrafters-io&#x2F;build-your-own-x</a></li><li><a href="https://github.com/donnemartin/system-design-primer">donnemartin&#x2F;system-design-primer</a></li></ul><h1 id="机场"><a href="#机场" class="headerlink" title="机场"></a>机场</h1><ul><li><a href="https://一元机场.com/#/dashboard">一元机场 (xn–4gq62f52gdss.com)</a></li><li><a href="https://glados.rocks/console">GLaDOS</a></li><li><a href="https://ciyy.cc/#/dashboard">次元雲☁️魔法之境 (ciyy.cc)</a></li><li><a href="https://www.fccloud.vip/#/dashboard">FCCloud</a></li></ul><h1 id="工具配置"><a href="#工具配置" class="headerlink" title="工具配置"></a>工具配置</h1><ul><li><a href="https://juejin.cn/post/7194435171633299513">C++工程实践必备技能 - 掘金 (juejin.cn)</a></li><li><a href="https://juejin.cn/post/7184793007302901820#heading-10">CLion开发环境配置完全解析（Qt开发？STM32？速通cmake？ - 掘金 (juejin.cn)</a></li></ul><h1 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h1><ul><li><a href="https://author.cnki.net/#/index">格式精灵 (cnki.net)</a></li><li><a href="https://zenvideo.qq.com/">腾讯智影-在线智能视频创作平台 (qq.com)</a></li><li><a href="https://qingtu.cn/">清图 - 模糊图片秒转高清图 (qingtu.cn)</a></li><li><a href="https://qinglian.tencent.com/console/">腾讯轻联 (tencent.com)</a></li><li><a href="https://www.thataicollection.com/zh-CN/">生成式 AI 景观 (thataicollection.com)</a></li><li><a href="https://academic.chatwithpaper.org/">GPT 学术优化 (chatwithpaper.org)</a></li></ul><h1 id="Ai"><a href="#Ai" class="headerlink" title="Ai"></a>Ai</h1><ul><li><a href="https://poe.com/Sage">https://poe.com/Sage</a></li><li><a href="https://chatgpt-plus.github.io/chatgpt-plus/">国内开通Chat GPT Plus保姆级教程【典藏】 | ChatGPT Plus官方推荐新手教程 (chatgpt-plus.github.io)</a></li><li><a href="https://portal.azure.com/#home">主页 - Microsoft Azure</a></li><li><a href="https://www.xfyun.cn/">讯飞开放平台-以语音交互为核心的人工智能开放平台 (xfyun.cn)</a></li><li><a href="https://www.perplexity.ai/">Perplexity AI</a></li></ul><h2 id="Openai"><a href="#Openai" class="headerlink" title="Openai"></a>Openai</h2><ul><li><a href="https://platform.openai.com/account/usage">Usage - OpenAI API</a></li></ul><h1 id="个人博客"><a href="#个人博客" class="headerlink" title="个人博客"></a>个人博客</h1><ul><li><a href="https://acking-you.github.io/">L_B__ (acking-you.github.io)</a></li><li><a href="https://www.nickxu.top/2022/12/14/%E3%80%8ECI-CD%E3%80%8F%E7%BB%93%E5%90%88GitHub-Actions-Docker%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2/#%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%8B%89%E5%8F%96%E6%B5%8B%E8%AF%95">『CI&#x2F;CD』结合 GitHub Actions+Docker 实现自动化部署 | NX の 博客 (nickxu.top)</a></li><li><a href="https://blog.misaka.rest/">MisakaNo の 小破站 - 这只是一个小破站而已！</a></li><li><a href="https://rigtorp.se/">Erik Rigtorp</a></li></ul><h1 id="病毒免杀"><a href="#病毒免杀" class="headerlink" title="病毒免杀"></a>病毒免杀</h1><ul><li><a href="https://link.springer.com/article/10.1007/s10207-021-00541-y">[m]allotROPism: a metamorphic engine for malicious software variation development | SpringerLink</a></li><li><a href="https://link.springer.com/article/10.1007/s11416-013-0194-3">Metamorphic code generation from LLVM bytecode | SpringerLink</a></li><li><a href="https://mp.weixin.qq.com/s/k6mi114uyzn2aMXy8uKy6A">绕过Windows Defender的十种方法 (qq.com)</a></li><li><a href="https://llm-attacks.org/index.html#ethics">Universal and Transferable Attacks on Aligned Language Models (llm-attacks.org)</a></li></ul><h1 id="Github"><a href="#Github" class="headerlink" title="Github"></a>Github</h1><p><strong>github.dev</strong> 或按下句号键帮你在线看源码。</p><p>&lt;<a href="http://www.gitpod.io>">www.gitpod.io&gt;</a> 帮你在云上搭建好开发环境并直接运行项目。</p><h1 id="ip-网络"><a href="#ip-网络" class="headerlink" title="ip 网络"></a>ip 网络</h1><ul><li><a href="https://ip.skk.moe/">查看我的 IP 地址 | 查询本机 IP 地址及归属地 | 查看 DNS 出口 IP | 测试 CDN 命中节点 | Sukka | https://ip.skk.moe</a></li><li><a href="https://ip.gs/">IP Address Lookup &#x2F; IPv4 &#x2F; IPv6 - IP.GS</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 归档 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>xmake从入门到精通</title>
      <link href="/posts/%E5%AD%A6%E4%B9%A0/%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/Xmake/xmake%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A.html"/>
      <url>/posts/%E5%AD%A6%E4%B9%A0/%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/Xmake/xmake%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A.html</url>
      
        <content type="html"><![CDATA[<p><a href="https://zhuanlan.zhihu.com/p/96031862">xmake从入门到精通9：交叉编译详解 - 知乎 (zhihu.com)</a><br><a href="https://zhuanlan.zhihu.com/p/97094249">xmake从入门到精通10：多个子工程目标的依赖配置 - 知乎 (zhihu.com)</a><br><a href="https://zhuanlan.zhihu.com/p/129064618">xmake从入门到精通11：如何组织构建大型工程 - 知乎 (zhihu.com)</a><br><a href="https://zhuanlan.zhihu.com/p/161553522">xmake从入门到精通12：通过自定义脚本实现更灵活地配置 - 知乎 (zhihu.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> 构建工具 </category>
          
          <category> Xmake </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Github主页美化</title>
      <link href="/posts/%E5%BA%94%E7%94%A8/%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7/Git/Github%E4%B8%BB%E9%A1%B5%E7%BE%8E%E5%8C%96.html"/>
      <url>/posts/%E5%BA%94%E7%94%A8/%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7/Git/Github%E4%B8%BB%E9%A1%B5%E7%BE%8E%E5%8C%96.html</url>
      
        <content type="html"><![CDATA[<h1 id="1、创建你的主页"><a href="#1、创建你的主页" class="headerlink" title="1、创建你的主页"></a>1、创建你的主页</h1><p>首先，你可以进入你的 GitHub，创建一个和你 _ 用户名相同 _ 的仓库，然后在里面创建 README 文件。</p><p>由于你这个仓库名和你的用户名是相同的，所以这个仓库就变得比较特殊了。</p><p>因为你在这里面的 README 写东西，都会显示到<img src="/../../../../img/blog/0cab18216da93fad8edffdba961283f3_MD5.jpg" alt="图片">a961283f3_MD5.jpg)</p><h1 id="2、美化的工具"><a href="#2、美化的工具" class="headerlink" title="2、美化的工具"></a>2、美化的工具</h1><p>如果你会点 <code>MarkDown</code> 或 <code>HTML 语言</code>，那么你基本就可以在自己的 <code>README</code> 中 diy 自己的主页了。</p><p>但是没有一些好看好玩的素材，是不是会显得有点单调？</p><p>来，给你推荐一些不错的素材。</p><h2 id="2-1-Emoji"><a href="#2-1-Emoji" class="headerlink" title="2.1 Emoji"></a>2.1 Emoji</h2><p>在这里有许多 emoji 的符号代码，你可以直接将它们用到 README 中。</p><blockquote><p><a href="https://www.webf![图片](../../../../img/blog/c5f21e5f5b071b1d6de7bf1e05cf9177_MD5.jpg)f5b071b1d6de7bf1e05cf9177_MD5.jpg">https://www.webf![图片](../../../../img/blog/c5f21e5f5b071b1d6de7bf1e05cf9177_MD5.jpg)f5b071b1d6de7bf1e05cf9177_MD5.jpg</a>)</p></blockquote><h2 id="2-2-GitHub-统计卡片"><a href="#2-2-GitHub-统计卡片" class="headerlink" title="2.2 GitHub 统计卡片"></a>2.2 GitHub 统计卡片</h2><p>在这里有不同主题的 GitHub 统计卡片，可以统计到你的 star，commit 等数据。</p><blockquote><p><a href="https://github.com/img/img/blog/564d94a6e310d6fed31589c18580850b_MD5.jpg)blog/564d94a6e310d6fed31589c18580850b_MD5.jpg">https://github.com/anuraghazra/github-read![图片](../../../../img/blog/e66d9a5708632818ce431af7934c1a53_MD5.jpg)/e66d9a5708632818c![图片](../../../../img/blog/564d94a6e310d6fed31589c18580850b_MD5.jpg)blog/564d94a6e310d6fed31589c18580850b_MD5.jpg</a>)</p></blockquote><h2 id="2-3-各种按钮"><a href="#2-3-各种按钮" class="headerlink" title="2.3 各种按钮"></a>2.3 各种按钮</h2><p>在这里有许多<img src="/../../../../img/blog/66c9e0a9fbe4644e36c1167b8cb061e5_MD5.jpg" alt="图片">..&#x2F;..&#x2F;img&#x2F;blog&#x2F;66<img src="/../../../../img/blog/db6ad38c705ca822f51a7baa6142f680_MD5.jpg" alt="图片">(..&#x2F;..&#x2F;..&#x2F;img&#x2F;blog&#x2F;db6ad38c705ca822f51a7baa6142f680_MD5.jpg)</p><h2 id="2-4-显示你最近的状态"><a href="#2-4-显示你最近的状态" class="headerlink" title="2.4 显示你最近的状态"></a>2.4 显示你最近的状态</h2><p>在这里可以显示你最近在 GitHub 上面做了些什<img src="/../../../../img/blog/314314c3a4bc6c8b17eb6c88867934a3_MD5.jpg" alt="图片"></p><p><img src="/../../../img/blog/314314c3a4bc6c8b17eb6c88867934a3_MD!%5B%E5%9B%BE%E7%89%87%5D(../../../../img/blog/5d49d7e176287cf10dff53dc943d6f1b_MD5.jpg" alt="图片">ns.org&#x2F;</p><p><img src="/../../../img/blog/5d49d7e176287cf10dff53dc943d6f1b_MD5.jpg" alt="图片"></p><h2 id="2-6-展示奖杯"><a href="#2-6-展示奖杯" class="headerlink" title="2.6 展示奖杯"></a>2.6 展示奖杯</h2><p>在这里可以统计 GitHub 的数据，并以奖杯的<img src="/../../../../img/blog/dea9c545e6b946f0b80b793169d3a83f_MD5.jpg" alt="图片">aster&#x2F;README.md</p><p><img src="/../../../img/blog/dea9c545e6b946f0b80b793169d3a83f_MD5.jpg" alt="图片"></p><h2 id="2-7-更多素材资源"><a href="#2-7-更多素材资源" class="headerlink" title="2.7 更多素材资源"></a>2.7 更多素材资源</h2><p>上面这些基本够你用了，如果你还想找更多的素材，可以<img src="/../../../../img/blog/4d1f232a664f9d81d6acb3edd4af227c_MD5.jpg" alt="图片">ub-profile-readme#tools</p><p><img src="/../../../img/blog/4d1f232a664f9d81d6acb3ed!%5B%E5%9B%BE%E7%89%87%5D(../../../../img/blog/e78f22cb866fd6c2a9cf58279259e94c_MD5.jpg" alt="图片">页啦。</p><p>你可以直接在 GitHub 上一边编辑一边预览。</p><p><img src="/../../../img/blog/e78f22cb8!%5B%E5%9B%BE%E7%89%87%5D(../../../../img/blog/9b7048b613cdc7d60ce0646e3ca76c28_MD5.jpg" alt="图片">ME 里面引用它们。</p><p>比如我就上传了自己的头像，然后让它显示并居中：</p><p><img src="/../../../img/blog/!%5B%E5%9B%BE%E7%89%87%5D(../../../../img/blog/4dd01be39d0480004196390243e7d781_MD5.jpg)%E6%B3%95!%5B%E5%9B%BE%E7%89%87%5D(../../../../img/blog/42c54cfe7404f7477314709b07249214_MD5.jpg)og/4dd01be39d0480004196390243e7d781_MD5.jpg" alt="图片"> <img src="/../../../img/blog/42c54cfe7404f7477314709b07249214_MD5.jpg" alt="图片"></p><p>对<img src="/../../../../img/blog/3a9957a806b6fd8e0b5b40905f7320ed_MD5.jpg" alt="图片">github.io&#x2F;gh-profile-r<img src="/../../../../img/blog/15fa6a21ef953cde035a4be238a92e08_MD5.jpg" alt="图片">b6fd8e0b5<img src="/../../../../img/blog/05623752e1ae843aa51a71f6acb1e1b6_MD5.jpg" alt="图片">g&#x2F;blog&#x2F;15fa6a21ef953cde035a4be238a92e08_MD5.jpg)</p><p>用就是了：</p><p><img src="/../../../img/blog/05623752e1ae843aa51a71f6acb1e1b6_MD5.jpg" alt="图片"></p><p>对于其他素材的使用方式，你可以直接参照相应文档食用，还是很方便的。</p>]]></content>
      
      
      <categories>
          
          <category> 应用 </category>
          
          <category> 编程工具 </category>
          
          <category> Git </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>chrome访问newbing</title>
      <link href="/posts/%E5%BA%94%E7%94%A8/ai/chrome%E8%AE%BF%E9%97%AEnewbing.html"/>
      <url>/posts/%E5%BA%94%E7%94%A8/ai/chrome%E8%AE%BF%E9%97%AEnewbing.html</url>
      
        <content type="html"><![CDATA[<p>前 New Bing 访问的比较麻烦，这里介绍一种稳定访问的方法。</p><p>首先假设你已经具备了科学上网的能力</p><p>我们可以实现脱离 edge 去访问，可以是 Chrome 浏览器，也可以是其他基于 Chromium 框架的浏览器。</p><p>这里强烈推荐使用 Sidekick 浏览器，能够稳定的保持登录环境和多账号。也是能够稳定访问的关键。下载地址 <a href="https://join.meetsidekick.com/7o7xy">https://join.meetsidekick.com/7o7xyopen in new window</a></p><h1 id="只需要简单的三步操作："><a href="#只需要简单的三步操作：" class="headerlink" title="只需要简单的三步操作："></a>只需要简单的三步操作：</h1><ul><li>第一步，安装 <a href="https://join.meetsidekick.com/7o7xy">Sidekickopen in new window</a> 浏览器。<a href="https://join.meetsidekick.com/7o7xy">点击下载open in new window</a></li><li>第二步，安装浏览器插件 <strong>Bing Unchained</strong>，<a href="https://chrome.google.com/webstore/detail/bing-unchained-use-new-bi/laldfnbbeocphnilnofhedhcjcnchbld">点击下载open in new window</a></li><li>第三步，按快捷键 <code>Ctrl + B</code> 打开 New Bing 网站，登录账号，修改配置<br>  - 回到 New Bing 主页，点击右上角的三道杠图标，进入设置<br>  - 设置地区为 “ 你 ip 所在的地区 “。<br>  - 有些朋友这里改过了之后，每次在打开网页就会变。但我的不会变，之所以这里推荐安装 <a href="https://join.meetsidekick.com/7o7xy">Sidekickopen in new window</a> 浏览器的关键点就在这里，会保持你的这个账号环境。</li><li>推荐安装 <a href="https://join.meetsidekick.com/7o7xy">Sidekickopen in new window</a> 浏览器的关键点就在这里，会保持你的这个账号环境。</li><li>如果不使用这个浏览器的话，每次重开地区就会恢复</li><li>你的上网环境 ip 地区不要老是跳动</li></ul>]]></content>
      
      
      <categories>
          
          <category> 应用 </category>
          
          <category> ai </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>A Tour of xmake - 06. 测试发布</title>
      <link href="/posts/%E5%AD%A6%E4%B9%A0/%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/Xmake/A%20Tour%20of%20xmake%20-%2006.%20%E6%B5%8B%E8%AF%95%E5%8F%91%E5%B8%83.html"/>
      <url>/posts/%E5%AD%A6%E4%B9%A0/%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/Xmake/A%20Tour%20of%20xmake%20-%2006.%20%E6%B5%8B%E8%AF%95%E5%8F%91%E5%B8%83.html</url>
      
        <content type="html"><![CDATA[<h1 id="工程信息"><a href="#工程信息" class="headerlink" title="工程信息"></a>工程信息</h1><p>对于较为正式的工程，xmake 推荐设置几个工程信息：</p><ul><li>工程名称。使用 <code>set_project</code> 语句设定，在一份 <code>xmake.lua</code> 中只能存在一份。</li><li>工程版本。使用 <code>set_version</code> 语句设定。</li><li>最低允许的 xmake 版本。使用 <code>set_xmakever</code> 指定。无法使用低于此版本的 xmake 编译项目。</li></ul><p>举例如下：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set_project(<span class="string">&quot;mylib&quot;</span>)</span><br><span class="line">set_version(<span class="string">&quot;1.0.0&quot;</span>)</span><br><span class="line">set_xmakever(<span class="string">&quot;2.6.1&quot;</span>)</span><br></pre></td></tr></table></figure><p>在此处设置的版本号会产生几个自动定义的配置变量：<code>$&#123;VERSION&#125;</code>、<code>$&#123;VERSION_MAJOR&#125;</code> 等。如果工程使用 Git 进行版本管理，xmake 还会定义 <code>$&#123;GIT_COMMIT&#125;</code> 等变量。</p><blockquote><p>Tips. Windows 上对于产生的二进制&#x2F;动态库，可以为其添加版本信息。这需要编写 resource 文件并将其加入工程中。xmake 中可以直接使用 <code>add_files</code> 接口添加这些文件。</p></blockquote><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><p>以 google test 框架为例进行说明。建立以下 C++ 库结构：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">root</span><br><span class="line">|- include</span><br><span class="line">    |- mylib.h</span><br><span class="line">|- src</span><br><span class="line">    |- mylib.cpp</span><br><span class="line">    |- mylib.def</span><br><span class="line">|- test</span><br><span class="line">    |- add.cpp</span><br><span class="line">    |- distract.cpp</span><br><span class="line">|- xmake.lua</span><br></pre></td></tr></table></figure><p>其中 mylib.cpp 中定义了 <code>int mylib_add(int, int)</code> 和 <code>int mylib_distract(int, int)</code> 两个函数。mylib.def 文件为 Windows definition module 文件，这个文件可以在不声明 <code>__declspec(dllexport)</code> 的情况下生成动态链接库，xmake 中可直接使用 <code>add_files</code> 接口将其加入项目。mylib.def 内容如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LIBRARY mylib</span><br><span class="line">EXPORTS</span><br><span class="line">    mylib_add</span><br><span class="line">    mylib_distract</span><br></pre></td></tr></table></figure><blockquote><p>Tips. xmake 中也可使用 <code>add_rules(&quot;utils.symbols.export_all&quot;)</code> 来生成 def 文件，并导出所有符号。</p></blockquote><p>test 文件夹下含有两个测试文件。add.cpp 内容如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;gtest/gtest.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mylib.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    ::testing::<span class="built_in">InitGoogleTest</span>(&amp;argc, argv);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">RUN_ALL_TESTS</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">TEST</span>(mylib, sum_zero) &#123;</span><br><span class="line">    <span class="keyword">auto</span> result = <span class="built_in">mylib_add</span>(<span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">ASSERT_EQ</span>(result, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">TEST</span>(mylib, sum_five) &#123;</span><br><span class="line">    <span class="keyword">auto</span> result = <span class="built_in">mylib_add</span>(<span class="number">1</span>, <span class="number">4</span>);</span><br><span class="line">    <span class="built_in">ASSERT_EQ</span>(result, <span class="number">5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>distract.cpp 类似，包含两个 distract 函数的测试。xmake.lua 内容如下</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">set_project(<span class="string">&quot;mylib&quot;</span>)</span><br><span class="line">set_version(<span class="string">&quot;1.0.0&quot;</span>)</span><br><span class="line">set_xmakever(<span class="string">&quot;2.6.9&quot;</span>)</span><br><span class="line"></span><br><span class="line">add_rules(<span class="string">&quot;mode.debug&quot;</span>, <span class="string">&quot;mode.release&quot;</span>)</span><br><span class="line">add_requires(<span class="string">&quot;gtest&quot;</span>)</span><br><span class="line"></span><br><span class="line">target(<span class="string">&quot;mylib&quot;</span>)</span><br><span class="line">    set_kind(<span class="string">&quot;$(kind)&quot;</span>)</span><br><span class="line">    add_files(<span class="string">&quot;src/mylib.cpp&quot;</span>)</span><br><span class="line">    add_includedirs(<span class="string">&quot;include&quot;</span>, &#123;public = <span class="literal">true</span>&#125;)</span><br><span class="line">    <span class="keyword">if</span> is_plat(<span class="string">&quot;windows&quot;</span>) <span class="keyword">and</span> is_kind(<span class="string">&quot;shared&quot;</span>) <span class="keyword">then</span></span><br><span class="line">        add_files(<span class="string">&quot;src/mylib.def&quot;</span>)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">target(<span class="string">&quot;test_add&quot;</span>)</span><br><span class="line">    set_kind(<span class="string">&quot;binary&quot;</span>)</span><br><span class="line">    set_group(<span class="string">&quot;tests&quot;</span>)</span><br><span class="line">    add_files(<span class="string">&quot;test/add.cpp&quot;</span>)</span><br><span class="line">    add_deps(<span class="string">&quot;mylib&quot;</span>)</span><br><span class="line">    add_packages(<span class="string">&quot;gtest&quot;</span>)</span><br><span class="line"></span><br><span class="line">target(<span class="string">&quot;test_distract&quot;</span>)</span><br><span class="line">    set_kind(<span class="string">&quot;binary&quot;</span>)</span><br><span class="line">    set_group(<span class="string">&quot;tests&quot;</span>)</span><br><span class="line">    add_files(<span class="string">&quot;test/distract.cpp&quot;</span>)</span><br><span class="line">    add_deps(<span class="string">&quot;mylib&quot;</span>)</span><br><span class="line">    add_packages(<span class="string">&quot;gtest&quot;</span>)</span><br></pre></td></tr></table></figure><p>运行 <code>xmake</code> 编译上述程序。再运行 <code>xmake run test_add</code> 即可看到 add.cpp 测试的结果：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ xmake run test_add</span><br></pre></td></tr></table></figure><p>注意 xmake.lua 中出现了一个新语句 <code>set_group</code>。这一语句将 target 加入一个名为 tests 的 group 中，在运行时可以一键全部运行：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ xmake run -g tests</span><br></pre></td></tr></table></figure><p>用这种方法可以执行项目中的全部测试。当某项测试失败时，该命令会直接退出。</p><p>测试当然也并不局限于框架。在测试 target 中可以通过 <code>on_run</code> 接口执行任意命令：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">target(<span class="string">&quot;test_script&quot;</span>)</span><br><span class="line">    set_kind(<span class="string">&quot;phony&quot;</span>)</span><br><span class="line">    set_group(<span class="string">&quot;tests&quot;</span>)</span><br><span class="line">    on_run(<span class="function"><span class="keyword">function</span> <span class="params">(target)</span></span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;log message&quot;</span>)</span><br><span class="line">        <span class="built_in">os</span>.exec(<span class="string">&quot;whatever you want&quot;</span>)</span><br><span class="line">    <span class="keyword">end</span>)</span><br></pre></td></tr></table></figure><blockquote><p>Tips. 类型为 <code>phony</code> 的 target 不会产生任何库或者可执行文件。它们可以用于理顺依赖结构、处理自定义命令等。</p></blockquote><h1 id="安装与发布"><a href="#安装与发布" class="headerlink" title="安装与发布"></a>安装与发布</h1><p>如果测试过程没有找到问题，那么就可以准备安装&#x2F;发布了。按照一般约定，C&#x2F;C++ 程序的安装目录结构如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">root</span><br><span class="line">|- bin</span><br><span class="line">|- include</span><br><span class="line">|- lib</span><br><span class="line">|- share</span><br><span class="line">|- ...</span><br></pre></td></tr></table></figure><p>这里 <code>bin</code> 存放生成的二进制文件和 Windows 上动态链接库文件，<code>include</code> 存放头文件，<code>lib</code> 存放链接库以及 Windows 上动态链接库的导入库（import library），<code>share</code> 则存放文档、数据等其他文件。当然这一目录也并不绝对，根据需求的不同，有时不按照约定反而更加方便。</p><p>xmake 中使用如下命令来安装一个项目：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ xmake install -o &lt;dist&gt;</span><br></pre></td></tr></table></figure><p><code>&lt;dist&gt;</code> 既可以是系统上存放第三方库的目录，也可以是自定义的其他目录（用于后续打包发布）。不同于 cmake 等构建系统，xmake 中安装路径是在编译完毕安装时进行指定的（而不是编译前），因此同一个项目在编译完成后可以被安装到多个位置。</p><h2 id="指定头文件"><a href="#指定头文件" class="headerlink" title="指定头文件"></a>指定头文件</h2><p>执行安装命令时，如果在 xmake.lua 中没有特殊指定，target 生成的二进制和库文件都会自动按上述约定路径安装。而要安装的头文件比较复杂，需要使用 <code>add_headerfiles</code> 语句指定。这一语句的基本用法如下：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add_headerfiles(<span class="string">&quot;include/(**.h)&quot;</span>, &#123;prefixdir = <span class="string">&quot;mylib&quot;</span>&#125;)</span><br></pre></td></tr></table></figure><p>通配符 <code>include/**.h</code> 匹配 include 目录及其子目录的所有.h 后缀文件。对于 <code>add_headerfiles</code> 语句，如果不加括号，则所有文件都会被直接安装到 <code>include</code> 文件夹下，目录结构将会丢失；而括号的作用在于保持括号内的目录结构。例如 <code>a/(b/c.h)</code> 安装后会变成 <code>include/b/c.h</code>。而在设置中的 <code>prefixdir</code> 选项则将所有头文件放在 <code>include</code> 的子目录中。如对于上述设置 <code>&#123;prefixdir = &quot;mylib&quot;&#125;</code>，<code>a/(b/c.h)</code> 安装后会变成 <code>include/mylib/b/c.h</code>。</p><blockquote><p>Tips. 对部分 IDE 项目生成器，<code>add_headerfiles</code> 不仅指定安装时安装的头文件，还设定了 IDE 项目中可见的头文件。如果仅将此语句用于项目生成，不希望对应头文件被安装，可以使用 <code>add_headerfiles(&lt;file&gt;, &#123;install = false&#125;)</code> 选项。</p></blockquote><h2 id="生成配置文件"><a href="#生成配置文件" class="headerlink" title="生成配置文件"></a>生成配置文件</h2><p>有时候使用 xmake 构建的库需要导出给使用其他构建系统的项目使用，这就需要对应构建工具的配置文件。xmake 提供 pkg-config 配置文件和 cmake 配置文件的生成。对于需要导出的 target，使用如下语句：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">add_rules(<span class="string">&quot;utils.install.pkgconfig_importfiles&quot;</span>)</span><br><span class="line">add_rules(<span class="string">&quot;utils.install.cmake_importfiles&quot;</span>)</span><br></pre></td></tr></table></figure><p>这两个语句会在 <code>lib</code> 文件夹下生成对应的配置文件。关于如何使用这些配置文件，请参考对应构建工具的文档。</p><h2 id="安装其它文件"><a href="#安装其它文件" class="headerlink" title="安装其它文件"></a>安装其它文件</h2><p>对于头文件之外的安装文件，xmake 提供了类似的接口 <code>add_installfiles</code>，它与 <code>add_headerfiles</code> 的区别在于，<code>prefixdir</code> 将直接放在安装目录下而不是 <code>include</code> 文件夹下。例如文档安装可以写</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add_installfiles(<span class="string">&quot;doc/*.md&quot;</span>, &#123;prefixdir = <span class="string">&quot;share/doc&quot;</span>&#125;)</span><br></pre></td></tr></table></figure><p>数据等文件同理。</p><h2 id="自定义安装过程"><a href="#自定义安装过程" class="headerlink" title="自定义安装过程"></a>自定义安装过程</h2><p>有时候，项目生成的库和二进制不要按约定的 <code>bin</code> 和 <code>lib</code> 目录存放，甚至不需要被安装。还有时候，安装的文件需要根据安装目录做一定的更改。这时可以使用 <code>on_install</code> 语句来重载 target 的安装过程。例如，将生成的库文件安装到 <code>mylib</code> 文件夹：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">target(<span class="string">&quot;mylib&quot;</span>)</span><br><span class="line">    ...</span><br><span class="line">    on_install(<span class="function"><span class="keyword">function</span> <span class="params">(target)</span></span></span><br><span class="line">        <span class="keyword">local</span> libdir = <span class="built_in">path</span>.join(target:installdir(), <span class="string">&quot;mylib&quot;</span>)</span><br><span class="line">        <span class="built_in">os</span>.mkdir(libdir)</span><br><span class="line">        <span class="built_in">os</span>.cp(target:targetfile(), libdir)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">local</span> includedir = <span class="built_in">path</span>.join(target:installdir(), <span class="string">&quot;myinclude&quot;</span>)</span><br><span class="line">        <span class="built_in">os</span>.mkdir(includedir)</span><br><span class="line">        <span class="keyword">for</span> _, headerfile <span class="keyword">in</span> <span class="built_in">ipairs</span>(target:headerfiles()) <span class="keyword">do</span></span><br><span class="line">            <span class="built_in">os</span>.cp(headerfile, includedir)</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span>)</span><br></pre></td></tr></table></figure><p>在重载 target 中部分过程时，可以参考 xmake 内部的实现。可以使用 git clone xmake 项目到本地，使用 IDE 中的搜索功能搜索需要的实现部分（例如搜索 install_headers），也可以访问 <a href="https://link.zhihu.com/?target=https://github1s.com/xmake-io/xmake">在线编辑器</a> 来查看。</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> 构建工具 </category>
          
          <category> Xmake </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>A Tour of xmake - 05. 构建选项</title>
      <link href="/posts/%E5%AD%A6%E4%B9%A0/%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/Xmake/A%20Tour%20of%20xmake%20-%2005.%20%E6%9E%84%E5%BB%BA%E9%80%89%E9%A1%B9.html"/>
      <url>/posts/%E5%AD%A6%E4%B9%A0/%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/Xmake/A%20Tour%20of%20xmake%20-%2005.%20%E6%9E%84%E5%BB%BA%E9%80%89%E9%A1%B9.html</url>
      
        <content type="html"><![CDATA[<h1 id="常用-C-x2F-C-项目描述设置详解"><a href="#常用-C-x2F-C-项目描述设置详解" class="headerlink" title="常用 C&#x2F;C++ 项目描述设置详解"></a>常用 C&#x2F;C++ 项目描述设置详解</h1><h2 id="先来一段最简短的"><a href="#先来一段最简短的" class="headerlink" title="先来一段最简短的"></a>先来一段最简短的</h2><p>一行描述即可编译 src 目录下所有 c 源文件，然后生成一个名为 demo 的可执行文件。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">target(<span class="string">&quot;demo&quot;</span>, &#123;kind = <span class="string">&quot;binary&quot;</span>, files = <span class="string">&quot;src/*.c&quot;</span>&#125;)</span><br></pre></td></tr></table></figure><p>上面的写法是精简写法，通常我们更推荐使用下面展开式写法：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">target(<span class="string">&quot;demo&quot;</span>) </span><br><span class="line">    set_kind(<span class="string">&quot;binary&quot;</span>) </span><br><span class="line">    add_files(<span class="string">&quot;src/*.c&quot;</span>)</span><br></pre></td></tr></table></figure><p>这两者完全等价，如果配置很简短，可以完全精简成一行，而拆分成多行更加方便灵活配置。</p><p>如果没有特殊目的，下文我们都会采用第二段的写法。</p><h2 id="配置项目目标类型"><a href="#配置项目目标类型" class="headerlink" title="配置项目目标类型"></a>配置项目目标类型</h2><p>通常的 C&#x2F;C++ 项目生成的目标文件猪油三大类：可执行程序，静态库，动态库。</p><p>我们可以通过 <code>set_kind()</code> 配置来设置，分别对应：binary, static, shared</p><p>例如，我们想要编译动态库，只需要修改 kind：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">target(<span class="string">&quot;demo&quot;</span>) </span><br><span class="line">    set_kind(<span class="string">&quot;shared&quot;</span>) </span><br><span class="line">    add_files(<span class="string">&quot;src/*.c&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="添加宏定义"><a href="#添加宏定义" class="headerlink" title="添加宏定义"></a>添加宏定义</h2><p>编译宏的设置，大多数 c&#x2F;c++ 项目都会用到，一般如果我们设置编译 flags 传给 gcc&#x2F;clang，都是要配置：<code>-DXXX</code></p><p>而在 xmake 里面，提供了 <code>add_defines()</code> 内置接口来配置：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">target(<span class="string">&quot;demo&quot;</span>) </span><br><span class="line">    set_kind(<span class="string">&quot;shared&quot;</span>) </span><br><span class="line">    add_files(<span class="string">&quot;src/*.c&quot;</span>) </span><br><span class="line">    add_defines(<span class="string">&quot;XXX&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="条件配置"><a href="#条件配置" class="headerlink" title="条件配置"></a>条件配置</h2><p>那如果我们想在不同编译平台，分别设置不同的宏开关呢？我们可以利用 lua 内置的 if 语句很方便的实现：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">target(<span class="string">&quot;demo&quot;</span>) </span><br><span class="line">    set_kind(<span class="string">&quot;shared&quot;</span>) </span><br><span class="line">    add_files(<span class="string">&quot;src/*.c&quot;</span>) </span><br><span class="line">    add_defines(<span class="string">&quot;XXX&quot;</span>) </span><br><span class="line">    <span class="keyword">if</span> is_plat(<span class="string">&quot;linux&quot;</span>, <span class="string">&quot;macosx&quot;</span>) <span class="keyword">then</span> </span><br><span class="line">       add_defines(<span class="string">&quot;YYY&quot;</span>) </span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>我们通过 <code>is_plat()</code> 判断，如果当前编译目标平台是 linux 或者 macosx，那么 target 会额外增加 <code>-DYYY</code> 宏定义。</p><h2 id="全局配置"><a href="#全局配置" class="headerlink" title="全局配置"></a>全局配置</h2><p>我们在 <code>target(&quot;demo&quot;)</code> 下面的所有配置，都属于 demo 这个 target 子域，并不是全局的，所以你会看到通常配置上都加了缩进，就是为了凸显作用域的影响范围。</p><p>通常如果多个 target 连续定义，下一个 target 定义就会自动结束上个 target 的作用域，每个 target 的配置完全独立，互不干扰：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">target(<span class="string">&quot;test1&quot;</span>)</span><br><span class="line">    set_kind(<span class="string">&quot;shared&quot;</span>)</span><br><span class="line">    add_files(<span class="string">&quot;src/*.c&quot;</span>)</span><br><span class="line">    add_defines(<span class="string">&quot;TEST1&quot;</span>)</span><br><span class="line"></span><br><span class="line">target(<span class="string">&quot;test2&quot;</span>)</span><br><span class="line">    set_kind(<span class="string">&quot;shared&quot;</span>)</span><br><span class="line">    add_files(<span class="string">&quot;src/*.c&quot;</span>)</span><br><span class="line">    add_defines(<span class="string">&quot;TEST2&quot;</span>)</span><br></pre></td></tr></table></figure><p>例如，上面的配置两个 target，各自拥有自己独立的宏定义：<code>TEST1</code> 和 <code>TEST2</code>。</p><p>那么，我们要对这两个 target，设置共用的宏定义，应该如何配置呢？</p><p>每个 target 下面都配置一遍 <code>add_defines(&quot;TEST&quot;)</code>? 当然可以，不过这样就有点冗余了，配置多了就会很难维护，其实我们只需要放置到全局根作用域就行了：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 全局设置</span></span><br><span class="line">add_defines(<span class="string">&quot;TEST&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> is_arch(<span class="string">&quot;arm64&quot;</span>, <span class="string">&quot;armv7&quot;</span>) <span class="keyword">then</span></span><br><span class="line">    add_defines(<span class="string">&quot;ARM&quot;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">target(<span class="string">&quot;test1&quot;</span>)</span><br><span class="line">    set_kind(<span class="string">&quot;shared&quot;</span>)</span><br><span class="line">    add_files(<span class="string">&quot;src/*.c&quot;</span>)</span><br><span class="line">    add_defines(<span class="string">&quot;TEST1&quot;</span>)</span><br><span class="line"></span><br><span class="line">target(<span class="string">&quot;test2&quot;</span>)</span><br><span class="line">    set_kind(<span class="string">&quot;shared&quot;</span>)</span><br><span class="line">    add_files(<span class="string">&quot;src/*.c&quot;</span>)</span><br><span class="line">    add_defines(<span class="string">&quot;TEST2&quot;</span>)</span><br></pre></td></tr></table></figure><p>在 target 的外层的所有配置都属于全局配置，我们也可以调用 <code>target_end()</code> 强制结束 target 子域，切回全局作用域：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">target(<span class="string">&quot;test1&quot;</span>)</span><br><span class="line">    set_kind(<span class="string">&quot;shared&quot;</span>)</span><br><span class="line">    add_files(<span class="string">&quot;src/*.c&quot;</span>)</span><br><span class="line">    add_defines(<span class="string">&quot;TEST1&quot;</span>)</span><br><span class="line">target_end()</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 全局设置</span></span><br><span class="line">add_defines(<span class="string">&quot;TEST&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> is_arch(<span class="string">&quot;arm64&quot;</span>, <span class="string">&quot;armv7&quot;</span>) <span class="keyword">then</span></span><br><span class="line">    add_defines(<span class="string">&quot;ARM&quot;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">target(<span class="string">&quot;test2&quot;</span>)</span><br><span class="line">    set_kind(<span class="string">&quot;shared&quot;</span>)</span><br><span class="line">    add_files(<span class="string">&quot;src/*.c&quot;</span>)</span><br><span class="line">    add_defines(<span class="string">&quot;TEST2&quot;</span>)</span><br><span class="line">target_end()</span><br></pre></td></tr></table></figure><h2 id="添加编译选项"><a href="#添加编译选项" class="headerlink" title="添加编译选项"></a>添加编译选项</h2><p>如果有些编译选项，xmake 没有提供内置 api 设置，那么我们可以退化到 <code>add_cflags</code>, <code>add_cxflags</code>, <code>add_cxxflags</code> 来设置， 不过这就需要用户自己去判断编译平台了，因为并不是所有编译 flags 每个平台都支持。</p><p>比如：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">add_cflags(<span class="string">&quot;-g&quot;</span>, <span class="string">&quot;-O2&quot;</span>, <span class="string">&quot;-DDEBUG&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> is_plat(<span class="string">&quot;windows&quot;</span>) <span class="keyword">then</span></span><br><span class="line">    add_cflags(<span class="string">&quot;/MT&quot;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>所有选项值都基于 gcc 的定义为标准，如果其他编译器不兼容（例如：vc），xmake 会自动内部将其转换成对应编译器支持的选项值。 用户无需操心其兼容性，如果其他编译器没有对应的匹配值，那么 xmake 会自动忽略器设置。</p><p>我们也可以通过 force 参数来强制禁用 flags 的自动检测，直接传入编译器，哪怕编译器有可能不支持，也会设置：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add_cflags(<span class="string">&quot;-g&quot;</span>, <span class="string">&quot;-O2&quot;</span>, &#123;force = <span class="literal">true</span>&#125;)</span><br></pre></td></tr></table></figure><p>那如何知道，哪些 flags 检测失败给忽略了呢，带 <code>-v</code> 编译就可以看到，比如：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ xmake -v</span><br><span class="line">checking <span class="keyword">for</span> the /usr/bin/xcrun -sdk macosx clang ... ok</span><br><span class="line">checking <span class="keyword">for</span> the flags (-Oz) ... ok</span><br><span class="line">checking <span class="keyword">for</span> the flags (-Wno-error=deprecated-declarations) ... ok</span><br><span class="line">checking <span class="keyword">for</span> the flags (-fno-strict-aliasing) ... ok</span><br><span class="line">checking <span class="keyword">for</span> the flags (-Wno-error=expansion-to-defined) ... no</span><br></pre></td></tr></table></figure><p>最后备注下这三个 api 的区别：</p><ul><li><code>add_cflags</code>：仅添加 C 代码相关编译 flags</li><li><code>add_cxflags</code>：添加 C&#x2F;C++ 代码相关编译 flags</li><li><code>add_cxxflags</code>：仅添加 C++ 代码相关编译 flags</li></ul><h2 id="添加库相关设置"><a href="#添加库相关设置" class="headerlink" title="添加库相关设置"></a>添加库相关设置</h2><p>一个 C&#x2F;C++ 库的集成使用，通常需要设置头文件搜索目录，链接库名，库搜索目录，比如：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">target(<span class="string">&quot;test&quot;</span>)</span><br><span class="line">    set_kind(<span class="string">&quot;binary&quot;</span>)</span><br><span class="line">    add_links(<span class="string">&quot;pthread&quot;</span>)</span><br><span class="line">    add_includedirs(<span class="string">&quot;/usr/local/include&quot;</span>)</span><br><span class="line">    add_linkdirs(<span class="string">&quot;/usr/local/lib&quot;</span>)</span><br></pre></td></tr></table></figure><p>通常，为了保证链接库的依赖顺序，系统库链接通常都会比较靠后，我们通过 <code>add_syslinks()</code> 来专门设置系统库链接，而 <code>add_links()</code> 通常用于非系统库链接：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">target(<span class="string">&quot;test&quot;</span>) </span><br><span class="line">    set_kind(<span class="string">&quot;binary&quot;</span>) </span><br><span class="line">    add_links(<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>) </span><br><span class="line">    add_syslinks(<span class="string">&quot;pthread&quot;</span>)</span><br></pre></td></tr></table></figure><p>上面的配置，我们添加了两个第三方链接库：A, B，以及系统库 pthread，整个完整的链接顺序是：<code>-lA -lB -lpthread</code>，syslinks 会放在最后面。</p><p>如果你不确定实际的链接顺序，我们可以执行 <code>xmake -v</code> 编译，查看完整的链接参数命令行。</p><h2 id="设置语言标准"><a href="#设置语言标准" class="headerlink" title="设置语言标准"></a>设置语言标准</h2><p>c 标准和 c++ 标准可同时进行设置，例如：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 设置c代码标准：c99， c++代码标准：c++11</span></span><br><span class="line">set_languages(<span class="string">&quot;c99&quot;</span>, <span class="string">&quot;c++11&quot;</span>)</span><br></pre></td></tr></table></figure><p>注：并不是设置了指定的标准，编译器就一定会按这个标准来编译，毕竟每个编译器支持的力度不一样，但是 xmake 会尽最大可能的去适配当前编译工具的支持标准。</p><p>例如：windows 下 vs 的编译器并不支持按 c99 的标准来编译 c 代码，只能支持到 c89，但是 xmake 为了尽可能的支持它，所以在设置 c99 的标准后， xmake 会强制按 c++ 代码模式去编译 c 代码，从一定程度上解决了 windows 下编译 c99 的 c 代码问题。</p><h2 id="设置编译优化"><a href="#设置编译优化" class="headerlink" title="设置编译优化"></a>设置编译优化</h2><p>xmake 提供了几种内置的编译优化配置：none, fast, faster, fastest, smallest, aggressive，来实现各种级别的编译优化。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set_optimize(<span class="string">&quot;fastest&quot;</span>)</span><br></pre></td></tr></table></figure><p>如果用户通过 flags 来设置，还需额外考虑不同编译器的不同编译选项，xmake 对其进行了内部映射处理，极大程度方便用户提供跨平台性。</p><p>如果想查看详细的映射规则，可以到 xmake 的官方文档进行查看：<a href="https://link.zhihu.com/?target=https://xmake.io/%23/zh-cn/manual/project_target?id=targetset_optimize">编译优化设置</a></p><h2 id="调试和发布模式"><a href="#调试和发布模式" class="headerlink" title="调试和发布模式"></a>调试和发布模式</h2><p>即使 xmake 提供了 <code>set_optimize</code> 简化了不同编译器的复杂配置，但是对于不同的编译模式: debug&#x2F;release，还是要自己做一些繁琐的判断和配置：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> is_mode(<span class="string">&quot;debug&quot;</span>) <span class="keyword">then</span></span><br><span class="line">    set_symbols(<span class="string">&quot;debug&quot;</span>)</span><br><span class="line">    set_optimize(<span class="string">&quot;none&quot;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">if</span> is_mode(<span class="string">&quot;release&quot;</span>) <span class="keyword">then</span></span><br><span class="line">    set_symbols(<span class="string">&quot;hidden&quot;</span>)</span><br><span class="line">    set_strip(<span class="string">&quot;all&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> is_plat(<span class="string">&quot;iphoneos&quot;</span>, <span class="string">&quot;android&quot;</span>) <span class="keyword">then</span></span><br><span class="line">        set_optimize(<span class="string">&quot;smallest&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        set_optimize(<span class="string">&quot;fastest&quot;</span>)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>这些看似常用的设置，如果每个项目都来一遍，那也很繁琐了，导致 xmake.lua 不够精简可读，因此 xmake 提供了一些常用内置规则来简化设置：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add_rules(<span class="string">&quot;mode.release&quot;</span>, <span class="string">&quot;mode.debug&quot;</span>)</span><br></pre></td></tr></table></figure><p>只需这一行即可，效果是完全一致，用户还可以基于此在做一些额外的定制化配置来改写：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">add_rules(<span class="string">&quot;mode.release&quot;</span>, <span class="string">&quot;mode.debug&quot;</span>) </span><br><span class="line"><span class="keyword">if</span> is_mode(<span class="string">&quot;release&quot;</span>) <span class="keyword">then</span> </span><br><span class="line">    set_optimize(<span class="string">&quot;fastest&quot;</span>) </span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>比如我想在 release 模式下，强制启用 fastest 编译优化，既然有了模式配置，那我们怎么切换到 debug 模式编译呢？（默认是 release 编译）</p><p>答案：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xmake f -m debug; xmake</span><br></pre></td></tr></table></figure><h2 id="添加源文件"><a href="#添加源文件" class="headerlink" title="添加源文件"></a>添加源文件</h2><p>最后，我们在介绍下 xmake 最常用，也最为强大的设置之一，也就是对编译源文件的配置管理：<code>add_files()</code>。</p><p>我们可以用这个接口，添加各类 xmake 支持的源文件，比如：c&#x2F;c++, asm, objc, swift, go, dlang 等源文件，甚至是：<code>.obj</code>, <code>.a/.lib</code> 等二进制对象和库文件。</p><p>例如：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">add_files(&quot;src/test_*.c&quot;) </span><br><span class="line">add_files(&quot;src/xxx/**.cpp&quot;) </span><br><span class="line">add_files(&quot;src/asm/*.S&quot;, &quot;src/objc/**/hello.m&quot;)</span><br></pre></td></tr></table></figure><p>其中通配符 <code>*</code> 表示匹配当前目录下文件，而 <code>**</code> 则匹配多级目录下的文件。</p><p><code>add_files</code> 的使用其实是相当灵活方便的，其匹配模式借鉴了 premake 的风格，但是又对其进行了改善和增强。</p><p>使得不仅可以匹配文件，还有可以在添加文件同时，过滤排除指定模式的一批文件。</p><p>例如：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 递归添加src下的所有c文件，但是不包括src/impl/下的所有c文件</span></span><br><span class="line">add_files(<span class="string">&quot;src/**.c|impl/*.c&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 添加src下的所有cpp文件，但是不包括src/test.cpp、src/hello.cpp以及src下所有带xx_前缀的cpp文件</span></span><br><span class="line">add_files(<span class="string">&quot;src/*.cpp|test.cpp|hello.cpp|xx_*.cpp&quot;</span>)</span><br></pre></td></tr></table></figure><p>其中分隔符 <code>|</code> 之后的都是需要排除的文件，这些文件也同样支持匹配模式，并且可以同时添加多个过滤模式，只要中间用 <code>|</code> 分割就行了。。</p><p>添加文件的时候支持过滤一些文件的一个好处就是，可以为后续根据不同开关逻辑添加文件提供基础。</p><p>注：为了使得描述上更加的精简，<code>|</code> 之后的过滤描述都是基于起一个模式：<code>src/*.cpp</code> 中 <code>*</code> 之前的目录为基础的。 所以上面的例子后面过滤的都是在 src 下的文件，这个是要注意的。</p><p>2.1.6 版本之后，对 <code>add_files</code> 进行了改进，支持基于 files 更细粒度的编译选项控制，例如：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">target(<span class="string">&quot;test&quot;</span>)</span><br><span class="line">    add_defines(<span class="string">&quot;TEST1&quot;</span>)</span><br><span class="line">    add_files(<span class="string">&quot;src/*.c&quot;</span>)</span><br><span class="line">    add_files(<span class="string">&quot;test/*.c&quot;</span>, <span class="string">&quot;test2/test2.c&quot;</span>, &#123;defines = <span class="string">&quot;TEST2&quot;</span>, languages = <span class="string">&quot;c99&quot;</span>, includedirs = <span class="string">&quot;.&quot;</span>, cflags = <span class="string">&quot;-O0&quot;</span>&#125;)</span><br></pre></td></tr></table></figure><p>可以在 <code>add_files</code> 的最后一个参数，传入一个配置 table，去控制指定 files 的编译选项，里面的配置参数跟 target 的一致，并且这些文件还会继承 target 的通用配置 <code>-DTEST1</code>。</p><p>2.1.9 版本之后，支持添加未知的代码文件，通过设置 rule 自定义规则，实现这些文件的自定义构建，例如：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">target(<span class="string">&quot;test&quot;</span>) </span><br><span class="line">    <span class="comment">-- ... </span></span><br><span class="line">    add_files(<span class="string">&quot;src/test/*.md&quot;</span>, &#123;rule = <span class="string">&quot;markdown&quot;</span>&#125;)</span><br></pre></td></tr></table></figure><p>并且在 2.1.9 版本之后，可以通过 force 参数来强制禁用 cxflags,cflags 等编译选项的自动检测，直接传入编译器，哪怕编译器有可能不支持，也会设置：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add_files(<span class="string">&quot;src/*.c&quot;</span>, &#123;force = &#123;cxflags = <span class="string">&quot;-DTEST&quot;</span>, mflags = <span class="string">&quot;-framework xxx&quot;</span>&#125;&#125;)</span><br></pre></td></tr></table></figure><h2 id="删除指定源文件"><a href="#删除指定源文件" class="headerlink" title="删除指定源文件"></a>删除指定源文件</h2><p>既然讲到了添加源文件，那么如何删除，我们也顺带着讲下吧，我们只需要通过 <code>del_files()</code> 接口，就可以从前面 <code>add_files</code> 接口添加的文件列表中，删除指定的文件，例如：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">target(<span class="string">&quot;test&quot;</span>) </span><br><span class="line">    add_files(<span class="string">&quot;src/*.c&quot;</span>) </span><br><span class="line">    del_files(<span class="string">&quot;src/test.c&quot;</span>)</span><br></pre></td></tr></table></figure><p>上面的例子，可以从 <code>src</code> 目录下添加除 <code>test.c</code> 以外的所有文件，当然这个也可以通过 <code>add_files(&quot;src/*.c|test.c&quot;)</code> 来达到相同的目的，但是这种方式更加灵活。</p><p>例如，我们可以条件判断来控制删除哪些文件，并且此接口也支持 <code>add_files</code> 的匹配模式，过滤模式，进行批量移除。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">target(<span class="string">&quot;test&quot;</span>) </span><br><span class="line">    add_files(<span class="string">&quot;src/**.c&quot;</span>) </span><br><span class="line">    del_files(<span class="string">&quot;src/test*.c&quot;</span>) </span><br><span class="line">    del_files(<span class="string">&quot;src/subdir/*.c|xxx.c&quot;</span>) </span><br><span class="line">    <span class="keyword">if</span> is_plat(<span class="string">&quot;iphoneos&quot;</span>) <span class="keyword">then</span> </span><br><span class="line">        add_files(<span class="string">&quot;xxx.m&quot;</span>) </span><br><span class="line">    <span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>通过上面的例子，我们可以看出 <code>add_files</code> 和 <code>del_files</code> 是根据调用顺序，进行顺序添加和删除的，并且通过 <code>del_files(&quot;src/subdir/*.c|xxx.c&quot;)</code> 删除一批文件， 并且排除 <code>src/subdir/xxx.c</code>（就是说，不删除这个文件）。</p><h1 id="使用选项切换构建参数"><a href="#使用选项切换构建参数" class="headerlink" title="使用选项切换构建参数"></a>使用选项切换构建参数</h1><h2 id="添加构建选项"><a href="#添加构建选项" class="headerlink" title="添加构建选项"></a>添加构建选项</h2><p>xmake 中使用 <code>option</code> 语句来声明构建选项。<code>option</code> 的基本用法如下：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">add_rules(<span class="string">&quot;mode.debug&quot;</span>, <span class="string">&quot;mode.release&quot;</span>)</span><br><span class="line">option(<span class="string">&quot;enable-verbose&quot;</span>)</span><br><span class="line">    set_default(<span class="literal">false</span>)</span><br><span class="line">    set_description(<span class="string">&quot;Enable verbose logging.&quot;</span>)</span><br><span class="line">    add_defines(<span class="string">&quot;MYEXE_VERBOSE&quot;</span>)</span><br><span class="line">target(<span class="string">&quot;myexe&quot;</span>)</span><br><span class="line">    set_kind(<span class="string">&quot;binary&quot;</span>)</span><br><span class="line">    add_files(<span class="string">&quot;src/*.cpp&quot;</span>)</span><br><span class="line">    add_options(<span class="string">&quot;enable-verbose&quot;</span>)</span><br></pre></td></tr></table></figure><p>注意与 <code>target</code> 语句类似，<code>option</code> 也是一个作用域的开始，之后一直到另一个作用域开始，或者显式的 <code>option_end</code> 调用之前的语句都是修饰当前 option 的。在上面的语句中，<code>option</code> 作用域一共含有三条语句。</p><ul><li><code>set_default</code> 语句设置 option 的默认值。xmake 中 option 可分为两类：boolean 和 string。boolean 类型的默认值可以是 <code>true</code>、<code>false</code> 或者 <code>nil</code>，string 类型的默认值可以是任意字符串或者 <code>nil</code>。</li><li><code>set_description</code> 语句设置 option 的描述语句。这一描述可以在通过运行 <code>xmake config -h</code> 或者 <code>xmake config --menu</code> 查看所有 option 时看到。</li><li><code>add_defines</code> 为 option 加入了一个预定义宏。默认情况下，在使用 <code>add_options</code> 将 option 加入 target 时，如果 option 含有预定义宏、编译参数等，并且 option 的状态是启用的（不是 <code>nil</code> 或 <code>false</code>），则 target 也会加入这些预定义宏和编译参数。</li></ul><blockquote><p>Tips. xmake 中作用域级别的语句有六种：<code>target</code> 和 <code>target_end</code>、<code>package</code> 和 <code>package_end</code>，<code>option</code> 和 <code>option_end</code>、<code>rule</code> 和 <code>rule_end</code>、<code>toolchain</code> 和 <code>toolchain_end</code>、<code>task</code> 和 <code>task_end</code>。其中前面三种比较常用。</p></blockquote><p>除了 <code>add_defines</code> 之外，xmake 中的 option 还支持 <code>add_&lt;language&gt;flags</code> 系列函数。如果要作更复杂的控制，可以使用 <code>has_config</code> 和 <code>is_config</code> 语句来进行判断：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">add_rules(<span class="string">&quot;mode.debug&quot;</span>, <span class="string">&quot;mode.release&quot;</span>)</span><br><span class="line">option(<span class="string">&quot;with-openssl&quot;</span>, &#123;default = <span class="literal">false</span>, description = <span class="string">&quot;Build with OpenSSL.&quot;</span>&#125;)</span><br><span class="line"><span class="keyword">if</span> has_config(<span class="string">&quot;with-openssl&quot;</span>) <span class="keyword">then</span></span><br><span class="line">    add_requires(<span class="string">&quot;openssl&quot;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">target(<span class="string">&quot;myexe&quot;</span>)</span><br><span class="line">    set_kind(<span class="string">&quot;binary&quot;</span>)</span><br><span class="line">    add_files(<span class="string">&quot;src/*.cpp&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> has_config(<span class="string">&quot;with-openssl&quot;</span>) <span class="keyword">then</span></span><br><span class="line">        add_packages(<span class="string">&quot;openssl&quot;</span>)</span><br><span class="line">        add_defines(<span class="string">&quot;MYEXE_HAVE_OPENSSL&quot;</span>)</span><br><span class="line">    <span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>这里用到了 <code>option</code> 的简写格式，这一格式下 <code>option</code> 不再作为作用域开始的标记。</p><h2 id="内置选项"><a href="#内置选项" class="headerlink" title="内置选项"></a>内置选项</h2><p>xmake 提供了一系列内置选项，在给自定义选项命名时记得避免与内置选项重名！常用的内置选项有：</p><ul><li><code>plat</code>：设置构建目标平台。</li><li><code>arch</code>：设置构建目标架构。</li><li><code>mode</code>：设置构建模式。</li><li><code>kind</code>：设置默认链接库类型。</li><li><code>buildir</code>：设置生成位置。默认为 <code>build</code>，可以使用这一选项更改。推荐对不同的选项组合使用不同的生成位置以避免冲突。</li></ul><p>还有一些可能比较少用但很容易重名的内置选项，包括 <code>qt</code>、<code>cuda</code>、<code>ndk</code>、<code>sdk</code> 等。这些选项的清单及其作用可以运行 <code>xmake config -h</code> 查看。</p><h2 id="指定构建选项"><a href="#指定构建选项" class="headerlink" title="指定构建选项"></a>指定构建选项</h2><p>xmake 在 configure 阶段指定各种构建选项。对 boolean 选项与 string 选项类型的指定方式类似，稍有不同：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ xmake config --opt1=yes --opt2=y --opt3=on # yes/no, y/n, on/off are all valid</span><br><span class="line">$ xmake config --str1=mystr &quot;--str2=some string&quot;</span><br></pre></td></tr></table></figure><p>当构建选项较多时，一个一个指定是一件很困难的事情。这时可以将一组选项导出为列表，切换时可以在列表间切换。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ xmake config --opt1=yes --opt2=mystr --buildir=build-preset1</span><br><span class="line">$ xmake config --export=preset1.txt</span><br></pre></td></tr></table></figure><p>这样就可以把当前所有构建选项导出到 preset1.txt 文件。需要导入构建选项时，执行</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ xmake config -c --import=preset1.txt</span><br></pre></td></tr></table></figure><p>这里 <code>-c</code> 表示先清除其他选项设置，避免干扰。</p><h2 id="构建选项依赖"><a href="#构建选项依赖" class="headerlink" title="构建选项依赖"></a>构建选项依赖</h2><p>xmake 中使用 <code>add_deps</code> 语句来声明选项之间的依赖关系。例如，选项 opt2 依赖选项 opt1，当设置 opt1 时 opt2 自动取消，xmake.lua 如下：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">option(<span class="string">&quot;opt1&quot;</span>, &#123;default = <span class="literal">false</span>&#125;)</span><br><span class="line">option(<span class="string">&quot;opt2&quot;</span>)</span><br><span class="line">    set_default(<span class="literal">true</span>)</span><br><span class="line">    add_deps(<span class="string">&quot;opt1&quot;</span>)</span><br><span class="line">    after_check(<span class="function"><span class="keyword">function</span> <span class="params">(option)</span></span></span><br><span class="line">        <span class="keyword">if</span> option:dep(<span class="string">&quot;opt1&quot;</span>):enabled() <span class="keyword">then</span></span><br><span class="line">            option:enable(<span class="literal">false</span>)</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span>)</span><br><span class="line">option_end()</span><br></pre></td></tr></table></figure><p>这里 <code>after_check</code> 语句接收了一个 Lua lambda 表达式作为参数，这个表达式函数会在选项的检查结束后执行，将 opt2 设置为与 opt1 相容的值。<code>option：enable(false)</code> 中 <code>option</code> 是函数的参数，调用函数时这个参数由 xmake 来构造。<code>enable</code> 是 <code>option</code> 的一个函数，用于修改 boolean 类型 option 的值。对于 string 类型的 option，这里可以使用 <code>set_value</code> 函数来设置：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> option:dep(<span class="string">&quot;opt1&quot;</span>):enabled() <span class="keyword">then</span></span><br><span class="line">    option:set_value(<span class="string">&quot;opt1&quot;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><blockquote><p>Tips. 所有 <code>option</code> 默认是并行检查的，其先后顺序仅能通过 <code>add_deps</code> 控制。不加 <code>add_deps</code> 语句，在 <code>after_check</code> 中取其他 <code>option</code> 的值是未定义行为！</p></blockquote><p>xmake 中大量使用了这类函数式方法用来灵活控制构建的每个过程。在 lambda 表达式函数之内的部分称为 Script Scope，与之对应的 xmake.lua 中外面的部分称为 Description Scope。Description Scope 胜在简洁方便，易读易写；而只有在 Script Scope 内才可以使用 xmake 提供的全部功能，包括 xmake 提供的大量第三方 Lua 模块。这些功能可以在官方文档中找到。</p><blockquote><p>Tips. Description Scope 内的语句会多次解析执行，而 Script Scope 内的语句只会执行一遍。不同 option&#x2F;不同 target 的 Script Scope 默认是并行执行的。调试用的 <code>print</code> 语句应当写在 Script Scope 内，并标注当前所在的 option&#x2F;target。</p></blockquote><p>常用的能够进入 Script Scope 的语句目前有如下一些。</p><p>option：</p><ul><li><code>before_check</code>&#x2F;<code>on_check</code>&#x2F;<code>after_check</code> configure 阶段</li></ul><p>target：</p><ul><li><code>on_config</code> configure 阶段</li><li><code>before_build</code>&#x2F;<code>on_build</code>&#x2F;<code>after_build</code> build 阶段</li><li><code>before_link</code>&#x2F;<code>on_link</code>&#x2F;<code>after_link</code> build 阶段</li><li><code>before_run</code>&#x2F;<code>on_run</code>&#x2F;<code>after_run</code> 运行 <code>xmake run &lt;target&gt;</code> 时</li><li><code>before_install</code>&#x2F;<code>on_install</code>&#x2F;<code>after_install</code> 运行 <code>xmake install &lt;target&gt;</code> 时</li><li><code>on_uninstall</code> 运行 <code>xmake uninstall &lt;target&gt;</code> 时</li><li><code>before_clean</code>&#x2F;<code>on_clean</code>&#x2F;<code>after_clean</code> 运行 <code>xmake clean &lt;target&gt;</code> 时</li></ul><h1 id="检测开发环境"><a href="#检测开发环境" class="headerlink" title="检测开发环境"></a>检测开发环境</h1><p>xmake 中，option 不仅用来处理用户指定的构建选项，还可以用来执行环境检测。这时 option 的写法为</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">option(<span class="string">&quot;__have_longlong&quot;</span>)</span><br><span class="line">    set_default(<span class="literal">false</span>)</span><br><span class="line">    set_showmenu(<span class="literal">false</span>) <span class="comment">-- do not show this option in the configuration menu</span></span><br><span class="line">    add_ctypes(<span class="string">&quot;long long int&quot;</span>)</span><br><span class="line">option_end()</span><br><span class="line"><span class="keyword">if</span> has_config(<span class="string">&quot;__have_longlong&quot;</span>) <span class="keyword">then</span></span><br><span class="line">    add_defines(<span class="string">&quot;HAVE_LONGLONG&quot;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>这里在 <code>option</code> 中加入了 <code>add_ctypes</code> 语句，这使得 <code>__have_longlong</code> 这个 option 成为了一个检测 option。xmake 中，包含以下语句中一个或者多个的 option 为检测 option：</p><ul><li><code>add_cincludes</code>&#x2F;<code>add_cxxincludes</code>：检测是否能找到某个头文件。</li><li><code>add_ctypes</code>&#x2F;<code>add_cxxtypes</code>：检测是否声明某个类型。通常与上一条联合使用，通过 <code>add_cincludes</code> 添加头文件，再通过 <code>add_ctypes</code> 检测头文件中声明的类型。</li><li><code>add_cfuncs</code>&#x2F;<code>add_cxxfuncs</code>：检测是否声明某个函数。同上，通常通过 <code>add_cincludes</code> 添加头文件，再通过 <code>add_cfuncs</code> 检测头文件中声明的函数。</li><li><code>add_links</code>：检测是否能找到某个链接库。</li><li><code>add_features</code>：检测编译器功能，例如 <code>add_features(&quot;cxx_std_11&quot;)</code> 检测是否支持 C++11.</li><li><code>add_csnippets</code>&#x2F;<code>add_cxxsnippets</code>：检测是否能通过编译某代码片段。这条语句功能最强大，可以实现上面提到的各种功能，还可以通过添加参数来检测是否能运行某代码片段，获取该代码片段的输出。详情可参考官方文档。</li></ul><p>使用 option 进行检测有时还是太复杂了，这时可以使用 xmake 提供的更简单的检测接口。下面的代码段和上面检测 <code>long long int</code> 的片段作用相同：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">includes(<span class="string">&quot;check_ctypes.lua&quot;</span>)</span><br><span class="line">check_ctypes(<span class="string">&quot;HAVE_LONGLONG&quot;</span>, <span class="string">&quot;long long int&quot;</span>)</span><br><span class="line"><span class="comment">--[[ if has_config(&quot;__HAVE_LONGLONG&quot;) then</span></span><br><span class="line"><span class="comment">    do something</span></span><br><span class="line"><span class="comment">end --]]</span></span><br></pre></td></tr></table></figure><p>检测接口通过 <code>includes</code> 方法引入，其中 <code>check_ctypes.lua</code> 为 xmake 内置的扩展脚本。需要注意的是，为了避免选项冲突，xmake 会自动将这里定义的选项命名为双下划线 <code>__</code> 接要定义的宏名称 <code>HAVE_LONGLONG</code>。xmake 中一共提供了如下简化检测接口。</p><ul><li><code>check_cflags.lua</code>&#x2F;<code>check_cxxflags.lua</code></li><li><code>check_cincludes.lua</code>&#x2F;<code>check_cxxincludes.lua</code></li><li><code>check_ctypes.lua</code>&#x2F;<code>check_cxxtypes.lua</code></li><li><code>check_cfuncs.lua</code>&#x2F;<code>check_cxxfuncs.lua</code></li><li><code>check_csnippets.lua</code>&#x2F;<code>check_cxxsnippets.lua</code></li><li><code>check_links.lua</code></li><li><code>check_features.lua</code></li><li><code>check_macros.lua</code></li></ul><p>大部分接口都和上面 <code>option</code> 的同名函数一一对应。其中三个接口例外：<code>check_cflags</code> 和 <code>check_cxxflags</code> 检测编译器是否支持某个编译参数，而 <code>check_macros</code> 检测编译器是否设置某个预定义宏。<code>macros</code> 检测都可以通过在 <code>option</code> 中设置 <code>add_csnippets</code> 和 <code>add_cxxsnippets</code> 来实现，而 <code>flags</code> 检测需要借助 <code>on_check</code> 进入 Script Scope 来处理。感兴趣的读者可以从 <code>path/to/xmake/includes</code> 找到这些接口的实现。</p><h1 id="生成配置头文件"><a href="#生成配置头文件" class="headerlink" title="生成配置头文件"></a>生成配置头文件</h1><p>当各种配置选项定义的宏仅影响源文件时，上面的开发环境检测功能就足够了。但是，当这些宏还影响头文件时，光在构建期检测是不够的，因为打包发布库与头文件时，不会包含任何检测结果的数据，这会导致头文件与库中的函数不匹配，最终导致链接失败。解决办法就是使用配置头文件（Configuration Headers）。</p><p>配置头文件是一个在构建时生成的文件，它根据检测到的各类选项来设置其中定义的宏变量。在构建过程中，先生成配置头文件，然后将该头文件加入项目中一起编译，最后一起打包发布。由于配置头文件的内容在构建时已经固定下来，如果构建头文件使用正确，头文件中将不再含有不清晰的分支，这也就避免了函数不匹配的问题。</p><p>一个使用配置头文件的项目目录如下：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">root</span><br><span class="line">|- include</span><br><span class="line">    |- mylib</span><br><span class="line">        |- mylib.h</span><br><span class="line">        |- <span class="built_in">config</span>.h.<span class="keyword">in</span></span><br><span class="line">|- src</span><br><span class="line">    |- mylib.cpp</span><br><span class="line">|- xmake.lua</span><br></pre></td></tr></table></figure><p>其中 mylib.h 文件内容如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;config.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __WIN32__</span></span><br><span class="line"><span class="meta">#  <span class="keyword">ifdef</span> MYLIB_STATIC</span></span><br><span class="line"><span class="meta">#    <span class="keyword">define</span> MYLIB_EXPORT</span></span><br><span class="line"><span class="meta">#  <span class="keyword">elif</span> defined(MYLIB_BUILDING)</span></span><br><span class="line"><span class="meta">#    <span class="keyword">define</span> MYLIB_EXPORT __declspec(dllexport)</span></span><br><span class="line"><span class="meta">#  <span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#    <span class="keyword">define</span> MYLIB_EXPORT __declspec(dllimport)</span></span><br><span class="line"><span class="meta">#  <span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#  <span class="keyword">define</span> MYLIB_EXPORT</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">MYLIB_EXPORT <span class="type">int</span> <span class="title">myfunc</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>mylib.cpp 包含 <code>myfunc</code> 函数的实现</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mylib/mylib.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">myfunc</span><span class="params">(<span class="type">int</span> a)</span> </span>&#123; <span class="keyword">return</span> a + <span class="number">1</span>; &#125;</span><br></pre></td></tr></table></figure><p><a href="https://link.zhihu.com/?target=http://config.h.in">http://config.h.in</a> 文件内容如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line">$&#123;define MYLIB_STATIC&#125;</span><br></pre></td></tr></table></figure><p>xmake.lua 内容如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">add_rules</span>(<span class="string">&quot;mode.debug&quot;</span>, <span class="string">&quot;mode.release&quot;</span>)</span><br><span class="line"><span class="built_in">target</span>(<span class="string">&quot;mylib&quot;</span>)</span><br><span class="line">    <span class="built_in">set_kind</span>(<span class="string">&quot;$(kind)&quot;</span>)</span><br><span class="line">    <span class="built_in">add_files</span>(<span class="string">&quot;src/mylib.cpp&quot;</span>)</span><br><span class="line">    <span class="built_in">add_includedirs</span>(<span class="string">&quot;include&quot;</span>)</span><br><span class="line">    <span class="built_in">add_defines</span>(<span class="string">&quot;MYLIB_BUILDING&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="title">is_kind</span><span class="params">(<span class="string">&quot;static&quot;</span>)</span> then</span></span><br><span class="line"><span class="function">        <span class="title">set_configvar</span><span class="params">(<span class="string">&quot;MYLIB_STATIC&quot;</span>, <span class="number">1</span>)</span></span></span><br><span class="line"><span class="function">    end</span></span><br><span class="line"><span class="function">    <span class="title">set_configdir</span><span class="params">(<span class="string">&quot;$(buildir)/mylib&quot;</span>)</span></span></span><br><span class="line"><span class="function">    <span class="title">add_includedirs</span><span class="params">(<span class="string">&quot;$(buildir)/mylib&quot;</span>)</span></span></span><br><span class="line"><span class="function">    <span class="title">add_configfiles</span><span class="params">(<span class="string">&quot;include/mylib/config.h.in&quot;</span>)</span></span></span><br></pre></td></tr></table></figure><p>运行 <code>xmake</code> 构建以上项目后，可以在 <code>build/mylib</code> 文件夹下找到一个文件 config.h：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MYLIB_STATIC 1</span></span><br></pre></td></tr></table></figure><p>在 <code>mylib.h</code> 文件中引用的头文件 <code>config.h</code> 正是这一文件。在发布时，将这一文件与 <code>include</code> 文件夹下的头文件一同打包，即可把 <code>MYLIB_STATIC</code> 这个设置项固定下来了。当其他文件引用 <code>mylib.h</code> 时，宏 <code>MYLIB_EXPORT</code> 将始终展开为空值。</p><blockquote><p>Tips. 上面的头文件设置看似很复杂，但却是大型 C++ 项目中非常常见的做法。这么做的原因是在 Windows 上要使用 MSVC 导出可以链接的动态库，必须要显式声明需要导出的符号，声明的方式其一是在 <code>.def</code> 文件中集中声明，其二就是在函数前加 <code>__declspec(dllexport)</code>。加导出声明后，相应函数的符号会以 <code>__imp_</code> 开头，以区分于静态库符号。为了避免符号冲突，若需要其他项目链接该动态库，则必须在库的头文件相应函数前加 <code>__declspec(dllimport)</code>。<br>Tips. config.h 是一个很常见的名称，如果安装的时候直接把这个文件所在的文件夹放在 <code>include</code> 下，很容易引起混乱。解决办法有两种：一种是改名 mylib_config.h，另一种是放在文件夹 mylib 下。这也是上面写 <code>#include &quot;mylib/mylib.h&quot;</code> 的原因。</p></blockquote><p>xmake 中，默认配置头文件以后缀 <code>.h.in</code> 结尾，在生成文件时去掉后缀的 <code>.in</code>。这一行为也可以通过添加参数 <code>&#123;filename = …&#125;</code> 进行更改。在配置头文件中有两种方法声明需替换的配置变量：</p><ul><li><code>$&#123;VAR&#125;</code>：替换为变量 <code>VAR</code> 的值，或者空字符串。常用于 <code>#define VAR $&#123;VAR&#125;</code>。</li><li><code>$&#123;define VAR&#125;</code>：如果 <code>VAR</code> 的值存在，则定义 <code>VAR</code>，否则注释掉当前行。要求写在行首。</li></ul><p>变量的值可以用 <code>set_configvar</code> 语句指定。<code>set_configvar</code> 语句可以结合 <code>option</code> 使用，根据不同的选项设置不同的配置变量：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">option(<span class="string">&quot;with-openssl&quot;</span>, &#123;default = <span class="literal">false</span>, description = <span class="string">&quot;Build with OpenSSL.&quot;</span>&#125;)</span><br><span class="line"><span class="keyword">if</span> has_config(<span class="string">&quot;with-openssl&quot;</span>) <span class="keyword">then</span></span><br><span class="line">    add_requires(<span class="string">&quot;openssl&quot;</span>)</span><br><span class="line">    set_configvar(<span class="string">&quot;WITH_OPENSSL&quot;</span>, <span class="number">1</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>进一步还可以结合 <code>set_configvar</code> 与环境探测。xmake 中已经预先提供了这样的接口，它们与 <code>check_xxx</code> 系列接口一脉相承，命名为 <code>configvar_check_xxx</code>，用法如下：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">includes(<span class="string">&quot;check_ctypes.lua&quot;</span>)</span><br><span class="line">configvar_check_ctypes(<span class="string">&quot;HAVE_LONGLONG&quot;</span>, <span class="string">&quot;long long int&quot;</span>)</span><br></pre></td></tr></table></figure><p>如果类型 <code>long long int</code> 可以通过编译，则变量 <code>HAVE_LONGLONG</code> 将被替换为 1，否则变量 <code>HAVE_LONGLONG</code> 值不存在。使用 <code>configvar_check_xxx</code> 接口设置的 option 选项命名仍为双下划线 <code>__</code>+ 变量名。</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> 构建工具 </category>
          
          <category> Xmake </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>A Tour of xmake - 04. 依赖仓库</title>
      <link href="/posts/%E5%AD%A6%E4%B9%A0/%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/Xmake/A%20Tour%20of%20xmake%20-%2004.%20%E4%BE%9D%E8%B5%96%E4%BB%93%E5%BA%93.html"/>
      <url>/posts/%E5%AD%A6%E4%B9%A0/%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/Xmake/A%20Tour%20of%20xmake%20-%2004.%20%E4%BE%9D%E8%B5%96%E4%BB%93%E5%BA%93.html</url>
      
        <content type="html"><![CDATA[<h1 id="编写包描述文件"><a href="#编写包描述文件" class="headerlink" title="编写包描述文件"></a>编写包描述文件</h1><p>前文说到，当 xmake-repo 未收录时，可以自己编写包描述文件。xmake 的官方仓库 <a href="https://link.zhihu.com/?target=https://github.com/xmake-io/xmake-repo">xmake-repo</a> 就是由一个个包描述文件组成的；它们也是编写包描述文件的最佳参考。</p><h2 id="远程拉取源码编译"><a href="#远程拉取源码编译" class="headerlink" title="远程拉取源码编译"></a>远程拉取源码编译</h2><p>一个 package 描述文件由一个 package 作用域组成，以 <a href="https://link.zhihu.com/?target=https://github.com/xmake-io/xmake-repo/blob/master/packages/j/jsoncpp/xmake.lua">jsoncpp</a> 为例，其包描述文件如下（为方便起见作了部分删改）：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">package</span>(<span class="string">&quot;jsoncpp&quot;</span>)</span><br><span class="line"></span><br><span class="line">    set_homepage(<span class="string">&quot;https://github.com/open-source-parsers/jsoncpp/wiki&quot;</span>)</span><br><span class="line">    set_description(<span class="string">&quot;A C++ library for interacting with JSON.&quot;</span>)</span><br><span class="line"></span><br><span class="line">    add_urls(<span class="string">&quot;https://github.com/open-source-parsers/jsoncpp/archive/$(version).zip&quot;</span>,</span><br><span class="line">             <span class="string">&quot;https://github.com/open-source-parsers/jsoncpp.git&quot;</span>)</span><br><span class="line">    add_versions(<span class="string">&quot;1.9.5&quot;</span>, <span class="string">&quot;a074e1b38083484e8e07789fd683599d19da8bb960959c83751cd0284bdf2043&quot;</span>)</span><br><span class="line"></span><br><span class="line">    add_deps(<span class="string">&quot;cmake&quot;</span>)</span><br><span class="line">    on_load(<span class="function"><span class="keyword">function</span> <span class="params">(package)</span></span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">package</span>:<span class="built_in">config</span>(<span class="string">&quot;shared&quot;</span>) <span class="keyword">then</span></span><br><span class="line">            <span class="built_in">package</span>:add(<span class="string">&quot;defines&quot;</span>, <span class="string">&quot;JSON_DLL&quot;</span>)</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span>)</span><br><span class="line"></span><br><span class="line">    on_install(<span class="string">&quot;linux&quot;</span>, <span class="string">&quot;macosx&quot;</span>, <span class="string">&quot;android&quot;</span>, <span class="string">&quot;iphoneos&quot;</span>, <span class="string">&quot;windows&quot;</span>, <span class="string">&quot;mingw&quot;</span>, <span class="string">&quot;cross&quot;</span>, <span class="function"><span class="keyword">function</span> <span class="params">(package)</span></span></span><br><span class="line">        <span class="keyword">local</span> configs = &#123;<span class="string">&quot;-DJSONCPP_WITH_POST_BUILD_UNITTEST=OFF&quot;</span>, <span class="string">&quot;-DJSONCPP_WITH_TESTS=OFF&quot;</span>, <span class="string">&quot;-DJSONCPP_WITH_EXAMPLE=OFF&quot;</span>, <span class="string">&quot;-DBUILD_OBJECT_LIBS=OFF&quot;</span>&#125;</span><br><span class="line">        <span class="built_in">table</span>.<span class="built_in">insert</span>(configs, <span class="string">&quot;-DCMAKE_BUILD_TYPE=&quot;</span> .. (<span class="built_in">package</span>:<span class="built_in">debug</span>() <span class="keyword">and</span> <span class="string">&quot;Debug&quot;</span> <span class="keyword">or</span> <span class="string">&quot;Release&quot;</span>))</span><br><span class="line">        <span class="built_in">table</span>.<span class="built_in">insert</span>(configs, <span class="string">&quot;-DBUILD_SHARED_LIBS=&quot;</span> .. (<span class="built_in">package</span>:<span class="built_in">config</span>(<span class="string">&quot;shared&quot;</span>) <span class="keyword">and</span> <span class="string">&quot;ON&quot;</span> <span class="keyword">or</span> <span class="string">&quot;OFF&quot;</span>))</span><br><span class="line">        <span class="built_in">table</span>.<span class="built_in">insert</span>(configs, <span class="string">&quot;-DBUILD_STATIC_LIBS=&quot;</span> .. (<span class="built_in">package</span>:<span class="built_in">config</span>(<span class="string">&quot;shared&quot;</span>) <span class="keyword">and</span> <span class="string">&quot;OFF&quot;</span> <span class="keyword">or</span> <span class="string">&quot;ON&quot;</span>))</span><br><span class="line">        import(<span class="string">&quot;package.tools.cmake&quot;</span>).install(<span class="built_in">package</span>, configs)</span><br><span class="line">    <span class="keyword">end</span>)</span><br><span class="line"></span><br><span class="line">    on_test(<span class="function"><span class="keyword">function</span> <span class="params">(package)</span></span></span><br><span class="line">        <span class="built_in">assert</span>(<span class="built_in">package</span>:check_cxxsnippets(&#123;test = <span class="string">[[</span></span><br><span class="line"><span class="string">            void test() &#123;</span></span><br><span class="line"><span class="string">                Json::Value root;</span></span><br><span class="line"><span class="string">                Json::CharReaderBuilder builder;</span></span><br><span class="line"><span class="string">            &#125;</span></span><br><span class="line"><span class="string">        ]]</span>&#125;, &#123;configs = &#123;languages = <span class="string">&quot;c++11&quot;</span>&#125;, includes = <span class="string">&quot;json/json.h&quot;</span>&#125;))</span><br><span class="line">    <span class="keyword">end</span>)</span><br></pre></td></tr></table></figure><p>可以看到，整个包描述文件分为四部分：描述、加载、安装、测试。描述部分最简洁，也很容易读懂，这里包括包名、项目主页、项目简介、url、版本、依赖等。url 既可以声明版本对应源码包的下载地址，也可以声明 git 地址。<code>add_versions</code> 语句有两个参数，分别是版本号、对应版本号源码包的 sha256 或者对应版本号的 git commit id。<code>add_deps</code> 语句声明了包依赖的其他包。</p><blockquote><p>Tips. xmake 提供了计算 sha256 的命令行接口 <code>shell $ xmake lua hash.sha256 &lt;filename&gt;</code> 除了 sha256 之外，xmake 还提供了 hash.md5 等其他实用命令行接口。</p></blockquote><p>加载阶段和包描述阶段类似，区别在于加载阶段使用一个 lambda 函数（Lua 中格式为 <code>function(t) … end</code>）来描写加载过程，此处可以使用 Lua 脚本以及包设置项进行判断。jsoncpp 中判断当包作为动态链接库链接时，为使用此库的 target 添加 <code>JSON_DLL</code> 预定义宏。由于 msvc 引入动态库时往往需要在头文件中加限定符 <code>__declspec(dllimport)</code>，这样的预定义宏需求在跨平台 C++ 项目中非常常见。</p><p>接下来便是一个包描述文件的重头戏了：安装部分。jsoncpp 使用 cmake 作为构建系统，xmake 为之提供了一个模块用于处理 cmake 包的编译与安装：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import(<span class="string">&quot;package.tools.cmake&quot;</span>).install(<span class="built_in">package</span>, configs)</span><br></pre></td></tr></table></figure><p>这一语句自动调用 cmake 的安装功能。package 为 xmake 自动生成的代表当前包的对象，configs 是一个 table，这一语句会根据 configs 里面的声明来编译当前包。通常 configs 包含几个方面：</p><ul><li>禁用文档生成、测试与示例程序构建</li><li>编译模式处理（debug&#x2F;release）</li><li>链接库类型处理（static&#x2F;shared）</li><li>指定其他编译选项</li></ul><p>整个安装部分包含在 <code>on_install</code> 语句中。这个语句除最后一个参数用于描写安装过程之外，其他参数声明了包可以安装的平台&#x2F;架构。有时，一个包在不同平台上需要不同的处理，则可以写多个 <code>on_install</code> 语句来做跨平台处理，例如 <a href="https://link.zhihu.com/?target=https://github.com/xmake-io/xmake-repo/blob/master/packages/f/fftw/xmake.lua">fftw</a>。</p><p><code>on_install</code> 语句最后运行的理想结果，是在 <code>package:installdir()</code> 这个目录下产生如下目录结构：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$XMAKE_PKG_INSTALLDIR/m/mylib/&lt;version&gt;/&lt;hash&gt;</span><br><span class="line">|- bin</span><br><span class="line">|- include</span><br><span class="line">|- lib</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>xmake 会将 <code>include</code> 加入头文件目录，将 <code>lib</code> 加入链接目录，并自动扫描 <code>lib</code> 下生成的所有库文件对其进行链接。也就是说，无论采用什么方法，只要最后生成的库按此结构放置即可。对常用构建系统，xmake 提供了 <code>import(&quot;package.tools.xxx&quot;)</code> 的接口进行安装。对于使用 make&#x2F;nmake 管理、没有提供 install 功能的包，可能需要手动复制其生成文件到 <code>package:installdir()</code>，见后文 “ 直接下载包文件 “ 一节。</p><p>部分包不按照这种目录标准安装。xmake 也提供了保持其原有目录结构的途径：在<strong>描述阶段</strong>使用 <code>add_includedirs</code> 和 <code>add_linkdirs</code> 来指定头文件目录和链接目录（可以指定多个）。默认行为就相当于</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">package</span>(<span class="string">&quot;mylib&quot;</span>)</span><br><span class="line">    ...</span><br><span class="line">    add_includedirs(<span class="string">&quot;include&quot;</span>)</span><br><span class="line">    add_linkdirs(<span class="string">&quot;lib&quot;</span>)</span><br></pre></td></tr></table></figure><p>类似地，自动扫描链接库目录的行为也可以通过 <code>add_links</code> 语句自定义，以避免自动扫描时的链接顺序等问题。xmake 将按照声明的前后顺序链接各个声明的链接库。</p><p>测试过程发生在安装完毕之后，xmake 会试着编译一小段程序以保证包的可用性。这里常常使用 <code>assert</code> 语句与 <code>package:check_cxxsnippets</code> 或者 <code>package:check_cfuncs</code> 语句的组合。这些语句的用法和含义都很直接，其全部参数可以参考官方文档查阅。</p><p>包描述文件可以直接写在 xmake.lua 所有 target 定义之前，这样自定义包将可以和 xmake-repo 中提供的包一样，用 <code>add_requires</code> 引入。xmake.lua 的内容如下：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">package</span>(<span class="string">&quot;mylib&quot;</span>)</span><br><span class="line">    ...</span><br><span class="line">package_end() <span class="comment">-- explicitly quit the package description scope. IMPORTANT!</span></span><br><span class="line"></span><br><span class="line">add_rules(<span class="string">&quot;mode.debug&quot;</span>, <span class="string">&quot;mode.release&quot;</span>)</span><br><span class="line">add_requires(<span class="string">&quot;mylib&quot;</span>)</span><br><span class="line">target(<span class="string">&quot;myexec&quot;</span>)</span><br><span class="line">    set_kind(<span class="string">&quot;binary&quot;</span>)</span><br><span class="line">    add_files(<span class="string">&quot;src/*.cpp&quot;</span>)</span><br><span class="line">    add_packages(<span class="string">&quot;mylib&quot;</span>)</span><br></pre></td></tr></table></figure><p>如果包描述文件过于冗长，可以将其单独写在一个 lua 文件里（例如 mylib.lua），使用 <code>includes</code> 语句引入：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">includes(<span class="string">&quot;mylib.lua&quot;</span>)</span><br><span class="line"></span><br><span class="line">add_rules(<span class="string">&quot;mode.debug&quot;</span>, <span class="string">&quot;mode.release&quot;</span>)</span><br><span class="line">add_requires(<span class="string">&quot;mylib&quot;</span>)</span><br><span class="line">target(<span class="string">&quot;myexec&quot;</span>)</span><br><span class="line">    set_kind(<span class="string">&quot;binary&quot;</span>)</span><br><span class="line">    add_files(<span class="string">&quot;src/*.cpp&quot;</span>)</span><br><span class="line">    add_packages(<span class="string">&quot;mylib&quot;</span>)</span><br></pre></td></tr></table></figure><blockquote><p>Tips. <code>includes</code> 是一个非常实用的功能，尤其是在项目含有多个子项目的情况。<code>includes</code> 并不仅仅是简单的代码替换，在被包含的文件中，<code>add_files</code> 添加的相对路径会改为相对于被包含文件的路径。例如，文件目录如下 <code>root |- lib1 |- lib1.cpp |- xmake.lua |- lib2 |- lib2.cpp |- xmake.lua |- xmake.lua</code> 则在根目录下的 <code>xmake.lua</code> 可以这样写： <code>lua add_rules(&quot;mode.debug&quot;, &quot;mode.release&quot;) includes(&quot;lib1/xmake.lua&quot;) includes(&quot;lib2/xmake.lua&quot;)</code> 这样一来，更改一个子部分就不再需要对根目录的构建文件进行修改了，构建文件的易维护性大大提升。</p></blockquote><p>由于 C++ 的包构建千奇百怪，xmake 使用 Lua 脚本的形式对包的构建过程提供了充分的自由度，这也导致包描述文件相对构建文件往往更加复杂。但是即使没有完全理解也没有关系，对于包括 cmake 在内的常见构建系统（xmake，autoconf，etc.），xmake-repo 中大多都有对应的示例，可以在复制粘贴基础上进行改动。</p><h2 id="直接下载包文件"><a href="#直接下载包文件" class="headerlink" title="直接下载包文件"></a>直接下载包文件</h2><p>部分包（尤其是 header-only 的 C++ 库）直接提供头文件和二进制文件下载，无需从源码安装。这时只需要修改 <code>on_install</code> 的安装部分，将安装改为复制即可。下面的部分摘自 <a href="https://link.zhihu.com/?target=https://github.com/xmake-io/xmake-repo/blob/master/packages/o/openblas/xmake.lua">openblas</a>。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">package</span>(<span class="string">&quot;openblas&quot;</span>)</span><br><span class="line">    ...</span><br><span class="line">    on_install(<span class="string">&quot;windows&quot;</span>, <span class="function"><span class="keyword">function</span> <span class="params">(package)</span></span></span><br><span class="line">        <span class="built_in">os</span>.mv(<span class="built_in">path</span>.join(<span class="string">&quot;bin&quot;</span>, <span class="string">&quot;libopenblas.dll&quot;</span>), <span class="built_in">package</span>:installdir(<span class="string">&quot;bin&quot;</span>))</span><br><span class="line">        <span class="built_in">os</span>.mv(<span class="string">&quot;include&quot;</span>, <span class="built_in">package</span>:installdir())</span><br><span class="line">        <span class="built_in">os</span>.mv(<span class="built_in">path</span>.join(<span class="string">&quot;lib&quot;</span>, <span class="string">&quot;libopenblas.lib&quot;</span>), <span class="built_in">path</span>.join(<span class="built_in">package</span>:installdir(<span class="string">&quot;lib&quot;</span>), <span class="string">&quot;openblas.lib&quot;</span>))</span><br><span class="line">        <span class="built_in">package</span>:addenv(<span class="string">&quot;PATH&quot;</span>, <span class="string">&quot;bin&quot;</span>)</span><br><span class="line">    <span class="keyword">end</span>)</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><h2 id="从系统查找"><a href="#从系统查找" class="headerlink" title="从系统查找"></a>从系统查找</h2><p>有时候一些包没有独立的源码或二进制，而是由发行版提供，或者强制要求从安装包安装。这时从系统查找的功能就派上用场了。xmake 中用 <code>on_fetch</code> 语句实现查找功能。下面例子摘自 <a href="https://link.zhihu.com/?target=https://github.com/xmake-io/xmake-repo/blob/master/packages/m/msmpi/xmake.lua">msmpi</a>。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">package</span>(<span class="string">&quot;msmpi&quot;</span>)</span><br><span class="line">    ...</span><br><span class="line">    on_fetch(<span class="string">&quot;windows&quot;</span>, <span class="function"><span class="keyword">function</span> <span class="params">(package, opt)</span></span></span><br><span class="line">        <span class="keyword">if</span> opt.system <span class="keyword">then</span></span><br><span class="line">            import(<span class="string">&quot;lib.detect.find_path&quot;</span>)</span><br><span class="line">            import(<span class="string">&quot;lib.detect.find_library&quot;</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment">-- init search paths</span></span><br><span class="line">            <span class="keyword">local</span> paths = &#123;</span><br><span class="line">                <span class="string">&quot;$(env MSMPI_ROOT)&quot;</span>,</span><br><span class="line">                <span class="string">&quot;$(env MSMPI_INC)\\..&quot;</span>,</span><br><span class="line">                <span class="string">&quot;$(env PROGRAMFILES%(x86%))\\Microsoft SDKs\\MPI&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">-- find library</span></span><br><span class="line">            <span class="keyword">local</span> result = &#123;links = &#123;&#125;, linkdirs = &#123;&#125;, includedirs = &#123;&#125;&#125;</span><br><span class="line">            <span class="keyword">local</span> arch = <span class="built_in">package</span>:is_arch(<span class="string">&quot;x64&quot;</span>) <span class="keyword">and</span> <span class="string">&quot;x64&quot;</span> <span class="keyword">or</span> <span class="string">&quot;x86&quot;</span></span><br><span class="line">            <span class="keyword">for</span> _, lib <span class="keyword">in</span> <span class="built_in">ipairs</span>(&#123;<span class="string">&quot;msmpi&quot;</span>, <span class="string">&quot;msmpifec&quot;</span>, <span class="string">&quot;msmpifmc&quot;</span>&#125;) <span class="keyword">do</span></span><br><span class="line">                <span class="keyword">local</span> linkinfo = find_library(lib, paths, &#123;suffixes = <span class="built_in">path</span>.join(<span class="string">&quot;Lib&quot;</span>, arch)&#125;)</span><br><span class="line">                <span class="keyword">if</span> linkinfo <span class="keyword">then</span></span><br><span class="line">                    <span class="built_in">table</span>.<span class="built_in">insert</span>(result.linkdirs, linkinfo.linkdir)</span><br><span class="line">                    <span class="built_in">table</span>.<span class="built_in">insert</span>(result.links, lib)</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            result.linkdirs = <span class="built_in">table</span>.unique(result.linkdirs)</span><br><span class="line"></span><br><span class="line">            <span class="comment">-- find headers</span></span><br><span class="line">            <span class="keyword">local</span> <span class="built_in">path</span> = find_path(<span class="string">&quot;mpi.h&quot;</span>, paths, &#123;suffixes = <span class="string">&quot;Include&quot;</span>&#125;)</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">path</span> <span class="keyword">then</span></span><br><span class="line">                <span class="built_in">table</span>.<span class="built_in">insert</span>(result.includedirs, <span class="built_in">path</span>)</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">if</span> #result.includedirs &gt; <span class="number">0</span> <span class="keyword">and</span> #result.linkdirs &gt; <span class="number">0</span> <span class="keyword">then</span></span><br><span class="line">                <span class="keyword">return</span> result</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span>)</span><br></pre></td></tr></table></figure><p>从系统查找包，最重要的是路径的设置。一般来说，通过环境变量或者注册表获取路径是最佳选择，如果没有就默认安装路径查找，并且还需要提供一个用户可自定义的环境变量（此处 <code>MSMPI_ROOT</code>）用于手动指定查找路径。如果要与 cmake 保持一致，建议使用 <code>&lt;package&gt;_ROOT</code> 作为该环境变量的名称。有了路径之后，配合使用 <code>lib.detect.find_library</code> 模块与 <code>lib.detect.find_path</code> 模块即可完成包链接目录、头文件目录的设置。</p><p>除了显式查找之外，xmake 还会到系统包管理器查找，查找时使用的名称由 <code>add_extsources</code> 语句指定。下面的例子来自 <a href="https://link.zhihu.com/?target=https://github.com/xmake-io/xmake-repo/blob/master/packages/e/eigen/xmake.lua">eigen</a>。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">package</span>(<span class="string">&quot;eigen&quot;</span>)</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> is_plat(<span class="string">&quot;mingw&quot;</span>) <span class="keyword">and</span> is_subhost(<span class="string">&quot;msys&quot;</span>) <span class="keyword">then</span></span><br><span class="line">        add_extsources(<span class="string">&quot;pacman::eigen3&quot;</span>)</span><br><span class="line">    <span class="keyword">elseif</span> is_plat(<span class="string">&quot;linux&quot;</span>) <span class="keyword">then</span></span><br><span class="line">        add_extsources(<span class="string">&quot;pacman::eigen&quot;</span>, <span class="string">&quot;apt::libeigen3-dev&quot;</span>)</span><br><span class="line">    <span class="keyword">elseif</span> is_plat(<span class="string">&quot;macosx&quot;</span>) <span class="keyword">then</span></span><br><span class="line">        add_extsources(<span class="string">&quot;brew::eigen&quot;</span>)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><h2 id="远程拉取与系统查找相结合"><a href="#远程拉取与系统查找相结合" class="headerlink" title="远程拉取与系统查找相结合"></a>远程拉取与系统查找相结合</h2><p>一个包可以同时支持远程拉取与系统查找。例如 CUDA Samples 包的描述文件为：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">package</span>(<span class="string">&quot;cuda_samples&quot;</span>)</span><br><span class="line"></span><br><span class="line">    set_kind(<span class="string">&quot;library&quot;</span>, &#123;headeronly = <span class="literal">true</span>&#125;)</span><br><span class="line">    set_homepage(<span class="string">&quot;https://github.com/NVIDIA/cuda-samples&quot;</span>)</span><br><span class="line">    set_description(<span class="string">&quot;CUDA Sample Utility Code&quot;</span>)</span><br><span class="line"></span><br><span class="line">    add_urls(<span class="string">&quot;https://github.com/NVIDIA/cuda-samples/archive/refs/tags/$(version).tar.gz&quot;</span>,</span><br><span class="line">             <span class="string">&quot;https://github.com/NVIDIA/cuda-samples.git&quot;</span>)</span><br><span class="line">    add_versions(<span class="string">&quot;v11.6&quot;</span>, <span class="string">&quot;9b5542747bc0aa66371b29043e46b3438266586332637001f2184d75415b920d&quot;</span>)</span><br><span class="line"></span><br><span class="line">    on_fetch(<span class="function"><span class="keyword">function</span> <span class="params">(package, opt)</span></span></span><br><span class="line">        <span class="keyword">if</span> opt.system <span class="keyword">then</span></span><br><span class="line">            import(<span class="string">&quot;lib.detect.find_path&quot;</span>)</span><br><span class="line">            <span class="keyword">local</span> paths = &#123;</span><br><span class="line">                <span class="string">&quot;C:\\ProgramData\\NVIDIA Corporation\\CUDA Samples\\v*\\common&quot;</span></span><br><span class="line">                <span class="comment">-- add your custom path here</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">local</span> headerpath = find_path(<span class="string">&quot;helper_cuda.h&quot;</span>, paths, &#123;suffixes = &#123;<span class="string">&quot;inc&quot;</span>&#125;&#125;)</span><br><span class="line">            <span class="keyword">if</span> headerpath <span class="keyword">then</span></span><br><span class="line">                vprint(<span class="string">&quot;CUDA Samples Found: &quot;</span> .. <span class="built_in">path</span>.directory(headerpath))</span><br><span class="line">                <span class="keyword">return</span> &#123;includedirs = &#123;headerpath&#125;&#125;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span>)</span><br><span class="line"></span><br><span class="line">    add_includedirs(<span class="string">&quot;include/Common&quot;</span>)</span><br><span class="line">    on_install(<span class="function"><span class="keyword">function</span> <span class="params">(package)</span></span></span><br><span class="line">        <span class="built_in">os</span>.cp(<span class="string">&quot;Common&quot;</span>, <span class="built_in">package</span>:installdir(<span class="string">&quot;include&quot;</span>)) <span class="comment">-- for header only</span></span><br><span class="line">    <span class="keyword">end</span>)</span><br><span class="line"></span><br><span class="line">    on_test(<span class="function"><span class="keyword">function</span> <span class="params">(package)</span></span></span><br><span class="line">        <span class="built_in">assert</span>(<span class="built_in">os</span>.isfile(<span class="built_in">path</span>.join(<span class="built_in">package</span>:installdir(<span class="string">&quot;include&quot;</span>), <span class="string">&quot;Common&quot;</span>, <span class="string">&quot;helper_cuda.h&quot;</span>)))</span><br><span class="line">    <span class="keyword">end</span>)</span><br><span class="line"></span><br><span class="line">package_end()</span><br></pre></td></tr></table></figure><p>在使用 <code>add_requires</code> 集成时，xmake 会优先执行 <code>on_fetch</code> 定义的从系统查找过程，如果找到，则将其加入项目；如果没有找到，则从远程下载。由于仅用到 sample 里面的头文件，这里的 <code>on_install</code> 函数仅做了简单的 copy，这是纯头文件库的一大好处：安装方便。对纯头文件库，xmake 提供了语句 <code>set_kind(&quot;library&quot;, &#123;headeronly = true&#125;)</code>，这一语句写在描述域，作用是忽略该库的链接时设置，例如动态库&#x2F;静态库、动态 runtime&#x2F;静态 runtime 等。</p><h2 id="从本地源码编译"><a href="#从本地源码编译" class="headerlink" title="从本地源码编译"></a>从本地源码编译</h2><p>xmake 的包管理既支持远程路径，也支持本地路径。这一功能可以用于集成源码在本地的第三方库（特别是，使用 git submodules 管理的第三方库源码）。远程路径用 <code>add_urls</code> 来声明，本地路径则用 <code>set_sourcedir</code> 语句来声明。例如，第三方库放在相对于包描述文件（直接写进 xmake.lua 的情况，包描述文件也就是 xmake.lua 构建描述文件）的 <code>third_party/mylib</code> 文件夹下，则 <code>add_urls</code> 和 <code>add_versions</code> 语句换为：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set_sourcedir(<span class="built_in">path</span>.join(<span class="built_in">os</span>.scriptdir(), <span class="string">&quot;third_party&quot;</span>, <span class="string">&quot;mylib&quot;</span>))</span><br></pre></td></tr></table></figure><p>其他全部与前文一致即可。</p><p>从零开始编写包描述文件绝不是一件容易的事情，甚至仅仅完全读懂上面的代码、理解其中每一个函数也是有一定难度的。限于篇幅，此处无法对其一一介绍，感兴趣的读者可以在官方文档中找到更多说明。如果你希望编写某个包描述文件并发布到仓库，但现有仓库中的包描述文件都不满足需要时，欢迎来 GitHub 讨论区交流获取灵感！</p><h1 id="自建-Xmake-repo-仓库"><a href="#自建-Xmake-repo-仓库" class="headerlink" title="自建 Xmake-repo 仓库"></a>自建 Xmake-repo 仓库</h1><p>xmake 支持自建仓库与官方仓库共存。一个仓库的基本结构如下</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">root</span><br><span class="line">|- packages</span><br><span class="line">    |- a</span><br><span class="line">        |- abc</span><br><span class="line">            |- xmake.lua</span><br><span class="line">    ...</span><br><span class="line">|- xmake.lua</span><br></pre></td></tr></table></figure><p>package 文件夹存放所有的包描述文件。这些文件放在<strong>与包名一致</strong>的文件夹内，包名文件夹又按照其首字母区分放在不同的文件夹内。这里文件夹名一定要与包描述文件里 <code>package(&quot;xxx&quot;)</code> 语句写的包名一致！最外层的 xmake.lua 是仓库的描述文件，其结构如下：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set_xmakever(<span class="string">&quot;2.6.1&quot;</span>) <span class="comment">-- minimal xmake version requirement for the repository</span></span><br><span class="line">set_description(<span class="string">&quot;repository for project xxx&quot;</span>) <span class="comment">-- description of the repository</span></span><br></pre></td></tr></table></figure><p>这一仓库既可以放在本地，也可以放在云端。例如，仓库的文件夹名为 myrepo，放在项目根目录下，则可以用如下语句将仓库加入构建文件中：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add_repositories(<span class="string">&quot;local-repo myrepo&quot;</span>)</span><br></pre></td></tr></table></figure><p><code>add_repositories</code> 语句接收一个字符串，字符串的各个部分以空格进行拼接。第一部分表示仓库的显示名称，第二部分为仓库的路径。如果路径为相对路径，则默认为相对于项目根目录的路径。<code>add_repositories</code> 语句还可以声明远程仓库：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add_repositories(<span class="string">&quot;remote-repo git@github.com:myrepo/xmake-repo.git dev&quot;</span>)</span><br></pre></td></tr></table></figure><p>这里的第三部分表示 git 仓库的 branch 或者 commit，可以省略，此时 xmake 将使用其默认 branch。在 xmake.lua 中添加自建仓库后，自建仓库的<strong>所有包</strong>都可以直接通过 <code>add_requires</code> 引入了。也就是说，如果需要批量引入自定义第三方库，自建仓库是你最好的选择。</p><h1 id="集成-Vcpkg-包管理"><a href="#集成-Vcpkg-包管理" class="headerlink" title="集成 Vcpkg 包管理"></a>集成 Vcpkg 包管理</h1><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ xmake f --vcpkg=F:\vcpkg</span><br></pre></td></tr></table></figure><p>比如加载以下库，xmake.lua 示例：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">add_requires(<span class="string">&quot;vcpkg::zlib 1.2.11&quot;</span>)</span><br><span class="line">target(<span class="string">&quot;test&quot;</span>)    </span><br><span class="line">add_files(<span class="string">&quot;src/*.c&quot;</span>)    </span><br><span class="line">add_packages(<span class="string">&quot;vcpkg::zlib&quot;</span>)</span><br></pre></td></tr></table></figure><p>至于加载 conan 的库，需要下载 exe 文件。安装后，配置 path 路径，然后就可以使用了如下：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add_requires(<span class="string">&quot;conan::poco/1.9.4&quot;</span>, &#123;alias = <span class="string">&quot;poco&quot;</span>, <span class="built_in">debug</span> = <span class="literal">true</span>&#125;)</span><br></pre></td></tr></table></figure><h1 id="添加代理"><a href="#添加代理" class="headerlink" title="添加代理"></a>添加代理</h1><p>注意添加代理,这样访问 github 会快：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ xmake g --proxy_pac=github_mirror.lua  </span><br></pre></td></tr></table></figure><h1 id="Xmake-的包管理工具-Xrepo"><a href="#Xmake-的包管理工具-Xrepo" class="headerlink" title="Xmake 的包管理工具 Xrepo"></a>Xmake 的包管理工具 Xrepo</h1><p>使用举例：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ xrepo search xxx</span><br><span class="line">$ xrepo list-repo</span><br><span class="line">$ xrepo rm-repo xxx</span><br></pre></td></tr></table></figure><p>在 xmake.lua 下写就更简单了，增加一句话就行：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add_requires(<span class="string">&quot;zlib 1.2.11&quot;</span>)</span><br></pre></td></tr></table></figure><p>还可以用其他包管理器的包，比如：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">add_requires(<span class="string">&quot;vcpkg::zlib 1.2.11&quot;</span>)</span><br><span class="line">target(<span class="string">&quot;test&quot;</span>)</span><br><span class="line">    add_files(<span class="string">&quot;src/*.c&quot;</span>)</span><br><span class="line">    add_packages(<span class="string">&quot;vcpkg::zlib&quot;</span>)</span><br></pre></td></tr></table></figure><h1 id="Build-结果示例"><a href="#Build-结果示例" class="headerlink" title="Build 结果示例"></a>Build 结果示例</h1>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> 构建工具 </category>
          
          <category> Xmake </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>A Tour of xmake - 03. 依赖管理</title>
      <link href="/posts/%E5%AD%A6%E4%B9%A0/%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/Xmake/A%20Tour%20of%20xmake%20-%2003.%20%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86.html"/>
      <url>/posts/%E5%AD%A6%E4%B9%A0/%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/Xmake/A%20Tour%20of%20xmake%20-%2003.%20%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86.html</url>
      
        <content type="html"><![CDATA[<h1 id="引入远程依赖"><a href="#引入远程依赖" class="headerlink" title="引入远程依赖"></a>引入远程依赖</h1><p>xmake 中引入远程依赖的形式非常简单，一行 <code>add_requires</code> 语句即可。以 imgui 为例，建立目录结构如下</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root</span><br><span class="line">|- src</span><br><span class="line">    |- main.cpp</span><br><span class="line">|- xmake.lua</span><br></pre></td></tr></table></figure><p>源文件来自 imgui 的示例文件 <a href="https://link.zhihu.com/?target=https://github.com/ocornut/imgui/blob/v1.88/examples/example_glfw_opengl3/main.cpp">main.cpp</a>，在文件的开头需要加一行 <code>#include &quot;imgui_impl_opengl3_loader.h&quot;</code>。xmake.lua 文件内容如下</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">add_rules(<span class="string">&quot;mode.debug&quot;</span>, <span class="string">&quot;mode.release&quot;</span>)</span><br><span class="line">add_requires(<span class="string">&quot;imgui 1.88&quot;</span>, &#123;configs = &#123;glfw_opengl3 = <span class="literal">true</span>&#125;&#125;)</span><br><span class="line">target(<span class="string">&quot;imgui-demo&quot;</span>)</span><br><span class="line">    set_kind(<span class="string">&quot;binary&quot;</span>)</span><br><span class="line">    add_files(<span class="string">&quot;src/main.cpp&quot;</span>)</span><br><span class="line">    add_packages(<span class="string">&quot;imgui&quot;</span>)</span><br></pre></td></tr></table></figure><p>这里用到了 <code>add_requires</code> 语句。这一语句的基本用法为</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add_requires(<span class="string">&quot;&lt;package&gt; &lt;version-range&gt;&quot;</span>, &#123;&lt;options&gt;, configs = &#123;&lt;<span class="built_in">config</span>-options&gt;&#125;&#125;)</span><br></pre></td></tr></table></figure><ul><li><code>&lt;package&gt;</code> 顾名思义表示包名，一个包在 xmake-repo 中的名字可能与想象中不同，这时需要到 <a href="https://link.zhihu.com/?target=https://xrepo.xmake.io/%23/">xrepo</a> 网站查证，或者在本地命令行运行 <code>xrepo search &lt;package&gt;</code> 来查证。如果需要的包尚未收录，也不用着急，后面还会介绍其他引入依赖的方式。</li><li><code>&lt;version-range&gt;</code> 表示版本范围。xmake 支持多种版本范围声明，以下几种声明都是合法的：</li><li><code>mylib 1.x</code></li><li><code>mylib &gt;=1.0.0 &lt;1.2.0</code></li><li><code>mylib ~1.0.3</code> 详细的语义版本范围见 <a href="https://link.zhihu.com/?target=https://github.com/uael/sv%23versions">uael&#x2F;sv</a>。</li><li><code>&lt;options&gt;</code> 包含了一系列限定选项，例如 <code>&#123;system = true&#125;</code> 表示仅从系统查找，<code>&#123;optional = true&#125;</code> 表示允许查找和安装都失败，<code>&#123;verify = false&#125;</code> 表示跳过验证强制启用声明的版本，等等。</li><li><code>&lt;config-options&gt;</code> 用于声明包本身的构建选项。这一选项因项目而异，常用有 <code>&#123;shared = true&#125;</code> 表示使用动态库等。一个包可更改的构建选项可以用 <code>xrepo info &lt;package&gt;</code> 查看。</li></ul><p>从上面的 xmake.lua 代码片段还可以看到一个语句 <code>add_packages</code>。这一语句的作用是将引入的第三方库导入对应的 target 作为依赖。这一语句作用的 target 在编译时会自动带上第三方库的头文件目录，链接到第三方库，并设置第三方库可能带来的一些编译参数。默认情况下，引入的头文件目录不会继承给子 target，但是可以用 <code>add_packages(&lt;package&gt;, &#123;public = true&#125;)</code> 来更改这一默认行为。</p><p>上述代码设置好之后，输入 <code>xmake</code> 编译，<code>xmake run</code> 运行，就可以看到 imgui 的 demo 窗口了。是不是很简单呢？</p><p>imgui 是一个比较简单的库，没有太多的依赖项。然而，对于一些更复杂的库，他们本身又依赖其他的库，最终形成一个<strong>依赖链</strong>。仅仅更改库本身的选项，而不处理依赖链的选项，很容易造成依赖链上的库冲突。为了减少这种冲突现象，xmake 也提供了修改依赖链上库的语句：<code>add_requireconfs</code>。例如，libpng 依赖 zlib，要是希望 libpng 和 zlib 都被编译为动态链接库，则应该使用如下语句：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">add_requires(<span class="string">&quot;libpng&quot;</span>, &#123;configs = &#123;shared = <span class="literal">true</span>&#125;&#125;)</span><br><span class="line">add_requireconfs(<span class="string">&quot;libpng.zlib&quot;</span>, &#123;configs = &#123;shared = <span class="literal">true</span>&#125;&#125;)</span><br></pre></td></tr></table></figure><p>如果还希望使用的 zlib 为 1.2.12 版本，则可以这样写：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">add_requires(<span class="string">&quot;libpng&quot;</span>, &#123;configs = &#123;shared = <span class="literal">true</span>&#125;&#125;)</span><br><span class="line">add_requireconfs(<span class="string">&quot;libpng.zlib&quot;</span>, &#123;version = <span class="string">&quot;1.2.12&quot;</span>, configs = &#123;shared = <span class="literal">true</span>&#125;&#125;)</span><br></pre></td></tr></table></figure><p>这一功能还可以用于解决菱形依赖问题。xmake 中，可以用一行语句使依赖链上的每一个依赖 zlib 的包都依赖同一个 zlib 包（这时依赖链变成依赖图）：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add_requireconfs(<span class="string">&quot;*.zlib&quot;</span>, &#123;version = <span class="string">&quot;1.2.12&quot;</span>, configs = &#123;shared = <span class="literal">true</span>&#125;&#125;)</span><br></pre></td></tr></table></figure><p>关于 <code>add_requireconfs</code> 的更多用法，请参考 xmake 官方文档。</p><blockquote><p>Tips. 对于远程依赖，依赖的引入可能导致构建一致性被破坏。要想固定远程依赖的版本，xmake 也有相应的语句。只需要在 <code>add_requires</code> 之前写 <code>lua set_policy(&quot;package.requires_lock&quot;, true)</code> 这时，在第一次构建成功后会生成 <code>xmake-requires.lock</code> 文件。这一文件存在时，所有依赖的版本将被固定，不会自动升级。如果能将 <code>xmake-requires.lock</code> 上传到 git，其他人在编译你的项目时再也不会因为依赖版本不匹配而烦恼了！</p></blockquote><h1 id="使用本地依赖"><a href="#使用本地依赖" class="headerlink" title="使用本地依赖"></a>使用本地依赖</h1><p>第 0 节 - 简介中提到，xmake 可以使用来自系统包管理器、vcpkg、conan、conda 等多个包管理器的包。这些包的引入丰富了 xmake 支持的第三方库源，即使 xmake-repo 未能收录的包，也可以通过这些方式间接引入。部分包在包描述文件中已经写有搜索部分，直接使用 <code>add_requires</code> 就可以自动从系统查找，例如 <code>cuda</code>；而其他包则需要显示说明第三方包管理器源。引入其他包管理器的包基本语法仍是使用 <code>add_requires</code>：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">add_requires(<span class="string">&quot;conan::poco/1.12.1&quot;</span>, &#123;alias = <span class="string">&quot;poco&quot;</span>,</span><br><span class="line">    configs = &#123;settings = &#123;<span class="string">&quot;compiler=gcc&quot;</span>, <span class="string">&quot;compiler.libcxx=libstdc++11&quot;</span>&#125;&#125;&#125;)</span><br><span class="line">add_requires(<span class="string">&quot;apt::libudev-dev&quot;</span>, &#123;alias = <span class="string">&quot;libudev&quot;</span>&#125;)</span><br><span class="line">add_requires(<span class="string">&quot;conda::openssl&quot;</span>, &#123;alias = <span class="string">&quot;openssl&quot;</span>&#125;)</span><br></pre></td></tr></table></figure><p>各个包管理器的参数设置方式可以在官方文档中找到。这里设置 alias 别名的好处是后面使用 <code>add_packages</code> 添加包时较为简单，无需考虑包的来源。需要注意的是，Windows 上包管理器安装的包需要注意其 runtime 是静态还是动态。xmake 默认使用静态 runtime，但是大部分其他包管理器默认使用动态 runtime。可以使用如下语句切换 xmake 默认 runtime 为动态：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set_runtimes(<span class="string">&quot;MD&quot;</span>)</span><br></pre></td></tr></table></figure><p>这一语句通常放在所有 target 声明之前，全局生效，以避免链接冲突。</p><p>对于包管理器未收录的包，xmake 还支持从 pkg-config 文件和 cmake 文件中查找。其使用方法也类似于包管理器：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">add_requires(<span class="string">&quot;pkg-config::cairo&quot;</span>, &#123;alias = <span class="string">&quot;cairo&quot;</span>&#125;)</span><br><span class="line">add_requires(<span class="string">&quot;cmake::Vulkan&quot;</span>, &#123;alias = <span class="string">&quot;vulkan&quot;</span>,</span><br><span class="line">    configs = &#123;envs = &#123;CMAKE_PREFIX_PATH = <span class="string">&quot;/usr/local/vulkan-sdk&quot;</span>&#125;&#125;&#125;)</span><br></pre></td></tr></table></figure><p>从 cmake 查找包的功能还不是很成熟，如果遇到问题，请在 GitHub 的讨论区或 issue 报告。</p><p>如果上述方案都不奏效，怎么办呢？一种办法是回归最原始的依赖管理——submodule 形式，使用 submodule 将第三方库的源码也作为项目的一部分。这时可以写一个 xmake.lua 来编译第三方库，使用 <code>includes</code> 语句来引入第三方库，例如</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">add_rules(<span class="string">&quot;mode.debug&quot;</span>, <span class="string">&quot;mode.release&quot;</span>)</span><br><span class="line">includes(<span class="string">&quot;third_party/dep1&quot;</span>)</span><br><span class="line">target(<span class="string">&quot;example1&quot;</span>)</span><br><span class="line">    set_kind(<span class="string">&quot;binary&quot;</span>)</span><br><span class="line">    add_deps(<span class="string">&quot;dep1&quot;</span>)</span><br><span class="line">    add_files(<span class="string">&quot;examples/example1.cpp&quot;</span>)</span><br></pre></td></tr></table></figure><p>这种方法对中小型依赖都比较方便。一般情况下，使用 cmake 1000 行左右的构建文件，使用 xmake 重写只用大概 200 行。另一种办法就是下一节要讲到的依赖仓库功能了。你可以自己编写自己的包描述文件，xmake 会将你自己编写的包像已经收录到 xmake-repo 中一样处理。当然，如果能将你编写的包描述文件贡献到 xmake-repo 中造福后人，那就更好了！</p><h1 id="管理已安装的包"><a href="#管理已安装的包" class="headerlink" title="管理已安装的包"></a>管理已安装的包</h1><blockquote><p>Tips. xmake 默认会将第三方库安装到 <code>~/.xmake</code> 文件夹下（Windows 上为 <code>C:\Users\&lt;username&gt;\Appdata\Local\.xmake</code>）。这一行为可以通过环境变量 <code>XMAKE_PKG_CACHEDIR</code> 和 <code>XMAKE_PKG_INSTALLDIR</code> 更改。</p></blockquote><p>xmake 使用 xrepo 命令作为单独的包管理命令。xrepo 的一些常用功能列举如下：</p><ul><li><code>xrepo search &lt;package&gt;</code>：用于搜索含有特定字符串的包。如果有浏览器，也可以使用 <a href="https://link.zhihu.com/?target=https://xrepo.xmake.io/%23/">xrepo</a> 网站的搜索功能。</li><li><code>xrepo info &lt;package&gt;</code>：用于查看包的详细信息。</li><li><code>xrepo scan</code>：用于查看所有已安装的包。</li><li><code>xrepo clean</code>：用于清理安装远程包时的缓存，以及清理一段时间内未使用过的包。</li><li><code>xrepo install &lt;package&gt;</code>：用于安装远程包到本地。可以使用 <code>-f</code> 参数声明远程包的构建选项。</li><li><code>xrepo remove &lt;package&gt;</code>：用于移除本地包。这一命令只会移除默认参数的本地包，要想完全移除，需要加上 <code>--all</code> 参数。</li></ul><p>xrepo 命令还有一些非常强大的功能，这些功能将在后面的章节中展开。</p><h1 id="一些特殊的依赖库"><a href="#一些特殊的依赖库" class="headerlink" title="一些特殊的依赖库"></a>一些特殊的依赖库</h1><h2 id="OpenMP"><a href="#OpenMP" class="headerlink" title="OpenMP"></a>OpenMP</h2><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add_requires(<span class="string">&quot;openmp&quot;</span>)</span><br></pre></td></tr></table></figure><p>可用的 configs： - <code>runtime</code>：设置 OpenMP 提供商。有 <code>default</code> 和 <code>custom</code> 两种选项，默认使用第一种，即使用平台默认的 OpenMP，对 msvc 为内置的 OpenMP 实现 vcomp，对 gcc 采用 libgomp，对 clang 采用 libomp。如果想要使用其他的实现，可以设置该项为 <code>custom</code>，然后自己手动链接其他 openmp 实现。 - <code>experimental</code>：启用实验性的 OpenMP 功能，目前仅对 msvc 生效。</p><h2 id="CUDA"><a href="#CUDA" class="headerlink" title="CUDA"></a>CUDA</h2><p>正常使用 CUDA 语言无需引入依赖，使用 <code>add_files</code> 添加.cu 源文件即可。由于 NVIDIA 不开放 CUDA 的脚本安装，xmake 并不执行 CUDA 的下载安装部分，使用 CUDA 需要用户自行在机器上安装好 CUDA。如果 CUDA Toolkit 安装在默认位置，configure 阶段可以直接设置使用的 CUDA 版本：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ xmake config --cuda=11.7</span><br></pre></td></tr></table></figure><p>否则，需要声明 CUDA Toolkit 的安装位置：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ xmake config --cuda=/path/to/cuda-toolkit</span><br></pre></td></tr></table></figure><p>当使用 CUDA 提供的库（cublas，cusolver 等）时，这才需要引入依赖。引入 CUDA 依赖的语句为</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add_requires(<span class="string">&quot;cuda&quot;</span>, &#123;configs = &#123;utils = &#123;<span class="string">&quot;cublas&quot;</span>, <span class="string">&quot;cusolver&quot;</span>, ...&#125;&#125;&#125;)</span><br></pre></td></tr></table></figure><p>之后正常使用 <code>add_packages</code> 添加依赖即可。</p><h2 id="Boost"><a href="#Boost" class="headerlink" title="Boost"></a>Boost</h2><p>Boost 是一个很多库的集合，xmake 中使用 configs 控制需要安装的组件。如果只使用 Boost 纯头文件的部分，直接 <code>add_requires(&quot;boost&quot;)</code> 即可。如果用到 Boost 需要编译安装的组件（例如 filesystem，serialization）可以用如下语句：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add_requires(<span class="string">&quot;boost&quot;</span>, &#123;configs = &#123;filesystem = <span class="literal">true</span>, serialization = <span class="literal">true</span>, ...&#125;&#125;)</span><br></pre></td></tr></table></figure><p>如果图方便，可以直接安装 boost 的所有组件：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add_requires(<span class="string">&quot;boost&quot;</span>, &#123;configs = &#123;all = <span class="literal">true</span>&#125;&#125;)</span><br></pre></td></tr></table></figure><p>很多第三方库依赖 boost。为了避免菱形依赖问题，最好能自行分析好同时满足项目要求与第三方库要求的 boost 配置，然后使用 <code>add_requireconfs</code> 进行设置。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> boost_configs = &#123;filesystem = <span class="literal">true</span>, serialization = <span class="literal">true</span>, ...&#125;</span><br><span class="line">add_requires(<span class="string">&quot;boost 1.79.0&quot;</span>, &#123;configs = boost_configs&#125;)</span><br><span class="line">add_requireconfs(<span class="string">&quot;*.boost&quot;</span>, &#123;version = <span class="string">&quot;1.79.0&quot;</span>, configs = boost_configs&#125;)</span><br></pre></td></tr></table></figure><h2 id="Qt"><a href="#Qt" class="headerlink" title="Qt"></a>Qt</h2><p>Qt 是一个非常庞大的 C++ 类库，xmake 针对 Qt 做了特殊处理，部分语句有所变化。类似 CUDA，Qt 的安装较为复杂，最好能自行安装好 Qt，由 xmake 来查找。xmake 目前提供了部分 Qt 库的下载安装功能，但尚不完整。安装 Qt 后，可以在 configure 阶段设置 Qt 安装位置：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ xmake config --qt=/path/to/qt</span><br></pre></td></tr></table></figure><p>Qt 不仅提供了一系列类库，还提供了 moc、uic 等代码生成器，并通过这些生成器对 C++ 语言进行了扩展，因此 <code>add_requires</code> 无法满足 Qt 的需要。这时就该 <code>add_rules</code> 来发挥作用了。对于一个 Qt Widget Application，写法如下：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">add_rules(<span class="string">&quot;mode.debug&quot;</span>, <span class="string">&quot;mode.release&quot;</span>)</span><br><span class="line">target(<span class="string">&quot;qtmain&quot;</span>)</span><br><span class="line">    set_kind(<span class="string">&quot;binary&quot;</span>)</span><br><span class="line">    add_rules(<span class="string">&quot;qt.widget&quot;</span>)</span><br><span class="line">    add_files(<span class="string">&quot;src/*.cpp&quot;</span>)</span><br><span class="line">    add_files(<span class="string">&quot;src/*.h&quot;</span>) <span class="comment">-- pass header files to qt meta-object-compiler(moc)</span></span><br><span class="line">    add_frameworks(<span class="string">&quot;QtCore&quot;</span>, <span class="string">&quot;QtGui&quot;</span>, <span class="string">&quot;QtWidgets&quot;</span>) <span class="comment">-- set enabled qt frameworks</span></span><br></pre></td></tr></table></figure><p>关于 Qt 程序的更多细节，请参考官方文档。</p><blockquote><p>Tips. <code>add_frameworks</code> 的本来作用是在 Mac OS 上添加 Framework 依赖，例如 <code>add_frameworks(&quot;CoreFoundation&quot;)</code>。只有在 Qt 程序中才可以用来表示启用 Qt Framework。</p></blockquote><h2 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h2><p>如果系统已安装有 python3，可以用</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add_requires(<span class="string">&quot;python 3.x&quot;</span>, &#123;system = <span class="literal">true</span>, kind = <span class="string">&quot;binary&quot;</span>&#125;)</span><br></pre></td></tr></table></figure><p>引入 python 解释器作为依赖。如果 xmake 没有找到 python 解释器，就会报错。如果要引入 python 作为库链接到程序，去掉 <code>kind</code> 设定即可：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add_requires(<span class="string">&quot;python 3.x&quot;</span>, &#123;system = <span class="literal">true</span>&#125;)</span><br></pre></td></tr></table></figure><p>xmake 还提供 python 的下载安装功能。如果不想使用系统上的 python，可以使用 xmake 安装的 python：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add_requires(<span class="string">&quot;python 3.x&quot;</span>, &#123;system = <span class="literal">false</span>&#125;)</span><br></pre></td></tr></table></figure><p>如果使用 xmake 安装的 python，在项目根目录运行 <code>xrepo env shell</code> 即可进入虚拟环境，执行 <code>python</code> 进入 python 解释器，执行 <code>pip install numpy …</code> 来安装 python 的各种包。在虚拟环境执行的操作都会保存，直到这次 python 安装被清理。运行 <code>xrepo remove --all python</code> 可以交互式地移除 xmake 安装的 python 包。</p><blockquote><p>Tips. 如果系统上尚未安装 python，xmake 提供了一键下载安装激活 python 环境的命令： <code>shell $ xrepo env -b python3 shell</code></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> 构建工具 </category>
          
          <category> Xmake </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>A Tour of xmake - 02. 编译选项</title>
      <link href="/posts/%E5%AD%A6%E4%B9%A0/%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/Xmake/A%20Tour%20of%20xmake%20-%2002.%20%E7%BC%96%E8%AF%91%E9%80%89%E9%A1%B9.html"/>
      <url>/posts/%E5%AD%A6%E4%B9%A0/%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/Xmake/A%20Tour%20of%20xmake%20-%2002.%20%E7%BC%96%E8%AF%91%E9%80%89%E9%A1%B9.html</url>
      
        <content type="html"><![CDATA[<h1 id="创建空工程"><a href="#创建空工程" class="headerlink" title="创建空工程"></a>创建空工程</h1><p>xmake 提供了 <code>xmake create</code> 命令，可以很方便的快速创建基于 c&#x2F;c++, swift, objc 等各种语言的空工程项目，比如：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ xmake create <span class="built_in">test</span>  </span><br></pre></td></tr></table></figure><p>可以用 <code>-P xxx</code> 来指定项目目录名，默认会创建一个 c++ 的 hello world 工程，根目录下会生成一个 xmake.lua 用于描述项目的构建规则。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">add_rules(<span class="string">&quot;mode.debug&quot;</span>, <span class="string">&quot;mode.release&quot;</span>) </span><br><span class="line">target(<span class="string">&quot;test&quot;</span>) </span><br><span class="line">    set_kind(<span class="string">&quot;binary&quot;</span>) </span><br><span class="line">    add_files(<span class="string">&quot;src/*.cpp&quot;</span>)</span><br></pre></td></tr></table></figure><p>这是一个非常简单的 xmake.lua 描述，<code>target(&quot;test&quot;)</code> 定义了一个子工程模块 test，每个 target 会生成一个对应的目标文件，此处的 binary 类型，指定创建一个最基础的可执行文件。</p><p>而最上面的 <code>mode.debug</code> 和 <code>mode.release</code> 规则设置，是可选设置，但是通常我们都会建议加上，这样默认就可以生效两种常用的构建模式：debug 和 release</p><h1 id="执行编译"><a href="#执行编译" class="headerlink" title="执行编译"></a>执行编译</h1><p>通常我们如果只是编译当前主机环境的可执行文件，只需要执行 xmake 这个命令就可以了。xmake 默认会检测当前环境已存在的构建环境，比如笔者当前的 xcode 环境，然后默认采用 release 模式编译，如果设置了 <code>mode.release</code> 规则，那么就会生效。</p><h1 id="编译模式切换"><a href="#编译模式切换" class="headerlink" title="编译模式切换"></a>编译模式切换</h1><p>而如果我们要切到 <code>mode.debug</code> 编译，只需要：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ xmake f -m <span class="built_in">debug</span></span><br><span class="line">$ xmake</span><br></pre></td></tr></table></figure><p>其中，<code>xmake f</code> 是 <code>xmake config</code> 命令的简写，用来快速的切换配置，如果上手之后，通常采用简写会更加方便，更多命令的简写，都可执行 <code>xmake --help</code> 查看。</p><h1 id="创建其他模板工程"><a href="#创建其他模板工程" class="headerlink" title="创建其他模板工程"></a>创建其他模板工程</h1><p><code>xmake create</code> 还可以用来创建各种其他类型的工程项目，我们可以敲 <code>xmake create --help</code></p><p>可以通过 <code>-l/--language</code> 来指定工程语言，而 <code>-t/--template</code> 用来指定创建的工程模板类型。</p><p>比如，我们创建一个基于 c 的静态库项目：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ xmake create -l c -t static <span class="built_in">test</span></span><br></pre></td></tr></table></figure><p>我们也可以创建基于 qt 的 quickapp 项目：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ xmake create -l c++ -t qt.quickapp <span class="built_in">test</span></span><br></pre></td></tr></table></figure><p>会自动检测你的 qt 本机安装的环境，自动的找到。当然也可以指定：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ xmake f --qt=/home/xxx/qtsdk</span><br></pre></td></tr></table></figure><p>或者设置到全局路径，避免每次编译切换都要配置一遍：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ xmake g --qt=/home/xxx/qtsdk</span><br></pre></td></tr></table></figure><p>除了源文件的添加，其他基本上都跟之前的可执行程序项目没什么不同，唯一的区别就是通过 <code>add_rules(&quot;qt.quickapp&quot;)</code> 这个内置的 Qt 构建规则来代替 <code>set_kind(&quot;binary&quot;)</code>。</p><p>其实 <code>qt.quickapp</code> 规则内部最终还是设置了 binary 类型，只不过在此基础上额外增加了一些只有 Qt 才需要的构建规则，比如：特定 links，flags 还有 includedirs 等。</p><p>除了 c&#x2F;c++ 项目，xmake 还支持其他语言的项目编译，但 xmake 重点还是在 c&#x2F;c++ 上，支持其他语言也主要是为了支持跟 c&#x2F;c++ 进行混合编译，毕竟其他语言向 rust 什么的官方有提供更好的构建方案。</p><p>不过我们还是可以使用 xmake 来尝试编译他们：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ xmake create -l rust <span class="built_in">test</span></span><br><span class="line">$ xmake</span><br></pre></td></tr></table></figure><h1 id="运行生成目标"><a href="#运行生成目标" class="headerlink" title="运行生成目标"></a>运行生成目标</h1><p>xmake 也提供了 run 命令，直接运行生成后的可执行文件，用于方便快速的进行测试，例如：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ xmake run</span><br><span class="line">hello xmake!</span><br></pre></td></tr></table></figure><h1 id="添加运行环境变量"><a href="#添加运行环境变量" class="headerlink" title="添加运行环境变量"></a>添加运行环境变量</h1><p>我们也可以在 xmake.lua 中通过 <code>add_runenvs</code> 接口来添加设置默认运行 target 程序的环境变量。</p><p>所以，对于 PATH 这种，通过此接口追加值是非常方便的，而且此接口支持多值设置，所以通常就是用来设置带有 path sep 的多值 env。。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">target(<span class="string">&quot;test&quot;</span>)</span><br><span class="line">    set_kind(<span class="string">&quot;binary&quot;</span>)</span><br><span class="line">    add_files(<span class="string">&quot;src/*.c&quot;</span>)</span><br><span class="line">    add_runenvs(<span class="string">&quot;PATH&quot;</span>, <span class="string">&quot;/tmp/bin&quot;</span>, <span class="string">&quot;xxx/bin&quot;</span>)</span><br><span class="line">    add_runenvs(<span class="string">&quot;LD_LIBRARY_PATH&quot;</span>, <span class="string">&quot;/tmp/lib&quot;</span>, <span class="string">&quot;xxx/lib&quot;</span>)</span><br></pre></td></tr></table></figure><p>更多关于此接口的描述，可以看下文档：<a href="https://link.zhihu.com/?target=https://xmake.io/%23/zh-cn/manual/project_target?id=targetadd_runenvs">add_runenvs接口文档</a></p><h1 id="自定义运行逻辑"><a href="#自定义运行逻辑" class="headerlink" title="自定义运行逻辑"></a>自定义运行逻辑</h1><p>如果单纯的环境设置，以及默认的加载运行规则不满足需求，我们可以通过定制化 <code>on_run</code> 脚本，实现更加复杂的运行逻辑：</p><p>例如，运行安装好的 apk 程序：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">target(<span class="string">&quot;test&quot;</span>)</span><br><span class="line">    <span class="comment">-- ...</span></span><br><span class="line">    <span class="comment">-- 设置自定义运行脚本，自动运行安装好的app程序，并且自动获取设备输出信息</span></span><br><span class="line">    on_run(<span class="function"><span class="keyword">function</span> <span class="params">(target)</span></span> </span><br><span class="line">        <span class="built_in">os</span>.run(<span class="string">&quot;adb shell am start -n com.demo/com.demo.DemoTest&quot;</span>)</span><br><span class="line">        <span class="built_in">os</span>.run(<span class="string">&quot;adb logcat&quot;</span>)</span><br><span class="line">    <span class="keyword">end</span>)</span><br></pre></td></tr></table></figure><h1 id="调试程序"><a href="#调试程序" class="headerlink" title="调试程序"></a>调试程序</h1><h1 id="命令行调试"><a href="#命令行调试" class="headerlink" title="命令行调试"></a>命令行调试</h1><p>我们也可以传递 <code>-d</code> 参数，调用 gdb&#x2F;lldb 等调试器程序，加载目标文件进行调试：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ xmake run -d</span><br></pre></td></tr></table></figure><p>xmake 将会使用系统自带的调试器去加载程序运行，目前支持：lldb, gdb, windbg, vsjitdebugger, ollydbg 等各种调试器。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[lldb]<span class="variable">$target</span> create <span class="string">&quot;build/hello&quot;</span></span><br><span class="line">[lldb]<span class="variable">$b</span> main</span><br><span class="line">[lldb]<span class="variable">$r</span></span><br></pre></td></tr></table></figure><h1 id="使用-Vscode-进行断点调试"><a href="#使用-Vscode-进行断点调试" class="headerlink" title="使用 Vscode 进行断点调试"></a>使用 Vscode 进行断点调试</h1><p>我们还可以通过 <a href="https://link.zhihu.com/?target=https://github.com/xmake-io/xmake-vscode">xmake-vscode</a> 插件配合 vscode 来实现对 c&#x2F;c++ 项目的断点调试支持。</p><p>另外我们还需要依赖 vscode 的 C++ 插件才能进行调试支持，不过由于开发 c&#x2F;c++ 程序，这个插件几乎是必需，所以并没有太大问题。</p><p>就算没有安装此插件，xmake-vscode 也会加载 lldb&#x2F;gdb&#x2F;vsjitdebugger 等系统调试器，直接加载调试。</p><h1 id="常用的编译器参数"><a href="#常用的编译器参数" class="headerlink" title="常用的编译器参数"></a>常用的编译器参数</h1><p>在 xmake 中添加编译参数的通用做法是使用 <code>add_&lt;language&gt;flags</code> 家族的几个函数：</p><ul><li><code>add_cflags</code>：添加 C 编译器的编译参数</li><li><code>add_cxxflags</code>：添加 C++ 编译器的编译参数</li><li><code>add_cuflags</code>：添加 CUDA 编译器的编译参数</li><li><code>add_asflags</code>：添加汇编语言的汇编参数</li><li><code>add_cxflags</code>：同时对 C 编译器和 C++ 编译器启用的编译参数</li><li><code>add_ldflags</code>：添加二进制文件链接参数</li><li><code>add_arflags</code>：添加静态库生成参数</li><li><code>add_shflags</code>：添加动态链接库生成参数</li></ul><p>在使用这些函数添加编译参数时，xmake 会自动检查编译参数的可用性，并对当前编译器启用可用的参数。若想略过这一检查过程，可以使用 <code>force</code> 参数指定。一个简单例子如下。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add_cxxflags(<span class="string">&quot;-march=native&quot;</span>, &#123;force = <span class="literal">true</span>&#125;) <span class="comment">-- skip the check</span></span><br></pre></td></tr></table></figure><blockquote><p>Tips. Lua 语言使用双横线 <code>--</code> 作为单行注释的标记。多行注释则使用 <code>--[[</code> 作为开头，<code>--]]</code> 作为结束。</p></blockquote><p>xmake 对一些常用的参数作了抽象，对这些参数无需手动指定其内容，实际编译时这些参数会自动根据编译器不同而变化。下面介绍其中的一些。</p><h2 id="指定语言版本"><a href="#指定语言版本" class="headerlink" title="指定语言版本"></a>指定语言版本</h2><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set_languages(<span class="string">&quot;c11&quot;</span>, <span class="string">&quot;cxx20&quot;</span>)</span><br></pre></td></tr></table></figure><p>xmake 中使用 <code>set_languages</code> 语句设置语言版本。与大部分声明不同，设置语言版本的语句通常放在所有 target 声明之前，全局生效，否则容易导致标准库冲突。xmake 中还提供了一个特殊的版本：<code>set_languages(&quot;cxxlatest&quot;)</code>，对 msvc 展开为 <code>-std:c++latest</code>，而对 gcc&#x2F;clang 则自动检测当前编译器支持的 C++ 标准并使用其中最新的标准。</p><h2 id="添加头文件目录"><a href="#添加头文件目录" class="headerlink" title="添加头文件目录"></a>添加头文件目录</h2><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add_includedirs(<span class="string">&quot;include&quot;</span>)</span><br></pre></td></tr></table></figure><p>头文件目录是 C&#x2F;C++ 编译器查找头文件的根目录，xmake 中使用 <code>add_includedirs</code> 指定。这一语句通常对单个 target 生效，在 msvc、gcc、clang 均展开为 <code>-Iinclude</code>。</p><h2 id="添加链接目录与链接库"><a href="#添加链接目录与链接库" class="headerlink" title="添加链接目录与链接库"></a>添加链接目录与链接库</h2><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">add_linkdirs(<span class="string">&quot;ext/lib&quot;</span>)</span><br><span class="line">add_links(<span class="string">&quot;myext&quot;</span>)</span><br><span class="line">add_syslinks(<span class="string">&quot;pthread&quot;</span>, <span class="string">&quot;m&quot;</span>)</span><br></pre></td></tr></table></figure><p>链接目录是链接器查找第三方链接库的目录，xmake 中使用 <code>add_linkdirs</code> 指定，而第三方链接库则使用 <code>add_links</code> 指定。有一些第三方链接库是系统提供的，这些库需要放在链接顺序的末尾以规避链接顺序问题，这时可使用 <code>add_syslinks</code> 来指定。通过 <code>add_syslinks</code> 添加的链接库会在所有通过 <code>add_links</code> 添加的链接库之后链接。</p><h2 id="添加预定义宏"><a href="#添加预定义宏" class="headerlink" title="添加预定义宏"></a>添加预定义宏</h2><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add_defines(<span class="string">&quot;MYMACRO=hello&quot;</span>)</span><br></pre></td></tr></table></figure><p>预定义宏是 C&#x2F;C++ 编译器在预处理阶段加入的额外宏定义，可以在编译时从命令行传入。这个功能是 C&#x2F;C++ 中通过选项控制编译内容的最常见方法。xmake 中使用 <code>add_defines</code> 来加入预定义宏，例如上面的语句将展开为 <code>-DMYMACRO=hello</code>。当预定义宏含有空格或歧义字符时，需要用户处理转义：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add_defines(<span class="string">&quot;MYMACRO=\&quot;hello world\&quot;&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="设置-Warning-等级"><a href="#设置-Warning-等级" class="headerlink" title="设置 Warning 等级"></a>设置 Warning 等级</h2><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set_warnings(<span class="string">&quot;all&quot;</span>)</span><br><span class="line">set_warnings(<span class="string">&quot;error&quot;</span>)</span><br></pre></td></tr></table></figure><p>xmake 中使用 <code>set_warnings</code> 来设置编译器警告的等级。例如，上述代码在 gcc 上展开为 <code>-Wall -Werror</code>。对 msvc，xmake 将自动将警告等级转换为 msvc 对应的级别，上述级别在 msvc 的对应为 <code>-W3 -WX</code>。需要注意的一点是，为了避免警告刷屏，xmake 默认不显示警告信息，除非设置 <code>set_warnings(&quot;error&quot;)</code> 将警告视为错误。要显示警告，可以运行 <code>xmake -w</code> 来查看。</p><h2 id="设置-Optimize-等级"><a href="#设置-Optimize-等级" class="headerlink" title="设置 Optimize 等级"></a>设置 Optimize 等级</h2><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set_optimize(<span class="string">&quot;faster&quot;</span>)</span><br></pre></td></tr></table></figure><p>通常情况下，引入 mode.debug 与 mode.release 后就无需单独设置 optimize 等级了。但是对于希望更精细优化等级控制的开发者而言，可能需要手动设置 optimize 等级。xmake 通过 <code>set_optimize</code> 函数提供了 4 个预定义的 optimize 等级：<code>none</code>、<code>faster</code>、<code>fastest</code>、<code>smallest</code>。<br>一般情况，即使需要这些等级，也用不着直接调用 <code>set_optimize</code>，因为内置的 mode 并不只有 debug 和 release，对应于这些等级有：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add_rules(<span class="string">&quot;mode.debug&quot;</span>, <span class="string">&quot;mode.releasedbg&quot;</span>, <span class="string">&quot;mode.release&quot;</span>, <span class="string">&quot;mode.minsizerel&quot;</span>)</span><br></pre></td></tr></table></figure><p>在 xmake 的 configure 过程，运行 <code>xmake config --mode &lt;mode&gt;</code> 即可在不同的优化等级之间切换。更多的内置 mode 可运行</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ xmake show -l buildmodes</span><br></pre></td></tr></table></figure><p>来查看。</p><h1 id="通过选择与循环添加编译器参数"><a href="#通过选择与循环添加编译器参数" class="headerlink" title="通过选择与循环添加编译器参数"></a>通过选择与循环添加编译器参数</h1><h2 id="选择结构"><a href="#选择结构" class="headerlink" title="选择结构"></a>选择结构</h2><p>Lua 语言中选择语句的结构如下：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> &lt;condition1&gt; <span class="keyword">then</span></span><br><span class="line">    &lt;task1&gt;</span><br><span class="line"><span class="keyword">elseif</span> &lt;condition2&gt; <span class="keyword">then</span></span><br><span class="line">    &lt;task2&gt;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    &lt;task3&gt;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>这一结构可以直接在 xmake.lua 中使用，在处理跨平台编译问题时尤为重要。例如，要在 windows 上和 linux 上定义不同的宏，可以这样写：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">set_allowedplats(<span class="string">&quot;windows&quot;</span>, <span class="string">&quot;linux&quot;</span>)</span><br><span class="line">target(<span class="string">&quot;helloworld&quot;</span>)</span><br><span class="line">    set_kind(<span class="string">&quot;binary&quot;</span>)</span><br><span class="line">    add_files(<span class="string">&quot;src/**.cpp&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> is_plat(<span class="string">&quot;windows&quot;</span>) <span class="keyword">then</span></span><br><span class="line">        add_defines(<span class="string">&quot;PLAT_WINDOWS&quot;</span>)</span><br><span class="line">    <span class="keyword">elseif</span> is_plat(<span class="string">&quot;linux&quot;</span>) <span class="keyword">then</span></span><br><span class="line">        add_defines(<span class="string">&quot;PLAT_LINUX&quot;</span>)</span><br><span class="line">    <span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>其中 <code>set_allowedplats</code> 用于限定支持的平台。可以注意到，这里用到了 <code>is_plat</code> 来判断编译的目标平台。xmake 提供了如下几个常用条件判断语句：</p><ul><li><code>is_plat</code>：判断编译的目标平台。configure 阶段选定。</li><li><code>is_host</code>：判断编译器的宿主平台（交叉编译时不同于目标平台）。</li><li><code>is_arch</code>：判断编译的目标架构。configure 阶段选定。</li><li><code>is_mode</code>：判断 configure 阶段选定的编译模式。</li><li><code>is_kind</code>：判断 configure 阶段选定的默认链接库类型。</li><li><code>has_config</code>：判断 option 是否被启用。这一语句的用法详见第 5 节 - 项目选项。</li></ul><blockquote><p>Tips. 这些判断支持 Lua 正则表达式匹配。这一功能的一个重要用途是判断目标架构是否为 64 位：<code>is_arch(&quot;.+64.*&quot;)</code>。关于 Lua 正则表达式的更多信息，请参考 Lua 语言文档。</p></blockquote><p>这些语句可以通过逻辑运算形成复合表达式。Lua 中逻辑判断的混合使用 <code>and</code>、<code>or</code> 和 <code>not</code> 运算符。例如，要限定 windows 系统 x64 架构，可以写</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> is_plat(<span class="string">&quot;windows&quot;</span>) <span class="keyword">and</span> is_arch(<span class="string">&quot;x64&quot;</span>) <span class="keyword">then</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>xmake 在各平台上支持的各架构名称可以运行如下命令查看：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ xmake show -l architectures</span><br></pre></td></tr></table></figure><p>前面提到，<code>plat</code>、<code>arch</code>、<code>mode</code>、<code>kind</code> 都是可以在 configure 阶段修改的。前两个参数的修改可以支持交叉编译时选择不同的平台与架构，后两个参数则可以调整编译模式以及默认链接库类型。也就是说，configure 阶段的完整写法应该是：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ xmake config --plat=... --<span class="built_in">arch</span>=... --mode=... --kind=... ...</span><br><span class="line">$ xmake f -p ... -a ... -m ... -k ... ... <span class="comment"># same with above</span></span><br></pre></td></tr></table></figure><p>实际使用大部分情况不需要这么复杂的设置，非交叉编译时 plat 和 arch 可以不用声明，只有 mode 默认为 release、kind 默认为 static 可能需要修改。</p><blockquote><p>Tips. Windows 上使用 mingw 也算交叉编译，所以需要运行 <code>xmake f -p mingw</code>，这就是第 1 节中提到的那个命令的由来。</p></blockquote><h2 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h2><p>Lua 语言支持三种循环结构：<code>for</code> 循环、<code>while</code> 循环与 <code>repeat</code> 循环。xmake 中常用第一种结构中的 table 循环，即 <code>for</code> 循环中的 table 循环。</p><p>说循环结构之前，得先说说 Lua 语言的变量系统。Lua 语言声明变量的方式如下：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> a = <span class="number">0</span></span><br><span class="line"><span class="keyword">local</span> b = a + <span class="number">1</span></span><br><span class="line"><span class="keyword">local</span> v = &#123;a, b, b + <span class="number">2</span>&#125;</span><br><span class="line"><span class="keyword">local</span> m = &#123;first = a, second = b&#125;</span><br></pre></td></tr></table></figure><p>其中，<code>local</code> 关键字表示声明变量为局部变量，<code>=</code> 用于赋值，常用的四则运算与比较运算符除了不等关系以外都与 C&#x2F;C++ 一致。Lua 中使用 <code>~=</code> 表示不等判断。Lua 中的变量有 nil、boolean、数值、字符串、table、function 等，table 还同时是数组（类似 std::vector）和映射（类似 std::map）。需要注意的一点是，Lua 中数组的下标从 1 开始。Lua 中使用运算符 <code>#</code> 来获取 table 的尺寸：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> len_v = #v</span><br></pre></td></tr></table></figure><p>关于 Lua 语言的更多内容请参考 <a href="https://link.zhihu.com/?target=https://www.lua.org/manual/5.4/manual.html">Lua官方文档</a>。</p><p><code>for</code> 循环中 table 循环结构如下：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> index, value <span class="keyword">in</span> <span class="built_in">ipairs</span>(&lt;<span class="built_in">table</span>-vector&gt;) <span class="keyword">do</span></span><br><span class="line">    &lt;task-vector&gt;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">for</span> name, value <span class="keyword">in</span> <span class="built_in">pairs</span>(&lt;<span class="built_in">table</span>-map&gt;) <span class="keyword">do</span></span><br><span class="line">    &lt;task-map&gt;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>这里 <code>ipairs</code> 和 <code>pairs</code> 是 Lua 的标准库函数，它们分别被用来遍历数组型 table 和映射型 table。这一功能常常可以用来简化 xmake.lua 的书写：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> supported_platform = &#123;<span class="string">&quot;windows&quot;</span>, <span class="string">&quot;macosx&quot;</span>, <span class="string">&quot;linux&quot;</span>, <span class="string">&quot;mingw&quot;</span>&#125;</span><br><span class="line">set_allowedplats(supported_platform) <span class="comment">-- xmake functions can accept table as input</span></span><br><span class="line">target(<span class="string">&quot;helloworld&quot;</span>)</span><br><span class="line">    set_kind(<span class="string">&quot;binary&quot;</span>)</span><br><span class="line">    add_files(<span class="string">&quot;src/**.cpp&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> _, p <span class="keyword">in</span> <span class="built_in">ipairs</span>(supported_platform) <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">if</span> is_plat(p) <span class="keyword">then</span></span><br><span class="line">            add_defines(<span class="string">&quot;PLAT_&quot;</span> .. p:<span class="built_in">upper</span>())</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>这里用到了 Lua 的两个特性：字符串拼接运算符 <code>..</code> 以及函数调用运算符 <code>:</code>。<code>..</code> 用于拼接两个字符串，将其合成一个；而 <code>p:upper()</code> 返回字符串 <code>p</code> 的全大写形式。例如，当 <code>p</code> 为 <code>&quot;windows&quot;</code> 时，添加的编译参数为 <code>-DPLAT_WINDOWS</code>。对这些特性感兴趣的读者可以参考 Lua 文档自行研究。</p><h2 id="编译参数在-Target-间的传递"><a href="#编译参数在-Target-间的传递" class="headerlink" title="编译参数在 Target 间的传递"></a>编译参数在 Target 间的传递</h2><p>当存在多个 target 时，往往 target 之间存在一定依赖关系。xmake 中使用 <code>add_deps</code> 来描述 target 间的依赖关系。我们用一个例子来说明这种情况。建立目录结构如下</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">root</span><br><span class="line">|- include</span><br><span class="line">    |- mylib.h</span><br><span class="line">|- src</span><br><span class="line">    |- mylib.cpp</span><br><span class="line">    |- myexe.cpp</span><br><span class="line">|- xmake.lua</span><br></pre></td></tr></table></figure><p>其中 mylib.h 包含函数 <code>myfunc</code> 声明，mylib.cpp 包含函数 <code>myfunc</code> 定义，myexe.cpp 使用 <code>myfunc</code>。xmake.lua 文件结构如下</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">add_rules(<span class="string">&quot;mode.debug&quot;</span>, <span class="string">&quot;mode.release&quot;</span>)</span><br><span class="line">set_languages(<span class="string">&quot;cxx20&quot;</span>)</span><br><span class="line">target(<span class="string">&quot;mylib&quot;</span>)</span><br><span class="line">    set_kind(<span class="string">&quot;static&quot;</span>)</span><br><span class="line">    add_includedirs(<span class="string">&quot;include&quot;</span>)</span><br><span class="line">    add_files(<span class="string">&quot;src/mylib.cpp&quot;</span>)</span><br><span class="line">target(<span class="string">&quot;myexe&quot;</span>)</span><br><span class="line">    set_kind(<span class="string">&quot;binary&quot;</span>)</span><br><span class="line">    add_files(<span class="string">&quot;src/myexe.cpp&quot;</span>)</span><br><span class="line">    add_deps(<span class="string">&quot;mylib&quot;</span>)</span><br></pre></td></tr></table></figure><p><code>add_deps</code> 将 <code>mylib</code> 设置为 <code>myexe</code> 的依赖，编译时将先链接 <code>mylib</code>，再链接 <code>myexe</code>，并在 <code>myexe</code> 链接时自动链接到 libmylib.a 或者 mylib.lib（取决于平台）。但是，这么写会编译报错找不到 ‘mylib.h’ 文件！为什么呢？因为 “include” 这个文件夹仅被设置为 <code>mylib</code> 的头文件目录，而没有被设置成 <code>myexe</code> 的头文件目录。为了解决这个问题，需要做一个小小的改动。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">add_rules(<span class="string">&quot;mode.debug&quot;</span>, <span class="string">&quot;mode.release&quot;</span>)</span><br><span class="line">set_languages(<span class="string">&quot;cxx20&quot;</span>)</span><br><span class="line">target(<span class="string">&quot;mylib&quot;</span>)</span><br><span class="line">    set_kind(<span class="string">&quot;static&quot;</span>)</span><br><span class="line">    add_includedirs(<span class="string">&quot;include&quot;</span>, &#123;public = <span class="literal">true</span>&#125;)</span><br><span class="line">    add_files(<span class="string">&quot;src/mylib.cpp&quot;</span>)</span><br><span class="line">target(<span class="string">&quot;myexe&quot;</span>)</span><br><span class="line">    set_kind(<span class="string">&quot;binary&quot;</span>)</span><br><span class="line">    add_files(<span class="string">&quot;src/myexe.cpp&quot;</span>)</span><br><span class="line">    add_deps(<span class="string">&quot;mylib&quot;</span>)</span><br></pre></td></tr></table></figure><p>再次输入 <code>xmake</code>，发现可以正确编译了！这是因为 <code>mylib</code> 的头文件目录被设置为 “public”，也就是说，这一属性会被依赖于 <code>mylib</code> 的 <code>myexe</code> 继承。对于 <code>add_defines</code>、<code>add_cxflags</code> 等接口，也有类似的设置选项。</p><p>在依赖时，xmake 默认会将依赖项生成的库文件链接到当前 target。然而，如果这一行为是不想要的，也可以通过选项来避免这一行为：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">add_rules(<span class="string">&quot;mode.debug&quot;</span>, <span class="string">&quot;mode.release&quot;</span>)</span><br><span class="line">set_languages(<span class="string">&quot;cxx20&quot;</span>)</span><br><span class="line">target(<span class="string">&quot;mylib&quot;</span>)</span><br><span class="line">    set_kind(<span class="string">&quot;static&quot;</span>)</span><br><span class="line">    add_includedirs(<span class="string">&quot;include&quot;</span>, &#123;public = <span class="literal">true</span>&#125;)</span><br><span class="line">    add_files(<span class="string">&quot;src/mylib.cpp&quot;</span>)</span><br><span class="line">target(<span class="string">&quot;myexe&quot;</span>)</span><br><span class="line">    set_kind(<span class="string">&quot;binary&quot;</span>)</span><br><span class="line">    add_files(<span class="string">&quot;src/myexe.cpp&quot;</span>)</span><br><span class="line">    add_deps(<span class="string">&quot;mylib&quot;</span>, &#123;inherit = <span class="literal">false</span>&#125;)</span><br></pre></td></tr></table></figure><p>这样一来 <code>myexe</code> 就不会链接到 <code>mylib</code> 了。</p><h1 id="切换编译模式"><a href="#切换编译模式" class="headerlink" title="切换编译模式"></a>切换编译模式</h1><h2 id="调试和发布模式"><a href="#调试和发布模式" class="headerlink" title="调试和发布模式"></a>调试和发布模式</h2><p>通常，如果我们是通过 <code>xmake create</code> 命令创建的项目，会在 xmake.lua 里面自动添加一行编译规则的配置，如下：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">add_rules(<span class="string">&quot;mode.release&quot;</span>, <span class="string">&quot;mode.debug&quot;</span>) </span><br><span class="line">target(<span class="string">&quot;hello&quot;</span>) </span><br><span class="line">    set_kind(<span class="string">&quot;binary&quot;</span>)</span><br><span class="line">    add_files(<span class="string">&quot;src/*.c&quot;</span>)</span><br></pre></td></tr></table></figure><p>通过 <code>add_rules</code> 接口，我们默认添加了 release 和 debug 两个常用的内置规则，它们会在编译的时候附带上对应模式相关的一些编译 flags，来开启优化用于发布或者调试编译。</p><p>如果仅仅执行了 <code>xmake</code> 命令，没有额外的配置，那么默认就会是 release 编译，等价于：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ xmake f -m release </span><br><span class="line">$ xmake</span><br></pre></td></tr></table></figure><p>如果我们要切换到 debug 编译模式，只需要：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ xmake f -m debug </span><br><span class="line">$ xmake </span><br></pre></td></tr></table></figure><p>上面的 <code>-m/--mode=</code> 参数就是用来设置编译模式，会跟 <code>mode.release</code> 和 <code>mode.debug</code> 这两个规则做关联。</p><p>那么，他们是如何关联上的呢？我们可以先来看下这两个规则的内部实现：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">rule(<span class="string">&quot;mode.debug&quot;</span>)</span><br><span class="line">    after_load(<span class="function"><span class="keyword">function</span> <span class="params">(target)</span></span></span><br><span class="line">        <span class="keyword">if</span> is_mode(<span class="string">&quot;debug&quot;</span>) <span class="keyword">then</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> target:get(<span class="string">&quot;symbols&quot;</span>) <span class="keyword">then</span></span><br><span class="line">                target:set(<span class="string">&quot;symbols&quot;</span>, <span class="string">&quot;debug&quot;</span>)</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> target:get(<span class="string">&quot;optimize&quot;</span>) <span class="keyword">then</span></span><br><span class="line">                target:set(<span class="string">&quot;optimize&quot;</span>, <span class="string">&quot;none&quot;</span>)</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span>)</span><br><span class="line"></span><br><span class="line">rule(<span class="string">&quot;mode.release&quot;</span>)</span><br><span class="line">    after_load(<span class="function"><span class="keyword">function</span> <span class="params">(target)</span></span></span><br><span class="line">        <span class="keyword">if</span> is_mode(<span class="string">&quot;release&quot;</span>) <span class="keyword">then</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> target:get(<span class="string">&quot;symbols&quot;</span>) <span class="keyword">and</span> target:targetkind() ~= <span class="string">&quot;shared&quot;</span> <span class="keyword">then</span></span><br><span class="line">                target:set(<span class="string">&quot;symbols&quot;</span>, <span class="string">&quot;hidden&quot;</span>)</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> target:get(<span class="string">&quot;optimize&quot;</span>) <span class="keyword">then</span></span><br><span class="line">                <span class="keyword">if</span> is_plat(<span class="string">&quot;android&quot;</span>, <span class="string">&quot;iphoneos&quot;</span>) <span class="keyword">then</span></span><br><span class="line">                    target:set(<span class="string">&quot;optimize&quot;</span>, <span class="string">&quot;smallest&quot;</span>)</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    target:set(<span class="string">&quot;optimize&quot;</span>, <span class="string">&quot;fastest&quot;</span>)</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> target:get(<span class="string">&quot;strip&quot;</span>) <span class="keyword">then</span></span><br><span class="line">                target:set(<span class="string">&quot;strip&quot;</span>, <span class="string">&quot;all&quot;</span>)</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span>)</span><br></pre></td></tr></table></figure><p>可以看到，在 target 被加载阶段，xmake 会去判断用户对 <code>xmake f --mode=xxx</code> 的参数配置，如果通过 <code>is_mode()</code> 接口获取到是 debug 模式，那么会禁用相关优化并且启用符号输出。 而如果是 release 模式，那么会开启编译优化并且 strip 掉所有调试符号。</p><h2 id="定制化的模式配置"><a href="#定制化的模式配置" class="headerlink" title="定制化的模式配置"></a>定制化的模式配置</h2><p>当然，内置的这两规则默认设置的这些编译配置，只能满足大部分场景的常规需求，如果用户想要在不同的编译模式下定制化一些个人的编译配置，那么需要自己在 xmake.lua 做判断。</p><p>例如，我们想在 release 下也启用调试符号，那么只需要：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> is_mode(<span class="string">&quot;release&quot;</span>) <span class="keyword">then</span></span><br><span class="line">   set_symbols(<span class="string">&quot;debug&quot;</span>) </span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>或者额外增加一些编译 flags：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> is_mode(<span class="string">&quot;release&quot;</span>) <span class="keyword">then</span> </span><br><span class="line">    add_cflags(<span class="string">&quot;-fomit-frame-pointer&quot;</span>) </span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>注：如果用户自己的配置和 <code>mode.release</code> 内置的配置冲突，会优先使用用户的设置。</p><p>当然，我们也可以完全不去通过 <code>add_rules(&quot;mode.debug&quot;, &quot;mode.release&quot;)</code> 添加默认的配置规则，让用户完全自己控制模式配置：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 如果当前编译模式是debug</span></span><br><span class="line"><span class="keyword">if</span> is_mode(<span class="string">&quot;debug&quot;</span>) <span class="keyword">then</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">-- 添加DEBUG编译宏</span></span><br><span class="line">    add_defines(<span class="string">&quot;DEBUG&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">-- 启用调试符号</span></span><br><span class="line">    set_symbols(<span class="string">&quot;debug&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">-- 禁用优化</span></span><br><span class="line">    set_optimize(<span class="string">&quot;none&quot;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 如果是release或者profile模式</span></span><br><span class="line"><span class="keyword">if</span> is_mode(<span class="string">&quot;release&quot;</span>, <span class="string">&quot;profile&quot;</span>) <span class="keyword">then</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">-- 如果是release模式</span></span><br><span class="line">    <span class="keyword">if</span> is_mode(<span class="string">&quot;release&quot;</span>) <span class="keyword">then</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">-- 隐藏符号</span></span><br><span class="line">        set_symbols(<span class="string">&quot;hidden&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">-- strip所有符号</span></span><br><span class="line">        set_strip(<span class="string">&quot;all&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">-- 忽略帧指针</span></span><br><span class="line">        add_cxflags(<span class="string">&quot;-fomit-frame-pointer&quot;</span>)</span><br><span class="line">        add_mxflags(<span class="string">&quot;-fomit-frame-pointer&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">-- 如果是profile模式</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">-- 启用调试符号</span></span><br><span class="line">        set_symbols(<span class="string">&quot;debug&quot;</span>)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">-- 添加扩展指令集</span></span><br><span class="line">    add_vectorexts(<span class="string">&quot;sse2&quot;</span>, <span class="string">&quot;sse3&quot;</span>, <span class="string">&quot;ssse3&quot;</span>, <span class="string">&quot;mmx&quot;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h2 id="其他内置模式规则"><a href="#其他内置模式规则" class="headerlink" title="其他内置模式规则"></a>其他内置模式规则</h2><p>通过上文的例子，我们看到除了 debug&#x2F;release 模式，还加了个 profile 模式的配置判断，其实 xmake 也提供了对应的内置模式，还有哪些，我们具体来看下：</p><h2 id="mode-debug"><a href="#mode-debug" class="headerlink" title="mode.debug"></a>mode.debug</h2><p>为当前工程 xmake.lua 添加 debug 编译模式的配置规则，例如：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add_rules(<span class="string">&quot;mode.debug&quot;</span>)</span><br></pre></td></tr></table></figure><p>相当于：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> is_mode(<span class="string">&quot;debug&quot;</span>) <span class="keyword">then</span> </span><br><span class="line">    set_symbols(<span class="string">&quot;debug&quot;</span>) </span><br><span class="line">    set_optimize(<span class="string">&quot;none&quot;</span>) </span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>我们可以通过：<code>xmake f -m debug</code> 来切换到此编译模式。</p><h2 id="mode-release"><a href="#mode-release" class="headerlink" title="mode.release"></a>mode.release</h2><p>为当前工程 xmake.lua 添加 release 编译模式的配置规则，例如：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add_rules(<span class="string">&quot;mode.release&quot;</span>)</span><br></pre></td></tr></table></figure><p>相当于：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> is_mode(<span class="string">&quot;release&quot;</span>) <span class="keyword">then</span> </span><br><span class="line">    set_symbols(<span class="string">&quot;hidden&quot;</span>) </span><br><span class="line">    set_optimize(<span class="string">&quot;fastest&quot;</span>) </span><br><span class="line">    set_strip(<span class="string">&quot;all&quot;</span>) </span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>我们可以通过：<code>xmake f -m release</code> 来切换到此编译模式。</p><h2 id="mode-check"><a href="#mode-check" class="headerlink" title="mode.check"></a>mode.check</h2><p>为当前工程 xmake.lua 添加 check 编译模式的配置规则，一般用于内存检测，例如：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add_rules(<span class="string">&quot;mode.check&quot;</span>)</span><br></pre></td></tr></table></figure><p>相当于：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> is_mode(<span class="string">&quot;check&quot;</span>) <span class="keyword">then</span></span><br><span class="line">    set_symbols(<span class="string">&quot;debug&quot;</span>)</span><br><span class="line">    set_optimize(<span class="string">&quot;none&quot;</span>)</span><br><span class="line">    add_cxflags(<span class="string">&quot;-fsanitize=address&quot;</span>, <span class="string">&quot;-ftrapv&quot;</span>)</span><br><span class="line">    add_mxflags(<span class="string">&quot;-fsanitize=address&quot;</span>, <span class="string">&quot;-ftrapv&quot;</span>)</span><br><span class="line">    add_ldflags(<span class="string">&quot;-fsanitize=address&quot;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>我们可以通过：<code>xmake f -m check</code> 来切换到此编译模式。</p><h2 id="mode-profile"><a href="#mode-profile" class="headerlink" title="mode.profile"></a>mode.profile</h2><p>为当前工程 xmake.lua 添加 profile 编译模式的配置规则，一般用于性能分析，例如：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add_rules(<span class="string">&quot;mode.profile&quot;</span>)</span><br></pre></td></tr></table></figure><p>相当于：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> is_mode(<span class="string">&quot;profile&quot;</span>) <span class="keyword">then</span></span><br><span class="line">    set_symbols(<span class="string">&quot;debug&quot;</span>)</span><br><span class="line">    add_cxflags(<span class="string">&quot;-pg&quot;</span>)</span><br><span class="line">    add_ldflags(<span class="string">&quot;-pg&quot;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>我们可以通过：<code>xmake f -m profile</code> 来切换到此编译模式。</p><h2 id="mode-coverage"><a href="#mode-coverage" class="headerlink" title="mode.coverage"></a>mode.coverage</h2><p>为当前工程 xmake.lua 添加 coverage 编译模式的配置规则，一般用于覆盖分析，例如：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add_rules(<span class="string">&quot;mode.coverage&quot;</span>)</span><br></pre></td></tr></table></figure><p>相当于：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> is_mode(<span class="string">&quot;coverage&quot;</span>) <span class="keyword">then</span></span><br><span class="line">    add_cxflags(<span class="string">&quot;--coverage&quot;</span>)</span><br><span class="line">    add_mxflags(<span class="string">&quot;--coverage&quot;</span>)</span><br><span class="line">    add_ldflags(<span class="string">&quot;--coverage&quot;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>我们可以通过：<code>xmake f -m coverage</code> 来切换到此编译模式。</p><p>注：生成的 gcno 文件一般都是个 obj 所在目录对应的哦，因此需要从 build 目录下去找。</p><h2 id="扩展自己的编译模式"><a href="#扩展自己的编译模式" class="headerlink" title="扩展自己的编译模式"></a>扩展自己的编译模式</h2><p>xmake 的模式配置，并没有固定值，用户可以随意传入和配置，只要 <code>xmake f -m/--mode=xxx</code> 传入的模式值和 xmake.lua 里面的 <code>is_mode(&quot;xxx&quot;)</code> 能对应上就行。</p><p>比如，我们设置了一个自己独有的编译模式 <code>my_mode</code>，可以直接在命令行配置切换；</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ xmake f -m my_mode </span><br><span class="line">$ xmake </span><br></pre></td></tr></table></figure><p>然后 xmake.lua 里面对相应的值进行判断即可：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> is_mode(<span class="string">&quot;my_mode&quot;</span>) <span class="keyword">then</span> </span><br><span class="line">    add_defines(<span class="string">&quot;ENABLE_MY_MODE&quot;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h2 id="使用模式变量"><a href="#使用模式变量" class="headerlink" title="使用模式变量"></a>使用模式变量</h2><p>我们也可以直接在配置值中传递模式变量 <code>$(mode)</code>，比如根据不同模式选择链接不同的库：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">target(<span class="string">&quot;test&quot;</span>)</span><br><span class="line">    set_kind(<span class="string">&quot;binary&quot;</span>)</span><br><span class="line">    add_files(<span class="string">&quot;src/*.c&quot;</span>)</span><br><span class="line">    add_links(<span class="string">&quot;xxx_$(mode)&quot;</span>)</span><br></pre></td></tr></table></figure><p>上面的配置，如果是调试模式编译就会选择链接：<code>libxxx_debug.a</code> 库，而 release 下就会链接 <code>libxxx_release.a</code>，当然，我们也可以设置到库搜索路径中，根据目录来选择对应的库。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">target(<span class="string">&quot;test&quot;</span>)</span><br><span class="line">    set_kind(<span class="string">&quot;binary&quot;</span>)</span><br><span class="line">    add_files(<span class="string">&quot;src/*.c&quot;</span>)</span><br><span class="line">    add_linkdirs(<span class="string">&quot;lib/$(mode)&quot;</span>)</span><br><span class="line">    add_links(<span class="string">&quot;xxx&quot;</span>)</span><br></pre></td></tr></table></figure><p>另外，我们可以通过 <code>get_config(&quot;mode&quot;)</code> 直接获取到传入的模式配置值，并且这几种获取方式，在自定义脚本也是同样有效的哦，例如：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">target(<span class="string">&quot;test&quot;</span>)</span><br><span class="line">    set_kind(<span class="string">&quot;binary&quot;</span>)</span><br><span class="line">    add_files(<span class="string">&quot;src/*.c&quot;</span>)</span><br><span class="line">    on_load(<span class="function"><span class="keyword">function</span> <span class="params">(target)</span></span></span><br><span class="line">        <span class="keyword">if</span> is_mode(<span class="string">&quot;release&quot;</span>) <span class="keyword">then</span></span><br><span class="line">            <span class="built_in">print</span>(get_config(<span class="string">&quot;mode&quot;</span>), <span class="string">&quot;$(mode)&quot;</span>)</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> 构建工具 </category>
          
          <category> Xmake </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>A Tour of xmake - 00. 简介</title>
      <link href="/posts/%E5%AD%A6%E4%B9%A0/%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/Xmake/A%20Tour%20of%20xmake%20-%2000.%20%E7%AE%80%E4%BB%8B.html"/>
      <url>/posts/%E5%AD%A6%E4%B9%A0/%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/Xmake/A%20Tour%20of%20xmake%20-%2000.%20%E7%AE%80%E4%BB%8B.html</url>
      
        <content type="html"><![CDATA[<h1 id="什么是构建系统"><a href="#什么是构建系统" class="headerlink" title="什么是构建系统?"></a>什么是构建系统?</h1><p>程序从一段代码到可执行文件的构建过程，往往中间要经过编译、链接等步骤，因此在不同的运行平台上需要各种各样的编译器和链接器。除了编译与链接之外，在构建过程中经常还需要调整配置、管理依赖、生成代码、打包代码库等操作。管理构建过程的程序叫做构建系统。构建系统并不执行编译本身，只是调用编译器和其他工具来执行构建任务。通常构建系统会使用<strong>配置文件</strong>来描述构建过程。几乎所有编译型编程语言都有它们的构建系统，例如 C&#x2F;C++ 的 autotools、cmake、xmake 等，Java 的 maven、gradle，Rust 的 cargo 等。解释型编程语言通常在执行时即时编译并运行，因此其构建系统的重心不在编译链接而在构建过程中的其他需求（管理依赖、打包、优化等），例如 Python 的 pip、conda，JavaScript 的 npm、yarn 等。</p><h1 id="为什么需要构建系统？"><a href="#为什么需要构建系统？" class="headerlink" title="为什么需要构建系统？"></a>为什么需要构建系统？</h1><p>理论上只需要一个文本编辑器，一组合适的编译器与链接器就能完成开发任务了。然而，实际上在开发过程中会遇到很多麻烦的工作，而构建系统的任务就是将这些麻烦的工作自动化，解放程序员的双手。构建系统至少有如下几个作用：</p><ol><li><p>编写大型系统时，需要<strong>保证构建的可重复性</strong>。一个地方的 flag 出错，可能导致整个构建过程失败。只有将构建过程写进文件中，把构建过程交给构建系统，才能保证构建过程中使用的指令的稳定性。当然由于编译环境和外部依赖不同，使用构建系统也不能完全保证构建的可重复性，这一点需要程序员来保证。</p></li><li><p>编码过程中一个合适的 IDE 可以大大提高编码效率，而 IDE 需要一些构建描述文件才能 “ 认识 “ 项目。让构建系统来<strong>生成构建描述文件</strong>，则无需在每次增删文件时都手动修改构建描述文件，大大减少无意义的重复工作。</p></li><li><p>依赖管理是开发过程中最令人头疼的问题之一。手动引入第三方依赖库很容易遇到版本不对、编译不过、链接繁琐、更新困难、难以调整等问题。使用构建系统来<strong>管理依赖</strong>，大大降低了依赖引入和更新过程中的繁琐步骤。</p></li><li><p>开发过程中同一个项目常常需要根据开发环境与用户需要，使用不同的参数和宏来进行构建，生成不同参数的可执行文件。构建系统可以使用 option 来<strong>管理构建参数</strong>，方便随时切换，解放双手。</p></li><li><p>当项目有多个开发者时，一份清晰的构建系统配置文件能大大<strong>降低交流成本</strong>，尤其是对于开源项目，构建系统将成为让别人了解项目结构的第一站。当需要将生成的文件打包分发时，构建系统的打包功能也非常实用。</p></li></ol><p>对单文件的简单程序，确实不需要构建系统。但是，一旦开发的项目需要大量文件，或者需要引入依赖，或者需要多组构建参数配置，构建系统将成为不可或缺的一部分。</p><h1 id="教程概览"><a href="#教程概览" class="headerlink" title="教程概览"></a>教程概览</h1><p>本教程分为三部分：</p><p>第一部分 概述</p><ol><li>简介，简要介绍 xmake 与 C&#x2F;C++ 的构建系统史。</li></ol><p>第二部分 基本功能</p><ol><li><p>快速入门，介绍如何配置并运行第一个 xmake 项目。</p></li><li><p>编译选项，介绍一些 C&#x2F;C++ 项目中常用编译选项设置。</p></li><li><p>依赖管理，介绍如何在 xmake 项目中查找并引入第三方库。</p></li><li><p>依赖仓库，介绍 xmake 仓库的包描述文件，以及自建仓库&#x2F;引用其它项目的方法。</p></li><li><p>构建选项，介绍如何通过选项控制构建过程，以及如何根据环境检测控制选项。</p></li><li><p>测试发布，介绍如何添加测试、安装&#x2F;发布生成的库与可执行文件（以及可能的文档）。</p></li></ol><p>第三部分 高级特性（暂定）</p><ol><li><p>跨语言项目，介绍 C&#x2F;C++&#x2F;CUDA&#x2F;Python 等多语言混合项目在 xmake 中的设置。</p></li><li><p>自定义规则，介绍 xmake 中的自定义规则与自定义工具链。</p></li><li><p>Lua 编程，介绍如何在 xmake 中使用 Lua 语言编写脚本解决复杂问题。</p></li><li><p>代码生成，介绍 xmake 对编译时生成代码的处理方式。</p></li></ol><p>实际上，只需要阅读到第二部分即可满足大部分项目的需要了。对于具有特殊需求的项目，第三部分仅对其中一部分作简要介绍，一些重要特性例如分布式编译未能涵盖。对此类项目，在教程之外更应根据需求参考官方文档、已有的其他项目进行补充，必要时可以在讨论区提问。本教程或有一定疏漏之处，恳请读者批评指正！</p><h1 id="相关网站"><a href="#相关网站" class="headerlink" title="相关网站"></a>相关网站</h1><p>xmake 的官方文档：<a href="https://xmake.io/">xmake</a></p><p>xmake-repo 的搜索站：<a href="https://xrepo.xmake.io/">xrepo</a></p><p>xmake 的 GitHub 仓库：<a href="https://link.zhihu.com/?target=https://github.com/xmake-io/xmake">xmake-io&#x2F;xmake</a></p><p>xmake-repo 的 GitHub 仓库：<a href="https://link.zhihu.com/?target=https://github.com/xmake-io/xmake-repo">xmake-io&#x2F;xmake-repo</a></p><p>xmake 提问讨论区：<a href="https://link.zhihu.com/?target=https://github.com/xmake-io/xmake/discussions">Discussions</a></p><p>xmake Discord：<a href="https://link.zhihu.com/?target=https://discord.gg/xmake">xmake channel</a></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.zhihu.com/column/c_1537535487199281152">A Tour of xmake - 知乎 (zhihu.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> 构建工具 </category>
          
          <category> Xmake </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>A Tour of xmake - 01. 快速入门</title>
      <link href="/posts/%E5%AD%A6%E4%B9%A0/%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/Xmake/A%20Tour%20of%20xmake%20-%2001.%20%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8.html"/>
      <url>/posts/%E5%AD%A6%E4%B9%A0/%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/Xmake/A%20Tour%20of%20xmake%20-%2001.%20%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8.html</url>
      
        <content type="html"><![CDATA[<h1 id="安装-Xmake"><a href="#安装-Xmake" class="headerlink" title="安装 Xmake"></a>安装 Xmake</h1><p>xmake 推荐使用 shell 脚本安装。<br>Bash</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash &lt;(wget https://xmake.io/shget.text -O -)</span><br></pre></td></tr></table></figure><p>Powershell</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Invoke-Expression</span> (<span class="built_in">Invoke-Webrequest</span> <span class="string">&#x27;https://xmake.io/psget.text&#x27;</span> <span class="literal">-UseBasicParsing</span>).Content</span><br></pre></td></tr></table></figure><p>Windows 上也可下载 <a href="https://link.zhihu.com/?target=https://github.com/xmake-io/xmake/releases">安装包</a> 手动安装。运行</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xmake --help</span><br></pre></td></tr></table></figure><p>能正常输出则说明安装成功。</p><p>使用 shell 脚本安装的 xmake 已经带有自动补全和虚拟环境功能。对于其他方式安装的 xmake，如果想要启用 xmake 的自动补全和虚拟环境功能，需要在安装完毕后运行</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xmake update --integrate</span><br></pre></td></tr></table></figure><p>安装之后，若要将 xmake 更新至最新版，使用</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xmake update</span><br></pre></td></tr></table></figure><p>卸载 xmake 时，运行</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xmake update --uninstall</span><br></pre></td></tr></table></figure><h1 id="更新升级"><a href="#更新升级" class="headerlink" title="更新升级"></a>更新升级</h1><p>从 v2.2.3 版本开始，新增了 <code>xmake update</code> 命令，来快速进行自我更新和升级，默认是升级到最新版本，当然也可以指定升级或者回退到某个版本：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ xmake update 2.2.4</span><br></pre></td></tr></table></figure><p>我们也可以指定更新到 master&#x2F;dev 分支版本：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ xmake update master </span><br><span class="line">$ xmake update dev</span><br></pre></td></tr></table></figure><p>从指定 git 源更新</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ xmake update github:xmake-io/xmake#master </span><br><span class="line">$ xmake update gitee:tboox/xmake#dev # gitee镜像</span><br></pre></td></tr></table></figure><p>如果 xmake&#x2F;core 没动过，仅仅更新 xmake 的 lua 脚本改动，可以加 <code>-s/--scriptonly</code> 快速更新 lua 脚本</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ xmake update -s dev</span><br></pre></td></tr></table></figure><p>最后，我们如果要卸载 xmake，也是支持的：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xmake update --uninstall </span><br></pre></td></tr></table></figure><h1 id="一个最简单的-Xmake-项目"><a href="#一个最简单的-Xmake-项目" class="headerlink" title="一个最简单的 Xmake 项目"></a>一个最简单的 Xmake 项目</h1><blockquote><p>Hint. 在之后的示例中，如无特殊说明，均以 $ 符号开头表示在 shell 中运行的命令。</p></blockquote><p>使用 shell 切换至一个有足够权限的文件目录，运行</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xmake create helloworld</span><br></pre></td></tr></table></figure><p>即可产生一个最简单的 xmake 项目。项目仅包含 main.cpp 一个文件，配置文件 xmake.lua 的内容如下：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">add_rules(<span class="string">&quot;mode.debug&quot;</span>, <span class="string">&quot;mode.release&quot;</span>)</span><br><span class="line">target(<span class="string">&quot;helloworld&quot;</span>)</span><br><span class="line">    set_kind(<span class="string">&quot;binary&quot;</span>)</span><br><span class="line">    add_files(<span class="string">&quot;src/main.cpp&quot;</span>)</span><br></pre></td></tr></table></figure><p>如果你已经安装了 C&#x2F;C++ 的编译器（gcc&#x2F;XCode&#x2F;Visual Studio），那么可以直接在 shell 中编译并运行这个项目：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ cd helloworld</span><br><span class="line">$ xmake</span><br><span class="line">...</span><br><span class="line">$ xmake run helloworld</span><br><span class="line">Hello World!</span><br></pre></td></tr></table></figure><p>默认情况下，中间缓存会被存储在.xmake 文件夹，构建生成的中间文件和目标文件放在 build 文件夹。</p><p>Windows 上若不想安装 Visual Studio，可以安装 mingw 作为编译器。如果在安装时启用了虚拟环境功能，则可以使用 xmake 提供的 mingw 虚拟环境（需要联网下载安装）。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ xrepo env -b mingw-w64 shell</span><br></pre></td></tr></table></figure><blockquote><p>Tips. 国内由于众所周知的原因，无法顺利访问 github。对此，xmake 提供了镜像功能，可以将 github 重定向到国内的镜像站点： <code>shell $ xmake global --proxy_pac=github_mirror.lua</code> 当然，如果本地存在代理，也可以直接在 shell 中设置环境变量以启用本地代理。</p><p>Tips. xmake 提供了 msvc、python3 等一系列内置的虚拟环境，可以用 <code>xrepo env -l</code> 命令查看。关于手动添加虚拟环境的方法请参考官方文档。</p></blockquote><p>激活虚拟环境后，运行</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[mingw-w64] $ cd helloworld</span><br><span class="line">[mingw-w64] $ xmake config -p mingw</span><br><span class="line">...</span><br><span class="line">[mingw-w64] $ xmake</span><br><span class="line">...</span><br><span class="line">[mingw-w64] $ xmake run helloworld</span><br><span class="line">Hello World!</span><br></pre></td></tr></table></figure><p>其中，<code>xmake config</code> 语句切换编译目标平台为 mingw。若使用 mingw 编译器，则编译之前必须执行这一命令，此后不再说明。</p><blockquote><p>Tips. <code>xmake config</code> 可以缩写为 <code>xmake f</code>，这个阶段称为 configure 阶段。直接运行 xmake 之前若未经过这一阶段，xmake 将自动运行 configure，并采用所有选项的默认参数。运行 <code>xmake --help</code> 来查看更多缩写！</p></blockquote><p>若不想使用平台默认的工具链（例如想要使用 clang 而不是 gcc），可以通过 <code>--toolchain</code> 选项来实现。同样在 configure 阶段，运行</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ xmake config --toolchain=clang</span><br></pre></td></tr></table></figure><p>即可切换编译工具链为 clang。</p><p>编译完成后，如果想要清理生成的文件，可以运行 <code>xmake clean</code> 来清理中间文件与目标文件。<code>xmake clean -a</code> 可以连同 xmake 缓存一同清除。<code>xmake config -c</code> 命令仅仅清除 xmake 缓存并重新生成，不清理中间文件和目标文件。</p><blockquote><p>Tips. xmake 文件发生更改后，为提升效率默认原来的缓存继续生效，可能会影响构建过程。建议在 xmake 文件发生较大更改后，或者遇到问题的时候手动运行 <code>xmake f -c</code> 来清理缓存。</p></blockquote><h1 id="在-IDE-中使用-Xmake"><a href="#在-IDE-中使用-Xmake" class="headerlink" title="在 IDE 中使用 Xmake"></a>在 IDE 中使用 Xmake</h1><p>xmake 直接支持生成 Makefile、ninja、compile_commands.json 等编译数据文件，Visual Studio 工程文件，以及 CMakeLists.txt 文件。通过这些编译数据，xmake 可以直接或间接支持各种常见 IDE。下以 Visual Studio Code 为例配置 xmake 项目的智能提示。</p><p>首先需要安装 VSCode 以及 C&#x2F;C++ 插件、xmake 插件，这两个插件可以在 VSCode Marketplace 找到。打开项目文件夹，运行 <code>xmake config</code> 完成 configure 过程。从 View 打开 Command Palette（默认快捷键 Ctrl+Shift+P），运行 XMake: Update Intellisense。此时可以在.vscode 文件夹中找到自动生成的 compile_commands.json。再打开 Command Palette，运行 C&#x2F;C++: Edit Configurations (UI)，检查编译器、C++ 语言版本等设置无误后，下拉选中 Advanced Settings，再选中 Compile commands，输入</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&#123;workspaceFolder&#125;/.vscode/compile_commands.json</span><br></pre></td></tr></table></figure><p>退出，再打开 src&#x2F;main.cpp 文件。此时智能提示已经可以工作了。此后，当项目构建过程发生变化时，运行 <code>xmake config</code> 后打开 Command Palette 运行 XMake: Update Intellisense 即可。</p><p>对于其他 IDE&#x2F;编辑器，根据其需要，生成对应的工程文件&#x2F;Compile Commands&#x2F;CMakeLists.txt 即可配置智能提示等功能。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ xmake project -k compile_commands</span><br><span class="line">$ xmake project -k cmake</span><br><span class="line">$ xmake project -k vs</span><br><span class="line">$ xmake project -k vsxmake</span><br></pre></td></tr></table></figure><blockquote><p>Tips. 对 Visual Studio，xmake 提供了两种不同的 project 生成器：vs 和 vsxmake。vs 生成直接基于 MSBuild 的构建文件，方便移植到其他机器，但其构建过程与直接执行 xmake 有可能存在少量差异；vsxmake 则在 MSBuild 中调用 xmake 进行编译，其构建过程等同于直接执行 xmake，但不便移植。对单机项目建议优先使用 vsxmake，而有特别需求时可以考虑使用 vs。</p></blockquote><h1 id="xmake-lua-再探"><a href="#xmake-lua-再探" class="headerlink" title="xmake.lua 再探"></a>xmake.lua 再探</h1><p>让我们回到配置文件本身，看看各行命令的作用是什么。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">add_rules(<span class="string">&quot;mode.debug&quot;</span>, <span class="string">&quot;mode.release&quot;</span>)</span><br><span class="line">target(<span class="string">&quot;helloworld&quot;</span>)</span><br><span class="line">    set_kind(<span class="string">&quot;binary&quot;</span>)</span><br><span class="line">    add_files(<span class="string">&quot;src/main.cpp&quot;</span>)</span><br></pre></td></tr></table></figure><p>第一行的 <code>add_rules</code> 语句声明了两个 mode：debug 与 release（默认 release）。debug 模式会关闭编译器优化并保留程序中的调试信息，而 release 模式会加入更激进的编译器优化。这一行并不是必须的，如果不写这一语句，编译时实际执行的命令中将不含有任何额外的 flag。</p><blockquote><p>Tips. 你可以运行 <code>xmake -v</code> 来查看实际执行的编译命令。在 xmake 执行出错时，执行 <code>xmake -vD</code> 可以打印出错的类型与位置，这一点在调试时尤其有用。</p></blockquote><p>第二行的 <code>target</code> 语句声明了一个 target：helloworld。在 xmake 中，所有的构建目标都用 target 来表示。如无额外声明，target 的名字将被默认作为库&#x2F;可执行文件的名字的主要部分。例如，windows 上 binary 类型的 target helloworld 其输出文件名为 helloworld.exe，linux 上 static 类型的 target helloworld 其输出文件名为 libhelloworld.a。声明 target 之后进入该 target 的作用域，直到声明另一个 target 或者显式调用 <code>target_end</code> 之前，所有语句都是针对该 target 生效的。</p><p>第三行的 <code>set_kind</code> 语句限定 target 的类型为 binary。xmake 中 target 类型一共有 5 种：binary（默认），static，shared，headeronly，phony，分别对应可执行文件、静态库、动态链接库、纯头文件、伪 target。phony 类型的 target 仅用于添加一些可继承的 flag、协调 target 编译顺序，不会执行编译链接操作。</p><p>第四行的 <code>add_files</code> 语句为 target 加入了源文件。通过 <code>add_files</code> 加入的所有源文件都会被编译为中间文件，然后链接到目标文件中。xmake 支持通配符匹配添加文件：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">target(...)</span><br><span class="line">    add_files(<span class="string">&quot;src/*.cpp|standalone.cpp&quot;</span>, <span class="string">&quot;src/*.cu&quot;</span>)</span><br></pre></td></tr></table></figure><p>这一语句将 src 文件夹下所有.cu 后缀的文件、除 standalone.cpp 之外所有.cpp 后缀的文件加入 target。不显式声明 rule 重载的情况下，默认.c 后缀的文件会自动调用 C 编译器编译，.cpp&#x2F;.cc&#x2F;.cxx 后缀的文件会调用 C++ 编译器编译，.cu 后缀的文件会调用 CUDA 编译器编译，.asm&#x2F;.S 后缀的文件会调用汇编器汇编。</p><p>以上就是最简单的可执行文件 xmake.lua 结构。如果 helloworld.cpp 中没有 main() 函数，想要把 helloworld 编译为一个库，xmake.lua 也非常简单：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">add_rules(<span class="string">&quot;mode.debug&quot;</span>, <span class="string">&quot;mode.release&quot;</span>)</span><br><span class="line">target(<span class="string">&quot;helloworld&quot;</span>)</span><br><span class="line">    set_kind(<span class="string">&quot;$(kind)&quot;</span>)</span><br><span class="line">    add_files(<span class="string">&quot;src/main.cpp&quot;</span>)</span><br></pre></td></tr></table></figure><p>唯一的变化是 <code>set_kind</code> 语句。<code>set_kind(&quot;$(kind)&quot;)</code> 中使用了 xmake 的内置变量 <code>kind</code>。这一变量是在 configure 阶段指定的：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ xmake config --kind=shared # make libraries shared by default</span><br></pre></td></tr></table></figure><p>未指定情况下，<code>kind</code> 的默认值为 static。</p><blockquote><p>Tips. “$(val)” 的用法在 xmake 中仅限于字符串内部，其作用为简单的字符串替换。这一替换过程并非即时生效，而是解析完毕后再执行替换，因此不建议在 Script Scope 使用。详见 <a href="https://link.zhihu.com/?target=https://xmake.io/%23/manual/builtin_variables">文档</a>。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> 构建工具 </category>
          
          <category> Xmake </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Obsidian 插件配置</title>
      <link href="/posts/%E5%BA%94%E7%94%A8/%E9%85%8D%E7%BD%AE/%E8%BD%AF%E4%BB%B6%E9%85%8D%E7%BD%AE/Obsidian%20%E6%8F%92%E4%BB%B6%E9%85%8D%E7%BD%AE.html"/>
      <url>/posts/%E5%BA%94%E7%94%A8/%E9%85%8D%E7%BD%AE/%E8%BD%AF%E4%BB%B6%E9%85%8D%E7%BD%AE/Obsidian%20%E6%8F%92%E4%BB%B6%E9%85%8D%E7%BD%AE.html</url>
      
        <content type="html"><![CDATA[<h1 id="Remotely-Save"><a href="#Remotely-Save" class="headerlink" title="Remotely Save"></a>Remotely Save</h1><p><a href="https://www.bilibili.com/video/BV1y54y1K7bV/?spm_id_from=333.999.0.0&vd_source=254fbc04b5fe132d6c95727aac670dea">obsidian+webDav网盘同步教程，笔记轻松同步，实现存储自由_哔哩哔哩_bilibili</a></p><h1 id="Memo"><a href="#Memo" class="headerlink" title="Memo"></a>Memo</h1><h2 id="设置-Memos"><a href="#设置-Memos" class="headerlink" title="设置 Memos"></a>设置 Memos</h2><p>Memos 的可设置选项比较复杂，这里仅对部分选项作简单说明。</p><p>下图设置了自定义 “ 用户名 “、” 发送按钮 “ 样式，部分订制 Memos 界面。</p><p><img src="/../../../../img/blog/44a754a46659b70e930de318adf04aee_MD5.webp"></p><p><img src="/../../../../img/blog/079958ee94351c462b858e6f092bdc45_MD5.webp"></p><p>这里我还设置了 <code># Memos</code> ，后面在具体使用 Memos 时会讲到。</p><h2 id="使用-Memos"><a href="#使用-Memos" class="headerlink" title="使用 Memos"></a>使用 Memos</h2><p>要注意的是，Obsidian Memos 中的文本是储存在核心插件日记中的，因此需要先对核心插件【日记】进行设置。</p><p><img src="/../../../../img/blog/4daf80be38c71d5e581c0d81d8564f3f_MD5.webp"></p><p>在设置中打开日记开关</p><p><img src="/../../../../img/blog/68857d4aedfa0ce25cf51181ea6572cd_MD5.webp"></p><p>对日记插件进行设置</p><p>至此，Memos 插件就可以运行了。</p><p><img src="/../../../../img/blog/e784e6c9840e9cc0bd91222f5c86f6a5_MD5.webp"></p><h3 id="3-1-基本用法"><a href="#3-1-基本用法" class="headerlink" title="3.1 基本用法"></a>3.1 基本用法</h3><p>首先在我的日记里设置标题 <code># Memos</code> 。</p><p><img src="/../../../../img/blog/ef756c5c3d46ba3a0e57c5c095907b53_MD5.webp"></p><p>打开 Memos 界面，输入 Memo，发送。然后就能在日记的 <code># Memos</code> 下看到刚刚发送的 Memo 了。</p><p><img src="/../../../../img/blog/742fb3bfd1cb95c801e0629c88cadf0a_MD5.webp"></p><p><img src="/../../../../img/blog/1adf63ca39a6b0cd7eff43dadc960c75_MD5.webp"></p><p>你还可以给你的 Memo 打上标签：</p><p><img src="/../../../../img/blog/0fe7df1743fa8dbdd731883fc0857e07_MD5.webp"></p><p><img src="/../../../../img/blog/d96b63327b01b4e95583c9d64fa59c10_MD5.webp"></p><p><strong>注意：</strong> Memos 中出现的标签，在 Obsidian 中也会出现。但 Obsidian 中的标签不会出现在 Memos 中（可通过设置 “ 使用在库内的所有标签 “ 来在 Memos 中查看库标签）</p><p>删除一条 Memo，该 Memo 会被移动到回收站，同时会在存放日记的文件夹下生成一个名为 “delete” 的文件，用于记录删除日志。 Memo 被删除后，日记中对应的内容也会被删除。</p><p><img src="/../../../../img/blog/4e06ead36a4682956512c82214255d8f_MD5.webp"></p><p><img src="/../../../../img/blog/2065ddcb125f3bbfce2bd2d95ccd1e9f_MD5.webp"></p><p><img src="/../../../../img/blog/daad1e6e2326ba2acb01040c4b45fcbf_MD5.webp"></p><p><strong>注意：</strong> 1. 请勿对 <code>delete</code> 文件进行直接编辑，容易导致 Memos 回收站出问题； 2. 回收站文件名可在 Memos 设置里更改。</p><p><img src="/../../../../img/blog/3c0d8979779c19d1d6c3dfb3aa8f0812_MD5.webp"></p><p>Memo 类型除了 “ 列表 “ 外，还可以是 “ 任务 “，可以在编辑时切换 Memo 类型，也可以在设置中设定默认类型（我不用 Memos 做待办，所以没改默认类型）</p><p><img src="/../../../../img/blog/64bf9ac46ba09bdf5f5cd46554c6905f_MD5.webp"></p><p><img src="/../../../../img/blog/6db5e42225adf70f480690a566eeaa2b_MD5.webp"></p><p><img src="/../../../../img/blog/3e6384c4f60e605879588a870b3c9b93_MD5.webp"></p><p><img src="/../../../../img/blog/d6c859bc028ab03499502a1b59953296_MD5.webp"></p><h3 id="3-2-检索式"><a href="#3-2-检索式" class="headerlink" title="3.2 检索式"></a>3.2 检索式</h3><p>Memos 中还有个 “ 检索式 “ 功能，你可以根据不同的 “ 标签 “、” 任务类型 “、” 文本内容 “、” 日期 “ 来创建检索器。 这里以标签 <code>#测试</code> 和 <code>#其他标签也可以加入检索式</code> 为例：</p><p><img src="/../../../../img/blog/322cffdd752ebdf49147ab622bfac4d6_MD5.webp"></p><p>创建完成后，” 检索式 “ 中多出了一个 “ 测试 “，作用是把带有标签 <code>#测试</code> 和 <code>#其他标签也可以加入检索式</code> 的 Memos 整合到了一个队列中。 检索式创建成功的同时，日记文件夹下会多出一个 “query” 文档，用于记录 “ 检索式的创建 “。同回收站，该文件名称可通过设置修改，且最好不要直接编辑该文件。</p><p><img src="/../../../../img/blog/b54b4a8140d0121b9971a48f1512101b_MD5.webp"></p><p>通过上面的例子不难看出，检索式的作用就是将 Memos 以一定的形式整合起来，即遵循卡片笔记写作法中 “ 将相关联的卡片笔记串联起来 “ 的原则。</p><h3 id="3-3-引用"><a href="#3-3-引用" class="headerlink" title="3.3 引用"></a>3.3 引用</h3><p>打开任意一个 Memo 的更多选项即可看到引用按钮，点击引用便会在编辑栏中生成一行 “ 引用 “ 文本。</p><p><img src="/../../../../img/blog/45449ff813d8bf18c9fe36e05300fc36_MD5.webp"></p><p><img src="/../../../../img/blog/e40a273b42fe33224fc61479b01ccccd_MD5.webp"></p><p>“ 阅读 “ 新发送的 “ 引用 “ 文本，即可看到该 Memo 的链接状态：</p><p><img src="/../../../../img/blog/0435c1d3dbc98840b8112972c24b5991_MD5.webp"></p><p><img src="/../../../../img/blog/069b4a39b3ce9e8da36c1bd5ec1c9868_MD5.webp"></p><p>“ 引用 “ 功能其实和 Obsidian 中的 “ 出链 “ 功能是一样的。学会了使用双链，也自然能用好这个功能。</p><h1 id="附件管家-Billfish"><a href="#附件管家-Billfish" class="headerlink" title="附件管家 Billfish"></a>附件管家 Billfish</h1><h2 id="1-Obsidian-中的配置"><a href="#1-Obsidian-中的配置" class="headerlink" title="1 Obsidian 中的配置"></a>1 Obsidian 中的配置</h2><p>总体策略是将图片、音频等所有附件集中保存到一个文件夹中，免得把 Ob 搞得很乱。</p><ul><li>在 Ob 库中建立一个附件文件夹，也就是专门用来存储附件的</li><li>打开设置→文件与链接 -&gt;指定的附件文件夹</li></ul><h2 id="2-Billfish-中的配置"><a href="#2-Billfish-中的配置" class="headerlink" title="2 Billfish 中的配置"></a>2 Billfish 中的配置</h2><p>打开 billfish→偏好设置→素材库→添加素材库<br>建议选择剪切模式（毕竟是开放式文件管理）</p><h1 id="快速插入模板"><a href="#快速插入模板" class="headerlink" title="快速插入模板"></a>快速插入模板</h1><ul><li>安装插件 Hotkeys for templates</li><li>打开 Hotkeys for templates 配置界面，一共分为三大块：Templator-obsidian 插件；核心模板插件；在特定的文件夹创建笔记会自动添加特定的模板</li></ul><p>咱们的需求是在特定的文件夹下新建笔记就会自动加载特定模板</p><p>那么，接下来就在 Templator-obsidian 模块或者核心模板模块中启用一个模板</p><p>来到 Create a new file in a specified folder with a specified template</p><p><img src="/../../../../img/blog/%E5%BF%AB%E9%80%9F%E6%8F%92%E5%85%A5%E6%A8%A1%E6%9D%BF-1.png"></p><p>点击 ADD 添加</p><h1 id="Obsidian-Git"><a href="#Obsidian-Git" class="headerlink" title="Obsidian Git"></a>Obsidian Git</h1><p>根目录创建一个 <code>.gitignore</code>，忽略掉 <code>.obsidian/workspace.json</code></p><h2 id="初始化仓库"><a href="#初始化仓库" class="headerlink" title="初始化仓库"></a>初始化仓库</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git init    </span><br><span class="line">git add .    </span><br><span class="line">git commit</span><br></pre></td></tr></table></figure><p>github 创建一个空仓库</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin git@github.com:xxx</span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p><img src="/../../../../img/blog/bb08041ebda0fd3abe12964bd6ca13bb_MD5.png"><br>打开插件设置界面，可以修改一下自动提交和手动提交的日志，我设置的是主机名 + 日期：</p><p><img src="/../../../../img/blog/4bfc7dad739c897acc45c75020c6e528_MD5.webp"></p><p>在提交信息设置里，可以修改主机名和日期格式，修改完成后点 Preview 可以预览提交信息：</p><p><img src="/../../../../img/blog/d9de7988f0b0e05d637c208ee1af1f12_MD5.webp"><br>快捷键 <code>Ctrl + P</code> 打开命令面板，输入 open source control view 启用可视化操作面板<br>然后在右侧菜单栏就可以看到操作面板了：</p><p><img src="/../../../../img/blog/2e724dfb7052ff16e35ad4083a764a48_MD5.webp"><br>一般操作就是：保存所有&gt;提交&gt;推送，就可以更新到 Git 服务器了，如下图顺序</p><p><img src="/../../../../img/blog/0e27ff82d7b40c4d1e96eaea51546248_MD5.jpg"></p><p>启用自动拉取功能，每次打开知识库就会自动拉取：</p><p><img src="/../../../../img/blog/0c1a0b636570aa507d23b4ffbddb0ed2_MD5.webp"></p><p>如果在使用过程中有报错的话，<code>Ctrl+Shift+I</code> 在控制台里可以查看详细日志，所有插件的日志都可以在这里看到：</p><p><img src="/../../../../img/blog/91a3e33577e44f1e48b2fb867ad67a60_MD5.webp"></p><h1 id="在-Obsidian-阅读并批注-Pdf-或-Epub-文档"><a href="#在-Obsidian-阅读并批注-Pdf-或-Epub-文档" class="headerlink" title="在 Obsidian 阅读并批注 Pdf 或 Epub 文档"></a>在 Obsidian 阅读并批注 Pdf 或 Epub 文档</h1><h2 id="下载-Annotator-插件"><a href="#下载-Annotator-插件" class="headerlink" title="下载 Annotator 插件"></a>下载 Annotator 插件</h2><h2 id="添加文件入-Obsidian"><a href="#添加文件入-Obsidian" class="headerlink" title="添加文件入 Obsidian"></a>添加文件入 Obsidian</h2><p>把你想要阅读的 pdf 或 epub 文件拖曳进指定的 obsidian 文件夹。当然，也可以直接拖曳到根目录下。我个人习惯是把 pdf 文件统一用一个文件夹放置，是为了让文件更有秩序。<br><img src="/../../../../img/blog/1aa4c304d8a14e8135bd00e7795c4a7e_MD5.png" alt="图片"></p><h2 id="编辑文档"><a href="#编辑文档" class="headerlink" title="编辑文档"></a>编辑文档</h2><p>在 obsidian 新建一个文档，这个文档就是你阅读这本书或者这篇论文之后的笔记文档。</p><p>在这个文档的开头，写上这三行代码：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">annotation-target:</span> <span class="string">xxxx.pdf</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure><p>其中，xxxx 的部分是写你目标文件所在的位置，比如我要提取王甦 - 认知心理学这个 pdf 文件，它所在的位置就是：Import Files&#x2F;PDF Files。</p><p>下图红色框框的部分就是你目标 pdf 文件的路径。记得最后要加上【.pdf】或者【.epub】这个后缀。</p><p><img src="/../../../../img/blog/202345e3c42e50d19624f047cf1730b6_MD5.png" alt="图片"></p><h2 id="切换成-Annotate-模式"><a href="#切换成-Annotate-模式" class="headerlink" title="切换成 Annotate 模式"></a>切换成 Annotate 模式</h2><p>完成第三步后，点开右上角的三个点，点击 Annotate 之后，就出现 pdf 文件和右侧栏标注视图了（如下图）。</p><p><img src="/../../../../img/blog/78633ce77103e46a1e6dfa8be8351e6c_MD5.png" alt="图片"></p><p><img src="/../../../../img/blog/40257ecda330e9a4e0e552297347b9e5_MD5.png" alt="图片"></p><h2 id="完成阅读后，切换回-Markdown-模式"><a href="#完成阅读后，切换回-Markdown-模式" class="headerlink" title="完成阅读后，切换回 Markdown 模式"></a>完成阅读后，切换回 Markdown 模式</h2><p>Annotator 最重要的功能就是能够直接在 pdf 文件上进行高亮和批注。等完成阅读后，点击右上角的三个点，点击 Open as Markdown 之后，再点击右上角切换成 “ 阅读视图 “，就可以看到你的高亮和批注啦。</p><p><img src="/../../../../img/blog/d5b67d5b541ce075e1b03442f392fc1c_MD5.png" alt="图片"></p><h2 id="进一步深加工你的批注"><a href="#进一步深加工你的批注" class="headerlink" title="进一步深加工你的批注"></a>进一步深加工你的批注</h2><p>Annotator 会帮你自动整理你在阅读过程中所批注和高亮的内容。</p><p>当你得到一篇你的笔记之后，你就可以进一步整理你的这些碎片笔记了，让这些碎片笔记真正为你所吸收，成为一篇读书报告或者书评。</p><p><img src="/../../../../img/blog/c758a95b637468bb9b45489f8c9c4db0_MD5.png" alt="图片"></p>]]></content>
      
      
      <categories>
          
          <category> 应用 </category>
          
          <category> 配置 </category>
          
          <category> 软件配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Obsidian </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker镜像使用</title>
      <link href="/posts/%E5%BA%94%E7%94%A8/%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7/Mysql/docker%E9%95%9C%E5%83%8F%E4%BD%BF%E7%94%A8.html"/>
      <url>/posts/%E5%BA%94%E7%94%A8/%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7/Mysql/docker%E9%95%9C%E5%83%8F%E4%BD%BF%E7%94%A8.html</url>
      
        <content type="html"><![CDATA[<h1 id="下载-MySQL-镜像"><a href="#下载-MySQL-镜像" class="headerlink" title="下载 MySQL 镜像"></a>下载 MySQL 镜像</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull mysql</span><br></pre></td></tr></table></figure><h1 id="创建挂载目录"><a href="#创建挂载目录" class="headerlink" title="创建挂载目录"></a>创建挂载目录</h1><p>创建 data 目录用来挂载数据库文件，创建 conf 目录用来挂载配置文件</p><h1 id="第一次启动-MySQL"><a href="#第一次启动-MySQL" class="headerlink" title="第一次启动 MySQL"></a>第一次启动 MySQL</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 3306:3306 --name mysql -v D:/Docker/MySQL/conf:/etc/mysql/conf.d -v D:/Docker/MySQL/datadir:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 -d mysql:latest</span><br></pre></td></tr></table></figure><p>解释下这条命令的参数</p><p><strong>-a stdin:</strong> 指定标准输入输出内容类型，可选 STDIN&#x2F;STDOUT&#x2F;STDERR 三项；</p><p><strong>-d:</strong> 后台运行容器，并返回容器 ID；</p><p><strong>-i:</strong> 以交互模式运行容器，通常与 -t 同时使用；</p><p><strong>-P:</strong> 随机端口映射，容器内部端口<strong>随机</strong>映射到主机的端口</p><p><strong>-p:</strong> 指定端口映射，格式为：<strong>主机 (宿主) 端口: 容器端口</strong></p><p><strong>-t:</strong> 为容器重新分配一个伪输入终端，通常与 -i 同时使用；</p><p><strong>–name&#x3D;”nginx-lb”:</strong> 为容器指定一个名称；</p><p><strong>–dns 8.8.8.8:</strong> 指定容器使用的 DNS 服务器，默认和宿主一致；</p><p><strong>–dns-search example.com:</strong> 指定容器 DNS 搜索域名，默认和宿主一致；</p><p><strong>-h “mars”:</strong> 指定容器的 hostname；</p><p><strong>-e username&#x3D;”ritchie”:</strong> 设置环境变量；</p><p><strong>–env-file&#x3D;[]:</strong> 从指定文件读入环境变量；</p><p><strong>–cpuset&#x3D;”0-2” or –cpuset&#x3D;”0,1,2”:</strong> 绑定容器到指定 CPU 运行；</p><p>**-m :**设置容器使用内存最大值;</p><p><strong>–net&#x3D;”bridge”:</strong> 指定容器的网络连接类型，支持 bridge&#x2F;host&#x2F;none&#x2F;container: 四种类型；</p><p><strong>–link&#x3D;[]:</strong> 添加链接到另一个容器；</p><p><strong>–expose&#x3D;[]:</strong> 开放一个端口或一组端口；</p><p><strong>–volume , -v 本地目录：容器目录:</strong> 绑定一个卷,将容器目录挂载到本地目录</p><h1 id="启动-Mysqldocker-容器"><a href="#启动-Mysqldocker-容器" class="headerlink" title="启动 Mysqldocker 容器"></a>启动 Mysqldocker 容器</h1><p>利用 docker ps 命令可以查看当前运行的容器，docker ps -a 查看所有容器（包括停止的容器）</p><p>可以命令 停止和启动 docker 容器</p><p>停止容器：docker stop [CONTAINER ID]</p><p>启动 容器：docker start [CONTAINER ID]</p><p>也可以在 windows 的 docker 桌面版里启动</p><p><img src="/../../../../img/blog/ba3f764c1b1ddb1c3b0dacc7c3b3fb0a_MD5.jpg"></p><h2 id="进入容器"><a href="#进入容器" class="headerlink" title="进入容器"></a>进入容器</h2><p>命令 docker exec -it [NAMES] bash，这里 names 可以用那么也可以使用容器 ID 即 Container ID</p><p><img src="/../../../../img/blog/2013019ac6572b7bde84da1285a612b4_MD5.jpg"></p><h2 id="进入数据库"><a href="#进入数据库" class="headerlink" title="进入数据库"></a>进入数据库</h2><p>使用 mysql -uroot -p123456 进入数据库</p><p>使用 show databases; 查看数据库</p><p><img src="/../../../../img/blog/20b9dd25df9db1f71ffdf25b9ed9f1bf_MD5.webp"></p><p>use mysql 进入名为 mysql 的数据库，show tables 可以查看当前数据库有哪些表</p><h2 id="使用-SQL"><a href="#使用-SQL" class="headerlink" title="使用 SQL"></a>使用 SQL</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source /etc/mysql/conf.d/kaoqin.sql</span><br></pre></td></tr></table></figure><h2 id="创建账户"><a href="#创建账户" class="headerlink" title="创建账户"></a>创建账户</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># 创建用户并开启远程登录</span><br><span class="line"></span><br><span class="line">CREATE USER &#x27; 你的账号 &#x27;@&#x27;%&#x27; IDENTIFIED BY &#x27; 你的密码 &#x27;;</span><br><span class="line"></span><br><span class="line"># 创建数据库并设置字符集</span><br><span class="line"></span><br><span class="line">CREATE DATABASE `库名` CHARACTER SET &#x27;utf8mb4&#x27;;</span><br><span class="line"></span><br><span class="line"># 给账号授权数据库</span><br><span class="line"></span><br><span class="line">GRANT ALL PRIVILEGES ON 库名.* TO &#x27; 你的账号 &#x27;@&#x27;%&#x27;;</span><br><span class="line"></span><br><span class="line"># 刷新权限</span><br><span class="line"></span><br><span class="line">flush privileges;</span><br></pre></td></tr></table></figure><h2 id="为了方便以后远程连接，需要下面操作"><a href="#为了方便以后远程连接，需要下面操作" class="headerlink" title="为了方便以后远程连接，需要下面操作"></a>为了方便以后远程连接，需要下面操作</h2><p>需要修改 user 表中的 user 为 root 变为 %。这里没有修改成功，因为一开始就是 %</p><p>exit 关掉，利用 service mysqld restart 重新启动 mysql 服务。</p><p><img src="/../../../../img/blog/5ae34a419de42bc94ab05f5550bf6e3d_MD5.webp"></p><h2 id="如何远程连接-Docker-的-Mysql-容器"><a href="#如何远程连接-Docker-的-Mysql-容器" class="headerlink" title="如何远程连接 Docker 的 Mysql 容器"></a>如何远程连接 Docker 的 Mysql 容器</h2><p>首先查看 dockers 镜像 ip，在终端输如 ifconfig，如果出现 bash: ifconfig: command not found，则需要安装一些东西 sudo apt-get install net-tools，现在就可以访问 ifconfig</p><p>现在还不能连接成功，给 root 用户分配权限</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter user &#x27;root&#x27;@&#x27;%&#x27; identified with mysql_native_password by &#x27;123456&#x27;;</span><br></pre></td></tr></table></figure><p>刷新权限</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flush privileges;</span><br></pre></td></tr></table></figure><h1 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h1><p>新装了 mysql8.0 后再用 navicat 链接就会报 2059 的错误。</p><p>上网查了发现是 8.0 之后 mysql 更改了密码的加密规则，只要在命令窗口把加密方法改回去即可。</p><p>首先使用以下命令进入 MySQL 的 docker 容器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it MYSQL8.0 bash</span><br></pre></td></tr></table></figure><p>然后登录 MySQL</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -uroot -p123456</span><br></pre></td></tr></table></figure><p>然后运行以下 SQL 即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">alter user &#x27;root&#x27;@&#x27;%&#x27; identified by &#x27;123456&#x27; password expire never;</span><br><span class="line">alter user &#x27;root&#x27;@&#x27;%&#x27; identified with mysql_native_password by &#x27;123456&#x27;;</span><br><span class="line">flush privileges;</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://blog.csdn.net/u014282578/article/details/127920419">写最好的Docker安装最新版MySQL8（mysql-8.0.31）教程（参考Docker Hub和MySQL官方文档）_docker 安装mysql8_大白有点菜的博客-CSDN博客</a></p>]]></content>
      
      
      <categories>
          
          <category> 应用 </category>
          
          <category> 编程工具 </category>
          
          <category> Mysql </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>IDEA创建maven项目卡在resolving dependencies</title>
      <link href="/posts/%E5%BA%94%E7%94%A8/%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7/IDEA/IDEA%E5%88%9B%E5%BB%BAmaven%E9%A1%B9%E7%9B%AE%E5%8D%A1%E5%9C%A8resolving%20dependencies.html"/>
      <url>/posts/%E5%BA%94%E7%94%A8/%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7/IDEA/IDEA%E5%88%9B%E5%BB%BAmaven%E9%A1%B9%E7%9B%AE%E5%8D%A1%E5%9C%A8resolving%20dependencies.html</url>
      
        <content type="html"><![CDATA[<p>记得在使用 IDEA 创建 maven 项目的时候，有时候会一直卡在 resolving dependencies…问题上，从而导致创建项目过慢，这是由于在下载 jar 包的时候由于可能没有设置镜像是从远程进行下载导致过慢，也有可能是网络的原因。这时候我们如果是在开始创建 maven 项目的时候在 Properties 的属性面板中添加一项：archetypeCatalog &#x3D; internal 即可。配置如下</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">archetypeCatalog</span><br><span class="line"><span class="keyword">internal</span></span><br></pre></td></tr></table></figure><p><img src="/../../../../img/blog/45bfcd7e428008c2f2401bd26948e965_MD5.webp" alt="在这里插入图片描述"></p><p>如果是在项目已经创建过后，在 pom 文件中添加其他的依赖的时候，也卡在了 resolving dependencies…问题上，则我们可以在 settings 中的 maven 进行设置，路径和配置如下：</p><p><img src="/../../../../img/blog/65c8f2f732a5129388710b9f129d4c42_MD5.webp" alt="在这里插入图片描述"></p><p>即在 vm options 添加参数</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">-DarchetypeCatalog</span>=internal</span><br></pre></td></tr></table></figure><p>-DarchetypeCatalog 参数是用来指定 archetype-catalog.xml 文件从哪里获取的。可以选择的值为：remote，internal ，local 等，如果不进行设置的话则默认使用 remote，而由于远程的中央仓库的 archetype 太多， 导致从远程网络加载所以非常慢，这也是之前卡在这里的原因。</p><p>settings 设置的是当前项目的配置，如果设置全局的设置，则在 other settings 进行上述设置，则对其他项目也生效。</p><p>通过上述设置即可解决 IDEA 创建 maven 项目过慢，一直卡在 resolving dependencies…的问题。</p><h1 id="打开-Settings"><a href="#打开-Settings" class="headerlink" title="打开 Settings"></a>打开 Settings</h1><p>修改 maven Importing 的 jvm 参数, 默认为 700 多, 直接修改成</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xms1024m -Xmx2048m</span><br></pre></td></tr></table></figure><p>（博主的话：猜测这个貌似是 maven 下载速度的带宽限制，我直接搞成了 -Xmx4096m，然后就看到进度条一直处在飞奔的状态。。。）</p><p>Resolving Maven dependencies 立刻就消失了。</p><p><img src="/../../../../img/blog/483947dcd3400e975b7618d564129533_MD5.webp"></p>]]></content>
      
      
      <categories>
          
          <category> 应用 </category>
          
          <category> 编程工具 </category>
          
          <category> IDEA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IDEA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>本地软件配置1</title>
      <link href="/posts/%E5%BA%94%E7%94%A8/%E9%85%8D%E7%BD%AE/%E8%BD%AF%E4%BB%B6%E9%85%8D%E7%BD%AE/%E6%9C%AC%E5%9C%B0%E8%BD%AF%E4%BB%B6%E9%85%8D%E7%BD%AE1.html"/>
      <url>/posts/%E5%BA%94%E7%94%A8/%E9%85%8D%E7%BD%AE/%E8%BD%AF%E4%BB%B6%E9%85%8D%E7%BD%AE/%E6%9C%AC%E5%9C%B0%E8%BD%AF%E4%BB%B6%E9%85%8D%E7%BD%AE1.html</url>
      
        <content type="html"><![CDATA[<h1 id="Scoop"><a href="#Scoop" class="headerlink" title="Scoop"></a>Scoop</h1><h2 id="将-Scoop-安装到自定义目录-命令行方式-设置环境变量）"><a href="#将-Scoop-安装到自定义目录-命令行方式-设置环境变量）" class="headerlink" title="将 Scoop 安装到自定义目录 (命令行方式)(设置环境变量）"></a>将 Scoop 安装到自定义目录 (命令行方式)(设置环境变量）</h2><p><code>$env:SCOOP=&#39;D:\Applications\Scoop&#39; </code><br><code>[Environment]::SetEnvironmentVariable(&#39;SCOOP&#39;, $env:SCOOP, &#39;User&#39;)</code></p><h2 id="将-Scoop-配置为将全局程序安装到自定义目录-SCOOP-GLOBAL-命令行方式"><a href="#将-Scoop-配置为将全局程序安装到自定义目录-SCOOP-GLOBAL-命令行方式" class="headerlink" title="将 Scoop 配置为将全局程序安装到自定义目录 SCOOP_GLOBAL(命令行方式)"></a>将 Scoop 配置为将全局程序安装到自定义目录 SCOOP_GLOBAL(命令行方式)</h2><p><code>$env:SCOOP_GLOBAL=&#39;F:\GlobalScoopApps&#39;</code><br><code>[Environment]::SetEnvironmentVariable(&#39;SCOOP_GLOBAL&#39;, $env:SCOOP_GLOBAL, &#39;Machine&#39;)</code></p><h2 id="安装并镜像加速"><a href="#安装并镜像加速" class="headerlink" title="安装并镜像加速"></a>安装并镜像加速</h2><p><a href="https://gitee.com/glsnames/scoop-installer#31-%E4%BB%A3%E7%90%86%E5%8F%AF%E9%80%89">https://gitee.com/glsnames/scoop-installer#31-%E4%BB%A3%E7%90%86%E5%8F%AF%E9%80%89</a></p><h1 id="Zotero-本体"><a href="#Zotero-本体" class="headerlink" title="Zotero 本体"></a>Zotero 本体</h1><h2 id="添加文献"><a href="#添加文献" class="headerlink" title="添加文献"></a>添加文献</h2><p>Zotero 添加文献主要有通过浏览器插件添加和手动添加两种方式。</p><h3 id="通过浏览器插件添加"><a href="#通过浏览器插件添加" class="headerlink" title="通过浏览器插件添加"></a>通过浏览器插件添加</h3><p><strong>注意，通过这种方式添加需要保证 Zotero 客户端在运行状态。</strong></p><p>安装好浏览器插件后，浏览器的插件栏会多出一个 Zotero 图标（空白页面下），如下图红框。</p><p><img src="/../../../../img/blog/a7b1dc70a97fea74d55355358a30481f_MD5.png"></p><p>随手打开一篇 arXiv 上的文章，你会发现这个图标变成了一张纸的样子，这意味着 Zotero 插件检测到了一篇文献。点一下它，将出现下图中的提示框，Zotero 说，我帮你把这个文献保存在 “My Library” 啦，除了它自身的信息之外，还有一个 “Comment”，一个全文 PDF 文件，以及一个网页快照（Snapshot）。</p><p><img src="/../../../../img/blog/c88365fe0ef3757e374debb85a3b0ca7_MD5.webp"></p><p>打开 Zotero，这篇文献已经出现在 “My Library” 中了，连同下载的所有附件。如果附件没有出现的话，你需要稍等片刻，因为 PDF 的下载可能需要一些时间。</p><p><img src="/../../../../img/blog/fe794eca77aafb142ab878cec2bba311_MD5.webp"></p><p>现在我们打开一个 Google Scholar 搜索结果页面，你会发现这个图标变成了一个 “ 文件夹 “，因为 Zotero 在这个页面找到了多篇文献。点击文件夹图标，在弹出的窗口可以选择一篇或多篇文献加入文献库。</p><p><img src="/../../../../img/blog/c89c69700f395d2782ded7fc738119ad_MD5.webp"></p><p>Amazing！打开 Zotero，刚才选择的文献全部被加进来了！</p><p><img src="/../../../../img/blog/a5c0c4c00dca176e891ff02ec5899b4c_MD5.webp"></p><p>即使在找不到文献的页面，Zotero 也可以保存网页的快照（Snapshot）以供离线查看。这是个非常实用的功能，一些大佬的技术博客、公众号推送、发出来可能很快就不会存在的文章，都可以通过这种方式用 Zotero 统一管理，简直不能太方便。下面的图中我用这种方式保存了一篇 GCN 教程：</p><p><img src="/../../../../img/blog/1eb6941df924c45f2e340bb62e4f3658_MD5.webp"></p><p><img src="/../../../../img/blog/1355e4a52bd280d759a1b38c63ea9a50_MD5.webp"></p><p>在知道有这个功能之后，我做的第一件事是保存了自己投过所有文章的 review，以在骄傲自满的时候给自己沉重打击。</p><h3 id="手动添加"><a href="#手动添加" class="headerlink" title="手动添加"></a>手动添加</h3><p>手动添加最常用的情况是直接导入一个本地的 PDF 文件。方法是直接把 PDF 文件拖进 Zotero 界面，像下面这样。</p><p><img src="/../../../../img/blog/793e17c80299296602bf227fef8d3372_MD5.webp"></p><p>Zotero 会自动识别 PDF 中的各种元数据，自动填充条目信息：</p><p><img src="/../../../../img/blog/75ed132fe774c2ad46c453a8067837c4_MD5.webp"></p><p>并不是每一个 PDF 文件都能够识别得很准确，比如这篇 Conference Paper 就被识别成了 Book Section，作者的顺序也不对。使用这种方法导入通常需要手动再进行一些修改。</p><p>当然，对于任何一个条目，除了修改基本信息之外，我们也可以手动为它添加各种附件。比如我们通过浏览器添加了一篇没有全文 PDF 的文献，我们可以通过这种方法为其加入自己下载的 PDF。方法是右击条目，选择 “Add attachment “。</p><p><img src="/../../../../img/blog/a90501bb644b1f5f63fb6da352e9056b_MD5.webp"></p><p>这里 “ Attach Stored Copy of File” 和 “Attach Link to File” 的区别是，前者会把这个文件复制一份丢进文献库，而后者只会把这个附件指向原文件（类似超链接）。</p><p>Zotero 也支持直接通过 ISBN、DOI、PMID 或 arXiv ID 来添加文献。点击工具栏的 “ 魔棒 “ 图标，输入一个 ISBN 编码：</p><p><img src="/../../../../img/blog/ec0dd8456a92fa425c8166366fe9fcc8_MD5.webp"></p><p>Zotero 会去网上找这个编码对应的元数据，把它加进文献库：</p><p><img src="/../../../../img/blog/de0611287f9f751f6db6c1a8e6c3ef63_MD5.webp"></p><p>最后，我们也可以纯手动添加条目，自己填写所有数据域、添加附件。点击工具栏的加号按钮，选择一个合适的类型即可。</p><p><img src="/../../../../img/blog/e4ec2eb01ac6f1582fba28048951f92a_MD5.webp"></p><h2 id="管理文献"><a href="#管理文献" class="headerlink" title="管理文献"></a>管理文献</h2><p>在文献管理上，Zotero 有文件夹（collection）、标签（tag）和便捷搜索（saved search）三种方式。</p><h3 id="文件夹（collection）管理"><a href="#文件夹（collection）管理" class="headerlink" title="文件夹（collection）管理"></a>文件夹（collection）管理</h3><p>在 Zotero 客户端左边栏的 “My Library” 上右键选择 “New Collection”（或者点击最左上角的按钮），新建一个文件夹：</p><p><img src="/../../../../img/blog/0dcfc09d372d33a9fbee8672e0b9edf9_MD5.webp"></p><p>Zotero 里的文件夹和操作系统里是一样的，我们可以把文献在文件夹之间拖来拖去，还可以在文件夹下新建子文件夹，建立层级的树状结构：</p><p><img src="/../../../../img/blog/58090b35374130309b53bbe9f53aa67f_MD5.webp"></p><p>如果只是使用 collection，其实和你不用 Zotero、在电脑上建一层一层的文件夹进行管理没有很大区别。我一般会用 collection 进行数据来源层级的区分（比如论文、公众号、网页等），再使用标签（tag）机制进行进一步的细粒度管理。</p><h3 id="标签（tag）管理"><a href="#标签（tag）管理" class="headerlink" title="标签（tag）管理"></a>标签（tag）管理</h3><p>我们可以对文献库中的文献添加一个或多个自定义的标签（tag）：</p><p><img src="/../../../../img/blog/dd23d27bb9ad6b32730c691f0bea71f7_MD5.webp"></p><p>也可以在用浏览器插件添加文献时顺手添加：</p><p><img src="/../../../../img/blog/405113edde415dde36da15ff528c3fdb_MD5.webp"></p><p>Zotero 支持最多为 9 个 tag 分别指定不同的颜色，做法是在界面左下角的 tag 面板中，右击一个 tag，选择 “ Assign Color”。</p><p><img src="/../../../../img/blog/f711e46e54b6fdf9f6976c71697f9cc2_MD5.webp"></p><p>如果一个文献被打上了带颜色的标签，这个颜色的色块也会被显示在文献标题中，一目了然，区别起来很方便！</p><p><img src="/../../../../img/blog/08e774bf004a3430c71d89c9ba43c718_MD5.webp"></p><p>现在，我们可以通过点击 tag 面板中的标签来实现对于文献的筛选了！</p><p><img src="/../../../../img/blog/5414718a5d4ade06a752b54f3f8a4b14_MD5.jpg" alt="动图封面"></p><h3 id="便捷搜索（saved-search）"><a href="#便捷搜索（saved-search）" class="headerlink" title="便捷搜索（saved search）"></a>便捷搜索（saved search）</h3><p>我们有时候需要对文献库进行一些搜索，针对关键词、标签，或者二者都有。但有些常用的搜索条件，我们不希望每次都重新输入，这时候便捷搜索功能（saved search）就是一个强大的工具。</p><p>右击 “My Library”，选择 “New Saved Search”。</p><p><img src="/../../../../img/blog/320e4a44517bb5ecf34bd824fbd0a576_MD5.webp"></p><p>在弹出的窗口中，输入检索条件，点击 “OK”。比如这里我做了一个 ICCV 2019 文章的搜索，限定会议名称包含 “IEEE International Conference on Computer Vision “，日期是 “2019”。当然这需要文献的元数据准确。</p><p><img src="/../../../../img/blog/0985d58709fd1a74c91260ef2a05c178_MD5.webp"></p><p>点击 “OK”，我们会发现出现了这样带齿轮的紫色文件夹，这就是便捷搜索生成的结果。文件夹中包含了当前文献库中符合此条件的所有文献，如果新增添的文献符合搜索条件的话，也会自动出现在这里。</p><p><img src="/../../../../img/blog/8bb2b462ed7c5131c14342fee6d70ef8_MD5.webp"></p><p>在工具栏点击搜索按钮，在弹出的高级搜索对话框中，也可以保存便捷搜索：</p><p><img src="/../../../../img/blog/69878e72e688127af92fc27bd3798f60_MD5.webp"></p><h2 id="笔记系统"><a href="#笔记系统" class="headerlink" title="笔记系统"></a>笔记系统</h2><p>Zotero 的笔记系统比较简单。由于 Zotero 没有内置 PDF 阅读器，所以 PDF 内部的高亮、标注等功能依赖用户的 PDF 阅读器。但 Zotero 允许我们给文献添加多篇笔记（note），在任意一篇文献的 “Notes” 选项卡中点击 “Add” 来添加笔记。</p><p><img src="/../../../../img/blog/d51bc1c8b0f5e7c216abd333ec9e5b1c_MD5.webp"></p><p>我们可以在出现的富文本编辑器中写简单的笔记。注意左边，文献的附件中出现了一条新的笔记。笔记也可以打标签，或是和文献一起被同步至云空间。</p><p><img src="/../../../../img/blog/f84ed344b50a4affd17a59c1f6e4481c_MD5.webp"></p><p>值得一提的是，你还可以在工具栏中，添加独立的笔记条目（standalone note），该条目不依赖于任何文献。这意味着，Zotero 还可以当做一个笔记本&#x2F;备忘录来用 [呲牙]。通用性多强啊！</p><p><img src="/../../../../img/blog/42c879055d7e65feb7045e25197896d7_MD5.webp"></p><h2 id="文献导出"><a href="#文献导出" class="headerlink" title="文献导出"></a>文献导出</h2><p>选中一篇或多篇文献，右击菜单中有三种导出方式： <strong>Export Items</strong>、<strong>Create Bibliography from Items</strong> 和 <strong>Generate Report from Items</strong>。</p><p><img src="/../../../../img/blog/38f04b3ff627f835ace93701d688cf1a_MD5.webp"></p><p>其中：</p><ul><li><strong>Export Items</strong> 可以将文献导出成不同的格式，包括 BibTex、 Bookmarks 、CSV、Endnote XML 等，也同时可以导出附件。我一般用来和他人分享文章，也可以用来在不同文献管理软件之间做数据迁移。</li><li><strong>Create Bibliography from Items</strong> 就是我们在写论文时生成参考文献最常用的选项了。弹出的对话框中可以选择不同的参考文献格式和导出的形式（默认是复制到剪贴板）。</li></ul><p><img src="/../../../../img/blog/1bcba8c35ec817bf114d845eef76fee9_MD5.webp"></p><ul><li><strong>Generate Report from Items</strong> 可以为这些文献生成一个固定格式的 HTML report，里面有每篇文献的元数据。感觉没啥用，官方说可以用来 “Reviewing Abstracts “、”Teaching” 以及 “ Organizing Notes into Outlines “。</li></ul><p>这里有一个小技巧——最便捷生成参考文献的方式，是直接把选中的文献拖动至文本编辑器中；或者按 Cmd+ Shift +C，再粘贴到文本编辑框中。这种方式输出的参考文献格式可以在设置的 Export 选项卡里更改，我改成了 BibTex。下面的 GIF 展示了这种 “Quick Copy” 的特性，实在是方便得过分。</p><p><img src="/../../../../img/blog/30d92b09fddfbe3c46cf3ad69aefbdeb_MD5.jpg" alt="动图封面"></p><p>Zotero 还提供了针对 Word、LibreOffice 的插件，以及对 Google Docs 的支持，如果你用以上工具写作，看看 <a href="https://link.zhihu.com/?target=https://www.zotero.org/support/word_processor_integration">官方的介绍</a> 吧。</p><h1 id="NSSM—封装-windows-服务工具"><a href="#NSSM—封装-windows-服务工具" class="headerlink" title="NSSM—封装 windows 服务工具"></a>NSSM—封装 windows 服务工具</h1><p><strong>NSSM 是一个服务封装程序，它可以将普通 exe 程序或 bat 文件封装成服务，使之像 windows 服务一样运行</strong>。同类型的工具还有微软自己的 srvany，不过 nssm 更加简单易用，并且功能强大。它的特点如下：</p><p><strong>1.支持普通 exe 程序（控制台程序或者带界面的 Windows 程序都可以）或 bat 文件</strong></p><p><strong>2.安装简单又方便</strong></p><p><strong>3.可以重定向输出（并且支持 Rotation）</strong></p><p><strong>4.可以自动守护封装了的服务，程序挂掉了后可以自动重启</strong></p><p><strong>5.可以自定义环境变量</strong></p><p><strong>6.可以自定义启动参数</strong></p><p>从以上可以得知，NSSM 每个功能都很实用，可以大大简化开发流程，降低了开发难度，使用和调试起来也非常方便，特别不需要考虑开发一个服务实现服务守护功能，以确保稳定可靠。</p><p>**NSSM 的官网下载地址：<a href="https://link.zhihu.com/?target=http://nssm.cc/download">http://nssm.cc/download</a>**，如下图：</p><p><img src="/../../../../img/blog/8cd0d9ab5f8e26606e0c474d5f06cacb_MD5.webp"></p><p>NSSM 的官网下载地址</p><p><strong>NSSM 常用命令，</strong>如下：</p><p><strong>1.安装服务：nssm install 服务名称</strong></p><p><strong>2.删除服务：nssm remove 服务名称</strong></p><p><strong>3.删除服务确定：nssm remove 服务名称 confirm</strong></p><p><strong>4.修改服务（显示界面修改）：nssm edit 服务名称</strong></p><p><strong>5.启动服务：nssm start 服务名称</strong></p><p><strong>6.停止服务：nssm stop 服务名名称</strong></p><p><strong>7.停止服务：nssm stop 服务名称</strong></p><p><strong>NSSM 使用步骤</strong>，如下：</p><p><strong>1.下载 NSSM</strong></p><p><strong>2.根据 windows 平台，将 32&#x2F;64 位 nssm.exe 文件解压至任意文件夹</strong></p><p><strong>3.cmd 定位至 nssm.exe 所在目录，如你操作系统是 32bit，请对应 32 位的 nssm.exe 文件，如你操作系统是 64bit，请对应 64 位的 nssm.exe</strong></p><p><strong>4.输入 nssm install {服务名称}，即注册 Windows 服务的名称。</strong></p><p><img src="/../../../../img/blog/817502c361bb8affe362565acb72665b_MD5.webp"></p><p>对应的 nssm.exe</p><p><strong>注册服务弹出如下 NSSM 界面</strong>，如下图：</p><p><img src="/../../../../img/blog/995ccd62bbd6febec71419597ff0c125_MD5.webp"></p><p>注册服务</p><p>设置说明，如下：</p><p><strong>1.Application Path: 选择系统安装的 exe 或 bat。</strong></p><p><strong>2.Startup directory: 选择 exe 或 bat 项目的根目录。</strong></p><p><strong>3.Arguments: 输入启动参数。</strong></p><p>上述步骤操作完成，即可点击 Install service 来注册服务。我们在系统的服务中即可找到刚刚注册的服务。</p><p><img src="/../../../../img/blog/e2d9007b90d24b64941a9491919659b8_MD5.webp"></p><p>安装服务</p><p><img src="/../../../../img/blog/0d10b71e5697d21cdf87fe32fa8a219d_MD5.webp"></p><p>安装成功</p><p><img src="/../../../../img/blog/e3be526bf010091371d60c21a5204060_MD5.webp"></p><p>新安装的 windows 服务</p><p>在系统服务中找到刚刚注册的服务，右键属性 - 恢复即可设置此服务挂掉重启等内容。<br><strong>需要注意一点，安装完服务后，需要启动服务，否则没有生效</strong>。</p><h1 id="PotPlayer"><a href="#PotPlayer" class="headerlink" title="PotPlayer"></a>PotPlayer</h1><p><a href="https://zhuanlan.zhihu.com/p/504190202">超详细PotPlayer教程：下载安装与优化设置 保姆级教程 - 知乎 (zhihu.com)</a><br><a href="https://www.appinn.com/potplayer-webdav-alist/">PotPlayer 直接播放网盘视频：连接 Alist，接入阿里云盘、百度&#x2F;夸克网盘等 - 小众软件 (appinn.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> 应用 </category>
          
          <category> 配置 </category>
          
          <category> 软件配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> scoop </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker安装和使用</title>
      <link href="/posts/%E5%BA%94%E7%94%A8/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Docker/docker%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8.html"/>
      <url>/posts/%E5%BA%94%E7%94%A8/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Docker/docker%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8.html</url>
      
        <content type="html"><![CDATA[<h1 id="Docker-Desktop"><a href="#Docker-Desktop" class="headerlink" title="Docker Desktop"></a>Docker Desktop</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>平时要使用 Docker 不想安装虚拟机，也不想买服务器时推荐安装官方提供的「Docker Desktop」</p><p>1、官网下载安装包： <a href="https://www.docker.com/">https://www.docker.com</a></p><p><img src="/../../../../img/blog/48f51444c4d1b5363ab558441fffe3e1_MD5.png" alt="图片"></p><hr><p>2、修改默认安装位置</p><p>默认是安装在 C 盘中的并且无法修改，后续下载一些镜像时也会存放在 C 盘，我这里通过「mklink 创建软链接」的方式，将文件映射到我的 D 盘中，先在 D 盘创建好如下四个目录结构：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir D:\Docker  </span><br><span class="line">mkdir D:\Docker\Local  </span><br><span class="line">mkdir D:\Docker\Roaming\Docker  </span><br><span class="line">mkdir &quot;D:\Docker\Roaming\Docker Desktop&quot;</span><br></pre></td></tr></table></figure><p><img src="/../../../../img/blog/6c73026be38cb3e6c6767df7cae248fe_MD5.png" alt="图片">然后以管理员身份打开 cmd，在打开的 cmd 窗口中依次执行下面四个 <code>mklink</code> 命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mklink /j &quot;C:\Program Files\Docker&quot; &quot;D:\Docker&quot;</span><br><span class="line">mklink /j &quot;C:\Users\ICEFJL\AppData\Local\Docker&quot; &quot;D:\Docker\Local&quot;</span><br><span class="line">mklink /j &quot;C:\Users\ICEFJL\AppData\Roaming\Docker&quot; &quot;D:\Docker\Roaming\Docker&quot;</span><br><span class="line">mklink /j &quot;C:\Users\ICEFJL\AppData\Roaming\Docker Desktop&quot; &quot;D:\Docker\Roaming\Docker Desktop&quot;</span><br></pre></td></tr></table></figure><p>3、安装<strong>「Docker Desktop」</strong></p><p>配置使用 WSL 2 而不是 Hyper-v（推荐）向桌面添加快捷方式<br><img src="/../../../../img/blog/f032a04751de9c7da78e303776aac9ce_MD5.png" alt="图片"></p><p>这一步安装成功必须要重启电脑，重启后出现以下页面，同意即可<img src="/../../../../img/blog/6aa10763fea03299263663fbe4460bbc_MD5.png" alt="图片"> Accept 后出现以下弹窗：Docker Desktop 需要更新的 WSL 内核版本。通过运行 “wsl –update” 更新 WSL 内核，或按照以下位置的说明进行操作 <a href="https://docs.microsoft.com/windows/wsl/wsl2-kernel">https://docs.microsoft.com/windows/wsl/wsl2-kernel</a><br>再次打开 Docker Desktop，看到如下界面即安装完成了</p><p><img src="/../../../../img/blog/568cf9761d743c2b2ceb0ff96a7e9eee_MD5.png" alt="图片"></p><h2 id="更改镜像下载源"><a href="#更改镜像下载源" class="headerlink" title="更改镜像下载源"></a>更改镜像下载源</h2><p>下载镜像时默认是从官方的 Docker Hub 拉取镜像的由于速度会比较感人，所以需要更改使用国内的镜像源</p><p><img src="/../../../../img/blog/d823d802503de776664e32fb0f187ec7_MD5.png" alt="图片">复制以下代码覆盖掉要更改部分，重启 Docker Desktop 即可，<strong>「registry-mirrors」</strong>配的都是国内的一些镜像源</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;builder&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;gc&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;defaultKeepStorage&quot;</span><span class="punctuation">:</span> <span class="string">&quot;20GB&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;enabled&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;experimental&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;features&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;buildkit&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;registry-mirrors&quot;</span> <span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="string">&quot;https://registry.docker-cn.com&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;https://docker.mirrors.ustc.edu.cn&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;http://hub-mirror.c.163.com&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;https://cr.console.aliyun.com/&quot;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p><img src="/../../../../img/blog/32d5b77b0cd97dfac76c81cb51e332f0_MD5.png" alt="图片"></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://mp.weixin.qq.com/s/ErDeO9e1aaOIRMkfnfXU7Q">Windows中也可以安装使用Docker (qq.com)</a></p><h1 id="Docker-学习"><a href="#Docker-学习" class="headerlink" title="Docker 学习"></a>Docker 学习</h1><p><a href="https://yeasy.gitbook.io/docker_practice/">前言 - Docker — 从入门到实践 (gitbook.io)</a></p><h1 id="Docker-安装"><a href="#Docker-安装" class="headerlink" title="Docker 安装"></a>Docker 安装</h1><p><a href="https://www.runoob.com/docker/ubuntu-docker-install.html">Ubuntu Docker 安装 | 菜鸟教程 (runoob.com)</a><br>linux&#x2F;ubuntu 下的安装命令 (使用阿里云镜像)：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update &amp;&amp; sudo apt-get install -y apt-transport-https ca-certificates curl software-properties-common &amp;&amp; curl -fsSL https:``//download``.[docker.com](http://docker.com/)``/linux/ubuntu/gpg | sudo apt-key add - &amp;&amp; sudo add-apt-repository <span class="string">&quot;deb [arch=amd64] [http://mirrors.aliyun.com/docker-ce/linux/ubuntu](http://mirrors.aliyun.com/docker-ce/linux/ubuntu) <span class="subst">$(lsb_release -cs)</span> stable&quot;</span> &amp;&amp; sudo apt-get update &amp;&amp; sudo apt-get install -y docker-ce</span><br></pre></td></tr></table></figure><p>一条命令就可以搞定安装，不过安装可能需要一些时间，等着就行。</p><p>在使用过程中，当需要查找某个镜像的时候，我们可以去 docker 中央仓库：<a href="https://hub.docker.com/">https://hub.docker.com/</a>  查看，从中我们可以看到该名称镜像历史的 release 的版本，我们可以根据需求选择自己需要的版本。</p><h1 id="Docker-常用管理命令"><a href="#Docker-常用管理命令" class="headerlink" title="Docker 常用管理命令"></a>Docker 常用管理命令</h1><p><a href="https://www.runoob.com/docker/docker-command-manual.html">Docker 命令大全 | 菜鸟教程 (runoob.com)</a><br>service docker start # 启动 docker 服务器</p><p>(1) 拉取某个镜像</p><p><code>docker pull xxxx</code></p><p>(2) 查看镜像与删除镜像</p><p>查看所有镜像：<code>docker images</code></p><p>删除镜像 ：<code>docker rmi xxxx</code></p><p>注意：删除镜像前必须先停用、删除该镜像产生的实例</p><p>(3) 查看与删除实例</p><p>查看所有实例：<code>docker ps -a</code></p><p>查看 activate 实例：<code>docker ps</code></p><p>删除实例：<code>docker rm xxx</code></p><p>(4) 根据镜像创造 docker 实例,这里以 nginx 为例</p><p><code>docker run --name nginx -p 80:80 -v /root/docker_conf/nginx/nginx.conf:/etc/nginx/nginx.conf -d docker.io/nginx</code></p><p>其中: -name 是镜像的名称,  -p 是端口映射, -v 是绑定一个卷, 我们可以把自己的文件目录映射到镜像内部目录, 冒号前面为自己的实际机器, : 后面是对应镜像的目录。</p><p>(5) 当 docker 启动失败的时候 debug 原因：</p><p><code>docker logs xxID</code></p><p>(6) 进入实例</p><p>根据上面的命令创建的实例之后，如果成功的话会默认启动实例，我们可以使用下列命令进入到该实例内部：</p><p><code>docker exec -it nginx bash</code></p><p><code>docker run -it --rm ubuntu /bin/bash</code>    运行存在的镜像，并以交互的方式进入容器，运行完删除容器</p><p>(7) 复制文件到实例内部系统</p><p><code>docker cp my.cnf mysql5.7:/etc/mysql/my.cnf</code></p><p>把宿主机文件拷到容器里面<br><code>docker cp 要拷贝的文件路径 容器名: 要拷贝到容器里面对应的路径</code></p><p>容器里面拷文件到主机<br><code>docker cp 容器名: 要拷贝的文件在容器中的路径 要拷贝到宿主机器的响应路径</code></p><p>(8)  实例内系统安装软件</p><p>实例内也是一个操作系统，我们可以安装需要使用的程序：</p><p><code>apt update</code></p><p>例如安装 vim 命令 :  <code>apt install vim</code></p><p>(9) 停止,启动,重新启动 docker 实例</p><p><code>docker start/stop/restart xxx</code></p><p>(10)  卸载 docker</p><p><code>yum remove docker-ce</code></p><p>删除镜像、容器、配置文件等内容：</p><p><code>rm -rf /var/lib/docker</code></p><h2 id="Docker-资源管理命令"><a href="#Docker-资源管理命令" class="headerlink" title="Docker 资源管理命令"></a>Docker 资源管理命令</h2><p>docker 镜像在很多时候会耗占比较多的内存和 cpu, 甚至某个镜像被用来挖矿的情况下, cpu 会达到 100%(都是血与泪的实践经历啊)， 所以我们可以使用下面的命令来限制性设置某个实例的内存与 cpu 占用量。</p><p>(1) docker 各个镜像资源使用情况查看 (包括 cpu 和内存)：</p><p><code>docker stats</code></p><p>(2)  限制 docker 内存</p><p><code>docker update -m 20M --memory-reservation 20M --memory-swap 20M nginx</code></p><p>（3）限制 docker cpu</p><p><code>docker update --cpu-period=100000 --cpu-quota=20000 nginx</code></p><p>在每 100 毫秒的时间里，运行进程使用的 CPU 时间最多为 20 毫秒，这里仅仅考虑百分比。</p><h1 id="Docker-常用软件管理"><a href="#Docker-常用软件管理" class="headerlink" title="Docker 常用软件管理"></a>Docker 常用软件管理</h1><h2 id="Docker-部署私有的笔记服务-Wiznote"><a href="#Docker-部署私有的笔记服务-Wiznote" class="headerlink" title="Docker 部署私有的笔记服务 Wiznote"></a>Docker 部署私有的笔记服务 Wiznote</h2><p>作为一个对写代码有追求的程序员，有一个自己用起来顺手的笔记服务是必不可少的，作者经过大量的筛选，目前主要在使用的就是 wiznote 这个软件，个人用户使用 5 个账号内免费，并且个人功能上的需求完全可以满足，使用 docker 部署也非常简单便利。</p><p>(1) 部署过程如下：</p><p><code>docker run --name wiz --restart=always -it -d -v /root/docker_conf/wiz_wiki_dat:/wiz/storage -v /etc/localtime:/etc/localtime -p 9191:80 -p 9269:9269/udp wiznote/wizserve</code></p><p>然后我们访问 <code>http://ip:9191</code> 网址即可以访问我们自己的笔记后端服务了。</p><p>初始账号：<code>admin@wiz.cn</code>,  密码：<code>123456，</code> 输入后记得自行进行修改啊，否则可能导致被他人登陆。</p><h2 id="Docker-部署-Mysql"><a href="#Docker-部署-Mysql" class="headerlink" title="Docker 部署 Mysql"></a>Docker 部署 Mysql</h2><p>（1）docker 部署 mysql</p><p>参考 wiki: <a href="https://blog.csdn.net/weixin_43888891/article/details/122518719">https://blog.csdn.net/weixin_43888891/article/details/122518719</a></p><p><code>docker pull mysql:5.7   docker run -itd --name mysql5.7 --restart=always -p 3306:3306 -e MYSQL_ROOT_PASSWORD=you_mysql_pwd docker.io/mysql:5.7    进入docker 内部：docker exec -it mysql5.7 bash   </code></p><p>(2) 配置数据库可以远程访问</p><p><code>docker exec -it mysql5.7 bash   grant all on *.* to root@&#39;%&#39; identified by &#39;you_mysql_pwd&#39; with grant option;      </code></p><p>(3) 优化 docker MySQL 配置</p><p>更新 my.cnf 文件</p><p><code>[mysqld]      max_connect_errors = 1000      lower_case_table_names = 1      performance_schema_max_table_instances = 200      table_definition_cache = 100      table_open_cache = 100      innodb_buffer_pool_size=2M      performance_schema=off   </code></p><p>更新 docker.cnf  文件</p><p><code>skip-host-cache   skip-name-resolve</code> </p><p>（4）覆盖 docker 内部文件配置</p><p><code>docker cp docker.cnf  mysql5.7:/etc/mysql/conf.d/docker.cnf   docker cp my.cnf  mysql5.7:/etc/mysql/my.cnf   </code></p><p>(5)  限制 docker MYSQL 内存和 cpu 使用</p><p><code>docker update -m 800M --memory-reservation 800M --memory-swap 800M mysql5.7   docker update  --cpu-period=100000 --cpu-quota=20000 mysql5.7</code></p><h2 id="Docker-部署-Redis"><a href="#Docker-部署-Redis" class="headerlink" title="Docker 部署 Redis"></a>Docker 部署 Redis</h2><p><a href="https://blog.csdn.net/yaoyuncn/article/details/103916573">使用docker desktop for windows安装redis:latest并挂载配置文件及持久化数据至windows的文件夹下</a></p><p>(1) docker 使用 redis</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name redis -p 6379:6379 -v /root/docker_conf/redis/redis.conf:/etc/redis/redis.conf -d redis redis-server /etc/redis/redis.conf</span><br></pre></td></tr></table></figure><p>我们可以把 redis 常用的配置文件放在 &#x2F;root&#x2F;docker_conf&#x2F;redis&#x2F;redis.conf 这个路径下。</p><p>(2) 外面访问容器里的 redis 服务</p><p><code>docker exec -it redis redis-cli</code></p><p>(3) 限制 redis 内存访问</p><p><code>docker update -m 50M --memory-reservation 50M --memory-swap 50M redis</code></p><p>然后我们就可以通过 ip: 6379 端口访问我们的 redis 服务了。</p><h2 id="Docker-部署-Nginx"><a href="#Docker-部署-Nginx" class="headerlink" title="Docker 部署 Nginx"></a>Docker 部署 Nginx</h2><p>(1) docker 使用 nginx</p><p><code>docker pull nginx</code></p><p>&#x2F;&#x2F; 本机卷映射 nginx 卷</p><p><code>docker run --name nginx -p 80:80 -v /root/docker_conf/nginx/nginx.conf:/etc/nginx/nginx.conf -d docker.io/nginx</code></p><p>(2) 限制 docker 使用内存</p><p><code>docker update -m 50M --memory-reservation 50M --memory-swap 50M nginx</code></p><p>注意，使用 docker 之后，映射的服务 IP 应该改成外部 IP，在使用 127.0.0.1 会报错。</p><p>（3）配置 nginx conf</p><p><code>/root/docker_conf/nginx下nginx.conf</code></p><p>这样我们修改本机器上的&#x2F;root&#x2F;docker_conf&#x2F;nginx&#x2F;nginx.conf  路径下的配置文件，就可以直接影响 docker nginx 服务的配置了。</p><p>然后我们就可以通过 <a href="http://ip/">http://ip:80</a>  端口访问我们的 nginx  服务了。</p><h2 id="Docker-部署-Gitea"><a href="#Docker-部署-Gitea" class="headerlink" title="Docker 部署 Gitea"></a>Docker 部署 Gitea</h2><p>在很多时候我们会需要部署我们自己的 git 版本管理仓库，可以使用 gitea 这个开源版本库，非常好用，使用 docker 部署也非常简单。</p><p>(1) 拉取 gitea 仓库</p><p><code>docker pull gitea/gitea</code></p><p>(2)  启动 gitea 实例与服务</p><p><code>docker run -d --privileged=true --restart=always --name=gitea -p 20022:22 -p 3000:3000 -v /root/docker_conf/gitea:/data gitea/gitea:latest</code></p><p>在下面我们就可以使用 <code>http://ip:3000</code> 去访问我们的 git 服务了。</p><h1 id="Docker-镜像文件保存与加载"><a href="#Docker-镜像文件保存与加载" class="headerlink" title="Docker 镜像文件保存与加载"></a>Docker 镜像文件保存与加载</h1><p>(1) 保存 docker 镜像文件到本地：</p><p><code>docker save nginx &gt;./nginx.tar</code></p><p>(2)  在另一台主机加载本地文件到镜像 ：</p><p><code>docker load &lt; nginx.tar</code></p><p>然后看 docker images ，就能看到该镜像 ，但是名字和标签都是 none</p><p>（3）执行完上述语句后，查看本地镜像，会看到新加载的镜像名字和标签都是 none，利用该镜像的 id 对名字和标签重新命名即可：</p><p><code>指令：docker tag 镜像id 镜像名:标签      docker tag 172825a55619 confluence6.12_cracked:0.1   </code></p><p>(4) 启动镜像</p><p><code>docker run -it --name nginx 172825a55619 /bin/bash</code></p><h1 id="Docker-镜像文件的提交与上传到中央仓库"><a href="#Docker-镜像文件的提交与上传到中央仓库" class="headerlink" title="Docker 镜像文件的提交与上传到中央仓库"></a>Docker 镜像文件的提交与上传到中央仓库</h1><p>很多时候，我们会需要在已有的镜像上进行一些自定义修改，然后重新打包上传自己的镜像供别人使用，我们可以使用下面的流程来上传自己新打包的镜像到中央仓库。</p><p>(5.1)  官网账号注册</p><p>首先我们先到 docker 官网注册一个账号，这样我们才能将制作好的镜像上传到 docker 仓库，</p><p>打开 <code>https://hub.docker.com/</code></p><p>(5.2) 提交自己要上传的镜像</p><p><code>docker commit Container_name yourdockerhub/nginx:latest</code></p><p>注意：commit 对包名命名有要求，Container_name 容器名称,yourdockerhub 改成自己的账号，否则无法上传</p><p>(5.3)  登录到远程 docker 仓库 (输入自己注册的账号和密码)</p><p><code>docker login</code></p><p>(5.4)  上传至 docker 云端</p><p><code>docker push yourdockerhub/nginx:latest</code><br>注意: 这里 push 对包名命名有要求，yourdockerhub 改成自己的账号，否则无法上传 上传成功了就可以在中央仓库你的账号下搜到你刚上传的镜像了。</p>]]></content>
      
      
      <categories>
          
          <category> 应用 </category>
          
          <category> 操作系统 </category>
          
          <category> Docker </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Vscode</title>
      <link href="/posts/%E5%BA%94%E7%94%A8/%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7/Vim/Vscode.html"/>
      <url>/posts/%E5%BA%94%E7%94%A8/%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7/Vim/Vscode.html</url>
      
        <content type="html"><![CDATA[<h1 id="输入法切换"><a href="#输入法切换" class="headerlink" title="输入法切换"></a>输入法切换</h1><p>设置 NORMAL 模式下的输入法为英文， 方便进行 vim 指令操作。</p><ul><li>Windows scoop 安装</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scoop bucket add im-select https://github.com/daipeihust/im-select</span><br><span class="line">scoop install im-select</span><br></pre></td></tr></table></figure><ul><li>需要在系统设置中添加中英文语言包，需要下载中文（简体，中国）和英语（美国），im-select<img src="/../../../../img/blog/4f7dd400131ed1102d1d590cdab024cd_MD5.webp">d590cdab024cd_MD5.webp)</li><li>勾选 <img src="/../../../../img/blog/b3ac789a137121fa6d03e9004ecda674_MD5.webp">a6d03e9004ecda674_MD5.webp)</li><li>随后在 im-select.exe 所在文件夹打开 shell 窗口，执行.\im-select.exe 之后会返回当前输入语言的句柄值，我的电脑中文使用搜狗输入法，执行.\im-select.exe 后其返回值为 2052，切换到英文输入法后再次执<img src="/../../../../img/blog/39498a4d9a902f8d90bdc30eae4ddbfb_MD5.webp">02f8d90bdc30eae4ddbfb_MD5.webp)</li><li>随后执行.\im-select.exe 1033 以及.\im-select.exe 2052 测试输入语言可以正常切换，说明<img src="/../../../../img/blog/e32d15d7fbc9c3746d4a21b2d42641ff_MD5.webp">fbc9c3746d4a21b2d42641ff_MD5.webp)<br>然后再到 settings.json 中加入以下配置项即可完成输入法在 INSERT 模式以及 NORMAL 模式下的自动切换。</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自动切换输入法</span></span><br><span class="line">   <span class="attr">&quot;vim.autoSwitchInputMethod.enable&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">   <span class="attr">&quot;vim.autoSwitchInputMethod.defaultIM&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1033&quot;</span><span class="punctuation">,</span>  <span class="comment">// 这里输入你刚刚获得的英文输入法名称</span></span><br><span class="line">   <span class="attr">&quot;vim.autoSwitchInputMethod.obtainIMCmd&quot;</span><span class="punctuation">:</span> <span class="string">&quot;C:/Users/User/scoop/apps/im-select/current/im-select.exe&quot;</span><span class="punctuation">,</span></span><br><span class="line">   <span class="attr">&quot;vim.autoSwitchInputMethod.switchIMCmd&quot;</span><span class="punctuation">:</span> <span class="string">&quot;C:/Users/User/scoop/apps/im-select/current/im-select.exe &#123;im&#125;&quot;</span></span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://hangx-ma.github.io/2023/03/14/vsvim-keyborad-setting.html#22-%E7%83%AD%E9%94%AE%E9%85%8D%E7%BD%AE%E5%8C%BA%E5%9F%9F%E8%AF%B4%E6%98%8E">VSCodeVim 配置指南 - 一只豆腐 (hangx-ma.github.io)</a><br><a href="https://www.barbarianmeetscoding.com/boost-your-coding-fu-with-vscode-and-vim">Boost Your Coding Fu With VSCode and Vim - The Book | Barbarian Meets Coding</a><br><a href="https://coolshell.cn/articles/5426.html">简明 Vim 练级攻略 | 酷 壳 - CoolShell</a></p>]]></content>
      
      
      <categories>
          
          <category> 应用 </category>
          
          <category> 编程工具 </category>
          
          <category> Vim </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vim </tag>
            
            <tag> vscode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu</title>
      <link href="/posts/%E5%BA%94%E7%94%A8/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux/Ubuntu.html"/>
      <url>/posts/%E5%BA%94%E7%94%A8/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux/Ubuntu.html</url>
      
        <content type="html"><![CDATA[<h1 id="Ubuntu-修改终端上显示的用户名和主机名"><a href="#Ubuntu-修改终端上显示的用户名和主机名" class="headerlink" title="Ubuntu 修改终端上显示的用户名和主机名"></a>Ubuntu 修改终端上显示的用户名和主机名</h1><p><a href="https://blog.nowcoder.net/n/9719c38265a44e23a0c7b4b9f0225b72?from=nowcoder_improve">Ubuntu修改终端上显示的用户名和主机名（详细步骤）_牛客博客 (nowcoder.net)</a></p>]]></content>
      
      
      <categories>
          
          <category> 应用 </category>
          
          <category> 操作系统 </category>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Go语言环境配置</title>
      <link href="/posts/%E5%BA%94%E7%94%A8/%E9%85%8D%E7%BD%AE/%E8%AF%AD%E8%A8%80%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/Go%E8%AF%AD%E8%A8%80%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE.html"/>
      <url>/posts/%E5%BA%94%E7%94%A8/%E9%85%8D%E7%BD%AE/%E8%AF%AD%E8%A8%80%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/Go%E8%AF%AD%E8%A8%80%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE.html</url>
      
        <content type="html"><![CDATA[<h1 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h1><p>下载安装包</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget -c https://storage.googleapis.com/golang/go1.8.3.linux-amd64.tar.gz</span><br></pre></td></tr></table></figure><p>解压至 &#x2F;usr&#x2F;local 目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo tar -C /usr/local -xzf go1.12.4.linux-amd64.tar.gz</span><br></pre></td></tr></table></figure><p>修改环境变量</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/profile</span><br></pre></td></tr></table></figure><p>在文件后面增加</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export GOPATH=$HOME/gopath</span><br><span class="line">export GOROOT=/usr/local/go</span><br><span class="line">export PATH=$PATH:$GOROOT/bin:$GOPATH/bin</span><br></pre></td></tr></table></figure><p>保存并退出，并执行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source ~/.profile</span><br></pre></td></tr></table></figure><p>重启系统，查看是否安装成功</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go version</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 应用 </category>
          
          <category> 配置 </category>
          
          <category> 语言环境配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WSL配置</title>
      <link href="/posts/%E5%BA%94%E7%94%A8/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/WSL/WSL%E9%85%8D%E7%BD%AE.html"/>
      <url>/posts/%E5%BA%94%E7%94%A8/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/WSL/WSL%E9%85%8D%E7%BD%AE.html</url>
      
        <content type="html"><![CDATA[<h1 id="Wsl-搬迁"><a href="#Wsl-搬迁" class="headerlink" title="Wsl 搬迁"></a>Wsl 搬迁</h1><p>如果我们是通过 Windows Store 进行安装的，就会默认安装到 C 盘。在使用过程中，WSL 占用空间会越来越大，很容易让 C 盘爆满，所以我们需要将其迁移到其他非 C 盘的地方。</p><h2 id="终止正在运行的-Wsl"><a href="#终止正在运行的-Wsl" class="headerlink" title="终止正在运行的 Wsl"></a>终止正在运行的 Wsl</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wsl --shutdown</span><br></pre></td></tr></table></figure><h2 id="将需要迁移的-Linux，进行导出"><a href="#将需要迁移的-Linux，进行导出" class="headerlink" title="将需要迁移的 Linux，进行导出"></a>将需要迁移的 Linux，进行导出</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wsl --export Ubuntu-18.04 D:\wsl\export</span><br></pre></td></tr></table></figure><h2 id="导出完成之后，就需要将原有的分发进行卸载"><a href="#导出完成之后，就需要将原有的分发进行卸载" class="headerlink" title="导出完成之后，就需要将原有的分发进行卸载"></a>导出完成之后，就需要将原有的分发进行卸载</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wsl --unregister Ubuntu-18.04</span><br></pre></td></tr></table></figure><h2 id="然后将导出的文件放到需要保存的地方，进行导入即可"><a href="#然后将导出的文件放到需要保存的地方，进行导入即可" class="headerlink" title="然后将导出的文件放到需要保存的地方，进行导入即可"></a>然后将导出的文件放到需要保存的地方，进行导入即可</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wsl --import Ubuntu-18.04 D:\wsl D:\wsl\export --version 2</span><br></pre></td></tr></table></figure><p>注意：如果导入后终端查找不到 wsl，可以重启系统后再打开终端。</p><p>这时打开终端，进的是 root 系统，还需要：</p><h2 id="设置默认登陆用户为安装时用户名"><a href="#设置默认登陆用户为安装时用户名" class="headerlink" title="设置默认登陆用户为安装时用户名"></a>设置默认登陆用户为安装时用户名</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">myUsername=caloewen</span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;[user]\ndefault=<span class="variable">$myUsername</span>&quot;</span> &gt;&gt; /etc/wsl.conf</span><br></pre></td></tr></table></figure><p>重启终端</p><h1 id="WSL2-优化"><a href="#WSL2-优化" class="headerlink" title="WSL2 优化"></a>WSL2 优化</h1><h2 id="压缩"><a href="#压缩" class="headerlink" title="压缩"></a>压缩</h2><p>随着使用时间的延长，WSL2 占用的硬盘空间会越来越多，这个时候就需要对其文件进行压缩。方法如下</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">wsl <span class="literal">--shutdown</span></span><br><span class="line">diskpart</span><br><span class="line"><span class="comment"># open window Diskpart</span></span><br><span class="line"><span class="built_in">select</span> vdisk file=<span class="string">&quot;C:\Users\Ci\AppData\Local\Packages\CanonicalGroupLimited.Ubuntu20.04onWindows_79rhkp1fndgsc\LocalState\ext4.vhdx&quot;</span></span><br><span class="line"><span class="comment"># select vdisk file=&quot;C:\Users\Ci\AppData\Local\Packages\KaliLinux.54290C8133FEE_ey8k8hqnwqnmg\LocalState\ext4.vhdx&quot;</span></span><br><span class="line">attach vdisk readonly</span><br><span class="line">compact vdisk</span><br><span class="line">detach vdisk</span><br></pre></td></tr></table></figure><h2 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h2><p>当然，WSL2 也会带来内存占用的问题，可以打开 <code>$home/.wslconfig</code>，进行如下设置</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="type">wsl2</span>]</span><br><span class="line">memory=<span class="number">4</span>GB</span><br><span class="line">swap=<span class="number">0</span></span><br></pre></td></tr></table></figure><h1 id="Wsl-2-设置静态-DNS-服务地址及-Linux-和-Windows-主机网络互相访问设置"><a href="#Wsl-2-设置静态-DNS-服务地址及-Linux-和-Windows-主机网络互相访问设置" class="headerlink" title="Wsl 2 设置静态 DNS 服务地址及 Linux 和 Windows 主机网络互相访问设置"></a>Wsl 2 设置静态 DNS 服务地址及 Linux 和 Windows 主机网络互相访问设置</h1><p>DNS 解析<br>wsl 2 使用的 DNS 解析服务器设置在文件：&#x2F;etc&#x2F;resolv.conf 内设置，这是一个 link 文件，真正的文件路径是：&#x2F;run&#x2F;resolvconf&#x2F;resolv.conf，这个文件是每次 wsl 启动时自动生成的，内容如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># This file was automatically generated by WSL. To stop automatic generation of this file, add the following entry to /etc/wsl.conf:</span></span><br><span class="line"><span class="comment"># [network]</span></span><br><span class="line"><span class="comment"># generateResolvConf = false</span></span><br><span class="line">nameserver 172.24.144.1</span><br></pre></td></tr></table></figure><p>nameserver 后面的就是指定的 DNS 服务器地址。我发现有时候分配的服务器地址是无效的，如：127.0.0.53，使用 ping 来测试发现提示无法解析地址。需要设置一个固定的 DNS 地址，方法如下：</p><p>新建文件：&#x2F;etc&#x2F;wsl.conf，内容如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[network]</span><br><span class="line">generateResolvConf = <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>以上配置好就不会自动创建 &#x2F;run&#x2F;resolvconf&#x2F;resolv.conf 文件了。</p><p>退出 wsl，关机然后重新启动：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">exit</span></span><br><span class="line">wsl --shutdown</span><br><span class="line">wsl</span><br></pre></td></tr></table></figure><p>删除 link 文件：&#x2F;etc&#x2F;resolv.conf:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">rm</span> /etc/resolv.conf</span><br></pre></td></tr></table></figure><p>然后新建 &#x2F;etc&#x2F;resolv.conf 文件，内容如下，可自定义 nameserver 地址：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nameserver 114.114.114.114</span><br></pre></td></tr></table></figure><p>再次退出 wsl，关机然后重新启动<br>查看 &#x2F;etc&#x2F;resolv.conf 文件是否是之前自定义的地址：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /etc/resolv.conf</span><br></pre></td></tr></table></figure><p>测试网络服务：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping niekun.net</span><br></pre></td></tr></table></figure><p>如果你想对将要安装的 deb 软件包使用 dpkg 命令，在这里是如何完成它：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo dpkg -i path_to_deb_file</span><br></pre></td></tr></table></figure><h1 id="记录-Windows11-安装-WSL2-配置环境时遇到的坑，以及一些常用命令（持续更新）"><a href="#记录-Windows11-安装-WSL2-配置环境时遇到的坑，以及一些常用命令（持续更新）" class="headerlink" title="记录 Windows11 安装 WSL2 配置环境时遇到的坑，以及一些常用命令（持续更新）"></a>记录 Windows11 安装 WSL2 配置环境时遇到的坑，以及一些常用命令（持续更新）</h1><p><a href="https://blog.csdn.net/luyuyingyingying/article/details/123110417">https://blog.csdn.net/luyuyingyingying/article/details/123110417</a></p><h1 id="WSL-systemd"><a href="#WSL-systemd" class="headerlink" title="WSL_systemd"></a>WSL_systemd</h1><p>安装好新版 wsl 后，通过以下命令来配置 wsl 启用 systemd:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;[boot]\nsystemd=true&quot;</span> | sudo <span class="built_in">tee</span> -a /etc/wsl.conf</span><br></pre></td></tr></table></figure><p>配置后需要通过 <code>wsl --shutdown</code> 命令关闭 wsl，来进行 wsl 的完整重启。</p><h2 id="如何判断-Systemd-是否启用成功"><a href="#如何判断-Systemd-是否启用成功" class="headerlink" title="如何判断 Systemd 是否启用成功"></a>如何判断 Systemd 是否启用成功</h2><p>判断 wsl 是否已启用 systemd，可通过以下命令查看：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps --no-headers -o <span class="built_in">comm</span> 1</span><br></pre></td></tr></table></figure><p>如果命令返回的是 <code>init</code> 说明 systemd 未启用，如果是 <code>systemd</code> 那么你的 systemd 已启用成功了。</p><h2 id="查看已启用的-Systemd-Service"><a href="#查看已启用的-Systemd-Service" class="headerlink" title="查看已启用的 Systemd Service"></a>查看已启用的 Systemd Service</h2><p>通过 systemctl 的 list-units、list-unit-files 命令，都可以很好的查看目前的 systemd 状态，命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl list-units --<span class="built_in">type</span>=service</span><br><span class="line">systemctl list-unit-files --<span class="built_in">type</span>=service --state=enabled</span><br></pre></td></tr></table></figure><h2 id="解决-Exec-Exec-Format-Error"><a href="#解决-Exec-Exec-Format-Error" class="headerlink" title="解决 Exec: Exec Format Error"></a>解决 Exec: Exec Format Error</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo sh -c &#x27;echo :WSLInterop:M::MZ::/init:PF &gt; /usr/lib/binfmt.d/WSLInterop.conf&#x27;</span><br></pre></td></tr></table></figure><p>After <code>wsl --shutdown</code> and logging back in, now next to systemd, <code>explorer.exe</code> and the like are finally working again!<br><a href="https://github.com/microsoft/WSL/issues/8843">[WSL2][systemd][interop] Unable to Execute Windows Binary when systemd enabled · Issue #8843 · microsoft&#x2F;WSL (github.com)</a></p><h2 id="启用-Systemd-支持后无法从-Wsl2-运行-Exe"><a href="#启用-Systemd-支持后无法从-Wsl2-运行-Exe" class="headerlink" title="启用 Systemd 支持后无法从 Wsl2 运行 Exe"></a>启用 Systemd 支持后无法从 Wsl2 运行 Exe</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo update-binfmts --disable cli</span><br></pre></td></tr></table></figure><h1 id="Kali"><a href="#Kali" class="headerlink" title="Kali"></a>Kali</h1><h2 id="升级"><a href="#升级" class="headerlink" title="升级"></a>升级</h2><p>安装完成后，在 Kali Linux 下，输入如下命令，安装工具集</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update &amp;&amp; sudo apt upgrade</span><br><span class="line">sudo apt install -y kali-linux-default</span><br></pre></td></tr></table></figure><h2 id="GUI"><a href="#GUI" class="headerlink" title="GUI"></a>GUI</h2><p>当然为了更好的体验 Kali，我们可以安装官方推荐的 GUI —— Win-KeX。输入如下命令，进行安装。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install -y kali-win-kex</span><br><span class="line">sudo mount -o remount,rw /tmp/.X11-unix</span><br></pre></td></tr></table></figure><p>安装完毕后，可使用如下命令启动</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动</span></span><br><span class="line"><span class="built_in">cd</span> ~</span><br><span class="line">kex</span><br><span class="line"><span class="comment"># 关闭</span></span><br><span class="line">kex stop</span><br><span class="line"><span class="comment"># 窗口模式</span></span><br><span class="line">kex --win -s</span><br></pre></td></tr></table></figure><p><a href="https://www.kali.org/docs/wsl/win-kex/#install-kali-linux-in-wsl2">Win-KeX | Kali Linux Documentation</a></p>]]></content>
      
      
      <categories>
          
          <category> 应用 </category>
          
          <category> 操作系统 </category>
          
          <category> WSL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> wsl </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解决方案</title>
      <link href="/posts/%E5%BA%94%E7%94%A8/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Vmware/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88.html"/>
      <url>/posts/%E5%BA%94%E7%94%A8/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Vmware/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88.html</url>
      
        <content type="html"><![CDATA[<h1 id="虚拟机-Deepin-网线未连接"><a href="#虚拟机-Deepin-网线未连接" class="headerlink" title="虚拟机 Deepin 网线未连接"></a>虚拟机 Deepin 网线未连接</h1><p>不小心将虚拟机 <a href="https://so.csdn.net/so/search?q=ubuntu&spm=1001.2101.3001.7020">ubuntu</a>&#x2F;deepin 强制关机后，重启之后系统显示网卡未连接。<br>解决办法：<br>编辑文件&#x2F;etc&#x2F;network&#x2F;interfaces:<br>sudo vi &#x2F;etc&#x2F;network&#x2F;interfaces，在文件里加上：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">auto ens33</span><br><span class="line">iface ens33 inet dhcp</span><br></pre></td></tr></table></figure><p>最后执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo /etc/init.d/networking restart</span><br></pre></td></tr></table></figure><h1 id="vmware-虚拟机网卡不启动时的-service-NetworkManager-修复"><a href="#vmware-虚拟机网卡不启动时的-service-NetworkManager-修复" class="headerlink" title="vmware 虚拟机网卡不启动时的 service NetworkManager 修复"></a>vmware 虚拟机网卡不启动时的 service NetworkManager 修复</h1><h2 id="1-检查-Windows-下的-Vmware-虚拟机网络相关服务是否开启"><a href="#1-检查-Windows-下的-Vmware-虚拟机网络相关服务是否开启" class="headerlink" title="1.检查 Windows 下的 Vmware 虚拟机网络相关服务是否开启"></a>1.检查 Windows 下的 Vmware 虚拟机网络相关服务是否开启</h2><p><img src="/../../../../img/blog/0dd2e698444a07e3d24ae66ce90bed4d_MD5.png" alt="image.png"></p><h2 id="2-检查虚拟接网络配置设置是否正确"><a href="#2-检查虚拟接网络配置设置是否正确" class="headerlink" title="2. 检查虚拟接网络配置设置是否正确"></a>2. 检查虚拟接网络配置设置是否正确</h2><p>检查 vmware workstation 的网络配置是否符合主机的虚拟网卡配置，若不确定就点击还原默认设置<br><img src="/../../../../img/blog/8f86b52d506cbb4260790e6f77103348_MD5.png" alt="image.png"></p><h2 id="3-检查虚拟机-Ubuntu-系统右上角的网络连接是否存在"><a href="#3-检查虚拟机-Ubuntu-系统右上角的网络连接是否存在" class="headerlink" title="3. 检查虚拟机 Ubuntu 系统右上角的网络连接是否存在"></a>3. 检查虚拟机 Ubuntu 系统右上角的网络连接是否存在</h2><p>若不存在，网络就可能连不上</p><h2 id="4-修复"><a href="#4-修复" class="headerlink" title="4. 修复"></a>4. 修复</h2><p>（1）删除 NetworkManager 缓存文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">service NetworkManager stop</span><br><span class="line">sudo <span class="built_in">rm</span> /var/lib/NetworkManager/NetworkManager.state</span><br><span class="line">service NetworkManager start</span><br></pre></td></tr></table></figure><p>（2）修改&#x2F;etc&#x2F;NetworkManager&#x2F;NetworkManager.conf</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo gedit /etc/NetworkManager/NetworkManager.conf</span><br><span class="line"><span class="comment">##找到managed=false修改为：managed=true</span></span><br></pre></td></tr></table></figure><p>（3）重启 NetworkManager</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo service network-manager restart</span><br></pre></td></tr></table></figure><p>就可以看到系统右上角出现了网络图标，重启虚拟机，搞定！</p><h1 id="Ubuntu22-04-在-VMware-17-无法实现拖放复制操作解决办法"><a href="#Ubuntu22-04-在-VMware-17-无法实现拖放复制操作解决办法" class="headerlink" title="Ubuntu22.04 在 VMware 17 无法实现拖放复制操作解决办法"></a>Ubuntu22.04 在 VMware 17 无法实现拖放复制操作解决办法</h1><p><a href="https://blog.csdn.net/ZRongZH/article/details/129237476">Ubuntu22.04 在 VMware 17 无法实现拖放复制操作解决办法_ubuntu无法拖拽文件-CSDN博客</a></p>]]></content>
      
      
      <categories>
          
          <category> 应用 </category>
          
          <category> 操作系统 </category>
          
          <category> Vmware </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>入门</title>
      <link href="/posts/%E5%AD%A6%E4%B9%A0/%E8%87%AA%E5%88%B6%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/%E5%85%A5%E9%97%A8.html"/>
      <url>/posts/%E5%AD%A6%E4%B9%A0/%E8%87%AA%E5%88%B6%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/%E5%85%A5%E9%97%A8.html</url>
      
        <content type="html"><![CDATA[<h1 id="练习一·算式分割"><a href="#练习一·算式分割" class="headerlink" title="练习一·算式分割"></a>练习一·算式分割</h1><p>目标：我们可以将一个算式分为几个部分——数字（NUM），运算符（SIGN），左括号（LPA）和右括号（RPA）。现在希望让词法分析器可以分析出这四个部分，并将一个算式中的成分按格式打印出来。<br>本程序中数字的定义为正整数。你也可以对其做适当扩展，使得程序可以将实数匹配为数字。<br>希望得到的结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入： 1+2*(3/4)-5</span><br><span class="line">输出：NUM SIGN NUM SIGN LPA NUM SIGN NUM RPA SIGN NUM</span><br></pre></td></tr></table></figure><p>提示：在相应规则的 action 中使用 print&#x2F;printf 进行输出，如果使用了 C 语言某个头文件的函数，记得在第一部分花括号内导入它。</p><p><strong>练习一参考答案：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">%&#123;</span><br><span class="line"></span><br><span class="line">%&#125;</span><br><span class="line"></span><br><span class="line">%%</span><br><span class="line"></span><br><span class="line">[1-9]+[0-9]*  printf(&quot;NUM &quot;);</span><br><span class="line">&quot;+&quot;|&quot;-&quot;|&quot;*&quot;|&quot;/&quot;  printf(&quot;SIGN &quot;);</span><br><span class="line">&quot;(&quot;printf(&quot;LPA &quot;);</span><br><span class="line">&quot;)&quot;printf(&quot;RPA &quot;);</span><br><span class="line"></span><br><span class="line">%%</span><br><span class="line">main(int argc, char **argv)</span><br><span class="line">&#123;</span><br><span class="line">  yylex();</span><br><span class="line">  yywrap();</span><br><span class="line">&#125;</span><br><span class="line">int yywrap()</span><br><span class="line">&#123;</span><br><span class="line">return 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>额外讲解：</strong><br>如果你想匹配实数，那么你应该将规则①的 pattern 这样来写：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(0|[1-9]+[0-9]*|[0-9]+&quot;.&quot;[0-9]+)  </span><br></pre></td></tr></table></figure><p>看到这段正则表达式，你可能会有些疑惑。因为这个表达式似乎只能匹配正实数，而事实也是如此。可能出乎你的意料，一旦需要在算式中匹配负数，那么这个问题立刻就变成了一个语法上的问题。因为表示负数的符号与减号相同，而根据此前所说的 flex 匹配规则，程序会尽量匹配长的字符串，如果加入负数的匹配，则 5-6 这个表达式就永远会被匹配成两个 NUM——毕竟词法分析和语法分析两个任务是互相隔离的，在词法分析器根本不知道你规定的语法，它当然也就不可能明白这是两个数在做运算还是单纯的两个数。<br>在现在这个只掌握了 flex 的情况下，如果我们想要匹配到负数，最好的办法可能就是不用 ‘-‘ 号表示负数，而改用其他的符号。<br>看到这里，你也许就能明白，为什么在 C 语言中，语法上是正确的语句（a++ + ++b）在编译时会报错了。在做词法分析时，它被分析成了 a ++ ++ +b，显然这样看的话在语法上是错误的。<br>&#x2F;—–<br>除此之外，还有一个会令人苦恼的地方，那就是这段 pattern 写起来真是又长又难看，如果一不小心写错了，可能就会产生非常难找出的顽固 BUG！<br>想要解决这个问题，我们就需要回到 flex 代码框架的第一段进行 “ 定义 “，关于这方面的内容，即将在第二个问题的答案中进行讲解。</p><p>&#x2F;——-</p><h1 id="一、环境配置"><a href="#一、环境配置" class="headerlink" title="一、环境配置"></a>一、环境配置</h1><p>1.1【lex 与 yacc 安装，gcc 安装】<br>对于 Unix 和 Linux 选手来说，这些都是标配，因此这一段针对使用 windows 的学习者。<br>在 windows 平台上，我们使用 <a href="https://so.csdn.net/so/search?q=flex&spm=1001.2101.3001.7020">flex</a> 来代替 lex，用 bison 来代替 yacc，这两者完全可以提供我们需要的功能，且 flex 还是 lex 的加强版，它们可以在 windows 上运行，且是免费的。<br>此外，我们还需要使用 gcc 来将 flex 与 bison 翻译成的 c 文件编译为可执行的 exe 文件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scoop install winflexbison</span><br><span class="line">scoop install msys2</span><br></pre></td></tr></table></figure><p>1.2【检测安装是否成功】<br>依旧以 Windows 为例，打开 cmd（务必以<strong>管理员身份</strong>打开，否则可能会出现问题！），直接输入以下代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">flex -V //注意是大写的V</span><br><span class="line">bison -V //同大写的V</span><br><span class="line">gcc -v//注意是小写的v</span><br></pre></td></tr></table></figure><h1 id="二、flex-入门"><a href="#二、flex-入门" class="headerlink" title="二、flex 入门"></a>二、flex 入门</h1><h2 id="2-0【介绍】"><a href="#2-0【介绍】" class="headerlink" title="2.0【介绍】"></a>2.0【介绍】</h2><p>在具有结构化输入的程序中，反复出现的两个任务是：将输入分隔成有意义的单元，然后找出这些单元之间的关系。<br>而 lex&#x2F;flex 所做的就是生成 <a href="https://so.csdn.net/so/search?q=%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90%E5%99%A8&spm=1001.2101.3001.7020">词法分析器</a>，以完成上面提高的第一个任务。先让新手在 flex 上入门是必然的，因为不分析词法，则分析语法没有意义。<br>通过编写特定的代码，在使用 flex 编译之后，就可以生成词法分析器的 C 程序。<br>使用 lex&#x2F;flex 制作词法分析器是很有必要的，因为 lex 将正则表达式转变为词法分析程序能够用来极快地扫描输入文本的形式，而且速度不依赖于词法分析程序尝试匹配的表达式的数量。这使得在绝大多数情况下，lex 生成的词法分析器的速度都快速手写的程序。<br>本节我们就来学习，如何使用 flex 生成词法分析器。</p><h2 id="2-1【先编译一下已经完成的-Flex-代码吧】"><a href="#2-1【先编译一下已经完成的-Flex-代码吧】" class="headerlink" title="2.1【先编译一下已经完成的 Flex 代码吧】"></a>2.1【先编译一下已经完成的 Flex 代码吧】</h2><p>最初接触一门工具，不知道它的语法，也不知道如何使用才是正确的，难免会出现恐慌的情绪。因此，我们先尝试，用提供的代码编译出一个可执行文件，在感性上初步认识 flex。（此外，这可能还会给你带来自己已经会使用 flex 的错觉，毕竟你已经成功做出了一个可执行文件了！）<br>现在，新建一个 txt 文件，取名 test，然后往里面写入如下代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">%&#123;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">%&#125;</span><br><span class="line"></span><br><span class="line">%%</span><br><span class="line"></span><br><span class="line">([1-9]+[0-9]*)|[0]ECHO;</span><br><span class="line">[0-9]+\.[0-9]+</span><br><span class="line">[a-zA-Z]+</span><br><span class="line">.</span><br><span class="line"></span><br><span class="line">%%</span><br><span class="line"></span><br><span class="line">int main(int argc, char **argv)</span><br><span class="line">&#123;</span><br><span class="line">  yylex();</span><br><span class="line">  yywrap();</span><br><span class="line">&#125;</span><br><span class="line">int yywrap()</span><br><span class="line">&#123;</span><br><span class="line">return 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你不需要知道这些东西是啥，直接无脑复制即可，这个代码不是我们接下来要讲解的 “ 教材 “。<br>保存文件，将这个 txt 文件改名为<strong>test.l</strong>（小写的 L），我们通常用这个扩展名表示它是 flex&#x2F;lex 文件。如果你有一个文本处理工具，例如 Notepad++，则不需要这么麻烦，直接新建 test.l，然后编辑这个文件即可。<br>随后，打开 cmd（再提醒一遍，使用管理员权限打开），为了方便，我们先来到 test.l 所在的路径。<br>为了避免学习者连 windows 的 cmd 操作也不甚清楚，这里说明一下如何来到 test.l 所在的路径：<br>（<strong>假设</strong>test.l 所在的路径为 E:\ComplierComplier\program，则输入以下代码：）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">E://转到E盘</span><br><span class="line">cd E:\ComplierComplier\program  //change directory至目标路径</span><br></pre></td></tr></table></figure><p>好的，现在我们来到了 test.l 所在的路径了，最后，使用 flex 对它进行编译，继续在 cmd 中输入以下代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">flex test.l//此后会生成C文件lex.yy.c</span><br><span class="line">gcc lex.yy.c//使用gcc编译成可执行文件</span><br></pre></td></tr></table></figure><p>接下来，你就将<strong>得到可执行文件 a.exe</strong>。如果直接双击它是没有什么效果的，我们需要在 cmd 中使用它，（如果你不小心把 cmd 关了，请再回到这个路径上），输入 a.exe 或者直接输入 a，回车之后就表示开始执行 a.exe。<br>虽然目前你还不知道之前的 flex 代码究竟是什么意思，但我可以告诉你，a.exe 的作用是什么：在 cmd 中输入一段文本，它会自动分辨出其中的整数内容，并输出出来。它会忽略其他内容，<strong>包括小数</strong>。<br>测试数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Alice bought 3 apples, 2 pearls, they cost 1.5$</span><br><span class="line">//理应输出3 2</span><br><span class="line">int a=23;</span><br><span class="line">//理应输出23</span><br><span class="line">double b=0.45;</span><br><span class="line">//理应输出空行</span><br></pre></td></tr></table></figure><p>如果测试成功，恭喜你，你成功掌握了如何编译一个.l 文件使之可以运行！如果未来在编译的过程中出现了错误，那想必就是代码中出现了 ERROR，而非其他的外部原因。<br>顺便，这个程序不会自己停止，请在 cmd 程序获得焦点时，按两次 ctrl+c，即可退出。</p><h2 id="2-2【介绍-Flex-的代码结构】"><a href="#2-2【介绍-Flex-的代码结构】" class="headerlink" title="2.2【介绍 Flex 的代码结构】"></a>2.2【介绍 Flex 的代码结构】</h2><p>一个来自于 flex 使用手册的结构：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">定义(definations)</span><br><span class="line">%%</span><br><span class="line">规则(rules)</span><br><span class="line">%%</span><br><span class="line">代码(user code)</span><br></pre></td></tr></table></figure><p>flex 的代码分为三个部分，由 <code>%%</code> 分割，这些部分可以为空，但为了让 flex 代码能够按照我们此前介绍的方法成功编译，需要加入部分内容，形成下方的<strong>新手框架</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">%&#123;</span><br><span class="line"></span><br><span class="line">%&#125;</span><br><span class="line"></span><br><span class="line">%%</span><br><span class="line"></span><br><span class="line">%%</span><br><span class="line">int main(int argc, char **argv)</span><br><span class="line">&#123;</span><br><span class="line">  yylex()</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br><span class="line">int yywrap()</span><br><span class="line">&#123;</span><br><span class="line">return 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来介绍这个框架中的内容：<br>①第一部分，较原框架加入了%{ %}，这对大括号内没有任何内容，所以目前起不到任何作用。加入这对大括号的目的是，在这个部分可以使用 C 语言代码进行预处理，例如使用#include&lt;stdio.h&gt;，或是定义宏、常量等等。<br>②第二部分，没有变化，这里的要写入的代码是重点内容，将在后续展开。<br>③第三部分，这个部分就是用来写 C 语言代码的，因此不需要使用%</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> 自制编程语言 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>图床配置</title>
      <link href="/posts/%E5%BA%94%E7%94%A8/%E9%85%8D%E7%BD%AE/%E5%8D%9A%E5%AE%A2%E9%85%8D%E7%BD%AE/%E5%9B%BE%E5%BA%8A%E9%85%8D%E7%BD%AE.html"/>
      <url>/posts/%E5%BA%94%E7%94%A8/%E9%85%8D%E7%BD%AE/%E5%8D%9A%E5%AE%A2%E9%85%8D%E7%BD%AE/%E5%9B%BE%E5%BA%8A%E9%85%8D%E7%BD%AE.html</url>
      
        <content type="html"><![CDATA[<h1 id="新建-Github-仓库用来存储图片"><a href="#新建-Github-仓库用来存储图片" class="headerlink" title="新建 Github 仓库用来存储图片"></a>新建 Github 仓库用来存储图片</h1><ol><li><p>登录你的 github 账号，<a href="https://github.com/">点击跳转登录</a>，右上角加号处点击此选项，创建一个新的仓库</p></li><li><p>详细设置</p><p> <img src="/../../../../img/blog/2eb9eb47fdd5b0100f3cf60b49b99a5d_MD5.png"></p></li><li><p>此仓库你可以上传你的图片，用来达到存储的目的</p></li></ol><h1 id="利用-PicGo-工具便捷管理图片"><a href="#利用-PicGo-工具便捷管理图片" class="headerlink" title="利用 PicGo 工具便捷管理图片"></a>利用 PicGo 工具便捷管理图片</h1><ol><li><p>前往 picgo 的 GitHub 仓库下载此工具，<a href="https://github.com/Molunerfinn/PicGo">点击前往下载</a>，如果下载速度太慢，科学上网下载会快一点，下载好后安装即可</p></li><li><p>然后，在 github 上创建一个 token1，点击右上角账号上的 settings</p></li><li><p>然后左侧点击 developer (开发人员) settings ，再点击 personal access tokens (令牌) ，然后点击 generate (生成) new token (令牌)</p><p> <img src="/../../../../img/blog/2139abd0eba7122bb6a60ba1f93945bc_MD5.png"></p></li><li><p>Note 用来说明你创建 token (令牌) 的用途，然后 scopes (范围) 只需要选 repo 的所有选项即可</p><p> <img src="/../../../../img/blog/bccc7b6d0de56c68064c5e60dc0cd539_MD5.png"></p></li><li><p>最后拉到底部，点击 generate (生成) token (令牌) ，即可成功</p></li><li><p>找个地方记下这一串 token，等会需要用到。（如果没有记住，等再查看时就只能重新生成了）</p><p> <img src="/../../../../img/blog/cf338c5de15fbd9974d2b7ee0b6d0601_MD5.png"></p></li><li><p>打开 picgo 工具进行配置</p><p> <img src="/../../../../img/blog/241f1dee5f9af2a1686281b25b8fcbb6_MD5.jpg"></p></li></ol><ul><li>在 PicGo 中，找到图床设置 -&gt; GitHub 图床。</li><li>仓库名即为你的 github 账号&#x2F;图片仓库名</li><li>分支名就用默认的 master&#x2F;main</li><li>Token (令牌) 就填写刚才我们生成的 Token</li><li>存储路径如果需要指定子目录可以填写例如 img&#x2F; 。我这里没有填，就会上传到我图片仓库的根目录。</li><li>自定义域名就填写 jsDelivr 的域名，<code>https://cdn.jsdelivr.net/gh/github用户名/仓库名@master</code></li><li>最后设为默认图床，下次在 typora 上传图片就会自动上传到 github 图床了</li></ul><h1 id="总结-便捷使用方法"><a href="#总结-便捷使用方法" class="headerlink" title="总结 - 便捷使用方法"></a>总结 - 便捷使用方法</h1><ol><li><p>点击上传图片，此时如果你上面的配置正确，上传的图片将会同步至 github 仓库内</p><p> <img src="/../../../../img/blog/898b8916b86821b3af8eb1dc871ca0a2_MD5.jpg"></p></li><li><p>点击相册，可见你的图片，点击此按钮，即可复制图片链接</p><p> <img src="/../../../../img/blog/7321f768c3e13ad3cbc24fb8cfe73c87_MD5.jpg"></p></li><li><p>你也可以指定上传后的链接格式</p><p> <img src="/../../../../img/blog/564d246fab33c92c74d59fb74dba8000_MD5.jpg"></p></li><li><p>得到链接后，你就可以尽情的使用了，加载速度十分迅速，白嫖真香，以后想要存图片就上传，接着复制链接出来使用，非常的方便</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 应用 </category>
          
          <category> 配置 </category>
          
          <category> 博客配置 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>butterfly主题配置</title>
      <link href="/posts/%E5%BA%94%E7%94%A8/%E9%85%8D%E7%BD%AE/%E5%8D%9A%E5%AE%A2%E9%85%8D%E7%BD%AE/butterfly%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE.html"/>
      <url>/posts/%E5%BA%94%E7%94%A8/%E9%85%8D%E7%BD%AE/%E5%8D%9A%E5%AE%A2%E9%85%8D%E7%BD%AE/butterfly%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE.html</url>
      
        <content type="html"><![CDATA[<p><a href="https://butterfly.js.org/posts/21cfbf15/">文档地址</a><br><a href="https://fontawesome.com/icons?d=gallery">Find Icons with the Perfect Look &amp; Feel | Font Awesome</a><br>将 <code>butterfly/_config.yml</code> 文件复制，重命名为 <code>_config.butterfly.yml</code> 放在 hexo 根目录下，在这个文件里做修改<br>命令：hexo clean &amp;&amp; hexo g &amp;&amp; hexo d 上传主题，验证是否修改成功。</p><h1 id="主题素材"><a href="#主题素材" class="headerlink" title="主题素材"></a>主题素材</h1><h2 id="本地图片"><a href="#本地图片" class="headerlink" title="本地图片"></a>本地图片</h2><p>在根目录的 source 文件夹下创建 img 文件夹，包含 web 和 blog 两个文件夹，网站图片使用 <code>/img/web/xx.jpg</code>,博客图片使用 <code>![](img/blog/xx.jpg)</code>,并把 butterfly 主题文件夹下的 img 文件夹剪切到 <code>/img/web</code> 文件夹下</p><h2 id="FontAwesome-图标本地加载"><a href="#FontAwesome-图标本地加载" class="headerlink" title="FontAwesome 图标本地加载"></a>FontAwesome 图标本地加载</h2><p>由于 all.min.css 下载 woff 文件较慢所以改为本地加载<br>首先注释掉 themes\butterfly\plugins.yml 中的以下代码</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#fontawesomeV6:</span></span><br><span class="line"><span class="comment">#   name: &#x27;@fortawesome/fontawesome-free&#x27;</span></span><br><span class="line"><span class="comment">#   file: css/all.min.css</span></span><br><span class="line"><span class="comment">#   other_name: font-awesome</span></span><br><span class="line"><span class="comment">#   version: 6.3.0</span></span><br></pre></td></tr></table></figure><p>再从 <a href="https://github.com/FortAwesome/Font-Awesome/tree/6.x">这个网站</a> 下载 css&#x2F;all.min.css 和 webfonts 文件夹<br>下载好后将 all.min.css 拷贝到 themes\butterfly\source\css 目录中,将 webfonts 文件夹拷贝到 themes\butterfly\source 目录中<br>最后引入 css</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">inject:</span></span><br><span class="line">  <span class="attr">head:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&lt;link</span> <span class="string">rel=&quot;stylesheet&quot;</span> <span class="string">href=&quot;/css/all.min.css&quot;&gt;</span></span><br><span class="line">  <span class="attr">bottom:</span></span><br><span class="line">    <span class="comment"># - &lt;script src=&quot;xxxx&quot;&gt;&lt;/script&gt;</span></span><br></pre></td></tr></table></figure><p>使用阿里图标与此类似 <a href="https://www.cnblogs.com/MoYu-zc/p/14399186.html">Hexo-使用阿里iconfont图标 - MoYu-zc - 博客园 (cnblogs.com)</a></p><h2 id="外挂-Css"><a href="#外挂-Css" class="headerlink" title="外挂 Css"></a>外挂 Css</h2><p>在 themes\butterfly\source\css 目录中添加 my.css,添加需要的 css</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 滚动条 */</span></span><br><span class="line">::-webkit-scrollbar &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">14px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">14px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">::-webkit-scrollbar-track &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="built_in">rgba</span>(<span class="number">73</span>, <span class="number">177</span>, <span class="number">245</span>, <span class="number">0.2</span>);</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">2em</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">::-webkit-scrollbar-thumb &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#49b1f5</span>;</span><br><span class="line">    <span class="attribute">background-image</span>: <span class="built_in">-webkit-linear-gradient</span>(<span class="number">45deg</span>,</span><br><span class="line">            <span class="built_in">rgba</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>, <span class="number">0.4</span>) <span class="number">25%</span>,</span><br><span class="line">            transparent <span class="number">25%</span>,</span><br><span class="line">            transparent <span class="number">50%</span>,</span><br><span class="line">            <span class="built_in">rgba</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>, <span class="number">0.4</span>) <span class="number">50%</span>,</span><br><span class="line">            <span class="built_in">rgba</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>, <span class="number">0.4</span>) <span class="number">75%</span>,</span><br><span class="line">            transparent <span class="number">75%</span>,</span><br><span class="line">            transparent);</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">2em</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">::-webkit-scrollbar-corner &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: transparent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">::-moz-selection &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#fff</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#49b1f5</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* a标签默认颜色 */</span></span><br><span class="line"><span class="selector-id">#article-container</span> <span class="selector-tag">a</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#00c4b6</span>;</span><br><span class="line">    <span class="attribute">text-decoration</span>: none;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 鼠标悬停时的颜色 */</span></span><br><span class="line"><span class="comment">/* #article-container a:hover &#123;</span></span><br><span class="line"><span class="comment">    color: #e58a8a;</span></span><br><span class="line"><span class="comment">&#125; */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*a标签颜色*/</span></span><br><span class="line"><span class="selector-tag">a</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#00c4b6</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后引入 css</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">inject:</span></span><br><span class="line">  <span class="attr">head:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&lt;link</span> <span class="string">rel=&quot;stylesheet&quot;</span> <span class="string">href=&quot;/css/my.css&quot;&gt;</span></span><br><span class="line">  <span class="attr">bottom:</span></span><br><span class="line">    <span class="comment"># - &lt;script src=&quot;xxxx&quot;&gt;&lt;/script&gt;</span></span><br></pre></td></tr></table></figure><h2 id="分割线图标更换"><a href="#分割线图标更换" class="headerlink" title="分割线图标更换"></a>分割线图标更换</h2><p>本次修改基于 Butterfly 主题 3.0.0 ！<br>将图标更换为 “ 太空飞船 “。<br>修改 butterfly 主题配置文件 <code>_data</code>–<code>_config.yml</code> ：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">hr_icon:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">icon:</span> <span class="string">&#x27;\f197&#x27;</span> <span class="comment"># the unicode value of Font Awesome icon</span></span><br><span class="line">  <span class="attr">icon-top:</span> <span class="string">-10px</span></span><br></pre></td></tr></table></figure><p><code>icon-top</code> 常用数值：</p><p>-20px：图标位于分割线上方<br>-10px：图标位于分割线中间<br>0px：图标位于分割线下方</p><h1 id="本地搜索"><a href="#本地搜索" class="headerlink" title="本地搜索"></a>本地搜索</h1><p>1、安装 hexo-generator-searchdb 搜索插件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-search --save</span><br></pre></td></tr></table></figure><p>2、修改配置文件：</p><p>找到 local_search 将 enable 修改为 true</p><h2 id="加速方案"><a href="#加速方案" class="headerlink" title="加速方案"></a>加速方案</h2><h3 id="减少索引内容"><a href="#减少索引内容" class="headerlink" title="减少索引内容"></a>减少索引内容</h3><ul><li>可以设置搜索内容，若仅搜索标题 （搜索内容 content 设置为 false） 则会加载快到飞起<br><img src="/../../../../img/blog/butterfly%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE-2.png"></li></ul><h3 id="外链加速"><a href="#外链加速" class="headerlink" title="外链加速"></a>外链加速</h3><p>打开主题下的 local-search.js 文件 (不同主题的位置会不同, 但是一般都在 source&#x2F;js 这种文件夹里) , 找到如下字段</p><p><code>url: GLOBAL_CONFIG.root + path</code> 改成 <code>url: 外链</code><br>外链推荐使用 Jsdelivr 的 cdn (引用 Github 的资源, 不需要手动更新, 速度也挺快)</p><h1 id="评论"><a href="#评论" class="headerlink" title="评论"></a>评论</h1><h2 id="使用-Valine-添加评论功能"><a href="#使用-Valine-添加评论功能" class="headerlink" title="使用 Valine 添加评论功能"></a>使用 Valine 添加评论功能</h2><ol><li><p>注册账号并进入：<a href="https://leancloud.cn/dashboard/login.html#/signin">LeanCloud</a></p></li><li><p>创建开发版应用：</p></li><li><p>创建后点击设置进入应用：</p></li><li><p>复制 AppID、AppKey</p></li><li><p>修改主题配置文件<br>找到 valine，分别将复制的 id 和 key 填入,开启评论需要在 comments-use 中填写你需要的评论。</p></li></ol><h2 id="Giscus-评论系统设置"><a href="#Giscus-评论系统设置" class="headerlink" title="Giscus 评论系统设置"></a>Giscus 评论系统设置</h2><h3 id="安装-Giscus"><a href="#安装-Giscus" class="headerlink" title="安装 Giscus"></a>安装 Giscus</h3><p>点击这个链接安装：**<a href="https://github.com/apps/giscus">GitHub Apps - giscus</a>**</p><h3 id="配置仓库-Discuss-部分"><a href="#配置仓库-Discuss-部分" class="headerlink" title="配置仓库 Discuss 部分"></a>配置仓库 Discuss 部分</h3><p>首先打开仓库的 setting，将 Discussions 部分打上对号，然后建立一个 Announcements 的分类</p><h3 id="进入-Giscus-配置"><a href="#进入-Giscus-配置" class="headerlink" title="进入 Giscus 配置"></a>进入 Giscus 配置</h3><p>链接在这：**<a href="https://link.zhihu.com/?target=https://giscus.app/zh-CN">giscus</a>**</p><p>配置完仓库和 discussion 分类后，可以在启动 giscus 下边复制几个东西</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">repo:</span><br><span class="line">repo_id:</span><br><span class="line">category_id:</span><br></pre></td></tr></table></figure><p>还可根据自己的需要在 option 中添加对应的选项，按照 yaml 格式填入</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">data-strict:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">data-lang:</span> <span class="string">zh-CN</span></span><br><span class="line"><span class="attr">data-input-position:</span> <span class="string">top</span></span><br><span class="line"><span class="attr">data-loading:</span> <span class="string">lazy</span></span><br></pre></td></tr></table></figure><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>在 Hexo 中，评论功能默认在所有页面都开启，如果部分页面我们不需要评论功能，例如分类、标记页面。我们可以在在站点根目录下 <code>/source/页面名称/index.md</code> 中通过 <code>comments</code> 属性设置 <code>true</code> 或 <code>false</code> 控制该页面或者是文章的评论功能是否打开</p><h1 id="收录谷歌、百度"><a href="#收录谷歌、百度" class="headerlink" title="收录谷歌、百度"></a>收录谷歌、百度</h1><p>1、 查看收录情况：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">地址栏输入：site:xingjiahui.top</span><br></pre></td></tr></table></figure><p>2、验证、提交网站：<a href="https://www.ancii.com/avcwpl4d6/">JingLisen</a></p><h1 id="PWA"><a href="#PWA" class="headerlink" title="PWA"></a>PWA</h1><p><a href="https://www.xiaowu95.wang/posts/80027c66/">记录hexo整合pwa的使用 | 小五的个人杂货铺 (xiaowu95.wang)</a><br><a href="https://butterfly.js.org/posts/ceeb73f/#PWA">Butterfly 安裝文檔(四) 主題配置-2 | Butterfly</a></p><h1 id="解决-cdn-jsdelivr-net-国内无法加载"><a href="#解决-cdn-jsdelivr-net-国内无法加载" class="headerlink" title="解决 cdn.jsdelivr.net 国内无法加载"></a>解决 cdn.jsdelivr.net 国内无法加载</h1><p>使用 <code>cdn.jsdelivr.net</code> 未受污染的子域：</p><ul><li><code>fastly.jsdelivr.net</code>，由 Fastly 提供 本站使用</li><li><code>gcore.jsdelivr.net</code>，由 G-Core 提供</li><li><code>testingcf.jsdelivr.net</code>，由 CloudFlare 提供<br>将博客主题的文件中 jsDelivr 链接里的 <code>cdn</code> 替换为子域名即可</li></ul><blockquote><p>比如 butterfly 主题中将 <code>themes\butterfly\layout\includes\head\preconnect.pug</code> 和 <code>themes\butterfly\scripts\events\cdn.js</code> 中的 <code>cdn.jsdelivr.net</code> 替换为 <code>fastly.jsdelivr.net</code></p></blockquote><h2 id="查看网页加载的大小和时间"><a href="#查看网页加载的大小和时间" class="headerlink" title="查看网页加载的大小和时间"></a>查看网页加载的大小和时间</h2><ol><li><p>右键点击网页，选择 “ 检查 “，(直接按 ctrl+shift+I 也可以）。</p></li><li><p>出来的界面上，点击 “Network”，按 Ctrl+R，就可以看到每个资源的大小和加载时间</p></li><li><p>进一步分析：点击特定请求，可以查看更详细的信息，如请求头、响应头、传输大小等。通过分析这些信息，你可以确定加载时间较长的资源，并找出导致问题的原因。</p></li></ol><h1 id="部署博客并使用自定义域名"><a href="#部署博客并使用自定义域名" class="headerlink" title="部署博客并使用自定义域名"></a>部署博客并使用自定义域名</h1><p>我将博客分别部署在了 github page 和 zeabur 上<br><a href="https://zeabur.com/docs/zh-CN/get-started">快速开始 - Zeabur</a><br>也可尝试其他的方式</p><h2 id="在-CloudFlare-workers-部署"><a href="#在-CloudFlare-workers-部署" class="headerlink" title="在 CloudFlare workers 部署"></a>在 CloudFlare workers 部署</h2><p><a href="https://sleele.com/2021/01/01/cloudflare-workers-site-deploy/#%E9%83%A8%E7%BD%B2%E9%9D%99%E6%80%81%E7%BD%91%E7%AB%99%E8%87%B3Cloudflare_Workers_Site">将静态网站部署到Cloudflare Workers Site | sleele的博客</a></p><h3 id="安装-Wrangler"><a href="#安装-Wrangler" class="headerlink" title="安装 Wrangler"></a>安装 Wrangler</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install @cloudflare/wrangler -g</span><br></pre></td></tr></table></figure><h3 id="在-hexo-项目下初始化-wrangler"><a href="#在-hexo-项目下初始化-wrangler" class="headerlink" title="在 hexo 项目下初始化 wrangler"></a>在 hexo 项目下初始化 wrangler</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wrangler init --site my-static-site # 其中 my-static-site 是目录名称</span><br></pre></td></tr></table></figure><p>初始化 wrangler 后，修改 wrangler 配置文件 <code>wrangler.toml</code>，填写 bucket &#x3D; “.&#x2F;public”，<code>bucket</code> 是存放生成好的网站静态文件的目录，对于 Hexo 而言默认是 <code>./public</code> 目录下。如果你想部署别的静态网页，都可以将文件地址放入 <code>./public</code> 文件内</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name</span> = <span class="string">&quot;worker-hexo&quot;</span></span><br><span class="line"><span class="attr">type</span> = <span class="string">&quot;webpack&quot;</span></span><br><span class="line"><span class="attr">route</span> = <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="attr">zone_id</span> = <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="attr">usage_model</span> = <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="attr">compatibility_flags</span> = []</span><br><span class="line"><span class="attr">workers_dev</span> = <span class="literal">true</span></span><br><span class="line"><span class="attr">site</span> = &#123;bucket = <span class="string">&quot;./public&quot;</span>,entry-point = <span class="string">&quot;workers-site&quot;</span>&#125;</span><br><span class="line"><span class="attr">compatibility_date</span> = <span class="string">&quot;2023-11-29&quot;</span></span><br></pre></td></tr></table></figure><h3 id="创建-Cloudflare-API-Token"><a href="#创建-Cloudflare-API-Token" class="headerlink" title="创建 Cloudflare API Token"></a>创建 Cloudflare API Token</h3><p>新建一个 API Token，选择「Edit Cloudflare Workers」模板。并将不需要的两个权限——「Account Settings」和「User’s Details」删去。</p><p><a href="https://dash.cloudflare.com/profile/api-tokens">https://dash.cloudflare.com/profile/api-tokens</a><br>将生成的 API Token 保存好，这串字符之后不会再出现。</p><h3 id="使用-API-Token-登录-Cloudflare-API-Token"><a href="#使用-API-Token-登录-Cloudflare-API-Token" class="headerlink" title="使用 API Token 登录 Cloudflare API Token"></a>使用 API Token 登录 Cloudflare API Token</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wrangler config</span><br><span class="line"># 复制刚刚的Token，回车登录</span><br></pre></td></tr></table></figure><h3 id="部署静态网站至-Cloudflare-Workers-Site"><a href="#部署静态网站至-Cloudflare-Workers-Site" class="headerlink" title="部署静态网站至 Cloudflare Workers Site"></a>部署静态网站至 Cloudflare Workers Site</h3><p>如果前期的所有步骤都没有问题，就可以将 hexo 部署到 Cloudflare Workers Site 上了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 上传并发布 </span><br><span class="line">wrangler publish</span><br></pre></td></tr></table></figure><p>注意，免费版本的 Workers Plan 有每天 100,000 次的访问限制（100,000 requests per day ），免费额度适合小站部署（流量大容易翻车）</p><h3 id="自定义域名"><a href="#自定义域名" class="headerlink" title="自定义域名"></a>自定义域名</h3><p>可在对应的 workers 界面绑定域名</p><h2 id="其他方式"><a href="#其他方式" class="headerlink" title="其他方式"></a>其他方式</h2><ul><li><a href="https://blog.csdn.net/kuizuo12/article/details/124716488">Vercel部署个人博客_愧怍12的博客-CSDN博客</a> 但 vercel 似乎无法正确解析带有 + 的 url,且 Vercel 的 CNAME 值有 CAA 记录，这个 CAA 记录限制了证书颁发机构</li><li><a href="https://zhuanlan.zhihu.com/p/55252024">手把手教你使用Netlify部署博客及部署自动化 - 知乎 (zhihu.com)</a><br>然后在域名提供商那里添加 CNAME 记录如下<br><img src="/../../../../img/blog/butterfly%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE-1.png"><br>可用该网站来检测速度 <a href="https://boce.aliyun.com/detect/ping">阿里云网站运维检测平台 (aliyun.com)</a><br>如果该域名本身没有 SSL 证书，但是你将其 CNAME 记录跳转到另一个有 SSL 证书且已经部署的域名，是可以实现 HTTPS 访问的。</li></ul><h1 id="SEO"><a href="#SEO" class="headerlink" title="SEO"></a>SEO</h1><p>百度主动提交链接</p><p>1、首先，在 Hexo 根目录下，安装本插件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-baidu-url-submit --save</span><br></pre></td></tr></table></figure><p>2、然后在根目录下，把以下内容配置到 _config.yml 文件中:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> </span><br><span class="line">    <span class="attr">gitee:</span> <span class="string">https://gitee.com/youthlql/youthlql.git</span></span><br><span class="line">    <span class="attr">github:</span> <span class="string">https://github.com/youthlql/youthlql.github.io.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> <span class="attr">type:</span> <span class="string">baidu_url_submitter</span></span><br><span class="line"><span class="comment"># 百度主动推送</span></span><br><span class="line"><span class="attr">baidu_url_submit:</span></span><br><span class="line">  <span class="attr">count:</span> <span class="number">100</span> <span class="comment">## 提交最新的一个链接</span></span><br><span class="line">  <span class="attr">host:</span>  <span class="comment">## 在百度站长平台中注册的域名</span></span><br><span class="line">  <span class="attr">token:</span>  <span class="comment">## 请注意这是您的秘钥， 所以请不要把博客源代码发布在公众仓库里!</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">baidu_urls.txt</span> <span class="comment">## 文本文档的地址， 新链接会保存在此文本文档里</span></span><br></pre></td></tr></table></figure><p>我把 deploy 配置也贴出来是因为有两个 type，注意用 - 区分</p><p>百度其它的 seo 到他的官网看文档就行</p><h1 id="查看网页-RSS"><a href="#查看网页-RSS" class="headerlink" title="查看网页 RSS"></a>查看网页 RSS</h1><p>本次修改基于 Butterfly 主题 3.0.0 ！</p><p>实现：增加社交图标 RSS，点击可查看网页 RSS。</p><p>1.下载插件 hexo-generator-feed</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-feed --save</span><br></pre></td></tr></table></figure><p>2.在 hexo 的主配置文件 _config.yml 中任意位置添加以下代码：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">feed:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">atom</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">atom.xml</span></span><br><span class="line">  <span class="attr">limit:</span> <span class="number">20</span></span><br><span class="line">  <span class="attr">hub:</span></span><br><span class="line">  <span class="attr">content:</span></span><br><span class="line">  <span class="attr">content_limit:</span> <span class="number">140</span></span><br><span class="line">  <span class="attr">content_limit_delim:</span> <span class="string">&#x27; &#x27;</span></span><br><span class="line">  <span class="attr">order_by:</span> <span class="string">-date</span></span><br><span class="line">  <span class="attr">icon:</span> <span class="string">icon.png</span></span><br><span class="line">  <span class="attr">autodiscovery:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">template:</span></span><br></pre></td></tr></table></figure><p>3.修改 butterfly 主题配置文件 _config.yml ，添加 RSS 的图标：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">social:</span></span><br><span class="line">  <span class="attr">fa fa-rss:</span> <span class="string">/atom.xml</span> <span class="string">||</span> <span class="string">RSS链接</span></span><br></pre></td></tr></table></figure><h1 id="社交信息设置"><a href="#社交信息设置" class="headerlink" title="社交信息设置"></a>社交信息设置</h1><p>在 <code>\source\_data</code> 中的 <code>butterfly.yml</code> 修改 <code>social</code>：</p><p>(可以选择使用 <code>fa fa-xxx</code> 图标，也可以选择使用 <code>阿里iconfont</code> 图标)</p><p>此处要注意：</p><p>​ 很多人不知道自己上方填的网址怎么找</p><p>​ <code>RSS</code> 上面有教程，<code>Giuhub</code>、<code>Github</code>、<code>CSDN</code>、<code>bilibili</code> 直接 <code>个人主页</code> 网址就可以</p><p>​ <code>QQ</code>：下方 xxxxxxx 填上对应的 <code>qq号码</code> 即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tencent://AddContact/?fromId=45&amp;fromSubId=1&amp;subcmd=all&amp;uin=xxxxxxx&amp;website=www.oicqzone.com</span><br></pre></td></tr></table></figure><h1 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h1><p>有时浏览器会缓存旧的链接或搜索结果，无法加载更新后的结果，可使用使用 Ctrl + F5 强制刷新页面，或清除缓存并刷新页面，如缓存图片和文件。</p>]]></content>
      
      
      <categories>
          
          <category> 应用 </category>
          
          <category> 配置 </category>
          
          <category> 博客配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> butterfly主题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo插件</title>
      <link href="/posts/%E5%BA%94%E7%94%A8/%E9%85%8D%E7%BD%AE/%E5%8D%9A%E5%AE%A2%E9%85%8D%E7%BD%AE/Hexo%E6%8F%92%E4%BB%B6.html"/>
      <url>/posts/%E5%BA%94%E7%94%A8/%E9%85%8D%E7%BD%AE/%E5%8D%9A%E5%AE%A2%E9%85%8D%E7%BD%AE/Hexo%E6%8F%92%E4%BB%B6.html</url>
      
        <content type="html"><![CDATA[<h1 id="Hexo-auto-category-自动生成-Categories"><a href="#Hexo-auto-category-自动生成-Categories" class="headerlink" title="Hexo-auto-category 自动生成 Categories"></a>Hexo-auto-category 自动生成 Categories</h1><p>最常用的文件管理策略，就是利用文件系统目录结构 (树形结构 directory-tree)。<br>同样，为了便于管理大量的日志文件，采用目录结构是一种简便可行的方案。<code>hexo-auto-category</code> 根据日志文件 (Markdown) 所在文件目录自动分类，即自动生成 <code>markdown</code> 的 front-matter 中的 <code>categories</code> 变量。</p><p><strong>示例</strong></p><p>对于博客 <code>source/_post/web/framework/hexo.md</code>，该插件会自动生成以下 <code>categories</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">categories:  </span><br><span class="line">  - web  </span><br><span class="line">  - framework  </span><br></pre></td></tr></table></figure><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-auto-category --save</span><br></pre></td></tr></table></figure><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>在站点根目录下的 <code>_config.yml</code> 添加：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">auto_category:  </span><br><span class="line"> enable: true  </span><br><span class="line"> depth:  </span><br></pre></td></tr></table></figure><h2 id="编译-amp-部署"><a href="#编译-amp-部署" class="headerlink" title="编译 &amp; 部署"></a>编译 &amp; 部署</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo d  </span><br></pre></td></tr></table></figure><h2 id="高级配置"><a href="#高级配置" class="headerlink" title="高级配置"></a>高级配置</h2><p>如果只想生成第一级目录分类，可以设置 <code>depth</code> 属性，比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">auto_category:  </span><br><span class="line"> enable: true  </span><br><span class="line"> depth: 1</span><br></pre></td></tr></table></figure><h2 id="利用-Git-钩子函数触发更新"><a href="#利用-Git-钩子函数触发更新" class="headerlink" title="利用 Git 钩子函数触发更新"></a>利用 Git 钩子函数触发更新</h2><p>这个插件只有执行 <code>hexo generate</code> 时才会去读取文件夹并更新所有文章的 Front-matter 分类信息，所以我们可以利用 <a href="https://link.zhihu.com/?target=https://git-scm.com/book/zh/v2/%25E8%2587%25AA%25E5%25AE%259A%25E4%25B9%2589-Git-Git-%25E9%2592%25A9%25E5%25AD%2590%23_git_hooks">Git的钩子函数</a>，在 commit (提交) 的时候先执行下 <code>hexo generate</code>，这样就能实现自动更新了。</p><p>在 <code>.git/hooks</code> 目录下新建一个 <code>pre-commit</code> 文件</p><p><img src="/../../../../img/blog/556caf664a0dcbfcadc114240db84416_MD5.webp"></p><p>可以先在该文件中写入 <code>echo hello world!</code>，然后在 git 终端下执行 <code>sh pre-commit</code> 或者 <code>./pre-commit</code> 测试钩子能不能正常执行，没问题后，将如下命令写到文件里：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">hexo generate &amp;&amp; git add .</span><br></pre></td></tr></table></figure><p> 之所以后面追加 <code>git add .</code>，是因为 generate (生成) 后，所有文章的 Front-matter 信息会更新，所以要将所有修改重新添加进来</p><h1 id="Hexo-neat-插件优化提升访问效率"><a href="#Hexo-neat-插件优化提升访问效率" class="headerlink" title="Hexo-neat 插件优化提升访问效率"></a>Hexo-neat 插件优化提升访问效率</h1><p><a href="https://cloud.tencent.com/developer/article/1946999">Hexo-neat插件优化提升访问效率-腾讯云开发者社区-腾讯云 (tencent.com)</a></p><h2 id="1、安装-Hexo-neat"><a href="#1、安装-Hexo-neat" class="headerlink" title="1、安装 Hexo-neat"></a>1、安装 Hexo-neat</h2><p>在站点根目录下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-neat --save</span><br></pre></td></tr></table></figure><h2 id="2、添加相关配置"><a href="#2、添加相关配置" class="headerlink" title="2、添加相关配置"></a>2、添加相关配置</h2><p>在站点配置文件 <code>_config.yml</code> 添加相关配置，直接添加到站点配置文件 <code>_config.yml</code> 的末尾就可以。可以安装自己的需求去自定义配置，不过有些注意事项</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># hexo-neat</span></span><br><span class="line"><span class="comment"># 博文压缩</span></span><br><span class="line"><span class="attr">neat_enable:</span> <span class="literal">true</span></span><br><span class="line"><span class="comment"># 压缩html（ejs，swig等也属于html格式片段）</span></span><br><span class="line"><span class="attr">neat_html:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">exclude:</span></span><br><span class="line"><span class="comment"># 压缩css  </span></span><br><span class="line"><span class="attr">neat_css:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">exclude:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;**/*.min.css&#x27;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;**/live2d-widget/waifu.css&#x27;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;jquery.fancybox.min.css&#x27;</span></span><br><span class="line"><span class="comment"># 压缩js</span></span><br><span class="line"><span class="attr">neat_js:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">mangle:</span> <span class="literal">true</span> <span class="comment">#打印日志</span></span><br><span class="line">  <span class="attr">output:</span></span><br><span class="line">  <span class="attr">compress:</span></span><br><span class="line">  <span class="attr">exclude:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;**/*.min.js&#x27;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;jquery.fancybox.min.js&#x27;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;**/index.js&#x27;</span>  </span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;**/live2d-widget/*.js&#x27;</span> </span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;**/live2d-widget/*.min.js&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="3、hexo-neat-插件注意事项"><a href="#3、hexo-neat-插件注意事项" class="headerlink" title="3、hexo-neat 插件注意事项"></a>3、hexo-neat 插件注意事项</h2><p>在使用 hexo-neat 插件时，可以在命令窗口中看到各个文件的压缩率，于是可以通过跳过一些文件让效率更高。<br><strong>1. 跳过压缩文件的正确配置方式</strong><br>如果按照官方插件的文档说明来配置 exclude，会发现完全不起作用。这是因为配置的文件路径不对，压缩时找不到你配置的文件，自然也就无法跳过了。于是需要给这些文件指定正确的路径，万能的配置方式如下：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">neat_css:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">exclude:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;**/*.min.css&#x27;</span></span><br></pre></td></tr></table></figure><ul><li>已经压缩过的 css 和 js 不用压缩：剔除 exclude（<code>*.min.css</code> 和 <code>* .min.js</code>）</li><li>特殊名字 xx.xx.min.js 的需要单独列出来（这里引用了 fancybox 图片弹窗效果，从压缩名单里单独剔除）</li><li>深目录的，需要单独列出来：（这里我引用了 live2d 看板娘的动画） 单用 <code>_*/_.min.js</code> 深目录跳过已压缩文件不行，这部分只好全部跳过压缩了</li></ul><p><strong>2.压缩 html 时不要跳过 <code>.md</code> 文件和 <code>.swig</code> 文件</strong><br><code>.md</code> 文件就是 markdown 文件，如果跳过压缩 <code>.md</code> 文件，而又刚好在文章中使用到了 tab 标签，那么当 hexo 在生成静态页面时就会发生解析错误。这会导致使用到了 tab 标签的页面生成失败而无法访问。</p><p><code>.swig</code> 文件是模板引擎文件，也就是 hexo 可以通过这些文件来生成对应的页面。如果跳过这些文件，所有页面完全没有起到压缩的效果，页面源代码里依然存在着一大堆空白。<br><strong>3.注意 md 中不要带特殊标签&lt;&gt;的颜表情&lt;(￣ˇ￣)&#x2F;、&lt;(ˉ^ˉ)&gt;等，因为压缩转换为 html 后会变成<br>&lt; (￣ˇ￣)&#x2F;，转义失败！！！</strong></p>]]></content>
      
      
      <categories>
          
          <category> 应用 </category>
          
          <category> 配置 </category>
          
          <category> 博客配置 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C++课程设计</title>
      <link href="/posts/%E5%AD%A6%E4%B9%A0/%E5%AD%A6%E6%A0%A1%E8%AF%BE%E7%A8%8B/C++%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1.html"/>
      <url>/posts/%E5%AD%A6%E4%B9%A0/%E5%AD%A6%E6%A0%A1%E8%AF%BE%E7%A8%8B/C++%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1.html</url>
      
        <content type="html"><![CDATA[<h1 id="程序设计课程设计报告—学生信息管理系统"><a href="#程序设计课程设计报告—学生信息管理系统" class="headerlink" title="程序设计课程设计报告—学生信息管理系统"></a>程序设计课程设计报告—学生信息管理系统</h1><h1 id="目-录"><a href="#目-录" class="headerlink" title="目 录"></a>目 录</h1><ol><li><p>需求分析</p></li><li><p>架构设计</p></li><li><p>模块设计</p></li><li><p>类和函数的说明</p></li><li><p>比较有特色的算法</p></li><li><p>存在的不足及对策</p></li><li><p>使用说明</p></li><li><p>程序源代码</p></li></ol><h1 id="一、需求分析"><a href="#一、需求分析" class="headerlink" title="一、需求分析"></a>一、需求分析</h1><p>      学生信息管理系统，能够实现计算机化的学生信息管理，能够提供实现基本的学生信息管理功能，方便管理员进行学生信息管理。</p><p>      本项目面向学生管理员，管理员需使用账号密码登录，其拥有学生基本信息管理和学生成绩管理两大功能。</p><h2 id="二、架构设计"><a href="#二、架构设计" class="headerlink" title="二、架构设计"></a>二、架构设计</h2><h3 id="（一）管理员登录主系统"><a href="#（一）管理员登录主系统" class="headerlink" title="（一）管理员登录主系统"></a>（一）管理员登录主系统</h3><p>       管理员可以登陆账号以管理学生信息，每个账号中都保存着相应的数据，管理员可以操控管理这些数据，可以修改自己的密码，退出登录或退出程序时自动将内存中的数据清空。</p><p><img src="/../../../img/blog/965da85c7dfebc6e8becc6a9d9b9873b_MD5.png" alt="image_48Mse1CdsA.png"></p><h3 id="（二）学生基本信息管理系统"><a href="#（二）学生基本信息管理系统" class="headerlink" title="（二）学生基本信息管理系统"></a>（二）学生基本信息管理系统</h3><p>①<strong>添加</strong>：管理员将信息依次录入。</p><p>②<strong>删除</strong>：按学号对一个学生的信息进行删除，还可以选择一键删除。</p><p>③<strong>修改</strong>：按学号修改相应的信息。</p><p>④<strong>查询</strong>：根据你键入的学生姓名或学号，显示其详细信息。</p><p>⑤<strong>浏览</strong>：管理员可以浏览当前所存储的全部学生信息。</p><p>⑥<strong>保存</strong>：管理员退出程序前或者退出登陆前，将数据自动储存到本地文件。</p><p><img src="/../../../img/blog/1ceeca2ae4ce2a5e57ff8ab541d15538_MD5.png" alt="image_LH3SQ4mlAi.png"></p><h3 id="（三）学生成绩管理系统"><a href="#（三）学生成绩管理系统" class="headerlink" title="（三）学生成绩管理系统"></a>（三）学生成绩管理系统</h3><p>①<strong>添加</strong>：管理员将信息依次录入。</p><p>②<strong>删除</strong>：按学号对一个学生的信息进行删除，还可以选择一键删除。</p><p>③<strong>修改</strong>：按学号选择修改相应的信息。</p><p>④<strong>查询</strong>：根据你键入的学生姓名或学号，显示其详细信息。</p><p>⑤<strong>浏览</strong>：</p><p>A) <strong>浏览总平均成绩</strong>：管理员可以看到以总平均成绩从高到低的学生所有成绩信息。</p><p>B) <strong>浏览单科成绩</strong>：管理员可以选择具体的单科，并且可以看到以该单科成绩从高到低的学生单科成绩信息。</p><p>C) <strong>浏览成绩报告分析</strong>：管理员可以看到各科以及总平均成绩中 60 分以下和 90 分以上人数占比和信息，还有 60 分以上人数占比。</p><p>⑥<strong>保存</strong>：管理员退出程序前或者退出登陆前，将数据自动储存到本地文件。</p><p><img src="/../../../img/blog/86124ef8a28606c2189cedeaf8b7647c_MD5.png" alt="image_PLsdkWmHyq.png"></p><h2 id="三、模块设计"><a href="#三、模块设计" class="headerlink" title="三、模块设计"></a>三、模块设计</h2><h3 id="1-添加模块"><a href="#1-添加模块" class="headerlink" title="1.添加模块"></a>1.添加模块</h3><p>学生基本信息管理系统：管理员按照学号、姓名、联系方式以及宿舍号的顺序依次录入，插入到 AVL 树中。</p><p>学生成绩管理系统：管理员按照学号、姓名、高数成绩、大学英语成绩以及 C++ 成绩的顺序依次录入，插入到多重链表中。</p><h3 id="2-删除模块"><a href="#2-删除模块" class="headerlink" title="2.删除模块"></a>2.删除模块</h3><p>管理员输入要删除学生的学号，然后调用删除函数，删除该名学生的信息，或者一键删除，清空 AVL 树或多重链表中的数据。</p><h3 id="3-修改模块"><a href="#3-修改模块" class="headerlink" title="3.修改模块"></a>3.修改模块</h3><p>管理员输入要修改学生的学号，然后管理员可以选择修改相应的信息。</p><h3 id="4-查询模块"><a href="#4-查询模块" class="headerlink" title="4.查询模块"></a>4.查询模块</h3><p>首先由管理员输入要查找的学生姓名或学号，然后系统用查找函数查找，然后系统就调用输出函数，输出所查找的学生信息。</p><h3 id="5-浏览模块"><a href="#5-浏览模块" class="headerlink" title="5.浏览模块"></a>5.浏览模块</h3><p>学生基本信息管理系统：显示当前所存储的全部学生基本信息。</p><p>学生成绩管理系统：管理员可以选择浏览以总成绩排名顺序分布的内容；可以浏览以单科成绩排名顺序分布的内容；亦可以浏览总体成绩报告分析。对于每一种需求，系统显示相应的数据。</p><h3 id="6-保存模块"><a href="#6-保存模块" class="headerlink" title="6.保存模块"></a>6.保存模块</h3><p>学生基本信息管理系统：将 AVL 树中的数据储存到 “ 用户名 “+”_ IF.txt” 中。</p><p>学生成绩管理系统：将多重链表中的数据储存到 “ 用户名 “+”_GD.txt” 中。</p><h3 id="7-管理员模块"><a href="#7-管理员模块" class="headerlink" title="7.管理员模块"></a>7.管理员模块</h3><p>管理员键入帐号密码，系统会从本地文件检索账号密码，如果管理员选择创建账号，那么系统会将账号密码保存至本地文件中，以便下次登陆时检索，并且系统会以管理员账号名创建额外两个文件，分别用以存储学生基本信息和学生成绩信息。</p><p>登陆成功后，系统从本地文件中获取数据，管理员可以对这些数据进行操作，在管理员退出时，系统将数据存入相应的文件之中，并且遍历 AVL 树和链表，清空数据。</p><p>管理员修改密码时，系统查阅本地文件，并修改数据。</p><h2 id="四、类和函数的说明"><a href="#四、类和函数的说明" class="headerlink" title="四、类和函数的说明"></a>四、类和函数的说明</h2><h3 id="1-menu1-的声明"><a href="#1-menu1-的声明" class="headerlink" title="1.menu1 的声明"></a>1.menu1 的声明</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">menu1</span> &#123;</span></span><br><span class="line">private:</span><br><span class="line">  <span class="built_in">string</span> sn;  <span class="comment">//学号 student number</span></span><br><span class="line">  <span class="built_in">string</span> name;  <span class="comment">//姓名</span></span><br><span class="line">  <span class="built_in">string</span> chat; <span class="comment">//联系方式</span></span><br><span class="line">  <span class="built_in">string</span> dor; <span class="comment">//宿舍号</span></span><br><span class="line">  <span class="type">int</span> height;     <span class="comment">//平衡树的高度</span></span><br><span class="line">  menu1* left;</span><br><span class="line">  menu1* right;</span><br><span class="line">public:</span><br><span class="line">  menu1(<span class="built_in">string</span> a, <span class="built_in">string</span> b, <span class="built_in">string</span> c, <span class="built_in">string</span> d, <span class="type">int</span> h=<span class="number">0</span>, menu1* L=nullptr,menu1* r=nullptr):</span><br><span class="line">    sn(a),name(b),chat(c),dor(d),height(h),left(L),right(r) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> <span class="title function_">high</span><span class="params">( menu1* p)</span>;<span class="comment">//返回高度</span></span><br><span class="line"></span><br><span class="line">  menu1* <span class="title function_">singleft</span><span class="params">( menu1* k2)</span>;<span class="comment">//左单旋</span></span><br><span class="line"></span><br><span class="line">  menu1* <span class="title function_">singright</span><span class="params">( menu1* k2)</span>;<span class="comment">//右单旋</span></span><br><span class="line"></span><br><span class="line">  menu1* <span class="title function_">doubleleft</span><span class="params">( menu1* k3)</span>;<span class="comment">//LR</span></span><br><span class="line"></span><br><span class="line">  menu1* <span class="title function_">doubleright</span><span class="params">( menu1* k3)</span>;<span class="comment">//RL</span></span><br><span class="line"></span><br><span class="line">  <span class="type">void</span> <span class="title function_">Record_1</span><span class="params">( menu1 *&amp; ph, <span class="built_in">string</span>&amp; a, <span class="built_in">string</span>&amp; b, <span class="built_in">string</span>&amp; c, <span class="built_in">string</span>&amp; d)</span>;<span class="comment">//记录系统一的用户数据，存储到文件中</span></span><br><span class="line"></span><br><span class="line">  <span class="type">void</span> <span class="title function_">Seeit_1</span><span class="params">( menu1 *&amp; head)</span>;<span class="comment">//查看所有数据函数</span></span><br><span class="line"></span><br><span class="line">  menu1* <span class="title function_">Read1</span><span class="params">( menu1 *&amp; head)</span>;   <span class="comment">//从文件中读取数据</span></span><br><span class="line"></span><br><span class="line">  menu1* <span class="title function_">Delete_1</span><span class="params">( menu1* p, <span class="built_in">string</span>&amp; x)</span>;<span class="comment">//删除实现</span></span><br><span class="line"></span><br><span class="line">  menu1* <span class="title function_">Find_1</span><span class="params">( menu1 *&amp; head, <span class="type">int</span> sp)</span>;<span class="comment">//查询函数</span></span><br><span class="line"></span><br><span class="line">  <span class="type">void</span> <span class="title function_">Change_1</span><span class="params">( menu1 *&amp; head)</span>;<span class="comment">//修改数据</span></span><br><span class="line"></span><br><span class="line">  <span class="type">void</span> <span class="title function_">EnterDelete_1</span><span class="params">( menu1 *&amp; head)</span>;<span class="comment">//进入删除，一个接口</span></span><br><span class="line"></span><br><span class="line">  <span class="type">void</span> <span class="title function_">FreeAll_1</span><span class="params">(<span class="type">void</span>)</span>;<span class="comment">//释放内存函数</span></span><br><span class="line"></span><br><span class="line">  <span class="type">void</span> <span class="title function_">Store1</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="2-menu2-的声明"><a href="#2-menu2-的声明" class="headerlink" title="2.menu2 的声明"></a>2.menu2 的声明</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">menu2</span>&#123;</span>  </span><br><span class="line">private:</span><br><span class="line">    <span class="built_in">string</span> sn2;    <span class="comment">//学号</span></span><br><span class="line">    <span class="built_in">string</span> name2;    <span class="comment">//姓名</span></span><br><span class="line">    <span class="type">static</span> <span class="built_in">string</span> g[<span class="number">4</span>];</span><br><span class="line">    <span class="type">float</span> grade[<span class="number">4</span>];       <span class="comment">//总成绩的平均数,高数,英语,C++</span></span><br><span class="line">    menu2* Next; <span class="comment">//链表下一节点</span></span><br><span class="line">    menu2* Previous; <span class="comment">//上一节点</span></span><br><span class="line">public:</span><br><span class="line">    <span class="type">void</span> <span class="title function_">FreeAll_2</span><span class="params">(<span class="type">void</span>)</span>;    <span class="comment">//释放内存，退出时用到</span></span><br><span class="line"></span><br><span class="line">    menu2* <span class="title function_">Record_2</span><span class="params">(menu2*&amp; head, <span class="built_in">string</span>&amp; a, <span class="built_in">string</span>&amp; b, <span class="type">float</span> G[<span class="number">4</span>], <span class="type">int</span> change)</span>;<span class="comment">//写入文件</span></span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> <span class="title function_">Record_2_isnert</span><span class="params">(menu2 *&amp; head, menu2* p, menu2* pr, menu2* ph, <span class="type">float</span> x, <span class="type">float</span> gr, <span class="built_in">string</span>&amp; a)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> <span class="title function_">Seeit_2</span><span class="params">(menu2*&amp; head)</span>; <span class="comment">//查看信息</span></span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> <span class="title function_">SeeThesingle_2</span><span class="params">(menu2*&amp; head, <span class="type">int</span> choice)</span>;   <span class="comment">//查看单科成绩</span></span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> <span class="title function_">SeeThesingle_2_print</span><span class="params">(menu2 *&amp; head, <span class="built_in">string</span> g, <span class="type">int</span> index)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> <span class="title function_">Delete_2</span><span class="params">(menu2 *&amp; head, <span class="built_in">string</span>&amp; s)</span>;   <span class="comment">//删除</span></span><br><span class="line"></span><br><span class="line">    menu2* <span class="title function_">Find_2</span><span class="params">(menu2*&amp; head, <span class="type">int</span> change, <span class="built_in">string</span>&amp; c)</span>;  <span class="comment">//查找</span></span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> <span class="title function_">EnterSee2</span><span class="params">(menu2* headx[<span class="number">4</span>])</span>; <span class="comment">//查看接口函数</span></span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> <span class="title function_">Change_2</span><span class="params">(menu2 *&amp; head, <span class="type">int</span> choice, <span class="built_in">string</span>&amp; sn, <span class="built_in">string</span>&amp; s, <span class="type">float</span> grade)</span>;<span class="comment">//修改数据函数</span></span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> <span class="title function_">CordReport_2</span><span class="params">(menu2* headx[<span class="number">4</span>])</span>;  <span class="comment">//成绩分析报告</span></span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> <span class="title function_">CordReport_2_print</span><span class="params">(menu2* p, <span class="built_in">string</span>&amp; g, <span class="type">int</span> index)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> <span class="title function_">Store2</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="3-Users-的声明"><a href="#3-Users-的声明" class="headerlink" title="3.Users 的声明"></a>3.Users 的声明</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Users</span>&#123;</span>   </span><br><span class="line">private:</span><br><span class="line">     <span class="built_in">string</span> accounts, password;</span><br><span class="line">     Users* next;</span><br><span class="line">public:</span><br><span class="line">    <span class="type">int</span> <span class="title function_">Enter</span><span class="params">(Users* user)</span>;<span class="comment">//登陆函数</span></span><br><span class="line"></span><br><span class="line">    Users* <span class="title function_">Readuser</span><span class="params">(Users* user)</span>;<span class="comment">//读取账户信息函数</span></span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> <span class="title function_">ChangePass</span><span class="params">(Users* user)</span>;<span class="comment">//修改密码函数</span></span><br><span class="line"></span><br><span class="line">    Users* <span class="title function_">Register</span><span class="params">(Users* user)</span>;<span class="comment">//注册函数</span></span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> <span class="title function_">StoreUser</span><span class="params">(Users* user)</span>;<span class="comment">//存储用户账户函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="4-输入函数声明"><a href="#4-输入函数声明" class="headerlink" title="4.输入函数声明"></a>4.输入函数声明</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> <span class="title function_">inputlnt</span><span class="params">(<span class="type">void</span>)</span>; <span class="comment">//这个函数是我们输入数字的函数</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">inputString</span><span class="params">(<span class="built_in">string</span>&amp; buffer)</span>; <span class="comment">//这个函数就是输入字符串，同样我们可以检测是否溢出</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> <span class="title function_">enterspring</span><span class="params">(<span class="type">int</span> c)</span>; <span class="comment">//接口，c是选择，可以实现输入密码的时候以****形式输入</span></span><br></pre></td></tr></table></figure><h3 id="5-显示函数声明"><a href="#5-显示函数声明" class="headerlink" title="5.显示函数声明"></a>5.显示函数声明</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ShowMap0</span><span class="params">(<span class="type">void</span>)</span>; <span class="comment">//登录注册菜单</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ShowMap1</span><span class="params">(<span class="type">void</span>)</span>; <span class="comment">//主系统菜单</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ShowMap2</span><span class="params">(<span class="type">void</span>)</span>; <span class="comment">//系统一菜单</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ShowMap3</span><span class="params">(<span class="type">void</span>)</span>; <span class="comment">//系统二菜单</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ShowSeeit_1</span><span class="params">(<span class="type">void</span>)</span>; <span class="comment">//菜单一信息</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">heart</span><span class="params">()</span>; <span class="comment">//登录爱心显示</span></span><br></pre></td></tr></table></figure><h2 id="五、比较有特色的算法"><a href="#五、比较有特色的算法" class="headerlink" title="五、比较有特色的算法"></a>五、比较有特色的算法</h2><h3 id="1-管理员登录主系统"><a href="#1-管理员登录主系统" class="headerlink" title="1.管理员登录主系统"></a>1.管理员登录主系统</h3><p><img src="/../../../img/blog/6b8f96f22126e56233278cda474c2cb3_MD5.png" alt="image_2-oqxglqv3.png"></p><p>采用心形算法，输出心形，优化界面。</p><p>登录使用检索本地文件以核对账户密码完成登录，对于数据文件采用用户名加后缀的形式作为对应文件名。</p><h3 id="2-学生基本信息管理系统"><a href="#2-学生基本信息管理系统" class="headerlink" title="2.学生基本信息管理系统"></a>2.学生基本信息管理系统</h3><p>鉴于对学号的顺序排序，选择采用一颗 AVL 树以保存数据，能够相对的提高程序的性能。</p><p>使用 AVL 树的几个基本旋转以实现插入。</p><p>对于每一个删除操作，均需调整 AVL 树的平衡，由于删除操作开销较大，我们可以选取左右子树较高的树中的最右或最左树以替代要删除的数据，这样可以明显减少时间平均复杂度。</p><h3 id="3-学生成绩管理系统"><a href="#3-学生成绩管理系统" class="headerlink" title="3.学生成绩管理系统"></a>3.学生成绩管理系统</h3><p>鉴于需要对总成绩以及各科成绩查询，寻常的排序需要花费大量的时间，十分不值，并且代码极其冗长，因此我们采用多重链表对数据进行操作，使用多个表头对应每一种成绩。这样做的缺点是查找和插入效率可能不如 AVL 树，但对于多根节点 AVL 树而言，删除一个数据所需要付出的代价是昂贵的，所以我们选择链表实现。</p><h2 id="六、存在的不足及对策"><a href="#六、存在的不足及对策" class="headerlink" title="六、存在的不足及对策"></a>六、存在的不足及对策</h2><p>1.不足：不知道如何进行开发程序</p><p>对策：先建造一个原型，列出想要实现的功能，逐步细化调整，再将功能一个一个实现，最终整合在一起</p><p>2.不足：想要实现好的效果，却不知从何下手</p><p>对策：有些问题已被前人解决过，可以通过借鉴实现，有的问题需要学习其他知识或工具，如数据可以储存在数据库中，UI 界面的优化等，则当前阶段只需要做到自己能做到的最好就行。</p><h2 id="七、使用说明"><a href="#七、使用说明" class="headerlink" title="七、使用说明"></a>七、使用说明</h2><p>程序编译运行平台：Windows 和 Vs2022</p><p>打开文件夹 “x64”→打开文件夹 “Debug”→打开 exe 文件运行</p><p>原本无账户，则需先注册</p><p>输入字符串长度不得超过 18</p><p><img src="/../../../img/blog/e2b262fccb741b7dddded98736f6f74d_MD5.png" alt="QQ截图20220520194350_tmm2d3QPTu.png"></p><h2 id="八、程序源代码"><a href="#八、程序源代码" class="headerlink" title="八、程序源代码"></a>八、程序源代码</h2><h3 id="1-Core1-h"><a href="#1-Core1-h" class="headerlink" title="1.Core1.h"></a>1.Core1.h</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> CORE1_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CORE1_H</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">menu1</span> &#123;</span></span><br><span class="line">private:</span><br><span class="line">  <span class="built_in">string</span> sn;  <span class="comment">//学号 student number</span></span><br><span class="line">  <span class="built_in">string</span> name;  <span class="comment">//姓名</span></span><br><span class="line">  <span class="built_in">string</span> chat; <span class="comment">//联系方式</span></span><br><span class="line">  <span class="built_in">string</span> dor; <span class="comment">//宿舍号</span></span><br><span class="line">  <span class="type">int</span> height;     <span class="comment">//平衡树的高度</span></span><br><span class="line">  menu1* left;</span><br><span class="line">  menu1* right;</span><br><span class="line">public:</span><br><span class="line">  menu1(<span class="built_in">string</span> a, <span class="built_in">string</span> b, <span class="built_in">string</span> c, <span class="built_in">string</span> d, <span class="type">int</span> h=<span class="number">0</span>, menu1* L=nullptr,menu1* r=nullptr):</span><br><span class="line">    sn(a),name(b),chat(c),dor(d),height(h),left(L),right(r) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> <span class="title function_">high</span><span class="params">( menu1* p)</span>;<span class="comment">//返回高度</span></span><br><span class="line"></span><br><span class="line">  menu1* <span class="title function_">singleft</span><span class="params">( menu1* k2)</span>;<span class="comment">//左单旋</span></span><br><span class="line"></span><br><span class="line">  menu1* <span class="title function_">singright</span><span class="params">( menu1* k2)</span>;<span class="comment">//右单旋</span></span><br><span class="line"></span><br><span class="line">  menu1* <span class="title function_">doubleleft</span><span class="params">( menu1* k3)</span>;<span class="comment">//LR</span></span><br><span class="line"></span><br><span class="line">  menu1* <span class="title function_">doubleright</span><span class="params">( menu1* k3)</span>;<span class="comment">//RL</span></span><br><span class="line"></span><br><span class="line">  <span class="type">void</span> <span class="title function_">Record_1</span><span class="params">( menu1*&amp; ph, <span class="built_in">string</span>&amp; a, <span class="built_in">string</span>&amp; b, <span class="built_in">string</span>&amp; c, <span class="built_in">string</span>&amp; d)</span>;<span class="comment">//记录系统一的用户数据，存储到文件中</span></span><br><span class="line"></span><br><span class="line">  <span class="type">void</span> <span class="title function_">Seeit_1</span><span class="params">( menu1*&amp; head)</span>;<span class="comment">//查看所有数据函数</span></span><br><span class="line"></span><br><span class="line">  menu1* <span class="title function_">Read1</span><span class="params">( menu1*&amp; head)</span>;   <span class="comment">//从文件中读取数据</span></span><br><span class="line"></span><br><span class="line">  menu1* <span class="title function_">Delete_1</span><span class="params">( menu1* p, <span class="built_in">string</span>&amp; x)</span>;<span class="comment">//删除实现</span></span><br><span class="line"></span><br><span class="line">  menu1* <span class="title function_">Find_1</span><span class="params">( menu1*&amp; head, <span class="type">int</span> sp)</span>;<span class="comment">//查询函数</span></span><br><span class="line"></span><br><span class="line">  <span class="type">void</span> <span class="title function_">Change_1</span><span class="params">( menu1 *&amp; head)</span>;<span class="comment">//修改数据</span></span><br><span class="line"></span><br><span class="line">  <span class="type">void</span> <span class="title function_">EnterDelete_1</span><span class="params">( menu1 *&amp; head)</span>;<span class="comment">//进入删除，一个接口</span></span><br><span class="line"></span><br><span class="line">  <span class="type">void</span> <span class="title function_">FreeAll_1</span><span class="params">(<span class="type">void</span>)</span>;<span class="comment">//释放内存函数</span></span><br><span class="line"></span><br><span class="line">  <span class="type">void</span> <span class="title function_">Store1</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><h3 id="2-Core2-h"><a href="#2-Core2-h" class="headerlink" title="2.Core2.h"></a>2.Core2.h</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> CORE2_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CORE2_H</span></span><br><span class="line"><span class="comment">/*这个头文件里存储着与系统二相关的核心操作*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">menu2</span>&#123;</span>  </span><br><span class="line">private:</span><br><span class="line">    <span class="built_in">string</span> sn2;    <span class="comment">//学号</span></span><br><span class="line">    <span class="built_in">string</span> name2;    <span class="comment">//姓名</span></span><br><span class="line">    <span class="type">static</span> <span class="built_in">string</span> g[<span class="number">4</span>];</span><br><span class="line">    <span class="type">float</span> grade[<span class="number">4</span>];       <span class="comment">//总成绩的平均数,高数,英语,C++</span></span><br><span class="line">    menu2* Next; <span class="comment">//链表下一节点</span></span><br><span class="line">    menu2* Previous; <span class="comment">//上一节点</span></span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> <span class="title function_">FreeAll_2</span><span class="params">(<span class="type">void</span>)</span>;    <span class="comment">//释放内存，退出时用到</span></span><br><span class="line"></span><br><span class="line">    menu2* <span class="title function_">Record_2</span><span class="params">(menu2*&amp; head, <span class="built_in">string</span>&amp; a, <span class="built_in">string</span>&amp; b, <span class="type">float</span> G[<span class="number">4</span>], <span class="type">int</span> change)</span>;<span class="comment">//写入文件</span></span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> <span class="title function_">Record_2_isnert</span><span class="params">(menu2 *&amp; head, menu2* p, menu2* pr, menu2* ph, <span class="type">float</span> x, <span class="type">int</span> ch, <span class="built_in">string</span>&amp; a)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> <span class="title function_">Seeit_2</span><span class="params">(menu2 *&amp; head)</span>; <span class="comment">//查看信息</span></span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> <span class="title function_">SeeThesingle_2</span><span class="params">(menu2 *&amp; head, <span class="type">int</span> choice)</span>;   <span class="comment">//查看单科成绩</span></span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> <span class="title function_">SeeThesingle_2_print</span><span class="params">(menu2*&amp; head, <span class="built_in">string</span> g, <span class="type">int</span> index)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> <span class="title function_">Delete_2</span><span class="params">(menu2*&amp; head, <span class="built_in">string</span>&amp; s)</span>;   <span class="comment">//删除</span></span><br><span class="line"></span><br><span class="line">    menu2* <span class="title function_">Find_2</span><span class="params">(menu2 *&amp; head, <span class="type">int</span> change, <span class="built_in">string</span>&amp; c)</span>;  <span class="comment">//查找</span></span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> <span class="title function_">EnterSee2</span><span class="params">(menu2* headx[<span class="number">4</span>])</span>; <span class="comment">//查看接口函数</span></span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> <span class="title function_">Change_2</span><span class="params">(menu2*&amp; head, <span class="type">int</span> choice, <span class="built_in">string</span>&amp; sn, <span class="built_in">string</span>&amp; s, <span class="type">float</span> grade)</span>;<span class="comment">//修改数据函数</span></span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> <span class="title function_">CordReport_2</span><span class="params">(menu2* headx[<span class="number">4</span>])</span>;  <span class="comment">//成绩分析报告</span></span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> <span class="title function_">CordReport_2_print</span><span class="params">(menu2* p, <span class="built_in">string</span>&amp; g, <span class="type">int</span> index)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> <span class="title function_">Store2</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><h3 id="3-Everything-h"><a href="#3-Everything-h" class="headerlink" title="3.Everything.h"></a>3.Everything.h</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> EVERTTHING_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EVERTTHING_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;conio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ShowMap.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;FileO.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Core1.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Core2.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Input.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//全局变量，用以记录用户存放数据的文件名</span></span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">string</span> filebuffer1, filebuffer2;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><h3 id="4-FileO-h"><a href="#4-FileO-h" class="headerlink" title="4.FileO.h"></a>4.FileO.h</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> FILEO_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FILEO_H</span></span><br><span class="line"><span class="comment">/*这个头文件里保存着大部分与文件读写有关的函数*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*账号-密码类*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Users</span>&#123;</span>   </span><br><span class="line">private:</span><br><span class="line">     <span class="built_in">string</span> accounts, password;</span><br><span class="line">     Users* next;</span><br><span class="line">public:</span><br><span class="line">    <span class="type">int</span> <span class="title function_">Enter</span><span class="params">(Users* user)</span>;<span class="comment">//登陆函数</span></span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> <span class="title function_">Readuser</span><span class="params">(Users* user)</span>;<span class="comment">//读取账户信息函数</span></span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> <span class="title function_">ChangePass</span><span class="params">(Users* user)</span>;<span class="comment">//修改密码函数</span></span><br><span class="line"></span><br><span class="line">    Users* <span class="title function_">Register</span><span class="params">(Users* user)</span>;<span class="comment">//注册函数</span></span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> <span class="title function_">StoreUser</span><span class="params">(Users* user)</span>;<span class="comment">//存储用户账户函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// FILEO_H</span></span></span><br></pre></td></tr></table></figure><h3 id="5-Input-h"><a href="#5-Input-h" class="headerlink" title="5.Input.h"></a>5.Input.h</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> INPUT_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INPUT_H</span></span><br><span class="line"><span class="type">float</span> <span class="title function_">inputlnt</span><span class="params">(<span class="type">void</span>)</span>; <span class="comment">//这个函数是我们输入数字的函数</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">inputString</span><span class="params">(<span class="built_in">string</span>&amp; buffer)</span>; <span class="comment">//这个函数就是输入字符串，同样我们可以检测是否溢出</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> <span class="title function_">enterspring</span><span class="params">(<span class="type">int</span> c)</span>; <span class="comment">//接口，c是选择，可以实现输入密码的时候以****形式输入</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><h3 id="6-ShowMap-h"><a href="#6-ShowMap-h" class="headerlink" title="6.ShowMap.h"></a>6.ShowMap.h</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SHOWMAP_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SHOWMAP_H</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ShowMap0</span><span class="params">(<span class="type">void</span>)</span>; <span class="comment">//登录注册菜单</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ShowMap1</span><span class="params">(<span class="type">void</span>)</span>; <span class="comment">//主系统菜单</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ShowMap2</span><span class="params">(<span class="type">void</span>)</span>; <span class="comment">//系统1菜单</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ShowMap3</span><span class="params">(<span class="type">void</span>)</span>; <span class="comment">//系统二菜单</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ShowSeeit_1</span><span class="params">(<span class="type">void</span>)</span>; <span class="comment">//菜单一信息</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">heart</span><span class="params">()</span>; <span class="comment">//登录爱心显示</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// SHOWMAP_H</span></span></span><br></pre></td></tr></table></figure><h3 id="7-Core1-cpp"><a href="#7-Core1-cpp" class="headerlink" title="7.Core1.cpp"></a>7.Core1.cpp</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Everything.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*用以计算高度的函数*/</span></span><br><span class="line"> <span class="type">int</span> <span class="title function_">menu1::high</span><span class="params">(menu1* p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (p == nullptr)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> p-&gt;height;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/*LL型旋转 */</span></span><br><span class="line">  menu1* <span class="title function_">menu1::singleft</span><span class="params">( menu1* k2)</span>  <span class="comment">//左单旋  LL</span></span><br><span class="line"> &#123;</span><br><span class="line">     menu1* k1 = k2-&gt;left;</span><br><span class="line">     k2-&gt;left = k1-&gt;right;</span><br><span class="line">     k1-&gt;right = k2;</span><br><span class="line">     k1-&gt;height = max(high(k1-&gt;left), high(k1-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">     k2-&gt;height = max(high(k2-&gt;left), high(k2-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">     <span class="keyword">return</span> k1;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/*RR型旋转*/</span></span><br><span class="line">  menu1* <span class="title function_">menu1::singright</span><span class="params">( menu1* k2)</span>  <span class="comment">//右单旋 RR</span></span><br><span class="line"> &#123;</span><br><span class="line">     menu1* k1 = k2-&gt;right;</span><br><span class="line">     k2-&gt;right = k1-&gt;left;</span><br><span class="line">     k1-&gt;left = k2;</span><br><span class="line">     k1-&gt;height = max(high(k1-&gt;left), high(k1-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">     k2-&gt;height = max(high(k2-&gt;left), high(k2-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">     <span class="keyword">return</span> k1;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">  menu1* <span class="title function_">menu1::doubleleft</span><span class="params">( menu1* k3)</span>   <span class="comment">//左双旋 LR 核心操作 LRL(左孩子右单旋，本身左单旋)</span></span><br><span class="line"> &#123;</span><br><span class="line">     k3-&gt;left = singright(k3-&gt;left);</span><br><span class="line">     <span class="keyword">return</span> singleft(k3);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">  menu1* <span class="title function_">menu1::doubleright</span><span class="params">( menu1* k3)</span>  <span class="comment">//右双旋 RL 核心操作 RLR</span></span><br><span class="line"> &#123;</span><br><span class="line">     k3-&gt;right = singleft(k3-&gt;right);</span><br><span class="line">     <span class="keyword">return</span> singright(k3);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*用以记录系统一数据的函数，并未保存至文件中，采用递归实现(学号是有序的) */</span></span><br><span class="line"><span class="comment">/*主要的思想就是平衡树的插入操作 */</span></span><br><span class="line"><span class="comment">/*a,b,c,d即结构体中的信息，都是按顺序来的 */</span></span><br><span class="line">   <span class="type">void</span> <span class="title function_">menu1::Record_1</span><span class="params">( menu1 *&amp; ph, <span class="built_in">string</span>&amp; a, <span class="built_in">string</span>&amp; b, <span class="built_in">string</span>&amp; c, <span class="built_in">string</span>&amp; d)</span></span><br><span class="line">  &#123;</span><br><span class="line">      <span class="keyword">if</span> (ph == nullptr)</span><br><span class="line">      &#123;</span><br><span class="line">          ph = new menu1(a,b,c,d);</span><br><span class="line">          <span class="keyword">if</span> (ph == nullptr)</span><br><span class="line">          &#123;</span><br><span class="line">              MessageBox(nullptr, TEXT(<span class="string">&quot;程序异常崩溃&quot;</span>), TEXT(<span class="string">&quot;sorry!&quot;</span>), <span class="number">0</span>);</span><br><span class="line">              <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">          &#125;</span><br><span class="line">            </span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (a.compare(ph-&gt;sn) &lt; <span class="number">0</span>)</span><br><span class="line">      &#123;</span><br><span class="line">          Record_1(ph-&gt;left, a, b, c, d);</span><br><span class="line">          <span class="keyword">if</span> (high(ph-&gt;left) - high(ph-&gt;right) == <span class="number">2</span>)</span><br><span class="line">          &#123;</span><br><span class="line">              <span class="keyword">if</span> (a.compare(ph-&gt;left-&gt;sn) &lt; <span class="number">0</span>)</span><br><span class="line">                  ph = singleft(ph);</span><br><span class="line">              <span class="keyword">else</span></span><br><span class="line">                  ph = doubleleft(ph);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (a.compare(ph-&gt;sn) &gt; <span class="number">0</span>)</span><br><span class="line">      &#123;     </span><br><span class="line">          Record_1(ph-&gt;right, a, b, c, d);</span><br><span class="line">          <span class="keyword">if</span> (high(ph-&gt;right) - high(ph-&gt;left) == <span class="number">2</span>)</span><br><span class="line">          &#123;</span><br><span class="line">              <span class="keyword">if</span> (a.compare(ph-&gt;right-&gt;sn) &gt; <span class="number">0</span>)</span><br><span class="line">                  ph = singright(ph);</span><br><span class="line">              <span class="keyword">else</span></span><br><span class="line">                  ph = doubleright(ph);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (a.compare(ph-&gt;sn) == <span class="number">0</span>)<span class="comment">//检索学号重复</span></span><br><span class="line">      &#123;</span><br><span class="line">          <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;您输入的学号有重复!请您检查并重新操作 &quot;</span>;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      ph-&gt;height = max(high(ph-&gt;left), high(ph-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/*查看信息，中序遍历递归 */</span></span><br><span class="line">    <span class="type">void</span> <span class="title function_">menu1::Seeit_1</span><span class="params">( menu1 *&amp; head)</span></span><br><span class="line">   &#123;</span><br><span class="line">       menu1* p = head;</span><br><span class="line">       <span class="keyword">if</span> (p)</span><br><span class="line">       &#123;</span><br><span class="line">           Seeit_1(p-&gt;left);</span><br><span class="line">           <span class="built_in">printf</span>(<span class="string">&quot;\t\t     %-19s%-22s%-27s%-16s\n&quot;</span>, p-&gt;sn.c_str(), p-&gt;name.c_str(), p-&gt;chat.c_str(), p-&gt;dor.c_str());</span><br><span class="line">           Seeit_1(p-&gt;right);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*删除节点函数，递归实现*/</span></span><br><span class="line"><span class="comment">/*主要的思想为平衡树删除节点的操作*/</span></span><br><span class="line">     menu1* <span class="title function_">menu1::Delete_1</span><span class="params">( menu1* p, <span class="built_in">string</span>&amp; x)</span>&#123;</span><br><span class="line">        menu1* ph;</span><br><span class="line">        <span class="keyword">if</span> (!p)</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;该学生不存在!\n&quot;</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (x.compare(p-&gt;sn) &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            p-&gt;left = Delete_1(p-&gt;left, x);</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">abs</span>(high(p-&gt;left) - high(p-&gt;right)) == <span class="number">2</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (high(p-&gt;left-&gt;left) &gt; high(p-&gt;left-&gt;right))</span><br><span class="line">                    p = singleft(p);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    p = doubleleft(p);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (x.compare(p-&gt;sn) &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            p-&gt;right = Delete_1(p-&gt;right, x);</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">abs</span>(high(p-&gt;left) - high(p-&gt;right)) == <span class="number">2</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (high(p-&gt;right-&gt;left) &lt; high(p-&gt;right-&gt;right))</span><br><span class="line">                    p = singright(p);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    p = doubleright(p);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p-&gt;left &amp;&amp; p-&gt;right)<span class="comment">/*可以找到较高的子树中符合的节点替代，这样可以减少旋转的开销*/</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (high(p-&gt;left) &gt;= high(p-&gt;right))</span><br><span class="line">            &#123;</span><br><span class="line">                ph = p-&gt;left;</span><br><span class="line">                <span class="keyword">while</span> (ph-&gt;right)<span class="comment">//左子树中最大节点替代</span></span><br><span class="line">                    ph = ph-&gt;right;</span><br><span class="line">                p-&gt;sn = ph-&gt;sn;</span><br><span class="line">                p-&gt;name = ph-&gt;name;</span><br><span class="line">                p-&gt;dor = ph-&gt;dor;</span><br><span class="line">                p-&gt;chat = ph-&gt;chat;</span><br><span class="line">                p-&gt;left = Delete_1(p-&gt;left, ph-&gt;sn);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                ph = p-&gt;right;</span><br><span class="line">                <span class="keyword">while</span> (ph-&gt;left)<span class="comment">//右子树中最下节点替代</span></span><br><span class="line">                    ph = ph-&gt;left;</span><br><span class="line">                p-&gt;sn = ph-&gt;sn;</span><br><span class="line">                p-&gt;name = ph-&gt;name;</span><br><span class="line">                p-&gt;dor = ph-&gt;dor;</span><br><span class="line">                p-&gt;chat = ph-&gt;chat;</span><br><span class="line">                p-&gt;right = Delete_1(p-&gt;right, ph-&gt;sn);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            menu1* ph = p;</span><br><span class="line">            <span class="keyword">if</span> (p-&gt;left == nullptr)</span><br><span class="line">                p = p-&gt;right;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p-&gt;right == nullptr)</span><br><span class="line">                p = p-&gt;left;</span><br><span class="line">            delete ph;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">/*查询函数 */</span></span><br><span class="line">      menu1* <span class="title function_">menu1::Find_1</span><span class="params">( menu1*&amp; head, <span class="type">int</span> sp)</span><span class="comment">//sp用以表示选择，即以何种方式查询</span></span><br><span class="line">     &#123;</span><br><span class="line">         <span class="built_in">string</span> s;</span><br><span class="line">         menu1* p = head,*  <span class="built_in">queue</span>[<span class="number">1000</span>];</span><br><span class="line">         <span class="type">int</span> hea = <span class="number">0</span>, tail = <span class="number">0</span>;</span><br><span class="line">         <span class="built_in">queue</span>[tail++] = head;</span><br><span class="line">         <span class="keyword">if</span> (p == nullptr)</span><br><span class="line">         &#123;</span><br><span class="line">             <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;暂无数据\n&quot;</span>;</span><br><span class="line">             <span class="keyword">return</span> p;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">switch</span> (sp)</span><br><span class="line">         &#123;</span><br><span class="line">         <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">             <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;请输入该生的学号  &quot;</span>;</span><br><span class="line">             inputString(s);</span><br><span class="line">             system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">             <span class="keyword">while</span> (s.compare(p-&gt;sn) != <span class="number">0</span>)</span><br><span class="line">             &#123;</span><br><span class="line">                 <span class="keyword">if</span> (s.compare(p-&gt;sn) &lt; <span class="number">0</span>)</span><br><span class="line">                     p = p-&gt;left;</span><br><span class="line">                 <span class="keyword">else</span> <span class="keyword">if</span> (s.compare(p-&gt;sn) &gt; <span class="number">0</span>)</span><br><span class="line">                     p = p-&gt;right;</span><br><span class="line">                 <span class="keyword">if</span> (p == nullptr)</span><br><span class="line">                 &#123;</span><br><span class="line">                     <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;对不起，该生不存在\n&quot;</span>;</span><br><span class="line">                     <span class="keyword">return</span> p;</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;\t----------------------******************学生信息查看*********************--------------------\n&quot;</span>;</span><br><span class="line">             <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;\t-------------学号---------------姓名------------------联系方式-------------------宿舍号-----\n\n&quot;</span>;</span><br><span class="line">             <span class="built_in">printf</span>(<span class="string">&quot;\t\t     %-19s%-22s%-27s%-16s\n&quot;</span>, p-&gt;sn.c_str(), p-&gt;name.c_str(), p-&gt;chat.c_str(), p-&gt;dor.c_str());</span><br><span class="line">             <span class="keyword">return</span> p;</span><br><span class="line">         <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">             <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;请输入该生的姓名  &quot;</span>;</span><br><span class="line">             inputString(s);</span><br><span class="line">             system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">             <span class="keyword">while</span> (hea &lt; tail &amp;&amp; s.compare(<span class="built_in">queue</span>[hea]-&gt;name) != <span class="number">0</span>)</span><br><span class="line">             &#123;</span><br><span class="line">                 <span class="keyword">if</span> (<span class="built_in">queue</span>[hea]-&gt;left)</span><br><span class="line">                     <span class="built_in">queue</span>[tail++] = <span class="built_in">queue</span>[hea]-&gt;left;</span><br><span class="line">                 <span class="keyword">if</span> (<span class="built_in">queue</span>[hea]-&gt;right)</span><br><span class="line">                     <span class="built_in">queue</span>[tail++] = <span class="built_in">queue</span>[hea]-&gt;right;</span><br><span class="line">                 hea++;</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">if</span> (hea == tail)</span><br><span class="line">             &#123;</span><br><span class="line"></span><br><span class="line">                 <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;对不起，该生不存在\n&quot;</span>;</span><br><span class="line">                 <span class="keyword">return</span> nullptr;</span><br><span class="line"></span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">else</span> p = <span class="built_in">queue</span>[hea];</span><br><span class="line">             <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;\t----------------------******************学生信息查看******************** *--------------------\n&quot;</span>;</span><br><span class="line">             <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;\t-------------学号---------------姓名------------------联系方式-------------------宿舍号-----\n&quot;</span>;</span><br><span class="line">             <span class="built_in">printf</span>(<span class="string">&quot;\t\t     %-19s%-22s%-27s%-16s\n&quot;</span>, p-&gt;sn.c_str(), p-&gt;name.c_str(), p-&gt;chat.c_str(), p-&gt;dor.c_str());</span><br><span class="line">             <span class="keyword">return</span> p;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/*修改数据函数 */</span></span><br><span class="line">      <span class="type">void</span> <span class="title function_">menu1::Change_1</span><span class="params">(menu1 *&amp; head)</span></span><br><span class="line">      &#123;</span><br><span class="line">          <span class="built_in">string</span> sn1;</span><br><span class="line">          <span class="type">int</span> ck;</span><br><span class="line">          <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;您需要输入您想要修改的学生的学号\n&quot;</span>;</span><br><span class="line">          menu1* p = Find_1(head, <span class="number">4</span>);</span><br><span class="line">          <span class="keyword">if</span> (p == nullptr)</span><br><span class="line">          &#123;</span><br><span class="line">              system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">          &#123;</span><br><span class="line">              <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;您可以输入 1 以修改学号，输入 2 以修改姓名，输入 3 以修改联系方式，输入 4 以修改宿舍号，输入 0 以退出本次操作\n&quot;</span>;</span><br><span class="line">              <span class="built_in">cin</span> &gt;&gt; ck;</span><br><span class="line">              <span class="keyword">switch</span> (ck)</span><br><span class="line">              &#123;</span><br><span class="line">              <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                  <span class="keyword">return</span>;</span><br><span class="line">              <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                  <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;请输入新学号 &quot;</span>;</span><br><span class="line">                  inputString(p-&gt;sn);</span><br><span class="line">                  <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;操作成功，请继续操作\n&quot;</span>;</span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">              <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                  <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;请输入新姓名 &quot;</span>;</span><br><span class="line">                  inputString(p-&gt;name);</span><br><span class="line">                  <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;操作成功，请继续操作\n&quot;</span>;</span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">              <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                  <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;请输入新联系方式 &quot;</span>;</span><br><span class="line">                  inputString(p-&gt;chat);</span><br><span class="line">                  <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;操作成功，请继续操作\n&quot;</span>;</span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">              <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">                  <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;请输入新宿舍号 &quot;</span>;</span><br><span class="line">                  inputString(p-&gt;dor);</span><br><span class="line">                  <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;操作成功，请继续操作\n&quot;</span>;</span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">              <span class="keyword">default</span>:</span><br><span class="line">                  <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;输入的数字有误，请重新输入\n&quot;</span>;</span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/*删除函数的接口，进入删除菜单 */</span></span><br><span class="line">       <span class="type">void</span> <span class="title function_">menu1::EnterDelete_1</span><span class="params">( menu1 *&amp; head)</span></span><br><span class="line">      &#123;</span><br><span class="line">          <span class="type">int</span> c;</span><br><span class="line">          <span class="built_in">string</span> sn1;</span><br><span class="line">          <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">          &#123;</span><br><span class="line">              ShowSeeit_1();</span><br><span class="line">              Seeit_1(head);</span><br><span class="line">              <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;您可以输入 1 以删除，2 以全部删除，0 以返回菜单\n&quot;</span>;</span><br><span class="line">              <span class="built_in">cin</span> &gt;&gt; c;</span><br><span class="line">              <span class="keyword">switch</span> (c)</span><br><span class="line">              &#123;</span><br><span class="line">              <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                  <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;请输入您想要删除学生的学号 &quot;</span>;</span><br><span class="line">                  inputString(sn1);</span><br><span class="line">                  head = Delete_1(head, sn1);</span><br><span class="line">                  <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;本次操作结束，请输入任意键继续... &quot;</span>;</span><br><span class="line">                  <span class="built_in">cin</span>.ignore();</span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">              <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                  head-&gt;FreeAll_1();</span><br><span class="line">                  head = nullptr;</span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">              <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                  <span class="keyword">return</span>;</span><br><span class="line">              <span class="keyword">default</span>:</span><br><span class="line">                  <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;输入有误，请重新输入\n&quot;</span>;</span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/*Free */</span></span><br><span class="line">       <span class="type">void</span> <span class="title function_">menu1::FreeAll_1</span><span class="params">()</span></span><br><span class="line">       &#123;    </span><br><span class="line">           menu1* head = this;</span><br><span class="line">           <span class="keyword">if</span> (head &amp;&amp; head-&gt;left)</span><br><span class="line">               head-&gt;left-&gt;FreeAll_1();</span><br><span class="line">           <span class="keyword">if</span> (head)</span><br><span class="line">           &#123;</span><br><span class="line">               delete head;</span><br><span class="line">               head = nullptr;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (head &amp;&amp; head-&gt;right)</span><br><span class="line">               head-&gt;right-&gt;FreeAll_1();</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><h3 id="8-Core2-cpp"><a href="#8-Core2-cpp" class="headerlink" title="8.Core2.cpp"></a>8.Core2.cpp</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Everything.h&quot;</span></span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> flag;<span class="comment">//申明全局变量的使用</span></span><br><span class="line"><span class="built_in">string</span> menu2::g[<span class="number">4</span>] = &#123; <span class="string">&quot;平均&quot;</span>,<span class="string">&quot;高数&quot;</span>,<span class="string">&quot;英语&quot;</span>,<span class="string">&quot;C++&quot;</span> &#125;;</span><br><span class="line"><span class="comment">/*用于记录数据，ch用以表示选择，1个函数分别处理多个表头 */</span></span><br><span class="line"> menu2* <span class="title function_">menu2::Record_2</span><span class="params">( menu2*&amp; head, <span class="built_in">string</span>&amp; a, <span class="built_in">string</span>&amp; b, <span class="type">float</span> G[<span class="number">4</span>], <span class="type">int</span> ch)</span></span><br><span class="line">&#123;</span><br><span class="line">     menu2* p = head,*  pr=nullptr,*  ph=nullptr;<span class="comment">//双向链表</span></span><br><span class="line">     G[<span class="number">0</span>] = (G[<span class="number">1</span>] + G[<span class="number">2</span>] + G[<span class="number">3</span>]) / <span class="number">3.0</span>;</span><br><span class="line">    <span class="keyword">while</span> (p)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (a.compare(p-&gt;sn2) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            MessageBox(nullptr, TEXT(<span class="string">&quot;学号存在重复，请检查输入...&quot;</span>), TEXT(<span class="string">&quot;!&quot;</span>), <span class="number">0</span>);</span><br><span class="line">            flag = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        p = p-&gt;Next;</span><br><span class="line">    &#125;<span class="comment">//检索学号重复</span></span><br><span class="line">    p = head;</span><br><span class="line">    ph = new menu2;</span><br><span class="line">    <span class="keyword">if</span> (ph == nullptr)</span><br><span class="line">    &#123;</span><br><span class="line">        MessageBox(nullptr, TEXT(<span class="string">&quot;程序异常崩溃&quot;</span>), TEXT(<span class="string">&quot;Sorry!&quot;</span>), <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p == nullptr)</span><br><span class="line">    &#123;</span><br><span class="line">        head = ph;</span><br><span class="line">        ph-&gt;Previous = nullptr;</span><br><span class="line">        ph-&gt;Next = nullptr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> head-&gt;Record_2_isnert(head, p, pr, ph, G[ch], ch, a);</span><br><span class="line">    ph-&gt;sn2 = a;</span><br><span class="line">    ph-&gt;name2 = b;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        ph-&gt;grade[i] = G[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">menu2::Record_2_isnert</span><span class="params">(menu2*&amp; head, menu2* p, menu2* pr, menu2* ph, <span class="type">float</span> x, <span class="type">int</span> ch, <span class="built_in">string</span>&amp; a)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (x &gt; p-&gt;grade[ch] || (x == p-&gt;grade[ch] &amp;&amp; a.compare(p-&gt;sn2) &lt;= <span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        head = ph;</span><br><span class="line">        ph-&gt;Previous = nullptr;</span><br><span class="line">        ph-&gt;Next = p;</span><br><span class="line">        p-&gt;Previous = ph;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (p &amp;&amp; x &lt; p-&gt;grade[ch])</span><br><span class="line">        &#123;</span><br><span class="line">            pr = p;</span><br><span class="line">            p = p-&gt;Next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (p &amp;&amp; x == p-&gt;grade[ch] &amp;&amp; a.compare(p-&gt;sn2) &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            pr = p;</span><br><span class="line">            p = p-&gt;Next;</span><br><span class="line">        &#125;</span><br><span class="line">        ph-&gt;Previous = pr;</span><br><span class="line">        <span class="keyword">if</span> (p == nullptr)</span><br><span class="line">        &#123;</span><br><span class="line">            pr-&gt;Next = ph;</span><br><span class="line">            ph-&gt;Next = nullptr;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            ph-&gt;Next = p;</span><br><span class="line">            pr-&gt;Next = ph;</span><br><span class="line">            p-&gt;Previous = ph;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*查看所有数据函数 */</span></span><br><span class="line"> <span class="type">void</span> <span class="title function_">menu2::Seeit_2</span><span class="params">( menu2 *&amp; head)</span></span><br><span class="line">&#123;</span><br><span class="line">    system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">    menu2* p = head;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;\n\n\n\n\t----------------------******************学生成绩查看******************** *--------------------\n\n\n&quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;\t学号----------姓名----------高数成绩--------英语成绩--------C++程序设计成绩--------总成绩(平均成绩)\n\n&quot;</span>;</span><br><span class="line">    <span class="keyword">while</span> (p)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\t%-14s%-15s%-15.1f%-18.1f%-23.1f%-15.1f\n&quot;</span>, p-&gt;sn2.c_str(), p-&gt;name2.c_str(), p-&gt;grade[<span class="number">1</span>], p-&gt;grade[<span class="number">2</span>], p-&gt;grade[<span class="number">3</span>], p-&gt;grade[<span class="number">0</span>]);</span><br><span class="line">        p = p-&gt;Next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*删除节点函数 */</span></span><br><span class="line"><span class="comment">//flag用以标记删除失败情况，避免多次删除</span></span><br><span class="line"><span class="comment">//主要要考虑前节点与后节点的存在情况</span></span><br><span class="line"> <span class="type">void</span> <span class="title function_">menu2::Delete_2</span><span class="params">( menu2 *&amp; head, <span class="built_in">string</span>&amp; s)</span></span><br><span class="line">&#123;</span><br><span class="line">     menu2* p = head;</span><br><span class="line">    <span class="keyword">if</span> (!p)</span><br><span class="line">    &#123;</span><br><span class="line">        flag = <span class="number">1</span>;<span class="comment">//没有这个学生</span></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;暂无数据!\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (s.compare(p-&gt;sn2) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        p = p-&gt;Next;</span><br><span class="line">        <span class="keyword">if</span> (!p)</span><br><span class="line">        &#123;</span><br><span class="line">            flag = <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;该生数据不存在，请重试！\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;Previous == nullptr &amp;&amp; p-&gt;Next == nullptr)</span><br><span class="line">    &#123;</span><br><span class="line">        delete p;</span><br><span class="line">        p = nullptr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!p-&gt;Previous)</span><br><span class="line">    &#123;</span><br><span class="line">        head = p-&gt;Next;</span><br><span class="line">        p-&gt;Next-&gt;Previous = nullptr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!p-&gt;Next)</span><br><span class="line">        p-&gt;Previous-&gt;Next = nullptr;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        p-&gt;Previous-&gt;Next = p-&gt;Next;</span><br><span class="line">        p-&gt;Next-&gt;Previous = p-&gt;Previous;</span><br><span class="line">    &#125;</span><br><span class="line">    delete p;</span><br><span class="line">    p = nullptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*遍历查询*/</span></span><br><span class="line"> menu2* <span class="title function_">menu2::Find_2</span><span class="params">( menu2 *&amp; head, <span class="type">int</span> change, <span class="built_in">string</span>&amp; c)</span><span class="comment">//C用以表示姓名或者学号，取决于change是否为6还是4</span></span><br><span class="line">&#123;</span><br><span class="line">    system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">    menu2* p = head;</span><br><span class="line">    <span class="keyword">if</span> (change == <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (p)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (c.compare(p-&gt;sn2) == <span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">else</span> p = p-&gt;Next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (p)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (c.compare(p-&gt;name2) == <span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">else</span> p = p-&gt;Next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\n\n\n\n\t----------------------******************学生成绩查看******************** *--------------------\n\n\n&quot;</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\t学号----------姓名----------高数成绩--------英语成绩--------C++程序设计成绩--------总成绩(平均成绩)\n\n&quot;</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\t%-14s%-15s%-15.1f%-18.1f%-23.1f%-15.1f&quot;</span>, p-&gt;sn2.c_str(), p-&gt;name2.c_str(), p-&gt;grade[<span class="number">1</span>], p-&gt;grade[<span class="number">2</span>], p-&gt;grade[<span class="number">3</span>], p-&gt;grade[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;该学生不存在\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*查看单科成绩 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">menu2::SeeThesingle_2</span><span class="params">( menu2 *&amp; headofit, <span class="type">int</span> ch)</span></span><br><span class="line">&#123;</span><br><span class="line">    menu2* head = headofit;</span><br><span class="line">    SeeThesingle_2_print(head, g[ch], ch);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;\n\n操作成功，您可以继续操作！\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">menu2::SeeThesingle_2_print</span><span class="params">(menu2 *&amp; head, <span class="built_in">string</span> g, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\n\n\n\n\t----------------------******************学生&quot;</span> &lt;&lt; g &lt;&lt; <span class="string">&quot;成绩查看*********************  --------------------\n\n\n&quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\t\t\t\t\t学号----------姓名----------&quot;</span> &lt;&lt; g &lt;&lt; <span class="string">&quot;成绩\n\n&quot;</span>;</span><br><span class="line">    <span class="keyword">while</span> (head)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\t\t\t\t\t%-14s%-15s%-15.1f\n&quot;</span>, head-&gt;sn2.c_str(), head-&gt;name2.c_str(), head-&gt;grade[index]);</span><br><span class="line">        head = head-&gt;Next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*进入查看单科成绩接口 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">menu2::EnterSee2</span><span class="params">(menu2* headx[<span class="number">4</span>])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> c;</span><br><span class="line">    system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;您可以输入数字 1 以查看学生高数成绩，2 以查看学生的英语成绩，3 以查看C++成绩,0 以返回菜单\n&quot;</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        fflush(<span class="built_in">stdin</span>);</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; c;</span><br><span class="line">        <span class="keyword">if</span> (!c) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (c &lt; <span class="number">4</span> &amp;&amp; c &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            SeeThesingle_2(headx[c], c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;输入有误，请重新输入\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*修改数据，sn学号，s姓名，grade取决于choice分别表示不同的需要修改的成绩 */</span></span><br><span class="line"> <span class="type">void</span> <span class="title function_">menu2::Change_2</span><span class="params">( menu2 *&amp; head, <span class="type">int</span> choice, <span class="built_in">string</span>&amp; sn, <span class="built_in">string</span>&amp; s, <span class="type">float</span> grade)</span></span><br><span class="line">&#123;</span><br><span class="line">    menu2* p = head;</span><br><span class="line">    <span class="type">float</span> f;</span><br><span class="line">    <span class="keyword">while</span> (p &amp;&amp; sn.compare(p-&gt;sn2)!=<span class="number">0</span>)<span class="comment">//找到对应的学生</span></span><br><span class="line">        p = p-&gt;Next;</span><br><span class="line">    <span class="keyword">if</span> (!p) <span class="keyword">return</span> ;<span class="comment">//没有什么也不做</span></span><br><span class="line">    <span class="keyword">switch</span> (choice)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        p-&gt;sn2 = s;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        p-&gt;name2 = s;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        f = (grade + p-&gt;grade[<span class="number">2</span>] + p-&gt;grade[<span class="number">3</span>]) / <span class="number">3.0</span>;</span><br><span class="line">        p-&gt;grade[<span class="number">1</span>] = grade;</span><br><span class="line">        p-&gt;grade[<span class="number">0</span>] = f;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">        f = (grade + p-&gt;grade[<span class="number">1</span>] + p-&gt;grade[<span class="number">3</span>]) / <span class="number">3.0</span>;</span><br><span class="line">        p-&gt;grade[<span class="number">2</span>] = grade;</span><br><span class="line">        p-&gt;grade[<span class="number">0</span>] = f;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">        f = (grade + p-&gt;grade[<span class="number">2</span>] + p-&gt;grade[<span class="number">1</span>]) / <span class="number">3.0</span>;</span><br><span class="line">        p-&gt;grade[<span class="number">3</span>] = grade;</span><br><span class="line">        p-&gt;grade[<span class="number">0</span>] = f;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*成绩报告函数*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">menu2::CordReport_2</span><span class="params">( menu2* headx[<span class="number">4</span>])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">        <span class="type">int</span> ch;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;----------------------******************输入4以返回菜单，输入5以刷新页面******************** *--------------------\n&quot;</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\t*您可以输入 0 以查看平均成绩报告，1 以查看高数成绩报告，2 以查看英语成绩报告，3 以查看C++成绩报告* \n&quot;</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            fflush(<span class="built_in">stdin</span>);</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; ch;</span><br><span class="line">            <span class="keyword">if</span> (ch == <span class="number">4</span>)<span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ch == <span class="number">5</span>)<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ch &lt; <span class="number">4</span> &amp;&amp; ch &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                CordReport_2_print(headx[ch], g[ch], ch);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;您的输入有误，请重新输入！\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">menu2::CordReport_2_print</span><span class="params">(menu2* p, <span class="built_in">string</span>&amp; g,<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="type">float</span> num1 = <span class="number">0</span>, num2 = <span class="number">0</span>, num3 = <span class="number">0</span>;<span class="comment">//满绩、及格、挂科占比</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\t\t\t\t *&quot;</span> &lt;&lt; g &lt;&lt; <span class="string">&quot;成绩报告*  \n\n\t\t\t\t&quot;</span> &lt;&lt; g &lt;&lt; <span class="string">&quot;成绩在90分及以上的人分别是:\n&quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\t\t\t\t学号----------姓名-----------成绩\n&quot;</span>;</span><br><span class="line">    <span class="keyword">while</span> (p &amp;&amp; p-&gt;grade[index] &gt;= <span class="number">90</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n\t\t\t\t%-15s%-15s%.1f&quot;</span>, p-&gt;sn2.c_str(), p-&gt;name2.c_str(), p-&gt;grade[index]);</span><br><span class="line">        num1++;</span><br><span class="line">        num2++;</span><br><span class="line">        p = p-&gt;Next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (num1 == <span class="number">0</span>)  <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\t\t\t\t您的班没有满分人士！&quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\n\n\t\t\t\t&quot;</span> &lt;&lt; g &lt;&lt; <span class="string">&quot;成绩在60分以下的人分别是:\n&quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\t\t\t\t学号----------姓名-----------成绩\n&quot;</span>;</span><br><span class="line">    <span class="keyword">while</span> (p)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;grade[index] &lt; <span class="number">60</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n\t\t\t\t%-15s%-15s%.1f&quot;</span>, p-&gt;sn2.c_str(), p-&gt;name2.c_str(), p-&gt;grade[index]);</span><br><span class="line">            num3++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> num2++;</span><br><span class="line">        p = p-&gt;Next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (num3 == <span class="number">0</span>)<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\t\t\t\t您的班没有挂科人士！&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (num2 + num3 != <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n\n\t\t\t\t总体分布:\n\t\t\t\t60分以下共有%.0f人，占比%.1f%%。\n\n\t\t\t\t60分以上共有%.0f人，占比%.1f%%。\n\n\t\t\t\t其中90分以上共有%.0f人,占比%.1f%%。\n\n&quot;</span>, num3, (<span class="type">float</span>)num3 / (num2 + num3)*  <span class="number">100.0</span>, num2, (<span class="type">float</span>)num2 / (num2 + num3)*  <span class="number">100.0</span>, num1, (<span class="type">float</span>)num1 / (num2 + num3)*  <span class="number">100.0</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\n\n\t\t\t暂无数据！&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">menu2::FreeAll_2</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    menu2* p,* h = this;</span><br><span class="line">    <span class="keyword">while</span> (h)</span><br><span class="line">    &#123;</span><br><span class="line">        p = h;</span><br><span class="line">        h = h-&gt;Next;</span><br><span class="line">        delete p;</span><br><span class="line">        p = nullptr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-FileO-cpp"><a href="#9-FileO-cpp" class="headerlink" title="9.FileO.cpp"></a>9.FileO.cpp</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Everything.h&quot;</span></span></span><br><span class="line"><span class="comment">/*存储基本信息函数接口 */</span></span><br><span class="line"> <span class="type">void</span> <span class="title function_">menu1::Store1</span><span class="params">( )</span></span><br><span class="line">&#123;</span><br><span class="line">    menu1* head = this;</span><br><span class="line">    fstream file1;</span><br><span class="line">    file1.open(filebuffer1, ios::out );</span><br><span class="line">    menu1* <span class="built_in">queue</span>[<span class="number">1000</span>];</span><br><span class="line">    <span class="type">int</span> first = <span class="number">0</span>, tail = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">queue</span>[tail++] = head;<span class="comment">//队列</span></span><br><span class="line">    <span class="keyword">if</span> (!file1) <span class="keyword">return</span> ;</span><br><span class="line">    file1 &lt;&lt; <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (!head) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">while</span> (first &lt; tail)<span class="comment">//BFS遍历树存储每个节点</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">queue</span>[first]-&gt;left)  <span class="built_in">queue</span>[tail++] = <span class="built_in">queue</span>[first]-&gt;left;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">queue</span>[first]-&gt;right) <span class="built_in">queue</span>[tail++] = <span class="built_in">queue</span>[first]-&gt;right;</span><br><span class="line">        file1 &lt;&lt; <span class="built_in">queue</span>[first]-&gt;sn&lt;&lt;<span class="string">&quot; &quot;</span> &lt;&lt; <span class="built_in">queue</span>[first]-&gt;name &lt;&lt;<span class="string">&quot; &quot;</span> &lt;&lt; <span class="built_in">queue</span>[first]-&gt;chat&lt;&lt;<span class="string">&quot; &quot;</span> &lt;&lt; <span class="built_in">queue</span>[first]-&gt;dor&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        first++;</span><br><span class="line">    &#125;</span><br><span class="line">    file1.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*从文件中读取信息数据函数接口 */</span></span><br><span class="line"> menu1* <span class="title function_">menu1::Read1</span><span class="params">( menu1 *&amp; head)</span></span><br><span class="line"> &#123;</span><br><span class="line">    <span class="built_in">string</span> a, b, c, d;<span class="comment">//顺序表示学号姓名联系宿舍</span></span><br><span class="line">    fstream file1;</span><br><span class="line">    file1.open(filebuffer1, ios::in | ios::out );</span><br><span class="line">    <span class="keyword">if</span> (!file1)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!file1.eof())</span><br><span class="line">    &#123;</span><br><span class="line">        file1&gt;&gt;a&gt;&gt; b&gt;&gt; c&gt;&gt; d;</span><br><span class="line">        <span class="keyword">if</span> (file1.fail())</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        Record_1(head, a, b, c, d);</span><br><span class="line">    &#125;</span><br><span class="line">    file1.close();</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*存储成绩信息函数接口*/</span></span><br><span class="line"> <span class="type">void</span> <span class="title function_">menu2::Store2</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    fstream file2;</span><br><span class="line">    file2.open(filebuffer2, ios::out);</span><br><span class="line">    menu2* p = this;</span><br><span class="line">    <span class="keyword">if</span> (!file2) <span class="keyword">return</span>;</span><br><span class="line">    file2 &lt;&lt; <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (!p) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">while</span> (p)</span><br><span class="line">    &#123;</span><br><span class="line">        file2&lt;&lt; p-&gt;sn2&lt;&lt;<span class="string">&quot; &quot;</span> &lt;&lt; p-&gt;name2 &lt;&lt;<span class="string">&quot; &quot;</span> &lt;&lt; p-&gt;grade[<span class="number">1</span>] &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; p-&gt;grade[<span class="number">2</span>] &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; p-&gt;grade[<span class="number">3</span>]&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        p = p-&gt;Next;</span><br><span class="line">    &#125;</span><br><span class="line">    file2.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*注册函数接口菜单 */</span></span><br><span class="line"> Users* <span class="title function_">Users::Register</span><span class="params">( Users* user)</span></span><br><span class="line">&#123;</span><br><span class="line">    Users* u = user, * ur = user,*  uh;</span><br><span class="line">    <span class="built_in">string</span> pass, act;</span><br><span class="line">    fstream f1, f2;</span><br><span class="line">    <span class="built_in">string</span> fs1, fs2;</span><br><span class="line">    <span class="type">int</span> ch;</span><br><span class="line">TOP _:</span><br><span class="line"></span><br><span class="line">    system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt;<span class="string">&quot;        --------------------******************注册账号******************** *--------------------------\n\n\n&quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt;<span class="string">&quot;                             您可以输入 1 以进入注册，输入其他任意数以返回...\n\n&quot;</span>;</span><br><span class="line">    fflush(<span class="built_in">stdin</span>);</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; ch;</span><br><span class="line">    <span class="keyword">if</span> (ch == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;请输入您的账号 &quot;</span>;</span><br><span class="line">        act = enterspring(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">while</span> (u)<span class="comment">//检查账号是否已经存在</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (act.compare(u-&gt;accounts) == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                MessageBox(nullptr, TEXT(<span class="string">&quot;账号已经存在...&quot;</span>), TEXT(<span class="string">&quot;!&quot;</span>), <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">return</span> user;</span><br><span class="line">            &#125;</span><br><span class="line">            ur = u;</span><br><span class="line">            u = u-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        uh = new Users;<span class="comment">//新账号信息</span></span><br><span class="line">        <span class="keyword">if</span> (uh == nullptr) <span class="keyword">return</span> user;<span class="comment">//异常错误</span></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;请输入您的密码 &quot;</span>;</span><br><span class="line">        pass = enterspring(<span class="number">2</span>);</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;请再次输入您的密码 &quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (pass.compare(enterspring(<span class="number">2</span>)) != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;两次输入密码不一致，请重新输入.\n按任意键继续...&quot;</span>;</span><br><span class="line">            <span class="built_in">cin</span>.ignore();</span><br><span class="line">            <span class="keyword">goto</span> TOP _;</span><br><span class="line">        &#125;</span><br><span class="line">        uh-&gt;accounts = act;</span><br><span class="line">        uh-&gt;password = pass;</span><br><span class="line">        uh-&gt;next = nullptr;</span><br><span class="line">        <span class="keyword">if</span> (user == nullptr)   user = uh;</span><br><span class="line">        <span class="keyword">else</span>    ur-&gt;next = uh;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> user;</span><br><span class="line">    fs1 = act;</span><br><span class="line">    fs2 = act;</span><br><span class="line">    fs1 += <span class="string">&quot;_IF.txt&quot;</span>;<span class="comment">//添加指定后缀</span></span><br><span class="line">    fs2 += <span class="string">&quot;_GD.txt&quot;</span>;</span><br><span class="line">    f1.open(fs1, ios::app);</span><br><span class="line">    f2.open(fs2, ios::app);</span><br><span class="line">    f1.close();</span><br><span class="line">    f2.close();</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;注册成功，即将返回登陆页面！...&quot;</span>;</span><br><span class="line">    Sleep(<span class="number">200</span>);</span><br><span class="line">    <span class="keyword">return</span> user;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*登陆函数接口菜单*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Users::Enter</span><span class="params">( Users* user)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">string</span> act;</span><br><span class="line">    <span class="type">int</span> ch, gh;</span><br><span class="line">TOP _:</span><br><span class="line">    system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;    ------------------------******************登陆系统******************** *------------------------\n\n\n&quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;                             您可以输入 1 以进入登陆，其他任意键以返回...\n\n&quot;</span>;</span><br><span class="line">    fflush(<span class="built_in">stdin</span>);</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; ch;</span><br><span class="line">    <span class="keyword">if</span> (ch == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;\n请输入您的账号 &quot;</span>;</span><br><span class="line">        act = enterspring(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (user == nullptr)</span><br><span class="line">        &#123;</span><br><span class="line">            MessageBox(nullptr, TEXT(<span class="string">&quot;账号信息不存在...&quot;</span>), TEXT(<span class="string">&quot;!&quot;</span>), <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">         Users* p = user;</span><br><span class="line">        <span class="keyword">while</span> (p &amp;&amp; act.compare(p-&gt;accounts) != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (p == nullptr)</span><br><span class="line">        &#123;</span><br><span class="line">            MessageBox(nullptr, TEXT(<span class="string">&quot;账号信息不存在...&quot;</span>), TEXT(<span class="string">&quot;!&quot;</span>), <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;\n请输入您的密码 &quot;</span>;</span><br><span class="line">        <span class="keyword">while</span> (p-&gt;password.compare(enterspring(<span class="number">2</span>)) != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;密码错误,您可以输入 1 以继续输入密码，0 以刷新页面重新登陆 \n&quot;</span>;</span><br><span class="line">            fflush(<span class="built_in">stdin</span>);</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; gh;</span><br><span class="line">            <span class="keyword">if</span> (gh == <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;\n请输入您的密码 &quot;</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (gh == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">goto</span> TOP _;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/*用以创建存放用户数据两个文件的名称*/</span></span><br><span class="line">    filebuffer1=act;</span><br><span class="line">    filebuffer2=act;</span><br><span class="line">    filebuffer1+= <span class="string">&quot;_IF.txt&quot;</span>;<span class="comment">//添加指定后缀</span></span><br><span class="line">    filebuffer2+= <span class="string">&quot;_GD.txt&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*读取用户账户信息*/</span></span><br><span class="line"> <span class="type">void</span> <span class="title function_">Users::Readuser</span><span class="params">( Users* user)</span></span><br><span class="line">&#123;</span><br><span class="line">    Users* ph, * pc = user;</span><br><span class="line">    fstream p;</span><br><span class="line">    p.open(<span class="string">&quot;Users.txt&quot;</span>, ios::in|ios::out);</span><br><span class="line">    <span class="keyword">if</span> (!p)<span class="keyword">return</span> ;</span><br><span class="line">    <span class="built_in">string</span> act,pass;</span><br><span class="line">    <span class="keyword">while</span> (!p.eof())</span><br><span class="line">    &#123;</span><br><span class="line">        p&gt;&gt; act&gt;&gt; pass;</span><br><span class="line">        <span class="keyword">if</span> (!p.fail())</span><br><span class="line">        &#123;</span><br><span class="line">            ph = new Users;</span><br><span class="line">            ph-&gt;accounts= act;</span><br><span class="line">            ph-&gt;password= pass;</span><br><span class="line">            ph-&gt;next = nullptr;</span><br><span class="line">            <span class="keyword">if</span> (user == nullptr)</span><br><span class="line">            &#123;</span><br><span class="line">                user = ph;</span><br><span class="line">                pc = user;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                pc-&gt;next = ph;</span><br><span class="line">                pc = pc-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    p.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*存储用户账户信息函数实现 */</span></span><br><span class="line"><span class="type">void</span>  <span class="title function_">Users::StoreUser</span><span class="params">( Users* user)</span></span><br><span class="line">&#123;</span><br><span class="line">     Users* p1;</span><br><span class="line">     fstream p;</span><br><span class="line">     p.open(<span class="string">&quot;Users.txt&quot;</span>, ios::out);</span><br><span class="line">    <span class="keyword">if</span> (!p)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;保存用户信息失败...&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    p &lt;&lt; <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">while</span> (user)</span><br><span class="line">    &#123;</span><br><span class="line">        p1 = user;</span><br><span class="line">        p&lt;&lt;user-&gt;accounts&lt;&lt;<span class="string">&quot; &quot;</span> &lt;&lt; user-&gt;password&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        user = user-&gt;next;</span><br><span class="line">        delete p1;</span><br><span class="line">    &#125;</span><br><span class="line">    p.close();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*修改用户账号密码函数 */</span></span><br><span class="line"> <span class="type">void</span> <span class="title function_">Users::ChangePass</span><span class="params">( Users* user)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">string</span> act, pass, pass1;</span><br><span class="line">    <span class="type">int</span> ch;</span><br><span class="line">    <span class="type">int</span> len = filebuffer1.size(), i;</span><br><span class="line">     Users* p = user;</span><br><span class="line">    <span class="comment">/*检索当前账户名 */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (filebuffer1[i] == <span class="string">&#x27; _&#x27;</span>)<span class="keyword">break</span>;</span><br><span class="line">        act+= filebuffer1[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (p &amp;&amp; act.compare(p-&gt;accounts) != <span class="number">0</span>)<span class="comment">//账户一定是存在的</span></span><br><span class="line">    &#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">TOP_:</span><br><span class="line">    system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;   --------------------******************修改密码*********************------------------------\n\n\n&quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;                        您可以输入 1 以开始修改操作，0 以返回...\n&quot;</span>;</span><br><span class="line">    fflush(<span class="built_in">stdin</span>);</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; ch;</span><br><span class="line">    <span class="keyword">if</span> (ch == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;\n请输入原密码  &quot;</span>;</span><br><span class="line">        <span class="keyword">while</span> (p &amp;&amp; enterspring(<span class="number">2</span>).compare(p-&gt;password) != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> gh;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;密码错误,您可以输入 1 以继续输入密码，0 以刷新页面 &quot;</span>;</span><br><span class="line">            fflush(<span class="built_in">stdin</span>);</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; gh;</span><br><span class="line">            <span class="keyword">if</span> (gh == <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;\n请输入您的原密码 &quot;</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (gh == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">goto</span> TOP_;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;请输入您的新密码 &quot;</span>;</span><br><span class="line">        pass1 = enterspring(<span class="number">2</span>);</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;请再次输入您的密码 &quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (pass1.compare(enterspring(<span class="number">2</span>)) != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;两次输入密码不一致，请重新输入.\n按任意键继续...&quot;</span>;</span><br><span class="line">            <span class="built_in">cin</span>.ignore();</span><br><span class="line">            <span class="keyword">goto</span> TOP _;</span><br><span class="line">        &#125;</span><br><span class="line">        p-&gt;password = pass1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ch == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;修改密码成功！请按任意键返回...&quot;</span>;</span><br><span class="line">    <span class="built_in">cin</span>.ignore();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="10-Input-cpp"><a href="#10-Input-cpp" class="headerlink" title="10.Input.cpp"></a>10.Input.cpp</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Everything.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">float</span> <span class="title function_">inputlnt</span><span class="params">()</span></span><br><span class="line">&#123;   </span><br><span class="line">    <span class="type">float</span> rax;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; rax;</span><br><span class="line">        <span class="keyword">if</span> (rax &lt; <span class="number">0</span> || rax &gt; <span class="number">100</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            MessageBox(nullptr, TEXT(<span class="string">&quot;您输入的数字范围有误，请重新输入&quot;</span>), TEXT(<span class="string">&quot;输入错误&quot;</span>), <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    fflush(<span class="built_in">stdin</span>);</span><br><span class="line">    <span class="keyword">return</span> rax;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">inputString</span><span class="params">(<span class="built_in">string</span>&amp; buffer)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; buffer;</span><br><span class="line">        <span class="keyword">if</span> (buffer.size() == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            MessageBox(nullptr, TEXT(<span class="string">&quot;您还未输入！&quot;</span>), TEXT(<span class="string">&quot;!&quot;</span>), <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (buffer.size() &gt; <span class="number">17</span>) &#123;</span><br><span class="line">            MessageBox(nullptr, TEXT(<span class="string">&quot;您输入字符串字数超过上限，请重新输入。。。&quot;</span>), TEXT(<span class="string">&quot;overbuffer!&quot;</span>), <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    fflush(<span class="built_in">stdin</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">string</span> <span class="title function_">enterspring</span><span class="params">(<span class="type">int</span> c)</span><span class="comment">//c是一则视为账号输入，二视为密码输入，输出用*</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> ch;</span><br><span class="line">    <span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">string</span> buf;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (ch = _getch(), ch != <span class="string">&#x27;\r&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (k &gt; <span class="number">17</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                MessageBox(nullptr, TEXT(<span class="string">&quot;您输入字符串字数已达上限，无法继续输入。。。&quot;</span>), TEXT(<span class="string">&quot;overbuffer!&quot;</span>), <span class="number">0</span>);</span><br><span class="line">                fflush(<span class="built_in">stdin</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (ch == <span class="string">&#x27;\b&#x27;</span> &amp;&amp; k &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                k--;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\b \b&quot;</span>;</span><br><span class="line">                buf.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((ch &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;z&#x27;</span>) || (ch &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;Z&#x27;</span>) || (ch &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                buf += ch;</span><br><span class="line">                k++;</span><br><span class="line">                <span class="keyword">if</span> (c == <span class="number">2</span>)</span><br><span class="line">                    <span class="built_in">putchar</span>(<span class="string">&#x27;*&#x27;</span>);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="built_in">putchar</span>(ch);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                MessageBox(nullptr, TEXT(<span class="string">&quot;您输入的字符有误，请重新输入&quot;</span>), TEXT(<span class="string">&quot;输入错误&quot;</span>), <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">1</span> &amp;&amp; k == <span class="number">0</span>) MessageBox(nullptr, TEXT(<span class="string">&quot;您还未输入...&quot;</span>), TEXT(<span class="string">&quot;!&quot;</span>), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="number">2</span> &amp;&amp; k &lt; <span class="number">6</span>) MessageBox(nullptr, TEXT(<span class="string">&quot;您的密码太短了...&quot;</span>), TEXT(<span class="string">&quot;!&quot;</span>), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> buf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="11-main-cpp"><a href="#11-main-cpp" class="headerlink" title="11.main.cpp"></a>11.main.cpp</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Everything.h&quot;</span></span></span><br><span class="line"><span class="type">int</span> flag;<span class="comment">//用于系统二的多重表重复性与存在性验证,0代表正确的操作，1代表错误的操作</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//全局变量，用以记录用户存放数据的文件名</span></span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">string</span> filebuffer1=<span class="string">&quot;&quot;</span>, filebuffer2=<span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*用于退出程序或者退出登陆的接口函数*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Exit</span><span class="params">( Users* h,  menu1* h1,  menu2* h2,  menu2* h3,  menu2* h4,  menu2* h5)</span></span><br><span class="line">&#123;</span><br><span class="line">    h1-&gt;Store1();</span><br><span class="line">    h2-&gt;Store2();</span><br><span class="line">    h-&gt;StoreUser(h);</span><br><span class="line"></span><br><span class="line">    h1-&gt;FreeAll_1();</span><br><span class="line">    h2-&gt;FreeAll_2();</span><br><span class="line">    h3-&gt;FreeAll_2();</span><br><span class="line">    h4-&gt;FreeAll_2();</span><br><span class="line">    h5-&gt;FreeAll_2();</span><br><span class="line">    filebuffer1=<span class="string">&quot;&quot;</span>;</span><br><span class="line">    filebuffer2=<span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    SetConsoleTitle(<span class="string">&quot;学生管理系统&quot;</span>);</span><br><span class="line"></span><br><span class="line">    heart();</span><br><span class="line">    <span class="comment">/*需要用到的定义*/</span></span><br><span class="line">     menu1* head = nullptr; <span class="comment">//这个是系统1的，只有一个头</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*下面是系统二的,headx[0]是平均成绩,headx[1]是高数头，headx[2]英语,headx[3]C++ */</span></span><br><span class="line">     menu2* headx[<span class="number">4</span>] = &#123; nullptr,nullptr,nullptr,nullptr &#125;;<span class="comment">//分别为平均成绩主头指针和各科头指针</span></span><br><span class="line"></span><br><span class="line">     Users* user = nullptr;<span class="comment">//用户信息</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*1，2表示系统1、2需要用到的变量，命名可以看看头文件中的类 */</span></span><br><span class="line">    <span class="built_in">string</span> Sn2, Name2, temp, name1, sn1, chat1, dor1;</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> Grade[<span class="number">4</span>]=&#123;<span class="number">0</span>&#125;;<span class="comment">//系统二的成绩变量</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> c, ch;<span class="comment">//临时需要用的</span></span><br><span class="line"></span><br><span class="line">Menu0:<span class="comment">//登录注册菜单</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//首先读取用户账号密码</span></span><br><span class="line">        user-&gt;Readuser(user);</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ShowMap0();</span><br><span class="line">            fflush(<span class="built_in">stdin</span>);</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; ch;</span><br><span class="line">            <span class="keyword">switch</span> (ch)</span><br><span class="line">            &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">if</span> (user-&gt;Enter(user)) <span class="comment">//如果登入成功则读取信息</span></span><br><span class="line">                &#123;</span><br><span class="line">                    head = head-&gt;Read1(head);</span><br><span class="line">                    fstream file2;</span><br><span class="line">                    file2.open(filebuffer2, ios::in|ios::out|ios::binary);</span><br><span class="line">                    <span class="keyword">if</span> (!file2)      </span><br><span class="line">                        <span class="keyword">goto</span> Menu1;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">while</span> (!file2.eof())</span><br><span class="line">                    &#123;</span><br><span class="line">                        file2&gt;&gt; Sn2&gt;&gt; Name2&gt;&gt; Grade[<span class="number">1</span>]&gt;&gt; Grade[<span class="number">2</span>]&gt;&gt; Grade[<span class="number">3</span>];</span><br><span class="line">                        <span class="keyword">if</span> (file2.fail())</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">                            headx[i]-&gt;Record_2(headx[i], Sn2, Name2, Grade, i);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    file2.close();</span><br><span class="line">                    <span class="keyword">goto</span> Menu1;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                user = user-&gt;Register(user);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;\t\t\t\t\tBye!期待您的下次使用\n\n\n&quot;</span>;</span><br><span class="line">                MessageBox(nullptr, TEXT(<span class="string">&quot;感谢您使用本程序&quot;</span>), TEXT(<span class="string">&quot;Bye!&quot;</span>), <span class="number">0</span>);</span><br><span class="line">                Exit(user, head, headx[<span class="number">0</span>], headx[<span class="number">1</span>], headx[<span class="number">2</span>], headx[<span class="number">3</span>]);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                MessageBox(nullptr, TEXT(<span class="string">&quot;输入有误，请重新输入...&quot;</span>), TEXT(<span class="string">&quot;!&quot;</span>), <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">Menu1:<span class="comment">//主页面菜单</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">        &#123;   </span><br><span class="line">            ShowMap1();</span><br><span class="line">            fflush(<span class="built_in">stdin</span>);</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;ch;</span><br><span class="line">            <span class="keyword">switch</span> (ch)</span><br><span class="line">            &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">goto</span> Menu2;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                <span class="keyword">goto</span> Menu3;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                user-&gt;ChangePass(user);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">                Exit(user, head, headx[<span class="number">0</span>], headx[<span class="number">1</span>], headx[<span class="number">2</span>], headx[<span class="number">3</span>]);</span><br><span class="line">                user = nullptr;</span><br><span class="line">                head = nullptr;</span><br><span class="line">                headx[<span class="number">0</span>] = headx[<span class="number">1</span>] = headx[<span class="number">2</span>] = headx[<span class="number">3</span>] = nullptr;</span><br><span class="line">                <span class="keyword">goto</span> Menu0;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">                system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;\t\t\t\t\tBye!期待您的下次使用\n\n\n&quot;</span>;</span><br><span class="line">                MessageBox(nullptr, TEXT(<span class="string">&quot;感谢您使用本程序&quot;</span>), TEXT(<span class="string">&quot;Bye!&quot;</span>), <span class="number">0</span>);</span><br><span class="line">                Exit(user, head, headx[<span class="number">0</span>], headx[<span class="number">1</span>], headx[<span class="number">2</span>], headx[<span class="number">3</span>]);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;输入有误，请重新输入\n&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">Menu2:<span class="comment">//子系统1的菜单</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">        &#123;   </span><br><span class="line">            ShowMap2();</span><br><span class="line">            fflush(<span class="built_in">stdin</span>);</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;ch;</span><br><span class="line">            <span class="keyword">switch</span> (ch)</span><br><span class="line">            &#123;</span><br><span class="line">                sn1 = <span class="string">&quot;&quot;</span>;</span><br><span class="line">                name1 = <span class="string">&quot;&quot;</span>;</span><br><span class="line">                chat1 = <span class="string">&quot;&quot;</span>;</span><br><span class="line">                dor1=<span class="string">&quot;&quot;</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;请输入学生的学号      &quot;</span>;</span><br><span class="line">                inputString(sn1);</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;请输入学生的姓名      &quot;</span>;</span><br><span class="line">                inputString(name1);</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;请输入学生的联系电话  &quot;</span>;</span><br><span class="line">                inputString(chat1);</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;请输入学生的宿舍号    &quot;</span>;</span><br><span class="line">                inputString(dor1);</span><br><span class="line">                head-&gt;Record_1(head, sn1, name1, chat1, dor1);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                head-&gt;EnterDelete_1(head);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                ShowSeeit_1();</span><br><span class="line">                head-&gt;Seeit_1(head);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">                head-&gt;Find_1(head, ch);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">                ShowSeeit_1();</span><br><span class="line">                head-&gt;Seeit_1(head);</span><br><span class="line">                head-&gt;Change_1(head);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">                head-&gt;Find_1(head, ch);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">                <span class="keyword">goto</span> Menu1;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\t\t\t\t\tBye!期待您的下次使用\n\n\n&quot;</span>;</span><br><span class="line">                MessageBox(nullptr, TEXT(<span class="string">&quot;感谢您使用本程序&quot;</span>), TEXT(<span class="string">&quot;Bye!&quot;</span>), <span class="number">0</span>);</span><br><span class="line">                Exit(user, head, headx[<span class="number">0</span>], headx[<span class="number">1</span>], headx[<span class="number">2</span>], headx[<span class="number">3</span>]);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;输入有误，请重新输入\n&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">Menu3:<span class="comment">//子系统二菜单，对着程序显示的具体功能理解，有一些函数利用了接口的性质</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">        &#123;   </span><br><span class="line">            ShowMap3();</span><br><span class="line">            Sn2 = <span class="string">&quot;&quot;</span>;</span><br><span class="line">            Name2 = <span class="string">&quot;&quot;</span>;</span><br><span class="line">            fflush(<span class="built_in">stdin</span>);</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; ch;</span><br><span class="line">            <span class="keyword">switch</span> (ch)</span><br><span class="line">            &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;请输入待录入学生的学号 &quot;</span>;</span><br><span class="line">                inputString(Sn2);</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;请输入该生的姓名  &quot;</span>;</span><br><span class="line">                inputString(Name2);</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;请录入该生的高等数学成绩  &quot;</span>;</span><br><span class="line">                Grade[<span class="number">1</span>] = inputlnt();</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;请录入该生的大学英语成绩  &quot;</span>;</span><br><span class="line">                Grade[<span class="number">2</span>] = inputlnt();</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;请录入该生的C++程序设计成绩(将为您自动计算三科平均成绩)  &quot;</span>;</span><br><span class="line">                Grade[<span class="number">3</span>] = inputlnt();</span><br><span class="line">                flag = <span class="number">0</span>; <span class="comment">//这里0代表没有学号重复，是正确的操作</span></span><br><span class="line">                headx[<span class="number">0</span>]-&gt;Record_2(headx[<span class="number">0</span>], Sn2, Name2, Grade, <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">if</span> (!flag)<span class="comment">//如果记录中没有检测到学生重复的话，就记录这个学生</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">/*参数0\1\2\3是具体的功能，记录不同的成绩*/</span></span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">                        headx[i]-&gt;Record_2(headx[i], Sn2, Name2, Grade, i);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    headx[<span class="number">0</span>]-&gt;Seeit_2(headx[<span class="number">0</span>]);</span><br><span class="line">                    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;您可以输入 1 以进行删除，2 以全部删除，0 以返回菜单\n&quot;</span>;</span><br><span class="line">                    <span class="built_in">cin</span>&gt;&gt;c;</span><br><span class="line">                    <span class="keyword">if</span> (c == <span class="number">1</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;请输入您想要删除学生数据的学生学号  &quot;</span>;</span><br><span class="line">                        inputString(Sn2);</span><br><span class="line">                        flag = <span class="number">0</span>;<span class="comment">//这里0代表学生存在，1代表学生不存在</span></span><br><span class="line">                        headx[<span class="number">0</span>]-&gt;Delete_2(headx[<span class="number">0</span>], Sn2);</span><br><span class="line">                        <span class="keyword">if</span> (!flag)<span class="comment">//如果存在就删除</span></span><br><span class="line">                        &#123;   </span><br><span class="line">                            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">                                headx[i]-&gt;Delete_2(headx[i], Sn2);</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;操作成功！ &quot;</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="number">2</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">                            headx[i]-&gt;FreeAll_2();</span><br><span class="line">                            headx[i] = nullptr;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                headx[<span class="number">0</span>]-&gt;Seeit_2(headx[<span class="number">0</span>]);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;请输入您要查看学生的学号 &quot;</span>;</span><br><span class="line">                inputString(Sn2);</span><br><span class="line">                headx[<span class="number">0</span>]-&gt;Find_2(headx[<span class="number">0</span>], <span class="number">4</span>, Sn2);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">                headx[<span class="number">0</span>]-&gt;Seeit_2(headx[<span class="number">0</span>]);</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;\n请输入您要修改学生的学号 &quot;</span>;</span><br><span class="line">                inputString(Sn2);</span><br><span class="line">                <span class="keyword">while</span> (headx[<span class="number">0</span>]-&gt;Find_2(headx[<span class="number">0</span>], <span class="number">4</span>, Sn2))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;\n您可以输入 1 以更改学号，2 以更改姓名，3 以更改高数成绩，4 以更改英语成绩，5 以更改C++成绩，0 以结束操作 \n&quot;</span>;</span><br><span class="line">                    <span class="built_in">cin</span>&gt;&gt;c;</span><br><span class="line">                    <span class="keyword">if</span> (!c) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (c &lt; <span class="number">3</span>) &#123;</span><br><span class="line">                        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请输入新学号/姓名！&quot;</span>;</span><br><span class="line">                        inputString(temp);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请输入新成绩！&quot;</span>;</span><br><span class="line">                        Grade[<span class="number">0</span>] = inputlnt();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">                        headx[i]-&gt;Change_2(headx[i], c, Sn2, temp, Grade[<span class="number">0</span>]);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (c == <span class="number">1</span>)Sn2 = temp;</span><br><span class="line">                &#125;</span><br><span class="line">                fflush(<span class="built_in">stdin</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;请输入您要查看学生的姓名 &quot;</span>;</span><br><span class="line">                inputString(Name2);</span><br><span class="line">                headx[<span class="number">0</span>]-&gt;Find_2(headx[<span class="number">0</span>], <span class="number">6</span>, Name2);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">                headx[<span class="number">0</span>]-&gt;EnterSee2(headx);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">                headx[<span class="number">0</span>]-&gt;CordReport_2(headx);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">9</span>:</span><br><span class="line">                <span class="keyword">goto</span> Menu1;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\t\t\t\t\tBye!期待您的下次使用\n\n\n&quot;</span>;</span><br><span class="line">                MessageBox(nullptr, TEXT(<span class="string">&quot;感谢您使用本程序&quot;</span>), TEXT(<span class="string">&quot;Bye!&quot;</span>), <span class="number">0</span>);</span><br><span class="line">                Exit(user, head, headx[<span class="number">0</span>], headx[<span class="number">1</span>], headx[<span class="number">2</span>], headx[<span class="number">3</span>]);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;输入有误，请重新输入\n&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="12-ShowMap-cpp"><a href="#12-ShowMap-cpp" class="headerlink" title="12.ShowMap.cpp"></a>12.ShowMap.cpp</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Everything.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ShowMap0</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;color 74&quot;</span>);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;\t     -------------------******************学生管理系统******************** *--------------------\n\n\n&quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot; --------------------******************账号只允许由1-18位英文与数字组成******************* **------------------------\n&quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;\n --------------------******************密码只允许由6-18位英文与数字组成******************** *------------------------\n&quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;\n\n\n\n\n&quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;\t\t                   (@^o^@) 欢迎使用学生信息管理系统   (⌒:⌒)\n&quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;\t\t                   (~):(~)                            (~)v(~) \n&quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;\t\t*****************************************                   \n&quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;\t\t******                                                                         \n&quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;\t\t**********                                                                     \n&quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;\t\t*****                               菜   单*****                               \n&quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;\t\t********                                                                       \n&quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;\t\t****                                1：登录****                                \n&quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;\t\t********                                                                       \n&quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;\t\t****                                2：注册****                                \n&quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;\t\t********                                                                     \n&quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;\t\t****                                0：退出****                                \n&quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;\t\t********                                                                       \n&quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;\t\t***********************************************                                \n&quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;\n\t\t                                请输入您的操作--&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">ShowMap1</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;color 06&quot;</span>);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;\n\n\n\n\n&quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;\t  -------------------******************学生管理系统*********************--------------------\n\n&quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;\n\t\t\t\t\t    * [1] 学生信息管理\n&quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;\n\t\t\t\t\t*     [2] 学生成绩管理\n&quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;\n\t\t\t\t\t*     [3] 修改密码\n&quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;\n\t\t\t\t\t*     [4] 退出登陆\n&quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;\n\t\t\t\t\t*     [5] 退出程序\n&quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;\n\n\n\n&quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;\t  -------------------*******************欢迎使用********************** **--------------------\n&quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;请您输入菜单上的按键--&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">ShowMap2</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;color 0E&quot;</span>);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;\n\n\n\n\n&quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;\t  -------------------******************学生信息管理******************** *--------------------\n\n\n&quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;\t\t\t*      [1] 添加学生信息*              [2] 删除学生信息\n\n&quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;\t\t\t*      [3] 查看学生信息*              [4] 以学号查询学生信息\n\n&quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;\t\t\t*      [5] 修改学生信息*              [6] 以姓名查询学生信息\n\n&quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;\t\t\t*      [7] 回到上一级*                [0] 退出程序\n\n&quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;\n\n\n\n&quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;\t  -------------------*******************欢迎使用********************** **--------------------\n&quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;请您输入菜单上的按键--&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">ShowMap3</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;color 0E&quot;</span>);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;\n\n\n\n\n&quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;\t  -------------------******************学生成绩管理******************** *--------------------\n\n\n&quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;\t\t\t*      [1]  录入学生成绩*              [2] 删除学生成绩\n\n&quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;\t\t\t*      [3]  查看学生成绩*              [4] 以学号查询学生成绩\n\n&quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;\t\t\t*      [5]  修改学生成绩*              [6] 以姓名查询学生成绩\n\n&quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;\t\t\t*      [7]  单科成绩排名*              [8] 学生成绩报告\n\n&quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;\t\t\t*      [9]  返回上一级*                [0] 退出程序\n\n&quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;\n\n\n\n&quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;\t  -------------------*******************欢迎使用********************** **--------------------\n&quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;请您输入菜单上的按键--&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ShowSeeit_1</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;\n\n\n\n\t----------------------******************学生信息查看******************** *--------------------\n\n\n&quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;\t-------------学号---------------姓名------------------联系方式-------------------宿舍号-----\n\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">heart</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    system(<span class="string">&quot;color 74&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">float</span> y = <span class="number">1.5f</span>; y &gt; <span class="number">-1.5f</span>; y -= <span class="number">0.1f</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;\t\t\t&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">float</span> x = <span class="number">-1.5f</span>; x &lt; <span class="number">1.5f</span>; x += <span class="number">0.05f</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">float</span> a = x*  x + y*  y - <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">putchar</span>(a*  a*  a - x*  x*  y*  y*  y &lt;= <span class="number">0.0f</span> ? <span class="string">&#x27;*&#x27;</span> : <span class="string">&#x27; &#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;\t\t\t       &quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;欢&quot;</span>;</span><br><span class="line">    Sleep(<span class="number">200</span>);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot; 迎&quot;</span>;</span><br><span class="line">    Sleep(<span class="number">200</span>);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot; 使&quot;</span>;</span><br><span class="line">    Sleep(<span class="number">200</span>);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot; 用&quot;</span>;</span><br><span class="line">    Sleep(<span class="number">200</span>);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot; 学&quot;</span>;</span><br><span class="line">    Sleep(<span class="number">200</span>);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot; 生&quot;</span>;</span><br><span class="line">    Sleep(<span class="number">200</span>);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot; 管&quot;</span>;</span><br><span class="line">    Sleep(<span class="number">200</span>);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot; 理&quot;</span>;</span><br><span class="line">    Sleep(<span class="number">200</span>);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot; 系&quot;</span>;</span><br><span class="line">    Sleep(<span class="number">200</span>);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot; 统！&quot;</span>;</span><br><span class="line">    Sleep(<span class="number">200</span>);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot; (请按任意键进入...)&quot;</span>;</span><br><span class="line">    <span class="built_in">cin</span>.ignore();</span><br><span class="line">    system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> 学校课程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>职业生涯规划书</title>
      <link href="/posts/%E5%AD%A6%E4%B9%A0/%E5%AD%A6%E6%A0%A1%E8%AF%BE%E7%A8%8B/%E8%81%8C%E4%B8%9A%E7%94%9F%E6%B6%AF%E8%A7%84%E5%88%92%E4%B9%A6.html"/>
      <url>/posts/%E5%AD%A6%E4%B9%A0/%E5%AD%A6%E6%A0%A1%E8%AF%BE%E7%A8%8B/%E8%81%8C%E4%B8%9A%E7%94%9F%E6%B6%AF%E8%A7%84%E5%88%92%E4%B9%A6.html</url>
      
        <content type="html"><![CDATA[<h1 id="一、自我分析"><a href="#一、自我分析" class="headerlink" title="一、自我分析"></a>一、自我分析</h1><h2 id="（一）职业兴趣—喜欢干什么"><a href="#（一）职业兴趣—喜欢干什么" class="headerlink" title="（一）职业兴趣—喜欢干什么"></a>（一）职业兴趣—喜欢干什么</h2><p>喜欢处理数据，文字等，喜欢软件的设计，编码，调试，测试等工作。</p><h2 id="（二）职业价值观—最看重什么"><a href="#（二）职业价值观—最看重什么" class="headerlink" title="（二）职业价值观—最看重什么"></a>（二）职业价值观—最看重什么</h2><ol><li><p>独立思考，了解事物怎样运行和作用</p></li><li><p>以自己的方式做事，或快或慢随自己所愿</p></li><li><p>报酬高，能拥有自己想要的事物</p></li><li><p>在怡人的环境里工作</p></li><li><p>在一个公平并能与之融洽相处的管理者手下工作</p></li></ol><h2 id="（三）职业能力—能够干什么"><a href="#（三）职业能力—能够干什么" class="headerlink" title="（三）职业能力—能够干什么"></a>（三）职业能力—能够干什么</h2><p>做事认真，踏实，学习能力强，具有一定的创造力和承压能力，专业基础扎实。</p><h2 id="（四）性格特征—适合干什么"><a href="#（四）性格特征—适合干什么" class="headerlink" title="（四）性格特征—适合干什么"></a>（四）性格特征—适合干什么</h2><p>做事深思熟虑，沉着冷静，善于自控，不善交际。</p><h2 id="（五）自我分析小结"><a href="#（五）自我分析小结" class="headerlink" title="（五）自我分析小结"></a>（五）自我分析小结</h2><p>我是一个内倾的人，喜欢软件方面的工作。对于自己发展方向,最大的希望就是成为有用之才,实现自己的人生价值和自己的梦想,同时喜欢创新,做事认真、投入,有很大的责任心。通过上面的分析,我对自己有了深刻的认识,在看到自己优点的同时还发现自己有许多的不足之处,我会取别人之长来弥补自己的不足之处。</p><h1 id="二、职业分析"><a href="#二、职业分析" class="headerlink" title="二、职业分析"></a>二、职业分析</h1><h2 id="家庭环境分析"><a href="#家庭环境分析" class="headerlink" title="家庭环境分析"></a>家庭环境分析</h2><p>父母对我的期望也是比较高的，父亲学历中学，他认为知识对于我将来的发展起到很大的作用，希望我能一直学习下去。家里条件一般，致使我从小养成了独立的习惯。</p><h2 id="学校环境分析"><a href="#学校环境分析" class="headerlink" title="学校环境分析"></a>学校环境分析</h2><p>软件工程我感觉学院的师资都还可以，老师都挺尽心尽责，学生大部分都挺好学的。课程量也不少，要求比较严格，考试周压力也挺大。该学的课程基本都安排了，只是自己还记不记得的问题。</p><h2 id="社会环境分析"><a href="#社会环境分析" class="headerlink" title="社会环境分析"></a>社会环境分析</h2><p>近几年国内就业的压力逐步加重，可能是历史上最巨大的。就业竞争激烈，我们应该有危机意识，认真学习理论知识，提高业务技能，为以后的工作发展打好坚实的基础。</p><h2 id="职业环境分析"><a href="#职业环境分析" class="headerlink" title="职业环境分析"></a>职业环境分析</h2><h3 id="行业分析"><a href="#行业分析" class="headerlink" title="行业分析"></a>行业分析</h3><p>伴随着互联网的发展，IT 人才的短缺现象将会越来越严重。在我国，IC 人才、网络存储人才、电子商务人才、信息安全人才、游戏技术人才严重短缺；在软件人才层次结构上，水平高的系统分析员和有行业背景的项目策划人员偏少，同时软件蓝领也比较缺乏。随着 IT 业越来越火，各大高校计算机专业报名的人数也越来越多。而近年来，随着毕业生人数激增，就业率与供求比例明显走低。</p><h3 id="职业分析"><a href="#职业分析" class="headerlink" title="职业分析"></a>职业分析</h3><p>软件工程师，目前有如下特点：<br>1.工作起点高，发展空间大。<br>2.企业缺口大，工作待遇高，环境好。<br>3.工作稳定，不用频繁跳槽。<br>4.复合型人才，工程师们需要掌握更多的编程语言。</p><h3 id="企业分析"><a href="#企业分析" class="headerlink" title="企业分析"></a>企业分析</h3><p>互联网企业，从事国内互联网公司开发岗位工作的同学收入相对其他行业和专业要高出很多的，当然国内互联网大厂的工作压力还是非常大的，入职之后在不加班的情况下也要工作到晚上八九点。<br>各大外企，对于实力较强的同学也可以考虑 Google，Microsoft 等外企的 IT 岗位，相比于国内的血汗厂，外企在国内 996 的情况要相对少很多，虽然工资相比于国内互联网公司要低一些，但是性价比较高。想进入 955 的外企，不仅要专业技术水平高，英语也要好。<br>各大国企、银行、公务员、事业单位计算机相关岗位，从事体制内的工作，虽然挣得少，但是生活质量是相对较高的。</p><h3 id="地域分析"><a href="#地域分析" class="headerlink" title="地域分析"></a>地域分析</h3><p>从就业区域的情况来看，不出意外，排名前四名分别为北、深、上、广四大一线城市，而省会城市杭州、成都、南京、武汉、西安也在前十排名中，而前十名的榜单中只有苏州为非省会城市。</p><h2 id="职业分析小结"><a href="#职业分析小结" class="headerlink" title="职业分析小结"></a>职业分析小结</h2><p>就业率发展平稳，但薪酬水平有所下降。随着高校研究生和本科学生的扩招，特别是计算机专业毕业人数的急剧增加，以及受到经济因素的影响，计算机专业毕业生的就业不如从前那样火爆，就业的整体质量存在明显下降。平均起步收入较高。同其他专业相比，计算机专业在就业刚开始的时候的收入算高的。就业面广，计算机领域涉及到东西很多，各行各业都会涉及到计算机专业的就业岗位，可以结合自己的兴趣和实际情况，来选择合适自己的职位。</p><h1 id="三、职业定位"><a href="#三、职业定位" class="headerlink" title="三、职业定位"></a>三、职业定位</h1><table><thead><tr><th>内部环境因素</th><th></th><th>优势因素 (S)</th><th>弱势因素 (W)</th><th></th></tr></thead><tbody><tr><td></td><td>做事比较认真、踏实，有浓厚的学习兴趣和必须的实力，尤其在计算机方面有着浓厚的兴趣。</td><td>性格较内向，并不善于与人交往和沟通。工作、学习有些保守，冒险精神不够，没有结合长远目标，并且创新本事有待提高。</td><td></td><td></td></tr><tr><td>外部环境因素</td><td></td><td>机会因素 (O)</td><td>威胁因素 (T)</td><td></td></tr><tr><td></td><td>IT 行业迅猛发展，就业工作岗位也比比皆是。在最近几年内 IT 在职场排行榜中仍旧处于所有行业中的 “ 老大 “。</td><td>当今比我优秀的人才很多，而机会不必须是均等的，这时就不单单是知识的比拼，更是对个人发现机会、展示自我并把握机会本事的考验。</td><td></td><td></td></tr><tr><td>职业目标</td><td>软件开发工程师</td><td></td><td></td><td></td></tr><tr><td>职业发展策略</td><td>希望进入长三角地区、最好是外企类型的组织</td><td></td><td></td><td></td></tr><tr><td>职业发展路径</td><td>走专家路线</td><td></td><td></td><td></td></tr><tr><td>具体路径</td><td>软件工程师——高级软件工程师——架构师</td><td></td><td></td><td></td></tr></tbody></table><h2 id="计划实施"><a href="#计划实施" class="headerlink" title="计划实施"></a>计划实施</h2><table><thead><tr><th>名称</th><th>短期计划</th></tr></thead><tbody><tr><td>时间跨度</td><td>2022&#x2F;7——2023&#x2F;7</td></tr><tr><td>总目标</td><td>找到暑期实习</td></tr><tr><td>分目标</td><td>学习 Java,计算机基础，掌握基本算法和数据结构</td></tr><tr><td>计划内容</td><td>上课认真听讲，课余学习其他内容，刷题</td></tr></tbody></table><table><thead><tr><th>名称</th><th>中期计划</th></tr></thead><tbody><tr><td>时间跨度</td><td>2023&#x2F;7——2025&#x2F;7</td></tr><tr><td>总目标</td><td>找到理想的工作</td></tr><tr><td>分目标</td><td>准备好面试所需的经历，经验，技能</td></tr><tr><td>计划内容</td><td>做项目，找实习，学专业知识，刷面试题</td></tr></tbody></table><table><thead><tr><th>名称</th><th>长期计划</th></tr></thead><tbody><tr><td>时间跨度</td><td>2025——2030</td></tr><tr><td>总目标</td><td>成为架构师</td></tr><tr><td>分目标</td><td>提高自己的能力</td></tr><tr><td>计划内容</td><td>不断开阔自己眼界，提高自己的管理，沟通能力</td></tr></tbody></table><h1 id="评估调整"><a href="#评估调整" class="headerlink" title="评估调整"></a>评估调整</h1><h2 id="1、评估的内容"><a href="#1、评估的内容" class="headerlink" title="1、评估的内容"></a>1、评估的内容</h2><h3 id="职业目标评估"><a href="#职业目标评估" class="headerlink" title="职业目标评估"></a>职业目标评估</h3><p>对于自己制定的目标规划,可能会是一个失败的计划,但是只要去努力,无论失败还是成功,都将是一次巨大的收获,在今后的工作中,会不断完整自己的规划,将规划完善到最佳,将工作做到最佳,将人生规划到最佳。</p><h3 id="职业路径评估"><a href="#职业路径评估" class="headerlink" title="职业路径评估"></a>职业路径评估</h3><p>坚持自己的整体职业规划路径,中途中的一些小毛病可以适当的调整。如果规划发展方向有问题,可以选择更好的规划方向,但是规划中整体大局不变。</p><h3 id="实施策略评估"><a href="#实施策略评估" class="headerlink" title="实施策略评估"></a>实施策略评估</h3><p>如果出现一些变故,或者家庭需要,会去考虑改变行的策略,会在生活和工作中寻找一个平衡点。</p><h3 id="其它因素评估"><a href="#其它因素评估" class="headerlink" title="其它因素评估"></a>其它因素评估</h3><p>假如遇到什么事,我会根据实际情况去及时的调整及评估。</p><h2 id="2、评估的时间"><a href="#2、评估的时间" class="headerlink" title="2、评估的时间"></a>2、评估的时间</h2><p>一般情况下，我定期去评估和规划，当出现特殊情况时，我会随时评估并进行相应的调整。</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> 学校课程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>软件开发方法</title>
      <link href="/posts/%E5%AD%A6%E4%B9%A0/%E5%AD%A6%E6%A0%A1%E8%AF%BE%E7%A8%8B/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E6%96%B9%E6%B3%95.html"/>
      <url>/posts/%E5%AD%A6%E4%B9%A0/%E5%AD%A6%E6%A0%A1%E8%AF%BE%E7%A8%8B/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E6%96%B9%E6%B3%95.html</url>
      
        <content type="html"><![CDATA[<h1 id="一、-选题内容"><a href="#一、-选题内容" class="headerlink" title="一、 选题内容"></a>一、 选题内容</h1><p>在线购物系统</p><h1 id="二、-需求分析"><a href="#二、-需求分析" class="headerlink" title="二、 需求分析"></a>二、 需求分析</h1><p>在线购物系统所包含的基本功能为：<br>商家注册登录后可将新上架的商品信息通过系统发布到网上或对已有商品进行管理。<br>用户通过系统浏览商品，查看商品详细信息，或者直接搜索对应商品，还可对所属订单进行管理。<br>顾客注册登录之后，选择商品可加入购物车或下单购买，通过第三方支付平台支付，发货过程还需经过物流，还可进行售后服务。</p><h1 id="三、-系统设计"><a href="#三、-系统设计" class="headerlink" title="三、 系统设计"></a>三、 系统设计</h1><p><img src="/../../../img/blog/254561b7f5b7cbdf0fa706baac7f16a1_MD5.jpg"></p><h1 id="四、-实验内容整合"><a href="#四、-实验内容整合" class="headerlink" title="四、 实验内容整合"></a>四、 实验内容整合</h1><h2 id="用况图"><a href="#用况图" class="headerlink" title="用况图"></a>用况图</h2><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>1、确定系统边界<br>首先，在线购物系统的外部活动者有用户，商家和顾客，这些都不属于系统本身，是系统的外部环境。<br>其次，在线购物系统需要涉及到第三方支付平台与物流运输，他们也是系统的外部环境。<br>第三，在线购物系统需要运行在操作系统上，运行过程中可能要进行生成文件,获取时间等操作，这涉及到操作系统的 API，所以操作系统对于在线购物系统来说也是外部环境。<br>第四，在线购物系统的使用需要涉及到手机或者电脑等设备，这些设备对于系统来说也是外部环境。<br>2、识别参与者<br>在线购物系统需要用户，顾客和商家的直接使用，所以他们是参与者。<br>在线购物系统的使用过程中会涉及第三方支付平台与物流运输，所以他们也是参与者。<br>外部系统方面有操作系统，而设备方面则需要考虑电脑、手机等智能设备。<br>3、捕获用况<br>从用户方面考虑，用户需要通过登陆注册的操作成为商家或者是顾客。通过修改信息，订单管理，订单查阅，修改订单来向系统读写信息。而顾客需要在此系统的主要任务是购物，他需要搜索浏览商品，管理购物车，以及购买商品，支付等操作。商家的主要任务则是管理自己商店的商品，将商品打包派送，修改货架信息。<br>从系统功能的角度看，在线购物系统需完成顾客购买商品，商家对于顾客的售后服务，如咨询与退换货<br>从场景的角度来看，在线购物系统需要涉及到物流来对商品进行派送运输，需要第三方支付平台来令用户完成支付，同时根据场景模拟，支付还可分为立即支付与货到付款等方式。<br>4、建立用况图<br>根据上述涉及到的参与者和捕获的用况来建立用况图，分析参与者与参与者，参与者与用况，用况与用况之间的关系。例如用户是顾客与商家的泛化，而用户与登陆注册，修改信息等用况是关联关系。订单管理与订单查询是包含关系，立即支付、货到付款与支付是继承关系，购买商品与购物车管理是扩展关系。<br>5、检查与调整<br>检查每个参与者是否都至少有一个用况关联，考虑了参与者与参与者是否有继承，考虑了用况的细化分解与用况之间关系的确立。</p><h3 id="模型图"><a href="#模型图" class="headerlink" title="模型图"></a>模型图</h3><p><img src="/../../../img/blog/4b43099a7b937fdd9fec26db69f20386_MD5.jpg"></p><h3 id="用况描述"><a href="#用况描述" class="headerlink" title="用况描述"></a>用况描述</h3><h4 id="用况一"><a href="#用况一" class="headerlink" title="用况一"></a>用况一</h4><p>用况名：订单管理<br>简述：” 订单管理 “ 主要为用户，即顾客或商家提供订单的查询和更改<br>参与者：用户，顾客，商家<br>包含：包含订单查询和修改订单两个用况<br>扩展：无<br>继承：无<br>前置条件：用户登录成功<br>细节：</p><ol><li><p>在主界面，用户选择订单管理，进入界面</p></li><li><p>在订单管理界面，用户进行查询订单或直接选择订单</p></li><li><p>对于选中订单，用户可以进行修改或删除</p></li><li><p>修改完成后点击确认后结束</p></li></ol><p>后置条件：对于要修改的订单，修改信息必须填写完整<br>例外：</p><ul><li>用户点击确认时修改信息不完全</li></ul><p>（1）系统提示信息：修改信息未填写完全<br>（2）用户确认信息<br>（3）返回细节第 3 步<br>限制：对于顾客而言，可修改或删除的订单应是待付款订单<br>注释：无</p><h4 id="用况二"><a href="#用况二" class="headerlink" title="用况二"></a>用况二</h4><p>用况名：购买商品<br>简述：” 购买商品 “ 为商家顾客提供购买所需商品的提交订单和支付功能<br>参与者：顾客<br>包含：包含提交订单和支付两个用况<br>扩展：扩展它的用况有购物车管理<br>继承：无<br>前置条件：顾客登录成功<br>细节：<br>①基本流程</p><ol><li><p>客户在购物车或商品界面选择要确定购买的商品以及数量，点击提交订单</p></li><li><p>客户在订单页面填写收货地址等信息</p></li><li><p>选择支付方式，完成支付</p></li><li><p>系统提示交易成功</p></li></ol><p>②可选流程</p><ol><li><p>选择优惠方式（红包&#x2F;积分）</p></li><li><p>购买运费险</p></li></ol><p>后置条件：生成订单并变为待发货状态<br>例外：</p><ul><li>某商品数量不足或有购买数量限制<br>（1）系统提示信息：该商品剩余数量&#x2F;该商品限购数量<br>（2）顾客确认消息<br>（3）返回基本流程第 1 步</li><li>所选择的的第三方支付系统资金不足<br>（1）系统提示信息：账户资金不足，请重新选择支付方式<br>（2）顾客确认信息<br>（3）返回基本流程第 3 步</li></ul><p>限制：下单数量不得超过上限<br>注释：无</p><h4 id="用况三"><a href="#用况三" class="headerlink" title="用况三"></a>用况三</h4><p>用况名：商品派送<br>简述：商家通过商品派送将顾客所购买的商品打包出货<br>参与者：商家，物流<br>包含：被商品管理所包含<br>扩展：无<br>继承：无<br>前置条件：商家登录成功<br>细节：</p><ol><li><p>待顾客下单后，发货状态会改为待发货，商家会确认顾客的订单信息，如顾客的收货地址与联系方式是否正确，顾客是否有备注要求，收款是否到达后台账户。</p></li><li><p>如订单有误，商家可以修改或取消订单，如无误，商家则分配订单到物流配送部门进行备货，出货的处理。</p></li><li><p>同时，商家还会根据线下配送情况修改网上订单的配送状态进行标识，如待发货，待收货等。</p></li></ol><p>后置条件：发货成功<br>例外：</p><ul><li><p>某商品存在物流限制无法送达顾客收货地点时<br>（1）商家提示顾客物流受限无法送达<br>（2）顾客选择退货处理</p></li><li><p>顾客订单超过设定处理时间</p><pre><code>  （1）系统提示信息：顾客订单超过预定处理时间（2）商家确认信息（3）商家处理订单</code></pre></li></ul><p>限制：用户订单信息必须真实有效<br>注释：无</p><h4 id="用况四"><a href="#用况四" class="headerlink" title="用况四"></a>用况四</h4><p>用况名：修改上架商品<br>简述：商家想调整销售策略时，可以使用修改上架商品操作<br>参与者：商家<br>包含：被商品管理所包含<br>扩展：无<br>继承：无<br>前置条件：商家登录成功<br>细节：</p><ol><li><p>商家进入商品管理界面</p></li><li><p>商家根据最近的销售情况结合外部环境及政策来对上架商品的价格进行调整，也可查看上架商品的库存量，对热销商品进行补货，对滞销商品进行降价或者活动促销等操作。</p></li><li><p>如若有新品，商家也可点击添加商品，填写完商品的信息，点击确定，即可上架商品。</p></li></ol><p>后置条件：上架商品种类或信息改变<br>例外：</p><ul><li>上架新品时商品信息填写不完整<br>（1）系统提示信息：商品信息未填写完整<br>（2）商家确认消息<br>（3）返回商品信息填写界面</li><li>修改后的商品信息存在违规内容<br>（1）系统提示信息：商品内容违规请整改<br>（2）商家确认信息<br>（3）商家重新更改商品信息</li></ul><p>限制：无<br>注释：无</p><h4 id="用况五"><a href="#用况五" class="headerlink" title="用况五"></a>用况五</h4><p>用况名：支付<br>简述：顾客使用第三方支付平台进行支付来购买商品<br>参与者：顾客，第三方支付平台<br>包含：被购买商品所包含<br>扩展：无<br>继承：一般用况为支付，特殊用况为立即支付和货到付款<br>前置条件：顾客登录成功<br>细节：</p><ol><li><p>顾客选择支付方式</p></li><li><p>选择立即支付，顾客输入支付所需的信息并支付</p></li><li><p>选择货到付款，顾客收到商品，检查确认后签收付款</p></li><li><p>系统提示支付成功</p></li></ol><p>后置条件：账户扣款成功<br>例外：</p><ul><li>所选择的的第三方支付系统资金不足<br>（1）系统提示信息：账户资金不足，请重新选择支付方式<br>（2）顾客确认信息<br>（3）顾客重新选择支付方式</li></ul><p>限制：需实名认证后才可支付<br>注释：无</p><h2 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h2><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><h4 id="1）识别对象与类"><a href="#1）识别对象与类" class="headerlink" title="1）识别对象与类"></a>1）识别对象与类</h4><p>从系统边界、问题域、系统责任、名词代词和名词短语等角度出发，可以识别出的对象有游客、注册用户、商家、店铺、物流、商品、操作系统、电脑、手机、客服、交易订单、支付手段、购物车、订阅商铺等多种对象。<br>通过审查与筛选，从舍去无用对象，精简对象以及推迟到 OOD 考虑的对象等角度出发，发现如操作系统、电脑、手机等对象可以舍去，而商家和店铺则能够进行合并。<br>抽象出类并进行调整，将对象依据属性和操作进行分类，并对分好的类进行调整，如商家和顾客虽拥有共同部分，如用户名、账号、密码等，但两类属性与操作并不相同，则考虑建立一个用户类形成继承关系。</p><h4 id="2）类的属性与操作"><a href="#2）类的属性与操作" class="headerlink" title="2）类的属性与操作"></a>2）类的属性与操作</h4><p>识别出类的属性与操作、并对其进行审查与调整，如明确该属性或操作是否是否提供真正对系统有用信息、该属性是否描述的是这个类的特征，一个操作是否只完成一项明确定义的、相对完整而单一的功能。</p><h4 id="3）确定类之间的关系"><a href="#3）确定类之间的关系" class="headerlink" title="3）确定类之间的关系"></a>3）确定类之间的关系</h4><h5 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h5><p>审查类的属性与操作不难发现用户类中如存在支付，管理商品等操作并不适合用户类的全部对象，管理商品应属于商家，而支付则属于顾客。因此因在用户类下建立两个特殊类：商家与顾客，来形成继承</p><h5 id="关联"><a href="#关联" class="headerlink" title="关联"></a>关联</h5><p>通过类的静态联系可以看出，如用户与商品，商家与客服售后，顾客与订单等类中都存在关联关系</p><h5 id="聚合与组合"><a href="#聚合与组合" class="headerlink" title="聚合与组合"></a>聚合与组合</h5><p>顾客与订阅店铺、购物车构成一个整体，且订阅店铺、购物车不能独立于顾客存在，因此为组合关系</p><h5 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h5><p>商家对商品进行更新的同时，如果顾客订阅该店铺，顾客订阅店铺中的内容也会发生变化，因此两者存在依赖关系</p><h3 id="模型图-1"><a href="#模型图-1" class="headerlink" title="模型图"></a>模型图</h3><p><img src="/../../../img/blog/fef1521c0bd0e1c7e51a248dd2ec24d8_MD5.jpg"></p><h1 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h1><p>软件开发方法这门课使我初步了解了面向对象的概念和它的基本思想，基本原则，并且基本掌握了 UML 语言的用法。通过实验，我对于如何建立需求模型——用况图，如何建立基本模型——类图有了更多的理解。<br>在建立需求模型中，我通过确定系统边界，通过交互识别参与者，捕获用况等方法建模得到了在线购物系统的用况图，并以此加深了对系统功能相互关系的理解，明白了外部事物如何使用系统以及系统所提供的功能，从而能更好地设计系统功能，使系统责任更加全面具体。<br>在建立基本模型中，我明白了对象和类与参与者的不同，并通过识别系统中的对象与类，确定了类的属性和操作以及类之间的关系后构建起在线购物系统的类图，在此过程中对于类的抽象和他们之间的各种关系有了更加深刻的理解，能够在实际问题中更好地通过编程构建类。<br>虽然最后因为种种原因这门课的内容并没有上完全，但它面向对象分析的思想和方法都对我有了一定的帮助，让我能够快速地分析出系统的功能以及结构，从而让编程变得更加轻松。</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> 学校课程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>MySQL忘记密码的修改密码方法</title>
      <link href="/posts/%E5%BA%94%E7%94%A8/%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7/Mysql/MySQL%E5%BF%98%E8%AE%B0%E5%AF%86%E7%A0%81%E7%9A%84%E4%BF%AE%E6%94%B9%E5%AF%86%E7%A0%81%E6%96%B9%E6%B3%95.html"/>
      <url>/posts/%E5%BA%94%E7%94%A8/%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7/Mysql/MySQL%E5%BF%98%E8%AE%B0%E5%AF%86%E7%A0%81%E7%9A%84%E4%BF%AE%E6%94%B9%E5%AF%86%E7%A0%81%E6%96%B9%E6%B3%95.html</url>
      
        <content type="html"><![CDATA[<h1 id="第一步：关闭-Mysql-服务"><a href="#第一步：关闭-Mysql-服务" class="headerlink" title="第一步：关闭 Mysql 服务"></a>第一步：关闭 Mysql 服务</h1><p>首先先停止 mysql 服务。可通过 net stop mysql,以<strong>管理员权限</strong>操作<br><img src="/../../../../img/blog/3d1208dd95dda690b90f32e1fcf9f6bb_MD5.png" alt="image.png"></p><h1 id="第二步：跳过-Mysql-密码验证"><a href="#第二步：跳过-Mysql-密码验证" class="headerlink" title="第二步：跳过 Mysql 密码验证"></a>第二步：跳过 Mysql 密码验证</h1><p>进入命令提示符（管理员登陆）操作，进入 mysql 目录中 bin 文件夹下，使用 mysqld -console –skip-grant-tables –shared-memory 来跳过权限验证。<br><img src="/../../../../img/blog/44e642cb9bc6960e6dd0d0b304e91a4d_MD5.png" alt="image.png"><br>输入执行后没有反馈，新开一个管理员窗口重新执行。（这是第二个窗口）<br>进入目录后，确保自己已经关闭了 Mysql 的服务：net stop mysql<br><img src="/../../../../img/blog/9634323dbbca0d39b1dbd8b8e53f6daa_MD5.png" alt="image.png"><br>关闭 Mysql 服务之后，继续在 D:\mysql-8.0.19-winx64\bin 目录下进行操作：<br>输入 mysqld -console –skip-grant-tables –shared-memory<br><img src="/../../../../img/blog/a4fc001803694ae84a7f9b1ec529da44_MD5.png" alt="image.png"></p><h1 id="第三步：无密码方式进入-Mysql"><a href="#第三步：无密码方式进入-Mysql" class="headerlink" title="第三步：无密码方式进入 Mysql"></a>第三步：无密码方式进入 Mysql</h1><p>在上述步骤之后，再打开一个管理员模式运行的 cmd.exe （这是第三个窗口）<br>进入 mysql 下的 bin 目录后，直接登录 mysql<br>不需要通过 net start mysql 打开 mysql 服务<br>在命令行中输入以下代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd D:\mysql-8.0.19-winx64\bin(此处输入自己电脑上的安装目录)</span><br><span class="line">mysql -u root -p</span><br></pre></td></tr></table></figure><p>此时会显示让你输入密码，直接回车，就可以成功连接 Mysql。<br><img src="/../../../../img/blog/6e953ef22d472b9e51e4d80a83c19984_MD5.png" alt="image.png"></p><h1 id="第四步：将登陆密码设置为空"><a href="#第四步：将登陆密码设置为空" class="headerlink" title="第四步：将登陆密码设置为空"></a>第四步：将登陆密码设置为空</h1><p>输入代码，将密码设置为空（<strong>此时还不能直接修改密码，必须先设置为空，否则会报错</strong>）</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">use mysql; (使用mysql数据表)</span><br><span class="line">update user set authentication_string=<span class="comment">&#x27;&#x27; where user=&#x27;root&#x27;;（将密码置为空）</span></span><br><span class="line">quit; (然后退出Mysql)</span><br></pre></td></tr></table></figure><p><img src="/../../../../img/blog/c3cc01a12044ba39eba3a59f19a75554_MD5.png" alt="image.png"></p><h1 id="第五步：更改自己的登陆密码"><a href="#第五步：更改自己的登陆密码" class="headerlink" title="第五步：更改自己的登陆密码"></a>第五步：更改自己的登陆密码</h1><h2 id="1-关闭前两个-Cmd-窗口-一定要关闭！-；"><a href="#1-关闭前两个-Cmd-窗口-一定要关闭！-；" class="headerlink" title="1.关闭前两个 Cmd 窗口 (一定要关闭！)；"></a>1.关闭前两个 Cmd 窗口 (一定要关闭！)；</h2><h2 id="2-在第三个窗口中输入代码；"><a href="#2-在第三个窗口中输入代码；" class="headerlink" title="2.在第三个窗口中输入代码；"></a>2.在第三个窗口中输入代码；</h2><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">net <span class="keyword">stop</span> mysql(关闭mysql服务,虽然会显示没有开启服务，但是以防万一)</span><br><span class="line">net start mysql(再打开mysql服务)</span><br><span class="line">cd D:\mysql-<span class="number">8.0</span>.<span class="number">19</span>-winx64\bin  (此处输入自己电脑上的安装目录)</span><br><span class="line">mysql -u root -p</span><br><span class="line">(此处会显示输入密码，直接回车就好了，第四步我们已经将他置为空了)</span><br><span class="line">ALTER USER <span class="comment">&#x27;root&#x27;@&#x27;localhost&#x27; IDENTIFIED BY &#x27;root&#x27;;（更改密码，此处密码已设置为root）</span></span><br></pre></td></tr></table></figure><p><img src="/../../../../img/blog/0bdf0d296cd61a0be8e9432b287e375c_MD5.png" alt="image.png"></p><h2 id="3-验证密码是否修改成功"><a href="#3-验证密码是否修改成功" class="headerlink" title="3.验证密码是否修改成功"></a>3.验证密码是否修改成功</h2><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">quit（退出mysql）</span><br><span class="line">mysql -u root -p</span><br><span class="line">(输入新密码，再次登录)</span><br></pre></td></tr></table></figure><p><img src="/../../../../img/blog/42e7f6292604a68ac074ee231f80bb93_MD5.png" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> 应用 </category>
          
          <category> 编程工具 </category>
          
          <category> Mysql </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Github 代理加速或 CDN 加速</title>
      <link href="/posts/%E5%BA%94%E7%94%A8/%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7/Git/Github%20%E4%BB%A3%E7%90%86%E5%8A%A0%E9%80%9F%E6%88%96%20CDN%20%E5%8A%A0%E9%80%9F.html"/>
      <url>/posts/%E5%BA%94%E7%94%A8/%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7/Git/Github%20%E4%BB%A3%E7%90%86%E5%8A%A0%E9%80%9F%E6%88%96%20CDN%20%E5%8A%A0%E9%80%9F.html</url>
      
        <content type="html"><![CDATA[<h1 id="WSL-使用-Proxy-连接-Github"><a href="#WSL-使用-Proxy-连接-Github" class="headerlink" title="WSL 使用 Proxy 连接 Github"></a>WSL 使用 Proxy 连接 Github</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> hostip=127.0.0.1 </span><br><span class="line"><span class="built_in">export</span> hostport=10808 // 取决于win的proxy工具设置的端口号</span><br><span class="line"><span class="built_in">export</span> HTTPS_PROXY=<span class="string">&quot;socks5://<span class="variable">$&#123;hostip&#125;</span>:<span class="variable">$&#123;hostport&#125;</span>&quot;</span>;</span><br><span class="line"><span class="built_in">export</span> HTTP_PROXY=<span class="string">&quot;socks5://<span class="variable">$&#123;hostip&#125;</span>:<span class="variable">$&#123;hostport&#125;</span>&quot;</span>;</span><br><span class="line"><span class="built_in">export</span> ALL_PROXY=<span class="string">&quot;socks5://<span class="variable">$&#123;hostip&#125;</span>:<span class="variable">$&#123;hostport&#125;</span>&quot;</span>;</span><br></pre></td></tr></table></figure><p>下面的命令只针对 github.com，在国内还可能会用到 gitee.com，所以不能将所有的 git 站点都添加上代理。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置代理</span></span><br><span class="line">git config --global http.https://github.com.proxy socks5://127.0.0.1:1086</span><br><span class="line"><span class="comment"># 取消代理</span></span><br><span class="line">git config --global --<span class="built_in">unset</span> http.https://github.com.proxy</span><br></pre></td></tr></table></figure><p>如果没有代理也不要急，有专门的 cdn 加速：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git config --global url.<span class="string">&quot;https://github.com.cnpmjs.org&quot;</span>.insteadOf <span class="string">&quot;https://github.com&quot;</span></span><br><span class="line">git config --global url.<span class="string">&quot;https://ghproxy.com&quot;</span>.insteadOf <span class="string">&quot;https://github.com&quot;</span> </span><br><span class="line">git config --global url.<span class="string">&quot;https://hub.fastgit.xyz/&quot;</span>.insteadOf <span class="string">&quot;https://github.com/&quot;</span></span><br></pre></td></tr></table></figure><p>因为没有官方 CDN，上面都是用爱发电，没准哪天就挂了。</p><h1 id="在-Terminal-中通过代理访问-GitHub"><a href="#在-Terminal-中通过代理访问-GitHub" class="headerlink" title="在 Terminal 中通过代理访问 GitHub"></a>在 Terminal 中通过代理访问 GitHub</h1><h2 id="通过代理访问-GitHub"><a href="#通过代理访问-GitHub" class="headerlink" title="通过代理访问 GitHub"></a>通过代理访问 GitHub</h2><p>从国内访问 GitHub 速度慢是一个困扰大家很久的问题，使用代理可以提高网页浏览和下载 ZIP 文件的速度。但是在 Terminal 中，git 工具在访问 <a href="https://github.com/">github.com</a> 时，是不会经过代理的，这就导致了执行 <code>clone</code>、<code>pull</code>、<code>push</code> 等命令时，传输速度只有可怜的 10KiB&#x2F;s。</p><blockquote><p>如果使用代理之后网页加载速度还是很慢，有可能是没有打开代理的 <strong>全局模式（Global Mode）</strong>。因为 GitHub 在国内没有被封锁，只是被限速了，所以有的代理会 “ 智能 “ 地忽略对 <a href="https://github.com/">github.com</a> 的访问请求。</p></blockquote><p>论坛上常见解决方法是更改 <code>/etc/hosts</code> 文件，但这个方法成功率不是很高，而且因为 IP 地址变动的问题，每次都要重新配置。还有一个方法是通过 <a href="https://gitee.com/">gitee.com</a> 来中转仓库，但是这只适合用于一次性的克隆，如果要经常获取别人的提交，这种方法就过于繁琐了。<br>下面我就来讲解一下怎么让 git 工具通过代理访问 <a href="https://github.com/">github.com</a>。</p><hr><h1 id="第一步：配置代理"><a href="#第一步：配置代理" class="headerlink" title="第一步：配置代理"></a>第一步：配置代理</h1><p>从代理客户端设置中找到 <strong>允许其他设备连接本机代理</strong> 选项，并输入一个代理端口：<br><img src="/../../../../img/blog/6e9499d89107234ed9447832bfb16949_MD5.png"><br><strong>注意：</strong></p><ul><li>每个代理的设置界面可能不一样，但是应该都有这些选项。</li><li>0～1023 端口为系统端口，所以这里选择 1024～65535 之间的端口。</li><li>如果有 SOCKS5 协议，也可以选择一个端口使用。</li></ul><h1 id="第二步：配置-Git-工具"><a href="#第二步：配置-Git-工具" class="headerlink" title="第二步：配置 Git 工具"></a>第二步：配置 Git 工具</h1><h2 id="设置-Git-局部代理"><a href="#设置-Git-局部代理" class="headerlink" title="设置 Git 局部代理"></a>设置 Git 局部代理</h2><p>如果你想在本地已有的仓库中，让 <code>pull</code> 或者 <code>push</code> 命令经过代理，就需要将 git 工具的代理设置为上一步中输入的端口（我的端口是 41091）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> path/to/your/repo/</span><br><span class="line">$ git config http.proxy http://127.0.0.1:41091</span><br><span class="line">$ git config https.proxy https://127.0.0.1:41091</span><br><span class="line">$ git config --list <span class="comment"># 查看设置结果</span></span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><ul><li>这里使用的是 git 工具的 <strong>局部代理</strong>（没有 <code>--global</code> 标示），所以仅该目录下的 git 命令会经过代理。</li><li>127.0.0.1 是 localhost 的 IP 地址，如果你的代理不在同一个计算机上，就需要输入对应的 IP 地址。</li><li>如果上一步选择了 SOCKS5 协议，使用以下命令：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config http.proxy socks5://127.0.0.1:1090</span><br><span class="line">$ git config https.proxy socks5://127.0.0.1:1090</span><br></pre></td></tr></table></figure><ul><li>如果想要停用代理，输入以下命令：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --unset http.proxy</span><br><span class="line">$ git config --unset https.proxy</span><br></pre></td></tr></table></figure><h2 id="设置-Git-全局代理"><a href="#设置-Git-全局代理" class="headerlink" title="设置 Git 全局代理"></a>设置 Git 全局代理</h2><p>如果你想让 <code>clone</code> 命令经过代理，首先需要设置 git 工具的 <strong>全局代理</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global http.proxy http://127.0.0.1:41091</span><br><span class="line">$ git config --global https.proxy https://127.0.0.1:41091</span><br></pre></td></tr></table></figure><p>在 <code>clone</code> 完成之后，记得停用全局代理，否则之后所有的 git 命令都会经过代理：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global --unset http.proxy</span><br><span class="line">$ git config --global --unset https.proxy</span><br></pre></td></tr></table></figure><p>如果想要在克隆的文件夹中打开局部代理，可以参照第一种情况。</p><h1 id="第三步：访问-GitHub"><a href="#第三步：访问-GitHub" class="headerlink" title="第三步：访问 GitHub"></a>第三步：访问 GitHub</h1><p>现在就可以用代理的最高限速访问 <a href="https://github.com/">github.com</a> 啦！我在测试中，<code>git pull</code> 的平均速度可以达到 10MiB&#x2F;s。<br><img src="/../../../../img/blog/497b63211b4cbaa8156e9558551f67d7_MD5.png"></p><hr><h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><p>如果有的小伙伴不想在 Terminal 里设置 git 工具，还可以使用 <strong>GitHub Desktop</strong> （<a href="https://desktop.github.com/">点这里下载</a>）来管理本地的 GitHub 仓库。只要打开代理，不需要任何设置，GitHub Desktop 就会自动经过代理访问 GitHub 的服务器。</p><h1 id="下载单个-Github-文件夹（实际下载整个文件夹，速度还行）"><a href="#下载单个-Github-文件夹（实际下载整个文件夹，速度还行）" class="headerlink" title="下载单个 Github 文件夹（实际下载整个文件夹，速度还行）"></a>下载单个 Github 文件夹（实际下载整个文件夹，速度还行）</h1><p>刚写了个库 <a href="https://link.zhihu.com/?target=https://github.com/ykfe/dclone">dclone</a>,看了一眼应该是 github 上最简单的实现其他的库实现都写的特别复杂，可以让你只下载单个文件夹提升你的下载速度。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ npm i -g dclone</span><br><span class="line">$ dclone <span class="attr">https</span>:<span class="comment">//github.com/ykfe/egg-react-ssr/tree/dev/example/ssr-with-loadable</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 应用 </category>
          
          <category> 编程工具 </category>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Cpp环境搭建</title>
      <link href="/posts/%E5%BA%94%E7%94%A8/%E9%85%8D%E7%BD%AE/%E8%AF%AD%E8%A8%80%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/Cpp%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA.html"/>
      <url>/posts/%E5%BA%94%E7%94%A8/%E9%85%8D%E7%BD%AE/%E8%AF%AD%E8%A8%80%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/Cpp%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA.html</url>
      
        <content type="html"><![CDATA[<h1 id="Window"><a href="#Window" class="headerlink" title="Window"></a>Window</h1><p>这套环境是 VSCode+MinGW（MSYS2）&#x2F;Msvc+Clangd+Xmake 的配置。<br>先安装 <a href="../%E8%BD%AF%E4%BB%B6%E9%85%8D%E7%BD%AE/%E6%9C%AC%E5%9C%B0%E8%BD%AF%E4%BB%B6%E9%85%8D%E7%BD%AE1">本地软件配置1</a></p><h2 id="MinGW"><a href="#MinGW" class="headerlink" title="MinGW"></a>MinGW</h2><p>首先使用 scoop 安装 msys2（在 main bucket 中就有）：<br><code>scoop install msys2 </code><br>msys2 镜像源替换<br><a href="https://mirrors.ustc.edu.cn/help/msys2.html">https://mirrors.ustc.edu.cn/help/msys2.html</a><br>终端中输入 <code>msys2</code> 进入环境，下载 minGW：<br><code>pacman -S mingw-w64-x86_64-toolchain </code><br>下面会提示选择哪些工具，如果不是硬盘空间实在有限的话，直接回车默认安装全部即可。<br>随后找到 minGW 的 bin 目录（这里推荐一手 Listary，直接搜索 <code>g++.exe</code> 打开文件目录即可，非常方便），添加环境变量（环境变量一般重启才生效），此时 GCC 编译器就算是安装成功了。</p><h2 id="Clangd"><a href="#Clangd" class="headerlink" title="Clangd"></a>Clangd</h2><p>在 vscode 扩展商店中搜索 clangd 下载，完成后右下角会弹窗提醒你安装 clangd server，点击 Install 即可直接安装，这一点非常便捷。</p><h3 id="自身配置"><a href="#自身配置" class="headerlink" title="自身配置"></a>自身配置</h3><p><a href="https://clangd.llvm.org/config">Configuration (llvm.org)</a><br><a href="https://github.com/clangd/clangd/discussions/1170">为什么 windows 上的 clangd 找不到标准头文件</a><br><a href="https://github.com/clangd/clangd/discussions/1510">clangd 找不到 iostream 和其他标准库</a><br><code>&lt;driver&gt; -E -v -x c++ -</code> 查看是否支持 clangd 用于尝试从驱动程序中提取内置包含的相同标志</p><ol><li><p>在工程目录下新建一个<strong>文件</strong>，名为 <code>.clangd</code>，或者编辑 <code>%LocalAppData%\clangd\config.yaml</code>, 通常为 <code>C:\Users\Bob\AppData\Local\clangd\config.yaml</code></p></li><li><p>在文件中添加</p></li></ol><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">CompileFlags:</span></span><br><span class="line">  <span class="attr">Add:</span> [<span class="string">&quot;-IC:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.34.31933\\include&quot;</span>]<span class="comment">#添加头文件</span></span><br><span class="line"><span class="attr">Diagnostics:</span></span><br><span class="line">  <span class="attr">UnusedIncludes:</span> <span class="string">Strict</span></span><br><span class="line">  <span class="attr">ClangTidy:</span></span><br><span class="line">    <span class="attr">Add:</span></span><br><span class="line">      [</span><br><span class="line">        <span class="string">performance-*</span>,</span><br><span class="line">        <span class="string">bugprone-*</span>,</span><br><span class="line">        <span class="string">portability-*</span>,</span><br><span class="line">        <span class="string">modernize-*</span>,</span><br><span class="line">      ]</span><br><span class="line">    <span class="attr">Remove:</span> <span class="string">modernize-use-trailing-return-type</span></span><br><span class="line">    <span class="attr">CheckOptions:</span></span><br><span class="line">      <span class="attr">WarnOnFloatingPointNarrowingConversion:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><h3 id="Mingw"><a href="#Mingw" class="headerlink" title="Mingw"></a>Mingw</h3><p>clangd 默认直接绑定了 VS 路径下的 MSVC 库，如果需要修改为 MinGW 则要改动 target。<br>配置如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**********</span></span><br><span class="line"><span class="comment">* Clangd *</span></span><br><span class="line"><span class="comment">**********/</span></span><br><span class="line"><span class="comment">// Clangd 运行参数(在终端/命令行输入 clangd --help-list-hidden 可查看更多)</span></span><br><span class="line"><span class="attr">&quot;clangd.arguments&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">  <span class="comment">//设置clangd server的驱动库路径，这里我设置了mingw的路径，但似乎没有效果（clangd仍然链接到了MSVC当中）</span></span><br><span class="line">  <span class="string">&quot;--query-driver=D:\\Scoop\\apps\\msys2\\current\\mingw64\\bin\\x86_64-w64-mingw32-g++.exe&quot;</span><span class="punctuation">,</span></span><br><span class="line">   </span><br><span class="line"><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line"><span class="comment">// clangd所在路径</span></span><br><span class="line"><span class="attr">&quot;clangd.path&quot;</span><span class="punctuation">:</span> <span class="string">&quot;D:\\Scoop\\apps\\llvm\\current\\bin\\clangd.exe&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="comment">// 默认编译器选项：在 clangd 没能找到 compile_flags.json 文件时采用</span></span><br><span class="line"><span class="comment">// 缺陷是不能如读取到 compile_flags.json 时一样直接索引同一项目的不同文件，因为没有它 clangd 仅能保守地分析</span></span><br><span class="line"><span class="comment">//系统头文件、当前文件、当前文件`#include`的文件</span></span><br><span class="line"><span class="comment">// compile_flags.json 可通过 CMake 等工具生成</span></span><br><span class="line"><span class="attr">&quot;clangd.fallbackFlags&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">  <span class="comment">//包含头文件</span></span><br><span class="line">  <span class="string">&quot;-ID:\\Scoop\\apps\\msys2\\current\\mingw64\\include\\c++\\12.2.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="string">&quot;-ID:\\Scoop\\apps\\msys2\\current\\mingw64\\include&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="string">&quot;-ID:\\Scoop\\apps\\msys2\\current\\mingw64\\include\\c++\\12.2.0\\x86_64-w64-mingw32&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="string">&quot;-I$&#123;workspaceFolder&#125;/src/includes&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="comment">//设置链接目标，这里改成了GNU，即对应MinGW</span></span><br><span class="line">  <span class="string">&quot;--target=x86_64-w64-windows-gnu&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">]</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure><p>逐一解释：</p><ul><li>header-insetion: 是否自动引入头文件，这里设置的是从不。</li><li>completion-style: 设置提示格式，这里设置的是展示所有细节。</li><li>query-driver：设置 clangd server 的驱动库路径，这里我设置了 mingw 的路径，但似乎没有效果（clangd 仍然链接到了 MSVC 当中）</li><li>std：设置 c++ 标准</li><li>-I：设置用户自定义的库路径</li><li>–target：设置链接目标，这里改成了 GNU，即对应 MinGW</li></ul><h3 id="Msvc"><a href="#Msvc" class="headerlink" title="Msvc"></a>Msvc</h3><p>msvc 编译器较快（推荐）</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**********</span></span><br><span class="line"><span class="comment"> * Clangd *</span></span><br><span class="line"><span class="comment"> **********/</span></span><br><span class="line"><span class="comment">// Clangd 运行参数(在终端/命令行输入 clangd --help-list-hidden 可查看更多)</span></span><br><span class="line"><span class="attr">&quot;clangd.arguments&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">  <span class="comment">//设置clangd server的驱动库路径</span></span><br><span class="line">  <span class="string">&quot;--query-driver=C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.34.31933\\bin\\HostX64\\x64\\cl.exe&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line"><span class="comment">// clangd所在路径</span></span><br><span class="line"><span class="attr">&quot;clangd.path&quot;</span><span class="punctuation">:</span> <span class="string">&quot;D:\\Scoop\\apps\\llvm\\current\\bin\\clangd.exe&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="comment">// 默认编译器选项：在 clangd 没能找到 compile_flags.json 文件时采用</span></span><br><span class="line"><span class="comment">// 缺陷是不能如读取到 compile_flags.json 时一样直接索引同一项目的不同文件，因为没有它 clangd 仅能保守地分析</span></span><br><span class="line"><span class="comment">//系统头文件、当前文件、当前文件`#include`的文件</span></span><br><span class="line"><span class="comment">// compile_flags.json 可通过 CMake 等工具生成</span></span><br><span class="line"><span class="attr">&quot;clangd.fallbackFlags&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">  <span class="comment">//包含头文件</span></span><br><span class="line">  <span class="string">&quot;-IC:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.34.31933\\include&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="string">&quot;-I$&#123;workspaceFolder&#125;/src/includes&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">]</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure><h2 id="Xmake"><a href="#Xmake" class="headerlink" title="Xmake"></a>Xmake</h2><p>设置工具链：<br><code>xmake f -p mingw --mingw=D:\Scoop\apps\msys2\current\mingw64  -c</code><br>贴一段 xmake 的配置代码：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">add_rules(<span class="string">&quot;mode.debug&quot;</span>, <span class="string">&quot;mode.release&quot;</span>)</span><br><span class="line">set_languages(<span class="string">&quot;c11&quot;</span>,<span class="string">&quot;cxx11&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">target(<span class="string">&quot;P2_6_1&quot;</span>)</span><br><span class="line">set_kind(<span class="string">&quot;binary&quot;</span>)</span><br><span class="line">add_files(<span class="string">&quot;src/chapter2/practice_2_6_1.cpp&quot;</span>)</span><br><span class="line">add_includedirs(<span class="string">&quot;src/includes&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><p>通过 <a href="https://github.com/xmake-io/xmake-vscode">xmake-vscode</a> 插件配合 vscode 来实现对 c&#x2F;c++ 项目的断点调试支持。<br>另外我们还需要依赖 vscode 的 C++ 插件才能进行调试支持</p><h1 id="使用-WSL-在-VScode-上用-LLVM-Clangd-LLDB-高效编程-C"><a href="#使用-WSL-在-VScode-上用-LLVM-Clangd-LLDB-高效编程-C" class="headerlink" title="使用 WSL 在 VScode 上用 LLVM + Clangd + LLDB 高效编程 C++"></a>使用 WSL 在 VScode 上用 LLVM + Clangd + LLDB 高效编程 C++</h1><h2 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h2><p>想要在 <a href="https://so.csdn.net/so/search?q=VScode&spm=1001.2101.3001.7020">VScode</a> 上使用 clang 编译 + LLDB 调试 + clangd 自动补全这一套工具链。</p><h2 id="安装工具链"><a href="#安装工具链" class="headerlink" title="安装工具链"></a>安装工具链</h2><p>当前工具链版本最新为 13，但是 20.04 版本的 Ubuntu 最新为 12，默认为 10。</p><h3 id="安装版本-10"><a href="#安装版本-10" class="headerlink" title="安装版本 10"></a>安装版本 10</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install clang clangd llvm liblldb-dev </span><br></pre></td></tr></table></figure><h3 id="安装版本-12"><a href="#安装版本-12" class="headerlink" title="安装版本 12"></a>安装版本 12</h3><p>我用的是最新 12 版本的<br> 使用 update-alternative 来设置 clang 默认使用 12 版本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install clang-12 clangd-12 llvm-12 liblldb-12-dev </span><br></pre></td></tr></table></figure><p><strong>可选：</strong><br> 如果你想后续均使用 12 版本，可以使用以下命令，默认将 clang 指向 12 版本。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo update-alternatives --install /usr/bin/clang clang /usr/bin/clang-12 100</span><br><span class="line">sudo update-alternatives --install /usr/bin/clangd clangd /usr/bin/clangd-12 100</span><br><span class="line">sudo update-alternatives --install /usr/bin/llvm-dis llvm-dis /usr/bin/llvm-dis-12 100</span><br></pre></td></tr></table></figure><h2 id="VScode-插件"><a href="#VScode-插件" class="headerlink" title="VScode 插件"></a>VScode 插件</h2><p>必装：</p><ol><li><p>clangd</p></li><li><p>CodeLLDB</p></li></ol><p>选装：</p><ol><li><p>Clang-Format</p></li><li><p>Clang-Tidy</p></li></ol><h3 id="CodeLLDB"><a href="#CodeLLDB" class="headerlink" title="CodeLLDB"></a>CodeLLDB</h3><p>这里安装后需要下载一个包，一般会超时。</p><ol><li>查看自己架构，一般是 X86_64</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">uname -m    </span><br><span class="line"># x86_64</span><br></pre></td></tr></table></figure><ol><li>自己下载对应架构的包，<a href="https://github.com/vadimcn/vscode-lldb/releases">下载链接</a><br> 比如这里是 x86_64 ，直接在 WSL 里面运行以下命令下载</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/vadimcn/vscode-lldb/releases/download/v1.6.10/codelldb-x86_64-linux.vsix</span><br></pre></td></tr></table></figure><ol><li>手动安装，选择刚刚下载到的安装包。图片参考 <a href="https://blog.csdn.net/Dimuky/article/details/109373334">博客</a><br> <img src="/../../../../img/blog/fcfef3558610976ad201fcc13231fb60_MD5.png"></li></ol><h2 id="配置-VScode"><a href="#配置-VScode" class="headerlink" title="配置 VScode"></a>配置 VScode</h2><h3 id="settings-json"><a href="#settings-json" class="headerlink" title="settings.json"></a>settings.json</h3><p>按下 Ctrl+Shift+P，输入 setting(设置)，找到 WSL 的选项<br><img src="/../../../../../public/img/blog/7f970935139f61c89700f15c8ec23c5e_MD5.png"><br> 粘贴以下配置：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;clangd.arguments&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="string">&quot;--compile-commands-dir=$&#123;workspaceFolder&#125;/build&quot;</span><span class="punctuation">,</span><span class="comment">//指定配置文件compelie_commands.json所在目录，这里有三种方法生成</span></span><br><span class="line">        <span class="comment">// 在后台自动分析文件（基于complie_commands)</span></span><br><span class="line">        <span class="string">&quot;--background-index&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="comment">// 同时开启的任务数量</span></span><br><span class="line">        <span class="string">&quot;-j=12&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="comment">// &quot;--folding-ranges&quot;</span></span><br><span class="line">        <span class="comment">// 告诉clangd用那个clang进行编译，路径参考which clang++的路径</span></span><br><span class="line">        <span class="string">&quot;--query-driver=/usr/bin/clang++&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="comment">// clang-tidy功能</span></span><br><span class="line">        <span class="string">&quot;--clang-tidy&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;--clang-tidy-checks=performance-*,bugprone-*&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="comment">// 全局补全（会自动补充头文件）</span></span><br><span class="line">        <span class="string">&quot;--all-scopes-completion&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="comment">// 更详细的补全内容</span></span><br><span class="line">        <span class="string">&quot;--completion-style=detailed&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;--function-arg-placeholders&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="comment">// 补充头文件的形式</span></span><br><span class="line">        <span class="string">&quot;--header-insertion=iwyu&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="comment">// pch优化的位置</span></span><br><span class="line">        <span class="string">&quot;--pch-storage=memory&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="生成-Clangd-配置文件"><a href="#生成-Clangd-配置文件" class="headerlink" title="生成 Clangd 配置文件"></a>生成 Clangd 配置文件</h3><p>clangd 对每个项目都需要生成一个名为 compile_commands.json 的配置文件，参见 <a href="https://_clang.llvm.org_docs_jsoncompilationdatabase/">官方文档</a></p><h3 id="调试-1"><a href="#调试-1" class="headerlink" title="调试"></a>调试</h3><p>通过 <a href="https://github.com/xmake-io/xmake-vscode">xmake-vscode</a> 插件配合 vscode 来实现对 c&#x2F;c++ 项目的断点调试支持。<br>另外我们还需要依赖 vscode 的 C++ 插件才能进行调试支持</p><h1 id="其他配置"><a href="#其他配置" class="headerlink" title="其他配置"></a>其他配置</h1><h2 id="clang-format"><a href="#clang-format" class="headerlink" title="clang-format"></a>clang-format</h2><p>在项目的根目录下创建一个 <code>.clang-format</code> 文件，然后添加内容：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">BasedOnStyle:</span> <span class="string">Google</span></span><br><span class="line"><span class="attr">IndentWidth:</span> <span class="number">4</span></span><br><span class="line"><span class="attr">DerivePointerAlignment:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">PointerAlignment:</span> <span class="string">Left</span></span><br></pre></td></tr></table></figure><h3 id="官方文档"><a href="#官方文档" class="headerlink" title="官方文档"></a>官方文档</h3><p><a href="https://clang.llvm.org/docs/ClangFormatStyleOptions.html">Clang-Format Style Options — Clang 18.0.0git documentation (llvm.org)</a></p>]]></content>
      
      
      <categories>
          
          <category> 应用 </category>
          
          <category> 配置 </category>
          
          <category> 语言环境配置 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>美化zsh终端</title>
      <link href="/posts/%E5%BA%94%E7%94%A8/%E9%85%8D%E7%BD%AE/%E7%BB%88%E7%AB%AF/%E7%BE%8E%E5%8C%96zsh%E7%BB%88%E7%AB%AF.html"/>
      <url>/posts/%E5%BA%94%E7%94%A8/%E9%85%8D%E7%BD%AE/%E7%BB%88%E7%AB%AF/%E7%BE%8E%E5%8C%96zsh%E7%BB%88%E7%AB%AF.html</url>
      
        <content type="html"><![CDATA[<h1 id="Zsh-安装"><a href="#Zsh-安装" class="headerlink" title="Zsh 安装"></a>Zsh 安装</h1><ul><li>查看自己系统是否存在 zsh</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /etc/shells</span><br></pre></td></tr></table></figure><ul><li>查看是否是使用的 zsh</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo $SHELL</span><br></pre></td></tr></table></figure><ul><li>ubuntu</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">apt-get update</span><br><span class="line"># ubuntu下载安装zsh</span><br><span class="line">apt install zsh -y</span><br><span class="line"># 切换</span><br><span class="line">chsh -s /bin/zsh</span><br><span class="line">reboot</span><br></pre></td></tr></table></figure><p>第一次进入 Zsh 会自动出现一个配置界面，这个界面可以根据需要自定义 Zsh。</p><p><img src="/../../../../img/blog/c773655c02f59e687eaea4359fb5a6ff_MD5.png"></p><p>在这里输入  <code>1</code>  就可以进入配置界面了。</p><p><img src="/../../../../img/blog/bc5c230efde8f4fd68396d10c8dfef9d_MD5.png"></p><p>配置界面中各个菜单代表的意思分别是：</p><ul><li><code>1</code>：设置命令历史记录相关的选项</li><li><code>2</code>：设置命令补全系统</li><li><code>3</code>：设置热建</li><li><code>4</code>：选择各种常见的选项，只需要选择 “On” 或者 “Off”</li><li><code>0</code>：退出，并使用空白（默认）配置</li><li><code>a</code>：终止设置并退出</li><li><code>q</code>：退出</li></ul><p>这里根据提示，然后按照你自己的喜好配置就可以了。配置好后，会在你的用户目录下生成  <code>.zshrc</code>  文件。然后我们要去这个文件中启用插件和主题。</p><h2 id="Ubuntu-安装插件"><a href="#Ubuntu-安装插件" class="headerlink" title="Ubuntu 安装插件"></a>Ubuntu 安装插件</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install zsh-autosuggestions zsh-syntax-highlighting autojump exa</span><br></pre></td></tr></table></figure><p><a href="https://github.com/wting/autojump">autojump</a> 实现目录间的快速跳转。<br>如果使用「autojump」，只需要输入</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ j 路径关键词</span><br></pre></td></tr></table></figure><p><img src="/../../../../img/blog/2710cb80bea91134d1f934f9ac51d6ae_MD5.png"></p><p>可以看到直接跳进该路径下了。</p><p>「autojump」会按照关键词使用频率做一个排序，有的时候有一些路径有相似的关键词时，使用「tab」可以查看排序，例如：</p><p><img src="/../../../../img/blog/4f336a6ce3326ab7784225b14a3ba6f4_MD5.png"></p><p>想访问哪一个，输入相应的数字即可。</p><ol><li><p>autojump 只能跳转到已经用 <code>cd</code> 进入过的目录，无法跳转到没有用 <code>cd</code> 进入过的目录。即使用 cd 进入过一个特定的目录才会被记录到 autojump 的数据库中，才可以使用 autojump 进行跳转。</p></li><li><p>自动跳转不支持 <code>-</code> 开头的目录。</p></li></ol><blockquote><p><a href="https://github.com/zsh-users/zsh-autosuggestions">zsh-autosuggestion</a><br> 基于历史记录，进行命令的推荐和补全。<br> <a href="https://github.com/zsh-users/zsh-syntax-highlighting">zsh-syntax-highlighting</a><br> 对输入的命令提供高亮显示和语法检查。<br> <a href="https://github.com/ogham/exa">exa</a><br> 用于替代原生的  <code>ls</code>，通过不同的颜色来更好地区分文件的类型及相关的元属性。</p></blockquote><h1 id="powerlevel10k-安装"><a href="#powerlevel10k-安装" class="headerlink" title="powerlevel10k 安装"></a>powerlevel10k 安装</h1><p>打开此链接 <a href="https://github.com/romkatv/powerlevel10k">github</a>，进入到库里面，按照安装步骤：</p><ol><li><p>安装字体：随便下载一个字体，我是下载了第一个，然后双击下载文件，最后我们开启 terminal，点击偏好设置，在字体那个地方点击更改，右上角搜索 Meslo 就能看到你安装的字体<br><img src="/../../../../img/blog/6c989af71948343f43ee1567004d0930_MD5.png" alt="在这里插入图片描述"></p></li><li><p>安装 powerlevel10k</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone --depth=1 https://gitee.com/romkatv/powerlevel10k.git ~/module/powerlevel10k</span><br></pre></td></tr></table></figure><p>你要是用着之后想换的话直接在命令行里加</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p10k configure</span><br></pre></td></tr></table></figure><h1 id="Zsh-Vi-mod"><a href="#Zsh-Vi-mod" class="headerlink" title="Zsh Vi mod"></a>Zsh Vi mod</h1><p><a href="https://github.com/jeffreytse/zsh-vi-mode#custom-escape-key">jeffreytse&#x2F;zsh-vi-mode: 💻 A better and friendly vi(vim) mode plugin for ZSH. (github.com)</a><br>使用 vi 模式编辑命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://gitee.com/mirrors_jeffreytse/zsh-vi-mode.git ~/module/zsh-vi-mode</span><br></pre></td></tr></table></figure><h1 id="Fzf-tab"><a href="#Fzf-tab" class="headerlink" title="Fzf-tab"></a>Fzf-tab</h1><p><a href="https://github.com/Aloxaf/fzf-tab">Aloxaf&#x2F;fzf-tab: Replace zsh’s default completion selection menu with fzf! (github.com)</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install fzf</span><br><span class="line">git clone https://gitee.com/mirrors_Aloxaf/fzf-tab.git ~/module/fzf-tab</span><br></pre></td></tr></table></figure><h1 id="x2F-zshrc"><a href="#x2F-zshrc" class="headerlink" title="~&#x2F;.zshrc"></a>~&#x2F;.zshrc</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">source /usr/share/zsh-autosuggestions/zsh-autosuggestions.zsh</span><br><span class="line">source /usr/share/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh</span><br><span class="line">source /usr/share/autojump/autojump.zsh</span><br><span class="line">source ~/module/zsh-vi-mode/zsh-vi-mode.plugin.zsh</span><br><span class="line">source ~/module/powerlevel10k/powerlevel10k.zsh-theme</span><br><span class="line">source ~/module/fzf-tab/fzf-tab.plugin.zsh</span><br><span class="line">alias ls=&quot;exa&quot;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 应用 </category>
          
          <category> 配置 </category>
          
          <category> 终端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows的shell美化</title>
      <link href="/posts/%E5%BA%94%E7%94%A8/%E9%85%8D%E7%BD%AE/%E7%BB%88%E7%AB%AF/Windows%E7%9A%84shell%E7%BE%8E%E5%8C%96.html"/>
      <url>/posts/%E5%BA%94%E7%94%A8/%E9%85%8D%E7%BD%AE/%E7%BB%88%E7%AB%AF/Windows%E7%9A%84shell%E7%BE%8E%E5%8C%96.html</url>
      
        <content type="html"><![CDATA[<h1 id="Powershell-美化"><a href="#Powershell-美化" class="headerlink" title="Powershell 美化"></a>Powershell 美化</h1><h2 id="安装-NF-字体"><a href="#安装-NF-字体" class="headerlink" title="安装 NF 字体"></a>安装 NF 字体</h2><p>后面介绍的一些功能会有显示一些特殊字符的需求，所以这里我们要提前安装一些支持特殊字符的字体。而 <a href="https://link.zhihu.com/?target=https://github.com/ryanoasis/nerd-fonts">nerd-fonts</a> 这个项目，包含了众多适配过特殊字符的字体，可以放心使用。这里推荐 <code>Meslo-Nerd-Fonts</code>，可以在 scoop 中安装。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># scoop默认没有开启nerd-fonts分类，需要开启才能安装相关字体</span><br><span class="line">scoop bucket add nerd-fonts</span><br><span class="line"># 安装字体时需要在管理员权限的终端中运行</span><br><span class="line">scoop install Meslo-NF-Mono</span><br></pre></td></tr></table></figure><h2 id="Windows-Terminal-终端-选项"><a href="#Windows-Terminal-终端-选项" class="headerlink" title="Windows Terminal (终端) 选项"></a>Windows Terminal (终端) 选项</h2><p>然后再来配置一下 Windows Terminal (终端) ，点击下拉菜单选择设置打开设置标签页，然后依次修改以下选项：</p><ul><li>启动 -&gt; 默认配置文件，改为 Powershell，如果你已经安装了 Powershell 7.2，这里应当可以自动搜索到。否则可能需要手动编辑配置文件。</li><li>启动 -&gt; 默认终端应用程序，改为 Windows Terminal (终端) 。</li><li>外观 -&gt; 在选项卡中显示亚力克效果，选择启用。</li><li>配色方案，这里可以根据自己喜好调整。</li><li>配置文件默认值 -&gt; 外观 -&gt; 字体，改为 <code>MesloLGS NF</code> 字体，字号按照自己屏幕大小选择，再开启亚力克效果，透明度选择 70% 左右。</li></ul><h2 id="对所有终端生效"><a href="#对所有终端生效" class="headerlink" title="对所有终端生效"></a>对所有终端生效</h2><p>在终端中配置只能在当前终端生效，为了让它能够在所有 Powershell 中永久生效，需要在配置文件中编辑。</p><p>在 Powershell 中运行以下命令，用 vscode 打开 Powershell 的配置文件，如果你没有 vscode，也可以改成 notepad 用记事本来编辑配置文件。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">code $PROFILE</span><br></pre></td></tr></table></figure><h2 id="安装-Oh-my-posh"><a href="#安装-Oh-my-posh" class="headerlink" title="安装 Oh-my-posh"></a>安装 Oh-my-posh</h2><p>oh-my-posh 是一个 Powershell 的主题项目，可以将 Powershell 美化成类似 ohmyzsh 的效果。安装 oh-my-posh 也很简单，运行下面的命令即可。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scoop install oh-my-posh</span><br></pre></td></tr></table></figure><p>这里有很多主题可供选择，<a href="https://link.zhihu.com/?target=https://ohmyposh.dev/docs/themes">https://ohmyposh.dev/docs/themes</a>。选择好后，在 Powershell 的配置文件中填入以下内容。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">oh-my-posh init pwsh --config &quot;$env:POSH_THEMES_PATH\powerlevel10k_rainbow.omp.json&quot; | Invoke-Expression</span><br></pre></td></tr></table></figure><h2 id="PSReadLine"><a href="#PSReadLine" class="headerlink" title="PSReadLine"></a>PSReadLine</h2><p>想让 Powershell 也拥有提示和补全功能？PSReadLine 可以帮你，这是一个可以增强终端体验的工具。</p><h3 id="安装-PSReadLine"><a href="#安装-PSReadLine" class="headerlink" title="安装 PSReadLine"></a>安装 PSReadLine</h3><p><a href="https://github.com/PowerShell/PSReadLine">PowerShell&#x2F;PSReadLine: A bash inspired readline implementation for PowerShell (github.com)</a><br>确保你使用的是 Powershell 7.2，然后运行下面的命令。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Install-Module PSReadLine -AllowPrerelease -Force</span><br><span class="line"># 或者你喜欢稳定版</span><br><span class="line">Install-Module PSReadLine -Scope CurrentUser</span><br></pre></td></tr></table></figure><h3 id="使用-PSReadLine"><a href="#使用-PSReadLine" class="headerlink" title="使用 PSReadLine"></a>使用 PSReadLine</h3><p>要使用 PSReadLine，同样需要在 <code>$PROFILE</code> 中添加一些配置，可以参考 <a href="https://link.zhihu.com/?target=https://docs.microsoft.com/zh-cn/powershell/module/psreadline/about/about_psreadline">官方文档</a></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">Import-Module PSReadLine</span><br><span class="line"></span><br><span class="line">Set-PSReadLineOption -EditMode Emacs</span><br><span class="line"></span><br><span class="line">Set-PSReadLineOption -PredictionSource HistoryAndPlugin</span><br><span class="line"></span><br><span class="line">Set-PSReadLineOption -PredictionViewStyle ListView</span><br><span class="line"></span><br><span class="line">Set-PSReadLineOption -BellStyle None</span><br><span class="line">```![](../../../../img/blog/a0856b932f590f9d9865faae32807172_MD5.jpg)dows Terminal 有了图形界面，直接选择就好</span><br><span class="line"></span><br><span class="line">![](../../../img/blog/a0856b932f590f9d9865faae32807172_MD5.jpg)</span><br><span class="line"></span><br><span class="line">具体 json 文件配置</span><br><span class="line"></span><br><span class="line">```json</span><br><span class="line">&quot;defaultProfile&quot;: &quot;&#123;c891c3d2-b798-4857-83c0-89bf2ea34021&#125;&quot;,</span><br><span class="line">    &quot;profiles&quot;: </span><br><span class="line">    &#123;</span><br><span class="line">        &quot;defaults&quot;: </span><br><span class="line">        &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;list&quot;: </span><br><span class="line">        [</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;commandline&quot;: &quot;D:\\Environment\\Git\\bin\\bash.exe --login -i&quot;,</span><br><span class="line">                &quot;guid&quot;: &quot;&#123;c891c3d2-b798-4857-83c0-89bf2ea34021&#125;&quot;,</span><br><span class="line">                &quot;name&quot;: &quot;Git Bash&quot;,</span><br><span class="line">                &quot;icon&quot;: &quot;D:\\Program_Files\\Git\\mingw64\\share\\git\\git-for-windows.ico&quot;</span><br><span class="line">            &#125;,</span><br></pre></td></tr></table></figure><p>其中 <code>&quot;commandline&quot;: &quot;D:\\Environment\\Git\\bin\\bash.exe --login -i&quot;,</code></p><h2 id="Pacman-环境配置"><a href="#Pacman-环境配置" class="headerlink" title="Pacman 环境配置"></a>Pacman 环境配置</h2><p><a href="https://github.com/LcJuves/lcjuves/blob/main/clang/linux-like/git_bash_install_pacman.sh">lcjuves&#x2F;git_bash_install_pacman.sh at main · LcJuves&#x2F;lcjuves · GitHub</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rm /usr/bin/msys-pcre-1.dll</span><br><span class="line">pacman -S zsh</span><br></pre></td></tr></table></figure><h2 id="配置默认启动-Zsh"><a href="#配置默认启动-Zsh" class="headerlink" title="配置默认启动 Zsh"></a>配置默认启动 Zsh</h2><p>在 <code>../Git/etc/bash.bashrc</code> 文件末尾追加以下内容：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Launch ![](../../../../img/blog/1535f6e4f7b9a2d8a37206c1b8d4b382_MD5.jpg)h`，都会是 zsh。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># UNIX 工具链</span></span><br><span class="line"></span><br><span class="line">```text</span><br><span class="line">scoop install busybox</span><br></pre></td></tr></table></figure><p>安装完成之后，来试用一下：</p><p><img src="/../../../img/blog/1535f6e4f7b9a2d8a37206c1b8d4b382_MD5.jpg"></p><p>输出 ls 命令结果的前几行</p><p>删除 Powershell 中的 ls</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Remove-Alias ls</span><br></pre></td></tr></table></figure><p>这个包还提供了很多常用工具，基本可以满足日常需要，大家可以都试一下。</p><h1 id="Sudo"><a href="#Sudo" class="headerlink" title="Sudo"></a>Sudo</h1><p>Linux 最好用的命令是什么？sudo！一键切换管理员权限，Powershell 每次发现忘了开管理员，就得重开一个，很麻烦的有没有！</p><p>所以我们来给 Windows 装一个 sudo：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scoop search sudo</span><br></pre></td></tr></table></figure><p>然后就可以爽到飞起了。以后不管什么命令失败，都可以 sudo 试一试。</p><h1 id="Zoxide-快速跳转"><a href="#Zoxide-快速跳转" class="headerlink" title="Zoxide 快速跳转"></a>Zoxide 快速跳转</h1><p><a href="https://github.com/img/blog/ae38a29dbac83120198414e614bea326_MD5.gif">ajeetdsouza&#x2F;zoxide: A smarter cd command. Supports all major shells. (github.com)</a>l 集成 | Microsoft Learn](https<img src="/../../../../img/blog/8d22e1a4b46e8f326c1139f6d2a060e1_MD5.gif" alt="图片">egration)</p><ul><li>标签拆分</li></ul><p> </p><p><img src="/../../../img/blog/ae38a29dbac83120198414e614bea326_MD5.gif" alt="图片"></p><p>您还可以将标签从一个终端窗口移动到另一个终端窗口。</p><p><img src="/../../../img/blog/8d22e1a4b46e8f326c1139f6d2a060e1_MD5.gif" alt="图片"></p>]]></content>
      
      
      <categories>
          
          <category> 应用 </category>
          
          <category> 配置 </category>
          
          <category> 终端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo配置</title>
      <link href="/posts/%E5%BA%94%E7%94%A8/%E9%85%8D%E7%BD%AE/%E5%8D%9A%E5%AE%A2%E9%85%8D%E7%BD%AE/Hexo%E9%85%8D%E7%BD%AE.html"/>
      <url>/posts/%E5%BA%94%E7%94%A8/%E9%85%8D%E7%BD%AE/%E5%8D%9A%E5%AE%A2%E9%85%8D%E7%BD%AE/Hexo%E9%85%8D%E7%BD%AE.html</url>
      
        <content type="html"><![CDATA[<h1 id="Hexo-安装配置"><a href="#Hexo-安装配置" class="headerlink" title="Hexo 安装配置"></a>Hexo 安装配置</h1><h2 id="Node-Js-安装设置"><a href="#Node-Js-安装设置" class="headerlink" title="Node.Js 安装设置"></a>Node.Js 安装设置</h2><p>安装完成后，要查看我们是否安装成功，可以打开命令提示符（<code>Win + R</code>），输入 <code>cmd</code> 打开控制台，输入如下命令，如果出现对应版本号，说明安装成功了；</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">node -v</span><br><span class="line">npm -v</span><br></pre></td></tr></table></figure><p>由于下载包是从国外服务器，所以速度较慢，因此我们推荐用阿里的国内镜像进行设置；</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm config <span class="built_in">set</span> registry https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure><h2 id="Hexo-安装"><a href="#Hexo-安装" class="headerlink" title="Hexo 安装"></a>Hexo 安装</h2><p>在你的硬盘上找个地儿，用来存放你的博客文件，比如我的就在 <code>D:personalFiles/github/blog</code>，这个文件夹你可以根据自己的喜好来设置。然后从命令台进入当前文件夹，接下来就是安装过程了；</p><p>首先安装 Hexo</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i hexo-cli -g</span><br></pre></td></tr></table></figure><p>新建一个文件夹用于存放你的博客，比如我的是 <code>blog</code>，然后进入该文件夹，并用如下命令进行初始化并安装必备组件；</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo init .</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure><p>然后输入如下命令，然后在浏览器中打开 <code>http://localhost:4000</code>；</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">新建博客</span></span><br><span class="line">hexo new &quot;博客名&quot;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">生成静态网页</span></span><br><span class="line">hexo g</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">打开本地服务器</span></span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure><h2 id="创建-Github-Pages-仓库"><a href="#创建-Github-Pages-仓库" class="headerlink" title="创建 Github Pages 仓库"></a>创建 Github Pages 仓库</h2><p>GitHub 主页右上角加号 -&gt; New repository：</p><ul><li>Repository name 中输入 <code>用户名.github.io</code>(<font color="#00b050">最好均为小写字母</font>)</li><li>勾选 “Initialize this repository with a README”</li><li>Description 选填</li></ul><p>填好后点击 Create repository 创建。<br>创建后默认自动启用 HTTPS，博客地址为：<code>https://用户名.github.io</code></p><h2 id="部署-Hexo-到-GitHub-Pages"><a href="#部署-Hexo-到-GitHub-Pages" class="headerlink" title="部署 Hexo 到 GitHub Pages"></a>部署 Hexo 到 GitHub Pages</h2><p>本地博客测试成功后，就是上传到 GitHub 进行部署，使其能够在网络上访问。</p><p>首先<strong>安装 hexo-deployer-git</strong>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p>然后<strong>修改 _config.yml</strong> 文件末尾的 Deployment 部分，修改成如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repository:</span> <span class="string">git@github.com:用户名/用户名.github.io.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">main</span></span><br></pre></td></tr></table></figure><p>完成后运行 <code>hexo d</code> 将网站上传部署到 GitHub Pages。</p><p>完成！这时访问我们的 GitHub 域名 <code>https://用户名.github.io</code> 就可以看到 Hexo 网站了。</p><h1 id="在-Obsidian-中执行-Shell-命令"><a href="#在-Obsidian-中执行-Shell-命令" class="headerlink" title="在 Obsidian 中执行 Shell 命令"></a>在 Obsidian 中执行 Shell 命令</h1><p>而 Shell commands 可以在 Obsidian 中设置好命令，并通过 Obsidian 的命令面板或快捷键快速运行。</p><p>在插件设置面板中添加命令：</p><p><img src="/../../../../img/blog/48f3cbd2ed2ea9918c17f72ba4e3e2f1_MD5.webp"></p><p>运行博客：</p><ul><li>Shell commands 没有显示终端窗口的功能，所以需要我们启动 powershell 再传入命令</li><li>有了终端窗口我们才可以在窗口中按 Ctrl + C 关闭 Hexo 服务，否则它会一直占用端口</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">start powershell <span class="string">&#x27;-NoExit -Command start http://localhost:4000 ; cd Blog ; hexo s&#x27;</span></span><br></pre></td></tr></table></figure><p>打开站点和主题配置文件：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">start Blog/_config.yml</span><br><span class="line">start Blog/themes/butterfly4.3.1/_config.yml</span><br></pre></td></tr></table></figure><p>然后修改默认执行环境为 PowerShell 5：</p><p><img src="/../../../../img/blog/a71dfad1e73f7d9f594fcc596e01b933_MD5.webp"></p><p>点这个按钮可以执行测试我们的命令：</p><p><img src="/../../../../img/blog/a5f82f052ff8f87198c08d18cc7af9b9_MD5.webp"></p><p>如果你遇到了这个错误：<code>hexo:无法加载文件C:\Users\xxx\AppData\Roaming\npm\hexo.ps1，因为在此系统上禁止运行脚本。</code> 只需在 Windows 设置&gt;更新和安全&gt;开发者选项，找到 PowerShell，点下应用即可：</p><p><img src="/../../../../img/blog/d23fe3ad93154ab94982bbe124d0e4c8_MD5.webp"></p><p>Ctrl+P 打开命令面板，输入 Shell commands 即可找到我们定义好的命令：</p><p><img src="/../../../../img/blog/3462bd22140ba71844ee901f66488eae_MD5.webp"></p><p>可以为每个命令设置下别名，就是在命令面板显示的名字：</p><p><img src="/../../../../img/blog/73564a2b5df297eafa35b27106300f77_MD5.png"></p><p><img src="/../../../../img/blog/f44caffc478975f0b99d1d7569206153_MD5.webp"></p><p>在 Hotkeys 面板中为我们的命令设置好快捷键，就可以通过快捷键快速执行命令了：</p><p><img src="/../../../../img/blog/43cdf9a774dbfec85ff37576057b5034_MD5.webp"></p><h1 id="Hexo-Obsidian-内部链接跳转"><a href="#Hexo-Obsidian-内部链接跳转" class="headerlink" title="Hexo+Obsidian 内部链接跳转"></a>Hexo+Obsidian 内部链接跳转</h1><ul><li>Obsidian 选择基于当前笔记的相对路径，关闭 WIKi 链接</li><li>Hexo 需要修改永久链接模式 <a href="https://hexo.io/zh-cn/docs/permalinks.html">永久链接（Permalinks）| Hexo</a>，修改 <code>_config.yml</code> 中的</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">permalink:</span> <span class="string">posts/:category/:post_title.html</span></span><br></pre></td></tr></table></figure><ul><li>不同级目录下的跳转</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[深度学习-图像视频文本标注工具](../../工具使用/深度学习-图像视频文本标注工具)</span><br></pre></td></tr></table></figure><p>需要去掉. md 后缀，采用以下 python 脚本自动全部去除, 脚本放在根目录</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义要查找的文件夹路径和要替换的链接格式</span></span><br><span class="line">folder_path = <span class="string">r&quot;.\source\_posts/&quot;</span></span><br><span class="line">link_pattern = <span class="string">r&quot;\[(.*?)\]\((.*?).md\)&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 遍历文件夹中的所有Markdown文件</span></span><br><span class="line"><span class="keyword">for</span> root, dirs, files <span class="keyword">in</span> os.walk(folder_path):</span><br><span class="line">    <span class="keyword">for</span> file <span class="keyword">in</span> files:</span><br><span class="line">        <span class="keyword">if</span> file.endswith(<span class="string">&quot;.md&quot;</span>):</span><br><span class="line">            file_path = os.path.join(root, file)</span><br><span class="line">            <span class="keyword">with</span> <span class="built_in">open</span>(file_path, <span class="string">&quot;r&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">                content = f.read()</span><br><span class="line">            <span class="comment"># 使用正则表达式查找并替换链接</span></span><br><span class="line">            new_content = re.sub(link_pattern, <span class="string">r&quot;[\1](\2)&quot;</span>, content)</span><br><span class="line">            <span class="keyword">with</span> <span class="built_in">open</span>(file_path, <span class="string">&quot;w&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">                f.write(new_content)</span><br></pre></td></tr></table></figure><p>借鉴 <a href="./Hexo%E6%8F%92%E4%BB%B6">Hexo插件</a> 中的钩子函数实现提交时自动更新</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">hexo generate &amp;&amp; python changemd.py &amp;&amp; git add .</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 应用 </category>
          
          <category> 配置 </category>
          
          <category> 博客配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
