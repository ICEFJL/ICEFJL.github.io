<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>nix包管理器</title>
      <link href="/posts/%E6%9C%AC%E5%9C%B0/nix%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8.html"/>
      <url>/posts/%E6%9C%AC%E5%9C%B0/nix%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8.html</url>
      
        <content type="html"><![CDATA[<h1 id="安装-Nix"><a href="#安装-Nix" class="headerlink" title="安装 Nix"></a>安装 Nix</h1><p>nix 是一个函数式的包管理器，想像成 apt-get 或者 homevrew 这种的，或者 npm。</p><p>在命令行执行 <code>curl -L https://nixos.org/nix/install | sh</code> 就可以自动安装 nix</p><p>如果被墙，也可以使用清华镜像站的 <code>sh &lt;(curl https://mirrors.tuna.tsinghua.edu.cn/nix/latest/install)</code></p><h2 id="更换镜像-可选"><a href="#更换镜像-可选" class="headerlink" title="更换镜像 (可选)"></a>更换镜像 (可选)</h2><p>目前已知的有清华镜像站 <a href="https://mirrors.tuna.tsinghua.edu.cn/help/nix/">https://mirrors.tuna.tsinghua.edu.cn/help/nix/</a></p><p>可以通过在 <code>~/.config/nix/nix.conf</code> 文件中写入以下内容，获得安装加速</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">substituters = https://mirrors.tuna.tsinghua.edu.cn/nix-channels/store https://cache.nixos.org/</span><br></pre></td></tr></table></figure><p>并且执行以下命令获得源码下载加速</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nix-channel --add https://mirrors.tuna.tsinghua.edu.cn/nix-channels/nixpkgs-unstable nixpkgs</span><br><span class="line">nix-channel --update</span><br></pre></td></tr></table></figure><h1 id="包管理"><a href="#包管理" class="headerlink" title="包管理"></a>包管理</h1><h2 id="搜索并安装包"><a href="#搜索并安装包" class="headerlink" title="搜索并安装包"></a>搜索并安装包</h2><p>安装 Nix 包管理器后，下一步是搜索包。</p><p>首先，<a href="https://search.nixos.org/packages">访问 Nix 搜索的官方页面</a> 并输入你要安装的软件包的名称。</p><p>从给定的描述中，你可以找到所需的软件包，然后选择 <code>nix-env</code> 进行永久安装。</p><p>在这里，你可以添加一些额外的关键字以获得更好的搜索结果。例如，在这里，我搜索 “Firefox browser”：</p><p><img src="/../../img/blog/7accd62ac8fdfa5dfab86af10bcc804a_MD5.png"></p><p>我上面提到的最后一步（” 复制命令 “）什么也不做，只是为你提供了一个用于安装的命令。</p><p>现在，你所要做的就是在终端中执行该命令。</p><p>就我而言，它给了我以下命令来安装 Firefox：</p><p> <code>nix-env -iA nixpkgs.firefox</code></p><p>完成后，你可以使用以下命令列出已安装的软件包：</p><p> <code>nix-env -q</code></p><h3 id="安装旧版包"><a href="#安装旧版包" class="headerlink" title="安装旧版包"></a>安装旧版包</h3><p>在 nix 中，官方的 Channel 是 <a href="https://github.com/NixOS/nixpkgs">nixpkgs</a>，这个 Channel 是通过 git 管理的。</p><p>通过 <code>nix-env -qaP go</code> 可以看到，目前最新版本提交的 nixpkgs 的 Go 只有最新的三个版本 1.18、1.19 和 1.20。</p><p>上文对于 Go 的安装，使用的是最新 commit 的 nixpkgs （通过 nix-channel 配置）。</p><p>而 <code>nix-env</code> 还提供了基于某个特殊版本的 nixpkgs 的安装机制。如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nix-env -iA go -f https://github.com/NixOS/nixpkgs/archive/d1c3fea7ecbed758168787fe4e4a3157e52bc808.tar.gz</span><br></pre></td></tr></table></figure><p>很多时候，我们希望，安装更旧版本的依赖时，就需要获取到包含更旧 Go 的配置的 nixpkgs 那个 commit 的快照。</p><p>因此，现在的问题是，如何通过包名查询历史版本对应的 commit，然后通过上文的类似于 <code>https://github.com/NixOS/nixpkgs/archive/$commitID.tar.gz</code> 的方式即可安装旧版本的包。</p><p>nixpkgs 官方并未提供该能力，但是幸运的是 nix 社区有一个站点可以查询这些信息： <a href="https://lazamar.co.uk/nix-versions/">https://lazamar.co.uk/nix-versions/</a> 。</p><p>其原理可以参见：<a href="https://lazamar.github.io/download-specific-package-version-with-nix/">该站点作者博客</a>。</p><p>此外，该项目已开源，参见： <a href="https://github.com/lazamar/nix-package-versions">lazamar&#x2F;nix-package-versions</a>。</p><p>nixpkgs 官方关于安装旧版包的讨论参见：<a href="https://github.com/NixOS/nixpkgs/issues/9682">No way to install&#x2F;use a specific package version? #9682</a>。</p><p>注意：</p><ul><li>中国大陆地区，建议先通过科学上网，clone 下整个 <a href="https://github.com/NixOS/nixpkgs">https://github.com/NixOS/nixpkgs</a> 仓库（几个 G 大小），然后 checkout 到指定版本，然后在通过 <code>nix-env -f</code> 指定到 nixpkgs 根目录目录。</li><li>从多个历史 commit 的 nixpkgs 安装包会导致磁盘占用快速上升。</li></ul><h2 id="使用包而不安装它们"><a href="#使用包而不安装它们" class="headerlink" title="使用包而不安装它们"></a>使用包而不安装它们</h2><p>到目前为止，这是 Nix 包管理器的最佳功能，因为你可以使用&#x2F;测试包甚至不用安装它！</p><p>为此，你可以使用 Nix Shell，它允许你将交互式 Shell 与指定的包一起使用，关闭后，你将无法再访问该包。</p><p>要使用 nix-shell 访问你喜欢的软件包，请使用以下命令语法：</p><p><code>nix-shell -p &lt;package_name&gt;</code></p><p>例如，我想使用一次 <code>neofetch</code>，所以我使用了以下命令：</p><p><code>nix-shell -p neofetch</code></p><p><img src="/../../img/blog/1bb0cda327dc537bcd941f3cb0c62447_MD5.png"></p><p>要退出 Shell，你所要做的就是执行 <code>exit</code> 命令：</p><h2 id="使用-Nix-包管理器更新包"><a href="#使用-Nix-包管理器更新包" class="headerlink" title="使用 Nix 包管理器更新包"></a>使用 Nix 包管理器更新包</h2><p>使用 Nix 包管理器更新包非常简单。</p><p>要更新软件包，首先，你需要使用以下命令更新频道：</p><p> <code>nix-channel --update</code></p><p>接下来，你可以通过试运行更新命令来列出过时的软件包：</p><p> <code>nix-env --upgrade --dry-run</code></p><p><img src="/../../img/blog/eaba90663a964c56bdcc715813bc86f2_MD5.png"></p><p>要更新单个包，请使用以下命令：</p><p> <code>nix-env -u &lt;Package_name&gt;</code></p><p>如果你想一次更新所有软件包，请使用以下命令：</p><p> <code>nix-env -u</code></p><h2 id="使用-Nix-包管理器删除包"><a href="#使用-Nix-包管理器删除包" class="headerlink" title="使用 Nix 包管理器删除包"></a>使用 Nix 包管理器删除包</h2><p>要删除软件包，你只需按以下方式执行 <code>nix-env</code> 命令即可：</p><p> <code>nix-env --uninstall [package_name]</code></p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="https://www.rectcircle.cn/posts/nix-1-package-manager/">Nix 详解（一） 像传统包管理器一样使用 Nix :: Rectcircle Blog</a></li><li><a href="https://www.rectcircle.cn/posts/nix-2-project-external-dependencies-manager/">Nix 详解（二） 项目外部依赖管理 :: Rectcircle Blog</a></li><li><a href="https://www.rectcircle.cn/posts/nix-3-nix-dsl/">Nix 详解（三） nix 领域特定语言 :: Rectcircle Blog</a></li><li><a href="https://www.rectcircle.cn/posts/nix-4-http-binary-cache/">Nix 详解（四） HTTP 二进制缓存详解 :: Rectcircle Blog</a></li><li><a href="https://www.rectcircle.cn/posts/nix-5-how-to-use-in-rd-group/">Nix 详解（五）在研发团队中落地设计 :: Rectcircle Blog</a></li><li><a href="https://www.rectcircle.cn/posts/nix-6-cheat-sheet/">Nix 详解（六） 备忘单 :: Rectcircle Blog</a></li></ul><h1 id="通过-NixOS-释放其全部潜力"><a href="#通过-NixOS-释放其全部潜力" class="headerlink" title="通过 NixOS 释放其全部潜力"></a>通过 NixOS 释放其全部潜力</h1><p>如果你喜欢 Nix 包管理器背后的想法，请相信我，你一定会喜欢 <a href="https://nixos.org/">NixOS</a>。</p><p>仅使用一个配置文件来复制整个系统就足以说服我切换到 NixOS，但还有更多原因：</p><p>我喜欢 NixOS。以至于我写了整个系列，这样你就不必阅读文档（基础知识）：</p><blockquote><p><strong><a href="https://linux.cn/article-15606-1.html">NixOS 系列</a></strong><br><strong><a href="https://www.rectcircle.cn/posts/nixos/">NixOS 指南 :: Rectcircle Blog</a></strong></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 本地 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nix </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>键盘按键映射</title>
      <link href="/posts/%E6%9C%AC%E5%9C%B0/%E9%94%AE%E7%9B%98%E6%8C%89%E9%94%AE%E6%98%A0%E5%B0%84.html"/>
      <url>/posts/%E6%9C%AC%E5%9C%B0/%E9%94%AE%E7%9B%98%E6%8C%89%E9%94%AE%E6%98%A0%E5%B0%84.html</url>
      
        <content type="html"><![CDATA[<h1 id="autohotkey"><a href="#autohotkey" class="headerlink" title="autohotkey"></a>autohotkey</h1><p><a href="https://zhuanlan.zhihu.com/p/360570752">AutoHotKey | 基础用法 + 示例 - 知乎 (zhihu.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> 本地 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu下bochs安装步骤</title>
      <link href="/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/Ubuntu%E4%B8%8Bbochs%E5%AE%89%E8%A3%85%E6%AD%A5%E9%AA%A4.html"/>
      <url>/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/Ubuntu%E4%B8%8Bbochs%E5%AE%89%E8%A3%85%E6%AD%A5%E9%AA%A4.html</url>
      
        <content type="html"><![CDATA[<h1 id="安装-bochs"><a href="#安装-bochs" class="headerlink" title="安装 bochs"></a>安装 bochs</h1><h2 id="下载-bochs"><a href="#下载-bochs" class="headerlink" title="下载 bochs"></a>下载 bochs</h2><p><strong>打开 vmtools，一开始是在桌面的，我们点到 home 目录，然后将下载好的 bochs 拉过去即可</strong><br>然后使用如下命令解压：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -xzvf bochs-2.6.11.tar.gz</span><br></pre></td></tr></table></figure><p>解压后可以看到一个新的文件夹（如图所示）</p><p><img src="/../../img/blog/88f9ad869190b3676eed730240c26089_MD5.webp"></p><p>然后通过运行下面一条命令进入到该文件夹中</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd bochs-2.6.11</span><br></pre></td></tr></table></figure><h2 id="2-配置环境"><a href="#2-配置环境" class="headerlink" title="2. 配置环境"></a>2. 配置环境</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install build-essential</span><br><span class="line">sudo apt install xorg-dev</span><br></pre></td></tr></table></figure><h3 id="3-选择功能"><a href="#3-选择功能" class="headerlink" title="3. 选择功能"></a>3. 选择功能</h3><p>接下来则是配置虚拟机的功能。</p><p>在 bochs-2.6.11 目录下执行以下命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./configure --prefix=/home/xxx/bochs --enable-debugger --enable-disasm --enable-iodebug --enable-iodebug --enable-x86-debugger --with-x --with-x11 LDFLAGS=<span class="string">&#x27;-pthread&#x27;</span> LIBS=<span class="string">&#x27;-lX11&#x27;</span></span><br></pre></td></tr></table></figure><p>2.7 版本没有–enable-disasm 选项，可不填<br>接下来执行以下命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><p>若两条指令在运行中均未报错则可进入下一步。</p><h3 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h3><p>Ubuntu 20.04 系统默认的 shell 是 bash。如果你没有改过的话你需要在主目录下执行以下命令：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gedit .bashrc</span><br></pre></td></tr></table></figure><p>如果你使用的是 zsh 的话把.bashrc 换成.zshrc 就行。</p><p>然后找个空行把以下代码加进去：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> PATH=/your_absolute_path/bochs/bin:<span class="variable">$PATH</span></span><br><span class="line"><span class="built_in">export</span> PATH=/your_absolute_path/bochsgdb/bin:<span class="variable">$PATH</span></span><br></pre></td></tr></table></figure><p>这样以来环境变量也配置好了。</p><h3 id="配置磁盘"><a href="#配置磁盘" class="headerlink" title="配置磁盘"></a>配置磁盘</h3><p><strong>咱们先 运行一下，可以发现默认选项是 [2] 代表咱们没有配置硬盘</strong>所以接下来就配置硬盘啦 <strong>按 ctrl + c 退出</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd bochs/bin/</span><br><span class="line">./bochs</span><br><span class="line">ctrl + c </span><br></pre></td></tr></table></figure><p><img src="/../../img/blog/f3c5b8dfec08d54328338d630d5f483c_MD5.png" alt="在这里插入图片描述"></p><h4 id="1-创建配置文件"><a href="#1-创建配置文件" class="headerlink" title="1.创建配置文件"></a>1.创建配置文件</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">code bochsrc.disk</span><br></pre></td></tr></table></figure><p>将下面的语句，直接复制进去 bochsrc.disk 就好啦。<strong>这个要改的比较多，大伙可以 在 vs code 里 ctrl + F</strong>，&#x3D;&#x3D;直接输入 linxi 全部一键改为自己的用户名即可&#x3D;&#x3D;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#关键字为 megs</span><br><span class="line">megs: 32</span><br><span class="line"></span><br><span class="line">#设置对应真实机器的 BIOS 和 VGA BIOS 。</span><br><span class="line">#对应两个关键字为 ： romimage 和 vgaromimage</span><br><span class="line">romimage: file=/home/linxi/bochs/share/bochs/BIOS-bochs-latest</span><br><span class="line">vgaromimage: file=/home/linxi/bochs/share/bochs/VGABIOS-lgpl-latest</span><br><span class="line"></span><br><span class="line">#选择启动盘符</span><br><span class="line">boot: disk  #从硬盘启动</span><br><span class="line"></span><br><span class="line"># 设置日志文件的输入位置</span><br><span class="line">log: /home/linxi/bochs/bochs.out</span><br><span class="line"></span><br><span class="line"># 关闭鼠标，打开键盘</span><br><span class="line">mouse: enabled=0</span><br><span class="line">keyboard: keymap=/home/linxi/bochs/share/bochs/keymaps/x11-pc-us.map</span><br><span class="line"></span><br><span class="line"># 设置硬盘</span><br><span class="line">ata0: enabled=1,ioaddr1=0x1f0, ioaddr2=0x3f0, irq=14</span><br><span class="line"></span><br><span class="line"># 启动盘信息   </span><br><span class="line">ata0-master: type=disk, path=&quot;/home/linxi/bochs/bin/hd60M.img&quot;, mode=flat</span><br></pre></td></tr></table></figure><p>配置文件信息咱们设置好啦，咱们可以试着运行一下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bochs -f bochsrc.disk</span><br></pre></td></tr></table></figure><p><strong>看下图可以发现默认是 6 了，说明这个 bochs 这个虚拟机可以跑啦，当然按回车之后还是不能运行的，因为咱们的 hd60M.img 还没有创建呢哈哈</strong></p><p><img src="/../../img/blog/004aef97c2379cf95f2b6adcab85c509_MD5.png" alt="在这里插入图片描述"></p><h4 id="2-创建-hd60M-img"><a href="#2-创建-hd60M-img" class="headerlink" title="2.创建 hd60M.img"></a>2.创建 hd60M.img</h4><p>咱们接着写一个脚本 de.sh</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">code de.sh</span><br></pre></td></tr></table></figure><p><strong>里面的 path 得改成自己的</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># !/bin/bash</span></span><br><span class="line">path=<span class="string">&quot;/home/linxi/bochs/bin&quot;</span>  <span class="comment">#bin  # 大伙记得改下路径</span></span><br><span class="line"><span class="built_in">cd</span> <span class="variable">$path</span></span><br><span class="line"><span class="built_in">rm</span> hd60M*  <span class="comment"># 先删除，当然这条语句第一次肯定会执行失败，不过也不影响后面的创建</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;1\nhd\nflat\n60\nhd60M.img&quot;</span>|./bximage  <span class="comment"># 利用bximage 创建一个60M的硬盘</span></span><br></pre></td></tr></table></figure><p>或者如下图所示，按照我的图片所示来输入：<br><img src="/../../img/blog/b26db9916c9855971fda41840239225c_MD5.png" alt="在这里插入图片描述"></p><h4 id="3-运行成功！"><a href="#3-运行成功！" class="headerlink" title="3.运行成功！"></a>3.运行成功！</h4><p>接下来就是创建一个汇编文件来进行测试了，我们测试的汇编代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">org07c00h; 告诉编译器程序加载到7c00处</span><br><span class="line">movax, cs</span><br><span class="line">movds, ax</span><br><span class="line">moves, ax</span><br><span class="line">callDispStr; 调用显示字符串例程</span><br><span class="line">jmp$; 无限循环</span><br><span class="line">DispStr:</span><br><span class="line">movax, BootMessage</span><br><span class="line">movbp, ax; ES:BP = 串地址</span><br><span class="line">movcx, 16; CX = 串长度</span><br><span class="line">movax, 01301h; AH = 13,  AL = 01h</span><br><span class="line">movbx, 000ch; 页号为0(BH = 0) 黑底红字(BL = 0Ch,高亮)</span><br><span class="line">movdl, 0</span><br><span class="line">int10h; 10h 号中断</span><br><span class="line">ret</span><br><span class="line">BootMessage:db&quot;Hello, OS world!&quot;</span><br><span class="line">times 510-($-$$)db0; 填充剩下的空间，使生成的二进制代码恰好为512字节</span><br><span class="line">dw 0xaa55; 结束标志</span><br></pre></td></tr></table></figure><p>然后就创建汇编文件吧，我们用的文件名为 test.asm, 输入上面的内容，然后保存。</p><p>再输入 ls，发现成功创建了 test.asm 文件</p><p><img src="/../../img/blog/acdcda66a7a9fd20293abe835cc61b81_MD5.png" alt="在这里插入图片描述"></p><p>接下来就可以对 test.asm 文件进行汇编了，在终端输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nasm test.asm -o test.bin</span><br></pre></td></tr></table></figure><p>最后把 test.bin 文件写入 hd60M.img 硬盘中</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下面path也可以这么写 path=hd60M.img 不过要求你的hd60M.img在bin目录下</span></span><br><span class="line"><span class="built_in">dd</span> <span class="keyword">if</span>=test.bin of=/home/linxi/bochs/bin/hd60M.img bs=512 count=1 conv=notrunc</span><br></pre></td></tr></table></figure><p>如下图：</p><p><img src="/../../img/blog/6ca84a714b5989ace4c91a9c7a74ed63_MD5.png" alt="在这里插入图片描述"></p><p>创建好这个之后咱们运行一下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bochs -f bochsrc.disk</span><br></pre></td></tr></table></figure><p>默认是 6 咱们回车之后是黑屏，<strong>是因为咱们进的调试模式，</strong></p><p><img src="/../../img/blog/22aa2e8aca4b48c01e2f44ace3a3f6e4_MD5.png" alt="在这里插入图片描述"></p><p>接下来咱们在箭头处输入<strong>c （continue）回车</strong>,接下来就可以看到：<strong>这是提示没有启动盘也就是没有 MBR，但是这也说明咱们的 bochs 装好啦哈哈哈装好啦！！</strong></p><p><img src="/../../img/blog/60d4a2dbe6f2be2d36916c4a06b94046_MD5.png" alt="在这里插入图片描述"></p><p><img src="/../../img/blog/56bd6e8eb0ea12fe3fbf400f5f2d11ca_MD5.png" alt="在这里插入图片描述"></p><p>同时，上面的 BXSHARE not set. using…那一行下面有：</p><p><img src="/../../img/blog/333ee46c8b20357e02f707d18b071cc5_MD5.png" alt="在这里插入图片描述"></p><p>可以看到，是按照配置文件来打开的。</p><p>最后，我们成功地安装了 bochs，并测试成功，以后如果你想把其它编译好的文件挂载到磁盘中，让 bochs 运行的话，就和上面的步骤一样，用 dd if&#x3D;…那条命令即可。</p><p>总结，bochs 安装最重要的四步：</p><p>一、配置 bochsrc.disk 文件</p><p>二、创建硬盘（或软盘，看你想以硬盘启动还是软盘启动了）</p><p>三、创建一个 bin 文件</p><p>四、把 bin 文件放到创建好的硬盘中，写一个 run 脚本来启动 bochs 即可</p><h3 id="shell-脚本的一些事"><a href="#shell-脚本的一些事" class="headerlink" title="shell 脚本的一些事"></a>shell 脚本的一些事</h3><p>之后咱们读写的硬盘都是 hd60M.img，创建 de.sh 呢是因为我在后面调试的时候，经常会出现把硬盘弄的启动不了的情况 emm，所以为了方便我直接</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mv de.shell de</span><br><span class="line">chmod 755 de</span><br><span class="line">cp de /usr/bin/</span><br></pre></td></tr></table></figure><p>这样之后无论在哪个文件夹，只要磁盘崩了，咱们都可以直接 de 就很方便啦</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">de </span><br></pre></td></tr></table></figure><p>还有这个.&#x2F;bochs -f bochsrc.disk 也不是很方便，所以就又写了一个 run 脚本</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">code run</span><br><span class="line">chomd 755 run</span><br><span class="line">sudo <span class="built_in">cp</span> run /usr/bin/</span><br><span class="line">run </span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># !/bin/bash</span></span><br><span class="line">path=<span class="string">&quot;/home/linxi/bochs/bin&quot;</span>  <span class="comment">#bin  # 大伙记得改下路径</span></span><br><span class="line"><span class="built_in">cd</span> <span class="variable">$path</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;\nc&quot;</span>|./bochs -f bochsrc.disk  </span><br></pre></td></tr></table></figure><p><strong>这 echo 加不加都行，我就是偷个懒不想按</strong>，不过等到以后要调试的时候还是得把 echo 去掉的哈哈哈</p><p><img src="/../../img/blog/d68b213fff479f0039f819c8fb97411a_MD5.png" alt="在这里插入图片描述"></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://blog.csdn.net/qq_45923646/article/details/120156421">ubuntu20.04 bochs配置安装《操作系统真象还原》环境-CSDN博客</a></li><li><a href="https://blog.csdn.net/weixin_49635198/article/details/126831887">Ubuntu下bochs详细安装步骤（超详细！）_ubuntu安装bochs密码-CSDN博客</a></li><li><a href="https://zhuanlan.zhihu.com/p/492780020">Ubuntu 20.04 系统环境下配置 Bochs虚拟机（2.6.11）第二期 - 知乎 (zhihu.com)</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机/操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ssh连接服务器</title>
      <link href="/posts/%E7%BD%91%E7%BB%9C/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8/ssh%E8%BF%9E%E6%8E%A5%E6%9C%8D%E5%8A%A1%E5%99%A8.html"/>
      <url>/posts/%E7%BD%91%E7%BB%9C/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8/ssh%E8%BF%9E%E6%8E%A5%E6%9C%8D%E5%8A%A1%E5%99%A8.html</url>
      
        <content type="html"><![CDATA[<h1 id="Windows-Terminal-终端实现"><a href="#Windows-Terminal-终端实现" class="headerlink" title="Windows Terminal 终端实现"></a>Windows Terminal 终端实现</h1><ol><li><p>打开 Windows Terminal, 输入 <code>Ctrl+,</code>，进入设置页面</p></li><li><p>左侧，点击 “ 添加新配置文件 “</p><p> <img src="/../../../img/blog/1fd5602d430bc40b687e6886a77b1092_MD5.webp" alt="配置文件"></p></li><li><p>直接按 “ 复制 “，复制了哪一个不要紧，反正都得改的</p></li><li><p>名称自己改</p></li><li><p>如果你的服务器是 Linux 的话（应该基本都是吧），启动目录可以改成 <code>~</code>，或者其他你想要的目录</p></li><li><p>可以将图标改成</p><p> <code>ms-appx:///ProfileIcons/&#123;9acb9455-ca41-5af7-950f-6bca1bc9722f&#125;.png</code><br> 是一个 Linux 小企鹅的图标</p></li><li><p>最关键的是 “ 命令行 “ 设置：设置为</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">ssh -p [端口] [用户名]@[服务器 ip]</span><br><span class="line"> <span class="comment">#端口是22的话 -p [端口] 可以省略</span></span><br><span class="line"> <span class="comment">#两个例子：</span></span><br><span class="line"> ssh -p 2342 example@114.514.114.514</span><br><span class="line"> ssh example@114.514.114.514 <span class="comment">#如果ssh端口为22</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果需要同时执行命令，可以：</span></span><br><span class="line">ssh -t bob@foo \&quot;<span class="built_in">cd</span> /data/bob &amp;&amp; <span class="built_in">exec</span> bash -l\</span><br></pre></td></tr></table></figure></li><li><p>点击 “ 保存 “，然后就可以使用了</p></li></ol><h1 id="使用-RSA-密钥来免密登录"><a href="#使用-RSA-密钥来免密登录" class="headerlink" title="使用 RSA 密钥来免密登录"></a>使用 RSA 密钥来免密登录</h1><ol><li><p>使你的服务器支持密钥登陆，如果已经设置过的可以跳到下一步</p><ol><li><p>可以去 <a href="https://www.runoob.com/w3cnote/set-ssh-login-key.html">这里</a> 看一看菜鸟教程的教学，我把主要过程摘录如下：</p></li><li><p>登陆你打算使用密钥登录的账户，执行以下指令：</p></li></ol> <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~ &amp; ssh-keygen</span><br></pre></td></tr></table></figure><ol start="3"><li>然后一路回车，不要设置密钥锁码！否则登陆的时候还得再输这个码，直接回车就行</li></ol> <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> .ssh</span><br><span class="line"><span class="built_in">cat</span> id_rsa.pub &gt;&gt; authorized_keys</span><br><span class="line"><span class="built_in">chmod</span> 600 authorized_keys</span><br><span class="line"><span class="built_in">chmod</span> 700 ~/.ssh</span><br></pre></td></tr></table></figure><ol start="4"><li><p>用 FTP 把 ~&#x2F;. ssh&#x2F;id_rsa（就是刚生成的私钥）下下来，我的建议是重命名（起个有意义的名字）后放进 <code>%USERPROFILE%/.ssh/</code> 目录下，因为自机生成的密钥也会放在这个文件夹, 可修改相应的 <code>config</code> 文件</p></li><li><p>编辑 &#x2F;etc&#x2F;ssh&#x2F;sshd_config, 增加（修改&#x2F;去除注释化&#x2F;检查）的设置如下</p></li></ol> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">RSAAuthentication yes</span><br><span class="line">PubkeyAuthentication yes</span><br><span class="line">PermitRootLogin yes</span><br><span class="line"></span><br><span class="line"># 如果希望的话，可以用下面的设置禁止使用密码登陆</span><br><span class="line"># 记得先测试了可以用密钥再改</span><br><span class="line">PasswordAuthentication no</span><br></pre></td></tr></table></figure><ol start="6"><li>测试可以使用密钥连接后，重启 SSH 服务</li></ol> <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service sshd restart</span><br></pre></td></tr></table></figure></li><li><p>将 Windows Terminal 的配置中 “ 命令行 “ 的值更改一下</p> <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ssh -i [私钥路径] -p [端口] [用户名]@[服务器ip]</span><br><span class="line"><span class="comment">#例如：</span></span><br><span class="line">ssh -i <span class="string">&quot;C:/Users/usr/.ssh/id_rsa_server&quot;</span> -p 2342 example@114.514.114.514</span><br></pre></td></tr></table></figure></li><li><p>如果你是跟着别人的教程或者官方文档走的，在 settings.json 中写路径的时候记得转义引号，使用 &#x2F; 而非 ,或者你也可以转义。如：</p></li></ol><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;commandline&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ssh -i \&quot;C:\\Users\\usr\\.ssh\\id_rsa_server\&quot; -p 1145 example@114.514.114.514&quot;</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure><p>贴上微软官方文档的链接 <a href="https://learn.microsoft.com/zh-cn/windows/terminal/tutorials/ssh">Windows 终端 SSH | Microsoft Learn</a></p><p>现在的 Windows Terminal 基本所有操作都可以可视化完成了，我觉得没有特殊需求，没必要再去改 settings.json 了</p><h1 id="x2F-ssh-x2F-config-配置实现"><a href="#x2F-ssh-x2F-config-配置实现" class="headerlink" title="~&#x2F;.ssh&#x2F;config 配置实现"></a>~&#x2F;.ssh&#x2F;config 配置实现</h1><p><a href="https://blog.csdn.net/qq_26189301/article/details/111051245?ops_request_misc=&request_id=&biz_id=102&utm_term=~/.ssh/config%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%AE%9E%E7%8E%B0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-1-111051245.142%5Ev11%5Epc_search_result_control_group,157%5Ev13%5Econtrol&spm=1018.2226.3001.4187">参考</a></p><p>最常用的登陆方法是 <code>ssh username@server -p port</code></p><p>通过 <code>~/.ssh/confg</code> 配置文件，实现免密、更改名称的登陆方法，不论你的 username、server address、port 是什么，都可以不用输入，只需要输入一个替换的名称即可登陆该服务器。像这样 <code>ssh &lt;any name here&gt;</code></p><h2 id="将公钥-rsa-pub-上传到服务器"><a href="#将公钥-rsa-pub-上传到服务器" class="headerlink" title="将公钥 rsa. pub 上传到服务器"></a>将公钥 rsa. pub 上传到服务器</h2><p>使用 ssh-copy-id 命令将生成的公钥上传到服务器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-copy-id -i ~/.ssh/id_rsa.pub username@server -p 22</span><br></pre></td></tr></table></figure><p><strong>注意权限</strong>：<code>chmod 600 ~/.ssh/config</code></p><h2 id="常用的-SSH-配置项"><a href="#常用的-SSH-配置项" class="headerlink" title="常用的 SSH 配置项"></a>常用的 SSH 配置项</h2><p>1、config 文件配置项</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Host 别名</span><br><span class="line">HostName 主机名</span><br><span class="line">Port 端口</span><br><span class="line">User 用户名</span><br><span class="line">IdentityFile 密钥文件的路径</span><br><span class="line">IdentitiesOnly 只接受SSH key 登录</span><br><span class="line">PreferredAuthentications 强制使用Public Key验证</span><br></pre></td></tr></table></figure><p>2、Host 配置</p><p>Host 配置项标识了一个配置区段。<br>SSH 配置项参数值可以使用通配符：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x27;*&#x27; 代表 0～n 个非空白字符。</span><br><span class="line">&#x27;?&#x27; 代表一个非空白字符。</span><br><span class="line">&#x27;!&#x27; 表示例外通配。</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 网络 </category>
          
          <category> 云服务器 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>大杂烩</title>
      <link href="/posts/%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%95%99%E8%82%B2%E7%BC%BA%E5%A4%B1%E7%9A%84%E4%B8%80%E8%AF%BE/%E5%A4%A7%E6%9D%82%E7%83%A9.html"/>
      <url>/posts/%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%95%99%E8%82%B2%E7%BC%BA%E5%A4%B1%E7%9A%84%E4%B8%80%E8%AF%BE/%E5%A4%A7%E6%9D%82%E7%83%A9.html</url>
      
        <content type="html"><![CDATA[<h1 id="修改键位映射"><a href="#修改键位映射" class="headerlink" title="修改键位映射"></a>修改键位映射</h1><p>通常这个功能由在计算机上运行的软件实现。当某一个按键被按下，软件截获键盘发出的按键事件（keypress event）并使用另外一个事件取代。比如：</p><ul><li>将 Caps Lock 映射为 Ctrl 或者 Escape：Caps Lock 使用了键盘上一个非常方便的位置而它的功能却很少被用到，所以我们（讲师）非常推荐这个修改；</li><li>将 PrtSc 映射为播放&#x2F;暂停：大部分操作系统支持播放&#x2F;暂停键；</li><li>交换 Ctrl 和 Meta 键（Windows 的徽标键或者 Mac 的 Command 键）。</li></ul><p>你也可以将键位映射为任意常用的指令。软件监听到特定的按键组合后会运行设定的脚本。</p><ul><li>打开一个新的终端或者浏览器窗口；</li><li>输出特定的字符串，比如：一个超长邮件地址或者 MIT ID；</li><li>使计算机或者显示器进入睡眠模式。</li></ul><p>甚至更复杂的修改也可以通过软件实现：</p><ul><li>映射按键顺序，比如：按 Shift 键五下切换大小写锁定；</li><li>区别映射单点和长按，比如：单点 Caps Lock 映射为 Escape，而长按 Caps Lock 映射为 Ctrl；</li><li>对不同的键盘或软件保存专用的映射配置。</li></ul><p>下面是一些修改键位映射的软件：</p><ul><li>macOS - <a href="https://pqrs.org/osx/karabiner/">karabiner-elements</a>, <a href="https://github.com/koekeishiya/skhd">skhd</a> 或者 <a href="https://folivora.ai/">BetterTouchTool</a></li><li>Linux - <a href="https://wiki.archlinux.org/index.php/Xmodmap">xmodmap</a> 或者 <a href="https://github.com/autokey/autokey">Autokey</a></li><li>Windows - 控制面板，<a href="https://www.autohotkey.com/">AutoHotkey</a> 或者 <a href="https://www.randyrants.com/category/sharpkeys/">SharpKeys</a></li><li>QMK - 如果你的键盘支持定制固件，<a href="https://docs.qmk.fm/">QMK</a> 可以直接在键盘的硬件上修改键位映射。保留在键盘里的映射免除了在别的机器上的重复配置。</li></ul><h1 id="守护进程"><a href="#守护进程" class="headerlink" title="守护进程"></a>守护进程</h1><p>即便守护进程（daemon）这个词看上去有些陌生，你应该已经大约明白它的概念。大部分计算机都有一系列在后台保持运行，不需要用户手动运行或者交互的进程。这些进程就是守护进程。以守护进程运行的程序名一般以 <code>d</code> 结尾，比如 SSH 服务端 <code>sshd</code>，用来监听传入的 SSH 连接请求并对用户进行鉴权。</p><p>Linux 中的 <code>systemd</code>（the system daemon）是最常用的配置和运行守护进程的方法。运行 <code>systemctl status</code> 命令可以看到正在运行的所有守护进程。这里面有很多可能你没有见过，但是掌管了系统的核心部分的进程：管理网络、DNS 解析、显示系统的图形界面等等。用户使用 <code>systemctl</code> 命令和 <code>systemd</code> 交互来 <code>enable</code>（启用）、<code>disable</code>（禁用）、<code>start</code>（启动）、<code>stop</code>（停止）、<code>restart</code>（重启）、或者 <code>status</code>（检查）配置好的守护进程及系统服务。</p><p><code>systemd</code> 提供了一个很方便的界面用于配置和启用新的守护进程或系统服务。下面的配置文件使用了守护进程来运行一个简单的 Python 程序。文件的内容非常直接所以我们不对它详细阐述。<code>systemd</code> 配置文件的详细指南可参见 <a href="https://www.freedesktop.org/software/systemd/man/systemd.service.html">freedesktop.org</a>。</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># /etc/systemd/system/myapp.service</span></span><br><span class="line"><span class="section">[Unit]</span></span><br><span class="line"><span class="comment"># 配置文件描述</span></span><br><span class="line"><span class="attr">Description</span>=My Custom App</span><br><span class="line"><span class="comment"># 在网络服务启动后启动该进程</span></span><br><span class="line"><span class="attr">After</span>=network.target</span><br><span class="line"></span><br><span class="line"><span class="section">[Service]</span></span><br><span class="line"><span class="comment"># 运行该进程的用户</span></span><br><span class="line"><span class="attr">User</span>=foo</span><br><span class="line"><span class="comment"># 运行该进程的用户组</span></span><br><span class="line"><span class="attr">Group</span>=foo</span><br><span class="line"><span class="comment"># 运行该进程的根目录</span></span><br><span class="line"><span class="attr">WorkingDirectory</span>=/home/foo/projects/mydaemon</span><br><span class="line"><span class="comment"># 开始该进程的命令</span></span><br><span class="line"><span class="attr">ExecStart</span>=/usr/bin/local/python3.<span class="number">7</span> app.py</span><br><span class="line"><span class="comment"># 在出现错误时重启该进程</span></span><br><span class="line"><span class="attr">Restart</span>=<span class="literal">on</span>-failure</span><br><span class="line"></span><br><span class="line"><span class="section">[Install]</span></span><br><span class="line"><span class="comment"># 相当于Windows的开机启动。即使GUI没有启动，该进程也会加载并运行</span></span><br><span class="line"><span class="attr">WantedBy</span>=multi-user.target</span><br><span class="line"><span class="comment"># 如果该进程仅需要在GUI活动时运行，这里应写作：</span></span><br><span class="line"><span class="comment"># WantedBy=graphical.target</span></span><br><span class="line"><span class="comment"># graphical.target在multi-user.target的基础上运行和GUI相关的服务</span></span><br></pre></td></tr></table></figure><p>如果你只是想定期运行一些程序，可以直接使用 <a href="https://www.man7.org/linux/man-pages/man8/cron.8.html"><code>cron</code></a>。它是一个系统内置的，用来执行定期任务的守护进程。</p><h1 id="FUSE"><a href="#FUSE" class="headerlink" title="FUSE"></a>FUSE</h1><p>现在的软件系统一般由很多模块化的组件构建而成。你使用的操作系统可以通过一系列共同的方式使用不同的文件系统上的相似功能。比如当你使用 <code>touch</code> 命令创建文件的时候，<code>touch</code> 使用系统调用（system call）向内核发出请求。内核再根据文件系统，调用特有的方法来创建文件。这里的问题是，UNIX 文件系统在传统上是以内核模块的形式实现，导致只有内核可以进行文件系统相关的调用。</p><p><a href="https://en.wikipedia.org/wiki/Filesystem_in_Userspace">FUSE</a>（用户空间文件系统）允许运行在用户空间上的程序实现文件系统调用，并将这些调用与内核接口联系起来。在实践中，这意味着用户可以在文件系统调用中实现任意功能。</p><p>FUSE 可以用于实现如：一个将所有文件系统操作都使用 SSH 转发到远程主机，由远程主机处理后返回结果到本地计算机的虚拟文件系统。这个文件系统里的文件虽然存储在远程主机，对于本地计算机上的软件而言和存储在本地别无二致。<code>sshfs</code> 就是一个实现了这种功能的 FUSE 文件系统。</p><p>一些有趣的 FUSE 文件系统包括：</p><ul><li><a href="https://github.com/libfuse/sshfs">sshfs</a>：使用 SSH 连接在本地打开远程主机上的文件</li><li><a href="https://rclone.org/commands/rclone_mount/">rclone</a>：将 Dropbox、Google Drive、Amazon S 3、或者 Google Cloud Storage 一类的云存储服务挂载为本地文件系统</li><li><a href="https://nuetzlich.net/gocryptfs/">gocryptfs</a>：覆盖在加密文件上的文件系统。文件以加密形式保存在磁盘里，但该文件系统挂载后用户可以直接从挂载点访问文件的明文</li><li><a href="https://keybase.io/docs/kbfs">kbfs</a>：分布式端到端加密文件系统。在这个文件系统里有私密（private），共享（shared），以及公开（public）三种类型的文件夹</li><li><a href="https://borgbackup.readthedocs.io/en/stable/usage/mount.html">borgbackup</a>：方便用户浏览删除重复数据后的压缩加密备份</li></ul><h1 id="备份"><a href="#备份" class="headerlink" title="备份"></a>备份</h1><p>任何没有备份的数据都可能在一个瞬间永远消失。复制数据很简单，但是可靠地备份数据很难。下面列举了一些关于备份的基础知识，以及一些常见做法容易掉进的陷阱。</p><p>首先，复制存储在同一个磁盘上的数据不是备份，因为这个磁盘是一个单点故障（single point of failure）。这个磁盘一旦出现问题，所有的数据都可能丢失。放在家里的外置磁盘因为火灾、抢劫等原因可能会和源数据一起丢失，所以是一个弱备份。推荐的做法是将数据备份到不同的地点存储。</p><p>同步方案也不是备份。即使方便如 Dropbox 或者 Google Drive，当数据在本地被抹除或者损坏，同步方案可能会把这些 “ 更改 “ 同步到云端。同理，像 RAID 这样的磁盘镜像方案也不是备份。它不能防止文件被意外删除、损坏、或者被勒索软件加密。</p><p>有效备份方案的几个核心特性是：版本控制，删除重复数据，以及安全性。对备份的数据实施版本控制保证了用户可以从任何记录过的历史版本中恢复数据。在备份中检测并删除重复数据，使其仅备份增量变化可以减少存储开销。在安全性方面，作为用户，你应该考虑别人需要有什么信息或者工具才可以访问或者完全删除你的数据及备份。最后一点，不要盲目信任备份方案。用户应该经常检查备份是否可以用来恢复数据。</p><p>备份不限制于备份在本地计算机上的文件。云端应用的重大发展使得我们很多的数据只存储在云端。当我们无法登录这些应用，在云端存储的网络邮件，社交网络上的照片，流媒体音乐播放列表，以及在线文档等等都会随之丢失。用户应该有这些数据的离线备份，而且已经有项目可以帮助下载并存储它们。</p><h1 id="API（应用程序接口）"><a href="#API（应用程序接口）" class="headerlink" title="API（应用程序接口）"></a>API（应用程序接口）</h1><p>大多数线上服务提供的 API（应用程序接口）让你可以通过编程方式来访问这些服务的数据。这些 API 大多具有类似的格式。它们的结构化 URL 通常使用 <code>api.service.com</code> 作为根路径，用户可以访问不同的子路径来访问需要调用的操作，以及添加查询参数使 API 返回符合查询参数条件的结果。</p><p>以美国天气数据为例，为了获得某个地点的天气数据，你可以发送一个 GET 请求（比如使用 <code>curl</code>）到 <a href="https://api.weather.gov/points/42.3604,-71.094"><code>https://api.weather.gov/points/42.3604,-71.094</code></a>。返回中会包括一系列用于获取特定信息（比如小时预报、气象观察站信息等）的 URL。通常这些返回都是 <code>JSON</code> 格式，你可以使用 <a href="https://stedolan.github.io/jq/"><code>jq</code></a> 等工具来选取需要的部分。</p><p>有些需要认证的 API 通常要求用户在请求中加入某种私密令牌（secret token）来完成认证。请阅读你想访问的 API 所提供的文档来确定它请求的认证方式，但是其实大多数 API 都会使用 <a href="https://www.oauth.com/">OAuth</a>。OAuth 通过向用户提供一系列仅可用于该 API 特定功能的私密令牌进行校验。因为使用了有效 OAuth 令牌的请求在 API 看来就是用户本人发出的请求，所以请一定保管好这些私密令牌。否则其他人就可以冒用你的身份进行任何你可以在这个 API 上进行的操作。</p><p><a href="https://ifttt.com/">IFTTT</a> 这个网站可以将很多 API 整合在一起，让某 API 发生的特定事件触发在其他 API 上执行的任务。IFTTT 的全称 If This Then That 足以说明它的用法，比如在检测到用户的新推文后，自动发布在其他平台。但是你可以对它支持的 API 进行任意整合，所以试着来设置一下任何你需要的功能吧！</p><h1 id="常见命令行标志参数及模式"><a href="#常见命令行标志参数及模式" class="headerlink" title="常见命令行标志参数及模式"></a>常见命令行标志参数及模式</h1><p>命令行工具的用法千差万别，阅读 <code>man</code> 页面可以帮助你理解每种工具的用法。即便如此，下面我们将介绍一下命令行工具一些常见的共同功能。</p><ul><li>大部分工具支持 <code>--help</code> 或者类似的标志参数（flag）来显示它们的简略用法。</li><li>会造成不可撤回操作的工具一般会提供 “ 空运行 “（dry run）标志参数，这样用户可以确认工具真实运行时会进行的操作。这些工具通常也会有 “ 交互式 “（interactive）标志参数，在执行每个不可撤回的操作前提示用户确认。</li><li><code>--version</code> 或者 <code>-V</code> 标志参数可以让工具显示它的版本信息（对于提交软件问题报告非常重要）。</li><li>基本所有的工具支持使用 <code>--verbose</code> 或者 <code>-v</code> 标志参数来输出详细的运行信息。多次使用这个标志参数，比如 <code>-vvv</code>，可以让工具输出更详细的信息（经常用于调试）。同样，很多工具支持 <code>--quiet</code> 标志参数来抑制除错误提示之外的其他输出。</li><li>大多数工具中，使用 <code>-</code> 代替输入或者输出文件名意味着工具将从标准输入（standard input）获取所需内容，或者向标准输出（standard output）输出结果。</li><li>会造成破坏性结果的工具一般默认进行非递归的操作，但是支持使用 “ 递归 “（recursive）标志函数（通常是 <code>-r</code>）。</li><li>有的时候你可能需要向工具传入一个 <em>看上去</em> 像标志参数的普通参数，比如：<ul><li>使用 <code>rm</code> 删除一个叫 <code>-r</code> 的文件；</li><li>在通过一个程序运行另一个程序的时候（<code>ssh machine foo</code>），向内层的程序（<code>foo</code>）传递一个标志参数。</li></ul></li></ul><p> 这时候你可以使用特殊参数 <code>--</code> 让某个程序 <em>停止处理</em> <code>--</code> 后面出现的标志参数以及选项（以 <code>-</code> 开头的内容）：</p><ul><li><code>rm -- -r</code> 会让 <code>rm</code> 将 <code>-r</code> 当作文件名；</li><li><code>ssh machine --for-ssh -- foo --for-foo</code> 的 <code>--</code> 会让 <code>ssh</code> 知道 <code>--for-foo</code> 不是 <code>ssh</code> 的标志参数。</li></ul><h1 id="窗口管理器"><a href="#窗口管理器" class="headerlink" title="窗口管理器"></a>窗口管理器</h1><p>大部分人适应了 Windows、macOS、以及 Ubuntu 默认的 “ 拖拽 “ 式窗口管理器。这些窗口管理器的窗口一般就堆在屏幕上，你可以拖拽改变窗口的位置、缩放窗口、以及让窗口堆叠在一起。这种堆叠式（floating&#x2F;stacking）管理器只是窗口管理器中的一种。特别在 Linux 中，有很多种其他的管理器。</p><p>平铺式（tiling）管理器就是一个常见的替代。顾名思义，平铺式管理器会把不同的窗口像贴瓷砖一样平铺在一起而不和其他窗口重叠。这和 <a href="https://github.com/tmux/tmux">tmux</a> 管理终端窗口的方式类似。平铺式管理器按照写好的布局显示打开的窗口。如果只打开一个窗口，它会填满整个屏幕。新开一个窗口的时候，原来的窗口会缩小到比如三分之二或者三分之一的大小来腾出空间。打开更多的窗口会让已有的窗口进一步调整。</p><p>就像 tmux 那样，平铺式管理器可以让你在完全不使用鼠标的情况下使用键盘切换、缩放、以及移动窗口。它们值得一试！</p><h1 id="VPN"><a href="#VPN" class="headerlink" title="VPN"></a>VPN</h1><p>VPN 现在非常火，但我们不清楚这是不是因为 <a href="https://gist.github.com/joepie91/5a9909939e6ce7d09e29">一些好的理由</a>。你应该了解 VPN 能提供的功能和它的限制。使用了 VPN 的你对于互联网而言，<strong>最好的情况</strong>下也就是换了一个网络供应商（ISP）。所有你发出的流量看上去来源于 VPN 供应商的网络而不是你的 “ 真实 “ 地址，而你实际接入的网络只能看到加密的流量。</p><p>虽然这听上去非常诱人，但是你应该知道使用 VPN 只是把原本对网络供应商的信任放在了 VPN 供应商那里——网络供应商 _能看到的_，VPN 供应商 _也都能看到_。如果相比网络供应商你更信任 VPN 供应商，那当然很好。反之，则连接 VPN 的价值不明确。机场的不加密公共热点确实不可以信任，但是在家庭网络环境里，这个差异就没有那么明显。</p><p>你也应该了解现在大部分包含用户敏感信息的流量已经被 HTTPS 或者 TLS 加密。这种情况下你所处的网络环境是否 “ 安全 “ 不太重要：供应商只能看到你和哪些服务器在交谈，却不能看到你们交谈的内容。</p><p>这一切的大前提都是 “ 最好的情况 “。曾经发生过 VPN 提供商错误使用弱加密或者直接禁用加密的先例。另外，有些恶意的或者带有投机心态的供应商会记录和你有关的所有流量，并很可能会将这些信息卖给第三方。找错一家 VPN 经常比一开始就不用 VPN 更危险。</p><p>MIT 向有访问校内资源需求的成员开放自己运营的 <a href="https://ist.mit.edu/vpn">VPN</a>。如果你也想自己配置一个 VPN，可以了解一下 <a href="https://www.wireguard.com/">WireGuard</a> 以及 <a href="https://github.com/trailofbits/algo">Algo</a>。</p><h1 id="Hammerspoon-macOS-桌面自动化"><a href="#Hammerspoon-macOS-桌面自动化" class="headerlink" title="Hammerspoon (macOS 桌面自动化)"></a>Hammerspoon (macOS 桌面自动化)</h1><p><a href="https://www.hammerspoon.org/">Hammerspoon</a> 是面向 macOS 的一个桌面自动化框架。它允许用户编写和操作系统功能挂钩的 Lua 脚本，从而与键盘、鼠标、窗口、文件系统等交互。</p><p>下面是 Hammerspoon 的一些示例应用：</p><ul><li>绑定移动窗口到的特定位置的快捷键</li><li>创建可以自动将窗口整理成特定布局的菜单栏按钮</li><li>在你到实验室以后，通过检测所连接的 WiFi 网络自动静音扬声器</li><li>在你不小心拿了朋友的充电器时弹出警告</li></ul><p>从用户的角度，Hammerspoon 可以运行任意 Lua 代码，绑定菜单栏按钮、按键、或者事件。Hammerspoon 提供了一个全面的用于和系统交互的库，因此它能没有限制地实现任何功能。你可以从头编写自己的 Hammerspoon 配置，也可以结合别人公布的配置来满足自己的需求。</p><h2 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h2><ul><li><a href="https://www.hammerspoon.org/go/">Getting Started with Hammerspoon</a>：Hammerspoon 官方教程</li><li><a href="https://github.com/Hammerspoon/hammerspoon/wiki/Sample-Configurations">Sample configurations</a>：Hammerspoon 官方示例配置</li><li><a href="https://github.com/anishathalye/dotfiles-local/tree/mac/hammerspoon">Anish’s Hammerspoon config</a>：Anish 的 Hammerspoon 配置</li></ul><h1 id="开机引导以及-Live-USB"><a href="#开机引导以及-Live-USB" class="headerlink" title="开机引导以及 Live USB"></a>开机引导以及 Live USB</h1><p>在你的计算机启动时，<a href="https://en.wikipedia.org/wiki/BIOS">BIOS</a> 或者 <a href="https://en.wikipedia.org/wiki/Unified_Extensible_Firmware_Interface">UEFI</a> 会在加载操作系统之前对硬件系统进行初始化，这被称为引导（booting）。你可以通过按下计算机提示的键位组合来配置引导，比如 <code>Press F9 to configure BIOS. Press F12 to enter boot menu</code>。在 BIOS 菜单中你可以对硬件相关的设置进行更改，也可以在引导菜单中选择从硬盘以外的其他设备加载操作系统——比如 Live USB。</p><p><a href="https://en.wikipedia.org/wiki/Live_USB">Live USB</a> 是包含了完整操作系统的闪存盘。Live USB 的用途非常广泛，包括：</p><ul><li>作为安装操作系统的启动盘；</li><li>在不将操作系统安装到硬盘的情况下，直接运行 Live USB 上的操作系统；</li><li>对硬盘上的相同操作系统进行修复；</li><li>恢复硬盘上的数据。</li></ul><p>Live USB 通过在闪存盘上 <em>写入</em> 操作系统的镜像制作，而写入不是单纯的往闪存盘上复制 <code>.iso</code> 文件。你可以使用 <a href="https://unetbootin.github.io/">UNetbootin</a> 、<a href="https://github.com/pbatard/rufus">Rufus</a> 等 Live USB 写入工具制作。</p><h1 id="Docker-Vagrant-VMs-Cloud-OpenStack"><a href="#Docker-Vagrant-VMs-Cloud-OpenStack" class="headerlink" title="Docker, Vagrant, VMs, Cloud, OpenStack"></a>Docker, Vagrant, VMs, Cloud, OpenStack</h1><p><a href="https://en.wikipedia.org/wiki/Virtual_machine">虚拟机</a>（Virtual Machine）以及容器化（containerization）等工具可以帮助你模拟一个包括操作系统的完整计算机系统。虚拟机可以用于创建独立的测试或者开发环境，以及用作安全测试的沙盒。</p><p><a href="https://www.vagrantup.com/">Vagrant</a> 是一个构建和配置虚拟开发环境的工具。它支持用户在配置文件中写入比如操作系统、系统服务、需要安装的软件包等描述，然后使用 <code>vagrant up</code> 命令在各种环境（VirtualBox，KVM，Hyper-V 等）中启动一个虚拟机。<a href="https://www.docker.com/">Docker</a> 是一个使用容器化概念的类似工具。</p><p>租用云端虚拟机可以享受以下资源的即时访问：</p><ul><li>便宜、常开、且有公共 IP 地址的虚拟机用来托管网站等服务</li><li>有大量 CPU、磁盘、内存、以及 GPU 资源的虚拟机</li><li>超出用户可以使用的物理主机数量的虚拟机</li><li>相比物理主机的固定开支，虚拟机的开支一般按运行的时间计算。所以如果用户只需要在短时间内使用大量算力，租用 1000 台虚拟机运行几分钟明显更加划算。</li></ul><p>受欢迎的 VPS 服务商有 <a href="https://aws.amazon.com/">Amazon AWS</a>，<a href="https://cloud.google.com/">Google Cloud</a>、<a href="https://azure.microsoft.com/">Microsoft Azure</a> 以及 <a href="https://www.digitalocean.com/">DigitalOcean</a>。</p><h1 id="交互式记事本编程"><a href="#交互式记事本编程" class="headerlink" title="交互式记事本编程"></a>交互式记事本编程</h1><p><a href="https://en.wikipedia.org/wiki/Notebook_interface">交互式记事本</a> 可以帮助开发者进行与运行结果交互等探索性的编程。现在最受欢迎的交互式记事本环境大概是 <a href="https://jupyter.org/">Jupyter</a>。它的名字来源于所支持的三种核心语言：Julia、Python、R。<a href="https://www.wolfram.com/mathematica/">Wolfram Mathematica</a> 是另外一个常用于科学计算的优秀环境。</p><h1 id="各种软件包和工具存储在哪里？引用过程是怎样的-bin-或-lib-是什么？"><a href="#各种软件包和工具存储在哪里？引用过程是怎样的-bin-或-lib-是什么？" class="headerlink" title="各种软件包和工具存储在哪里？引用过程是怎样的? /bin 或 /lib 是什么？"></a>各种软件包和工具存储在哪里？引用过程是怎样的? <code>/bin</code> 或 <code>/lib</code> 是什么？</h1><p>根据你在命令行中运行的程序，这些包和工具会全部在 <code>PATH</code> 环境变量所列出的目录中查找到，你可以使用 <code>which</code> 命令 (或是 <code>type</code> 命令) 来检查你的 shell 在哪里发现了特定的程序。<br>一般来说，特定种类的文件存储有一定的规范，<a href="https://en.wikipedia.org/wiki/Filesystem_Hierarchy_Standard">文件系统，层次结构标准（Filesystem, Hierarchy Standard）</a> 可以查到我们讨论内容的详细列表。</p><ul><li><code>/bin</code> - 基本命令二进制文件</li><li><code>/sbin</code> - 基本的系统二进制文件，通常是 root 运行的</li><li><code>/dev</code> - 设备文件，通常是硬件设备接口文件</li><li><code>/etc</code> - 主机特定的系统配置文件</li><li><code>/home</code> - 系统用户的主目录</li><li><code>/lib</code> - 系统软件通用库</li><li><code>/opt</code> - 可选的应用软件</li><li><code>/sys</code> - 包含系统的信息和配置</li><li><code>/tmp</code> - 临时文件 ( <code>/var/tmp</code> ) 通常重启时删除</li><li><code>/usr/</code> - 只读的用户数据<ul><li><code>/usr/bin</code> - 非必须的命令二进制文件</li><li><code>/usr/sbin</code> - 非必须的系统二进制文件，通常是由 root 运行的</li><li><code>/usr/local/bin</code> - 用户编译程序的二进制文件</li></ul></li><li><code>/var</code> - 变量文件像日志或缓存</li></ul><h1 id="用于提高代码性能，简单好用的性能分析工具有哪些"><a href="#用于提高代码性能，简单好用的性能分析工具有哪些" class="headerlink" title="用于提高代码性能，简单好用的性能分析工具有哪些?"></a>用于提高代码性能，简单好用的性能分析工具有哪些?</h1><p>性能分析方面相当有用和简单工具是 <a href="/2020/debugging-profiling/#timing">print timing</a>。你只需手动计算代码不同部分之间花费的时间。通过重复执行此操作，你可以有效地对代码进行二分法搜索，并找到花费时间最长的代码段。</p><p>对于更高级的工具， Valgrind 的 <a href="http://valgrind.org/docs/manual/cl-manual.html">Callgrind</a> 可让你运行程序并计算所有的时间花费以及所有调用堆栈（即哪个函数调用了另一个函数）。然后，它会生成带注释的代码版本，其中包含每行花费的时间。但是，它会使程序运行速度降低一个数量级，并且不支持线程。其他的，<a href="http://www.brendangregg.com/perf.html"><code>perf</code></a> 工具和其他特定语言的采样性能分析器可以非常快速地输出有用的数据。<a href="http://www.brendangregg.com/flamegraphs.html">Flamegraphs</a> 是对采样分析器结果的可视化工具。你还可以使用针对特定编程语言或任务的工具。例如，对于 Web 开发而言，Chrome 和 Firefox 内置的开发工具具有出色的性能分析器。</p><p>有时，代码中最慢的部分是系统等待磁盘读取或网络数据包之类的事件。在这些情况下，需要检查根据硬件性能估算的理论速度是否不偏离实际数值，也有专门的工具来分析系统调用中的等待时间，包括用于用户程序内核跟踪的 <a href="http://www.brendangregg.com/blog/2019-01-01/learn-ebpf-tracing.html">eBPF</a> 。如果需要低级的性能分析，<a href="https://github.com/iovisor/bpftrace"><code>bpftrace</code></a> 值得一试。</p><h1 id="有哪些有用的数据整理工具？"><a href="#有哪些有用的数据整理工具？" class="headerlink" title="有哪些有用的数据整理工具？"></a>有哪些有用的数据整理工具？</h1><p>在数据整理那一节课程中，我们没有时间讨论一些数据整理工具，包括分别用于 JSON 和 HTML 数据的专用解析器， <code>jq</code> 和 <code>pup</code>。Perl 语言是另一个更高级的可以用于数据整理管道的工具。另一个技巧是使用 <code>column -t</code> 命令，可以将空格文本（不一定对齐）转换为对齐的文本。</p><p>一般来说，vim 和 Python 是两个不常规的数据整理工具。对于某些复杂的多行转换，vim 宏是非常有用的工具。你可以记录一系列操作，并根据需要重复执行多次，有一个示例是使用 vim 宏将 XML 格式的文件转换为 JSON。</p><p>对于通常以 CSV 格式显示的表格数据， Python <a href="https://pandas.pydata.org/">pandas</a> 库是一个很棒的工具。不仅因为它能让复杂操作的定义（如分组依据，联接或过滤器）变得非常容易，而且还便于根据不同属性绘制数据。它还支持导出多种表格格式，包括 XLS，HTML 或 LaTeX。另外，R 语言 (一种有争议的 <a href="http://arrgh.tim-smith.us/">不好</a> 的语言）具有很多功能，可以计算数据的统计数字，这在管道的最后一步中非常有用。 <a href="https://ggplot2.tidyverse.org/">ggplot2</a> 是 R 中很棒的绘图库。</p><h1 id="Docker-和虚拟机有什么区别"><a href="#Docker-和虚拟机有什么区别" class="headerlink" title="Docker 和虚拟机有什么区别?"></a>Docker 和虚拟机有什么区别?</h1><p>Docker 基于容器这个更为概括的概念。关于容器和虚拟机之间最大的不同是，虚拟机会执行整个的 OS 栈，包括内核（即使这个内核和主机内核相同）。与虚拟机不同，容器避免运行其他内核实例，而是与主机分享内核。在 Linux 环境中，有 LXC 机制来实现，并且这能使一系列分离的主机像是在使用自己的硬件启动程序，而实际上是共享主机的硬件和内核。因此容器的开销小于完整的虚拟机。</p><p>另一方面，容器的隔离性较弱而且只有在主机运行相同的内核时才能正常工作。例如，如果你在 macOS 上运行 Docker，Docker 需要启动 Linux 虚拟机去获取初始的 Linux 内核，这样的开销仍然很大。最后，Docker 是容器的特定实现，它是为软件部署而定制的。基于这些，它有一些奇怪之处：例如，默认情况下，Docker 容器在重启之间不会有以任何形式的存储。</p><h1 id="不同操作系统的优缺点是什么，我们如何选择（比如选择最适用于我们需求的-Linux-发行版"><a href="#不同操作系统的优缺点是什么，我们如何选择（比如选择最适用于我们需求的-Linux-发行版" class="headerlink" title="不同操作系统的优缺点是什么，我们如何选择（比如选择最适用于我们需求的 Linux 发行版)?"></a>不同操作系统的优缺点是什么，我们如何选择（比如选择最适用于我们需求的 Linux 发行版)?</h1><p>关于 Linux 发行版，尽管有相当多的版本，但大部分发行版在大多数使用情况下的表现是相同的。<br>可以使用任何发行版去学习 Linux 与 UNIX 的特性和其内部工作原理。<br>发行版之间的根本区别是发行版如何处理软件包更新。<br>某些版本，例如 Arch Linux 采用滚动更新策略，用了最前沿的软件包（bleeding-edge），但软件可能并不稳定。另外一些发行版（如 Debian，CentOS 或 Ubuntu LTS）其更新策略要保守得多，因此更新的内容会更稳定，但会牺牲一些新功能。我们建议你使用 Debian 或 Ubuntu 来获得简单稳定的台式机和服务器体验。</p><p>Mac OS 是介于 Windows 和 Linux 之间的一个操作系统，它有很漂亮的界面。但是，Mac OS 是基于 BSD 而不是 Linux，因此系统的某些部分和命令是不同的。<br>另一种值得体验的是 FreeBSD。虽然某些程序不能在 FreeBSD 上运行，但与 Linux 相比，BSD 生态系统的碎片化程度要低得多，并且说明文档更加友好。<br>除了开发 Windows 应用程序或需要使用某些 Windows 系统更好支持的功能（例如对游戏的驱动程序支持）外，我们不建议使用 Windows。</p><p>对于双系统，我们认为最有效的是 macOS 的 bootcamp，长期来看，任何其他组合都可能会出现问题，尤其是当你结合了其他功能比如磁盘加密。</p>]]></content>
      
      
      <categories>
          
          <category> 编程工具 </category>
          
          <category> 计算机教育缺失的一课 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机/编程工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>安全和密码学</title>
      <link href="/posts/%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%95%99%E8%82%B2%E7%BC%BA%E5%A4%B1%E7%9A%84%E4%B8%80%E8%AF%BE/%E5%AE%89%E5%85%A8%E5%92%8C%E5%AF%86%E7%A0%81%E5%AD%A6.html"/>
      <url>/posts/%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%95%99%E8%82%B2%E7%BC%BA%E5%A4%B1%E7%9A%84%E4%B8%80%E8%AF%BE/%E5%AE%89%E5%85%A8%E5%92%8C%E5%AF%86%E7%A0%81%E5%AD%A6.html</url>
      
        <content type="html"><![CDATA[<p>去年的 <a href="https://missing-semester-cn.github.io/2019/security/">这节课</a> 我们从计算机 <em>用户</em> 的角度探讨了增强隐私保护和安全的方法。 今年我们将关注比如散列函数、密钥生成函数、对称&#x2F;非对称密码体系这些安全和密码学的概念是如何应用于前几节课所学到的工具（Git 和 SSH）中的。</p><p>本课程不能作为计算机系统安全 (<a href="https://css.csail.mit.edu/6.858/">6.858</a>) 或者 密码学 (<a href="https://courses.csail.mit.edu/6.857/">6.857</a> 以及 6.875) 的替代。 如果你不是密码学的专家，请不要 <a href="https://www.schneier.com/blog/archives/2015/05/amateurs_produc.html">试图创造或者修改加密算法</a>。从事和计算机系统安全相关的工作同理。</p><p>这节课将对一些基本的概念进行简单（但实用）的说明。 虽然这些说明不足以让你学会如何 <em>设计</em> 安全系统或者加密协议，但我们希望你可以对现在使用的程序和协议有一个大概了解。</p><h1 id="熵"><a href="#熵" class="headerlink" title="熵"></a>熵</h1><p><a href="https://en.wikipedia.org/wiki/Entropy_(information_theory)">熵</a>(Entropy) 度量了不确定性并可以用来决定密码的强度。</p><p>熵的单位是 _比特_。对于一个均匀分布的随机离散变量，熵等于 <code>log_2(所有可能的个数，即n)</code>。 扔一次硬币的熵是 1 比特。掷一次（六面）骰子的熵大约为 2.58 比特。</p><p>一般我们认为攻击者了解密码的模型（最小长度，最大长度，可能包含的字符种类等），但是不了解某个密码是如何随机选择的—— 比如 <a href="https://en.wikipedia.org/wiki/Diceware">掷骰子</a>。</p><p>使用多少比特的熵取决于应用的威胁模型。 上面的 XKCD 漫画告诉我们，大约 40 比特的熵足以对抗在线穷举攻击（受限于网络速度和应用认证机制）。 而对于离线穷举攻击（主要受限于计算速度）, 一般需要更强的密码 (比如 80 比特或更多)。</p><h1 id="散列函数"><a href="#散列函数" class="headerlink" title="散列函数"></a>散列函数</h1><p><a href="https://en.wikipedia.org/wiki/Cryptographic_hash_function">密码散列函数</a> (Cryptographic hash function) 可以将任意大小的数据映射为一个固定大小的输出。除此之外，还有一些其他特性。 一个散列函数的大概规范如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hash(value: array&lt;byte&gt;) -&gt; vector&lt;byte, N&gt;  (N对于该函数固定)</span><br></pre></td></tr></table></figure><p><a href="https://en.wikipedia.org/wiki/SHA-1">SHA-1</a> 是 Git 中使用的一种散列函数， 它可以将任意大小的输入映射为一个 160 比特（可被 40 位十六进制数表示）的输出。 下面我们用 <code>sha1sum</code> 命令来测试 SHA1 对几个字符串的输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$printf &#x27;hello&#x27; | sha1sum</span><br><span class="line">aaf4c61ddcc5e8a2dabede0f3b482cd9aea9434d</span><br><span class="line">$printf &#x27;hello&#x27; | sha1sum</span><br><span class="line">aaf4c61ddcc5e8a2dabede0f3b482cd9aea9434d</span><br><span class="line">$printf &#x27;Hello&#x27; | sha1sum </span><br><span class="line">f7ff9e8b7bb2e09b70935a5d785e0cc5d9d0abf0</span><br></pre></td></tr></table></figure><p>抽象地讲，散列函数可以被认为是一个不可逆，且看上去随机（但具确定性）的函数 （这就是 <a href="https://en.wikipedia.org/wiki/Random_oracle">散列函数的理想模型</a>）。 一个散列函数拥有以下特性：</p><ul><li>确定性：对于不变的输入永远有相同的输出。</li><li>不可逆性：对于 <code>hash(m) = h</code>，难以通过已知的输出 <code>h</code> 来计算出原始输入 <code>m</code>。</li><li>目标碰撞抵抗性&#x2F;弱无碰撞：对于一个给定输入 <code>m_1</code>，难以找到 <code>m_2 != m_1</code> 且 <code>hash(m_1) = hash(m_2)</code>。</li><li>碰撞抵抗性&#x2F;强无碰撞：难以找到一组满足 <code>hash(m_1) = hash(m_2)</code> 的输入 <code>m_1, m_2</code>（该性质严格强于目标碰撞抵抗性）。</li></ul><p>注：虽然 SHA-1 还可以用于特定用途，但它已经 <a href="https://shattered.io/">不再被认为</a> 是一个强密码散列函数。 你可参照 <a href="https://valerieaurora.org/hash.html">密码散列函数的生命周期</a> 这个表格了解一些散列函数是何时被发现弱点及破解的。 请注意，针对应用推荐特定的散列函数超出了本课程内容的范畴。 如果选择散列函数对于你的工作非常重要，请先系统学习信息安全及密码学。</p><h2 id="密码散列函数的应用"><a href="#密码散列函数的应用" class="headerlink" title="密码散列函数的应用"></a>密码散列函数的应用</h2><ul><li>Git 中的内容寻址存储 (Content-addressed storage)：<a href="https://en.wikipedia.org/wiki/Hash_function">散列函数</a> 是一个宽泛的概念（存在非密码学的散列函数），那么 Git 为什么要特意使用密码散列函数？</li><li>文件的信息摘要 (Message digest)：像 Linux ISO 这样的软件可以从非官方的（有时不太可信的）镜像站下载，所以需要设法确认下载的软件和官方一致。 官方网站一般会在（指向镜像站的）下载链接旁边备注安装文件的哈希值。 用户从镜像站下载安装文件后可以对照公布的哈希值来确定安装文件没有被篡改。</li><li><a href="https://en.wikipedia.org/wiki/Commitment_scheme">承诺机制</a>(Commitment scheme)： 假设我希望承诺一个值，但之后再透露它—— 比如在没有一个可信的、双方可见的硬币的情况下在我的脑海中公平的 “ 扔一次硬币 “。 我可以选择一个值 <code>r = random()</code>，并和你分享它的哈希值 <code>h = sha256(r)</code>。 这时你可以开始猜硬币的正反：我们一致同意偶数 <code>r</code> 代表正面，奇数 <code>r</code> 代表反面。 你猜完了以后，我告诉你值 <code>r</code> 的内容，得出胜负。同时你可以使用 <code>sha256(r)</code> 来检查我分享的哈希值 <code>h</code> 以确认我没有作弊。</li></ul><h1 id="密钥生成函数"><a href="#密钥生成函数" class="headerlink" title="密钥生成函数"></a>密钥生成函数</h1><p><a href="https://en.wikipedia.org/wiki/Key_derivation_function">密钥生成函数</a> (Key Derivation Functions) 作为密码散列函数的相关概念，被应用于包括生成固定长度，可以使用在其他密码算法中的密钥等方面。 为了对抗穷举法攻击，密钥生成函数通常较慢。</p><h2 id="密钥生成函数的应用"><a href="#密钥生成函数的应用" class="headerlink" title="密钥生成函数的应用"></a>密钥生成函数的应用</h2><ul><li>从密码生成可以在其他加密算法中使用的密钥，比如对称加密算法（见下）。</li><li>存储登录凭证时不可直接存储明文密码。</li></ul><blockquote><p>正确的方法是针对每个用户随机生成一个 <a href="https://en.wikipedia.org/wiki/Salt_(cryptography)">盐</a> <code>salt = random()</code>， 并存储盐，以及密钥生成函数对连接了盐的明文密码生成的哈希值 <code>KDF(password + salt)</code>。<br>在验证登录请求时，使用输入的密码连接存储的盐重新计算哈希值 <code>KDF(input + salt)</code>，并与存储的哈希值对比。</p></blockquote><h1 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h1><p>说到加密，可能你会首先想到隐藏明文信息。对称加密使用以下几个方法来实现这个功能：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">keygen() -&gt; key  (这是一个随机方法)</span><br><span class="line"></span><br><span class="line">encrypt(plaintext: array&lt;byte&gt;, key) -&gt; array&lt;byte&gt;  (输出密文)</span><br><span class="line">decrypt(ciphertext: array&lt;byte&gt;, key) -&gt; array&lt;byte&gt;  (输出明文)</span><br></pre></td></tr></table></figure><p>加密方法 <code>encrypt()</code> 输出的密文 <code>ciphertext</code> 很难在不知道 <code>key</code> 的情况下得出明文 <code>plaintext</code>。<br>解密方法 <code>decrypt()</code> 有明显的正确性。因为功能要求给定密文及其密钥，解密方法必须输出明文：<code>decrypt(encrypt(m, k), k) = m</code>。</p><p><a href="https://en.wikipedia.org/wiki/Advanced_Encryption_Standard">AES</a> 是现在常用的一种对称加密系统。</p><h2 id="对称加密的应用"><a href="#对称加密的应用" class="headerlink" title="对称加密的应用"></a>对称加密的应用</h2><ul><li>加密不信任的云服务上存储的文件。对称加密和密钥生成函数配合起来，就可以使用密码加密文件： 将密码输入密钥生成函数生成密钥 <code>key = KDF(passphrase)</code>，然后存储 <code>encrypt(file, key)</code>。</li></ul><h1 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h1><p>非对称加密的 “ 非对称 “ 代表在其环境中，使用两个具有不同功能的密钥： 一个是私钥 (private key)，不向外公布；另一个是公钥 (public key)，公布公钥不像公布对称加密的共享密钥那样可能影响加密体系的安全性。<br>非对称加密使用以下几个方法来实现加密&#x2F;解密 (encrypt&#x2F;decrypt)，以及签名&#x2F;验证 (sign&#x2F;verify)：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">keygen() -&gt; (public key, private key)  (这是一个随机方法)</span><br><span class="line"></span><br><span class="line">encrypt(plaintext: array&lt;byte&gt;, public key) -&gt; array&lt;byte&gt;  (输出密文)</span><br><span class="line">decrypt(ciphertext: array&lt;byte&gt;, private key) -&gt; array&lt;byte&gt;  (输出明文)</span><br><span class="line"></span><br><span class="line">sign(message: array&lt;byte&gt;, private key) -&gt; array&lt;byte&gt;  (生成签名)</span><br><span class="line">verify(message: array&lt;byte&gt;, signature: array&lt;byte&gt;, public key) -&gt; bool  (验证签名是否是由和这个公钥相关的私钥生成的)</span><br></pre></td></tr></table></figure><p>非对称的加密&#x2F;解密方法和对称的加密&#x2F;解密方法有类似的特征。</p><p>信息在非对称加密中使用 <em>公钥</em> 加密， 且输出的密文很难在不知道 <em>私钥</em> 的情况下得出明文。</p><p>解密方法 <code>decrypt()</code> 有明显的正确性。 给定密文及私钥，解密方法一定会输出明文： <code>decrypt(encrypt(m, public key), private key) = m</code>。</p><p>对称加密和非对称加密可以类比为机械锁。 对称加密就好比一个防盗门：只要是有钥匙的人都可以开门或者锁门。 非对称加密好比一个可以拿下来的挂锁。你可以把打开状态的挂锁（公钥）给任何一个人并保留唯一的钥匙（私钥）。这样他们将给你的信息装进盒子里并用这个挂锁锁上以后，只有你可以用保留的钥匙开锁。</p><p>签名&#x2F;验证方法具有和书面签名类似的特征。</p><p>在不知道 <em>私钥</em> 的情况下，不管需要签名的信息为何，很难计算出一个可以使 <code>verify(message, signature, public key)</code> 返回为真的签名。</p><p>对于使用私钥签名的信息，验证方法验证和私钥相对应的公钥时一定返回为真：<code>verify(message, sign(message, private key), public key) = true</code>。</p><h2 id="非对称加密的应用"><a href="#非对称加密的应用" class="headerlink" title="非对称加密的应用"></a>非对称加密的应用</h2><ul><li><a href="https://en.wikipedia.org/wiki/Pretty_Good_Privacy">PGP电子邮件加密</a>：用户可以将所使用的公钥在线发布，比如：PGP 密钥服务器或 <a href="https://keybase.io/">Keybase</a>。任何人都可以向他们发送加密的电子邮件。</li><li>聊天加密：像 <a href="https://signal.org/">Signal</a> 和 <a href="https://keybase.io/">Keybase</a> 使用非对称密钥来建立私密聊天。</li><li>软件签名：Git 支持用户对提交 (commit) 和标签 (tag) 进行 GPG 签名。任何人都可以使用软件开发者公布的签名公钥验证下载的已签名软件。</li></ul><h2 id="密钥分发"><a href="#密钥分发" class="headerlink" title="密钥分发"></a>密钥分发</h2><p>非对称加密面对的主要挑战是，如何分发公钥并对应现实世界中存在的人或组织。</p><p>Signal 的信任模型是，信任用户第一次使用时给出的身份 (trust on first use)，同时支持用户线下 (out-of-band)、面对面交换公钥（Signal 里的 safety number）。</p><p>PGP 使用的是 <a href="https://en.wikipedia.org/wiki/Web_of_trust">信任网络</a>。简单来说，如果我想加入一个信任网络，则必须让已经在信任网络中的成员对我进行线下验证，比如对比证件。验证无误后，信任网络的成员使用私钥对我的公钥进行签名。这样我就成为了信任网络的一部分。只要我使用签名过的公钥所对应的私钥就可以证明 “ 我是我 “。</p><p>Keybase 主要使用 <a href="https://keybase.io/blog/chat-apps-softer-than-tofu">社交网络证明 (social proof)</a>，和一些别的精巧设计。</p><p>每个信任模型有它们各自的优点：我们（讲师）更倾向于 Keybase 使用的模型。</p><h1 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h1><h2 id="密码管理器"><a href="#密码管理器" class="headerlink" title="密码管理器"></a>密码管理器</h2><p>每个人都应该尝试使用密码管理器，比如 <a href="https://keepassxc.org/">KeePassXC</a>、<a href="https://www.passwordstore.org/">pass</a> 和 <a href="https://1password.com/">1Password</a>)。</p><p>密码管理器会帮助你对每个网站生成随机且复杂（表现为高熵）的密码，并使用你指定的主密码配合密钥生成函数来对称加密它们。</p><p>你只需要记住一个复杂的主密码，密码管理器就可以生成很多复杂度高且不会重复使用的密码。密码管理器通过这种方式降低密码被猜出的可能，并减少网站信息泄露后对其他网站密码的威胁。</p><h2 id="两步验证（双因子验证）"><a href="#两步验证（双因子验证）" class="headerlink" title="两步验证（双因子验证）"></a>两步验证（双因子验证）</h2><p><a href="https://en.wikipedia.org/wiki/Multi-factor_authentication">两步验证</a>(2FA) 要求用户同时使用密码（” 你知道的信息 “）和一个身份验证器（” 你拥有的物品 “，比如 <a href="https://www.yubico.com/">YubiKey</a>）来消除密码泄露或者 <a href="https://en.wikipedia.org/wiki/Phishing">钓鱼攻击</a> 的威胁。</p><h2 id="全盘加密"><a href="#全盘加密" class="headerlink" title="全盘加密"></a>全盘加密</h2><p>对笔记本电脑的硬盘进行全盘加密是防止因设备丢失而信息泄露的简单且有效方法。 Linux 的 <a href="https://wiki.archlinux.org/index.php/Dm-crypt/Encrypting_a_non-root_file_system">cryptsetup + LUKS</a>， Windows 的 <a href="https://fossbytes.com/enable-full-disk-encryption-windows-10/">BitLocker</a>，或者 macOS 的 <a href="https://support.apple.com/en-us/HT204837">FileVault</a> 都使用一个由密码保护的对称密钥来加密盘上的所有信息。</p><h2 id="聊天加密"><a href="#聊天加密" class="headerlink" title="聊天加密"></a>聊天加密</h2><p><a href="https://signal.org/">Signal</a> 和 <a href="https://keybase.io/">Keybase</a> 使用非对称加密对用户提供端到端 (End-to-end) 安全性。</p><p>获取联系人的公钥非常关键。为了保证安全性，应使用线下方式验证 Signal 或者 Keybase 的用户公钥，或者信任 Keybase 用户提供的社交网络证明。</p><h2 id="SSH"><a href="#SSH" class="headerlink" title="SSH"></a>SSH</h2><p>当你运行 <code>ssh-keygen</code> 命令，它会生成一个非对称密钥对：公钥和私钥 <code>(public_key, private_key)</code>。 生成过程中使用的随机数由系统提供的熵决定。这些熵可以来源于硬件事件 (hardware events) 等。 公钥最终会被分发，它可以直接明文存储。 但是为了防止泄露，私钥必须加密存储。<code>ssh-keygen</code> 命令会提示用户输入一个密码，并将它输入密钥生成函数 产生一个密钥。最终，<code>ssh-keygen</code> 使用对称加密算法和这个密钥加密私钥。</p><p>在实际运用中，当服务器已知用户的公钥（存储在 <code>.ssh/authorized_keys</code> 文件中，一般在用户 HOME 目录下），尝试连接的客户端可以使用非对称签名来证明用户的身份——这便是 <a href="https://en.wikipedia.org/wiki/Challenge%E2%80%93response_authentication">挑战应答方式</a>。 简单来说，服务器选择一个随机数字发送给客户端。客户端使用用户私钥对这个数字信息签名后返回服务器。 服务器随后使用 <code>.ssh/authorized_keys</code> 文件中存储的用户公钥来验证返回的信息是否由所对应的私钥所签名。这种验证方式可以有效证明试图登录的用户持有所需的私钥。</p><h1 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h1><ul><li><a href="https://missing-semester-cn.github.io/2019/security/">去年的讲稿</a>: 更注重于计算机用户可以如何增强隐私保护和安全</li><li><a href="https://latacora.micro.blog/2018/04/03/cryptographic-right-answers.html">Cryptographic Right Answers</a>: 解答了在一些应用环境下 “ 应该使用什么加密？” 的问题</li></ul><h1 id="课后练习"><a href="#课后练习" class="headerlink" title="课后练习"></a>课后练习</h1><p><a href="https://missing-semester-cn.github.io/missing-notes-and-solutions/2020/solutions//security-solution">习题解答</a></p><ol><li><p><strong>熵</strong></p><ol><li><p>假设一个密码是由四个小写的单词拼接组成，每个单词都是从一个含有 10 万单词的字典中随机选择，且每个单词选中的概率相同。 一个符合这样构造的例子是 <code>correcthorsebatterystaple</code>。这个密码有多少比特的熵？</p></li><li><p>假设另一个密码是用八个随机的大小写字母或数字组成。一个符合这样构造的例子是 <code>rg8Ql34g</code>。这个密码又有多少比特的熵？</p></li><li><p>哪一个密码更强？</p></li><li><p>假设一个攻击者每秒可以尝试 1 万个密码，这个攻击者需要多久可以分别破解上述两个密码？</p></li></ol></li><li><p><strong>密码散列函数</strong> 从 <a href="https://www.debian.org/CD/http-ftp/">Debian镜像站</a> 下载一个光盘映像（比如这个来自阿根廷镜像站的 <a href="http://debian.xfree.com.ar/debian-cd/10.2.0/amd64/iso-cd/debian-10.2.0-amd64-netinst.iso">映像</a>）。使用 <code>sha256sum</code> 命令对比下载映像的哈希值和官方 Debian 站公布的哈希值。如果你下载了上面的映像，官方公布的哈希值可以参考 <a href="https://cdimage.debian.org/debian-cd/current/amd64/iso-cd/SHA256SUMS">这个文件</a>。</p></li><li><p><strong>对称加密</strong> 使用 <a href="https://www.openssl.org/">OpenSSL</a> 的 AES 模式加密一个文件: <code>openssl aes-256-cbc -salt -in &#123;源文件名&#125; -out &#123;加密文件名&#125;</code>。 使用 <code>cat</code> 或者 <code>hexdump</code> 对比源文件和加密的文件，再用 <code>openssl aes-256-cbc -d -in &#123;加密文件名&#125; -out &#123;解密文件名&#125;</code> 命令解密刚刚加密的文件。最后使用 <code>cmp</code> 命令确认源文件和解密后的文件内容相同。</p></li><li><p><strong>非对称加密</strong></p><ol><li><p>在你自己的电脑上使用更安全的 <a href="https://wiki.archlinux.org/index.php/SSH_keys#Ed25519">ED25519算法</a> 生成一组 <a href="https://www.digitalocean.com/community/tutorials/how-to-set-up-ssh-keys--2">SSH 密钥对</a>。为了确保私钥不使用时的安全，一定使用密码加密你的私钥。</p></li><li><p><a href="https://www.digitalocean.com/community/tutorials/how-to-use-gpg-to-encrypt-and-sign-messages">配置GPG</a>。</p></li><li><p>给 Anish 发送一封加密的电子邮件（<a href="https://keybase.io/anish">Anish的公钥</a>）。</p></li><li><p>使用 <code>git commit -S</code> 命令签名一个 Git 提交，并使用 <code>git show --show-signature</code> 命令验证这个提交的签名。或者，使用 <code>git tag -s</code> 命令签名一个 Git 标签，并使用 <code>git tag -v</code> 命令验证标签的签名。</p></li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> 编程工具 </category>
          
          <category> 计算机教育缺失的一课 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机/编程工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>元编程</title>
      <link href="/posts/%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%95%99%E8%82%B2%E7%BC%BA%E5%A4%B1%E7%9A%84%E4%B8%80%E8%AF%BE/%E5%85%83%E7%BC%96%E7%A8%8B.html"/>
      <url>/posts/%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%95%99%E8%82%B2%E7%BC%BA%E5%A4%B1%E7%9A%84%E4%B8%80%E8%AF%BE/%E5%85%83%E7%BC%96%E7%A8%8B.html</url>
      
        <content type="html"><![CDATA[<p>我们这里说的 “ 元编程（metaprogramming）” 是什么意思呢？好吧，对于本文要介绍的这些内容，这是我们能够想到的最能概括它们的词。因为我们今天要讲的东西，更多是关于 <em>流程</em> ，而不是写代码或更高效的工作。本节课我们会学习构建系统、代码测试以及依赖管理。在您还是学生的时候，这些东西看上去似乎对您来说没那么重要，不过当您开始实习或走进社会的时候，您将会接触到大型的代码库，本节课讲授的这些东西也会变得随处可见。必须要指出的是，” 元编程 “ 也有 <a href="https://en.wikipedia.org/wiki/Metaprogramming">用于操作程序的程序</a>“ 之含义，这和我们今天讲座所介绍的概念是完全不同的。</p><h1 id="构建系统"><a href="#构建系统" class="headerlink" title="构建系统"></a>构建系统</h1><p>如果您使用 LaTeX 来编写论文，您需要执行哪些命令才能编译出您想要的论文呢？执行基准测试、绘制图表然后将其插入论文的命令又有哪些？或者，如何编译本课程提供的代码并执行测试呢？</p><p>对于大多数系统来说，不论其是否包含代码，都会包含一个 “ 构建过程 “。有时，您需要执行一系列操作。通常，这一过程包含了很多步骤，很多分支。执行一些命令来生成图表，然后执行另外的一些命令生成结果，然后再执行其他的命令来生成最终的论文。有很多事情需要我们完成，您并不是第一个因此感到苦恼的人，幸运的是，有很多工具可以帮助我们完成这些操作。</p><p>这些工具通常被称为 “ 构建系统 “，而且这些工具还不少。如何选择工具完全取决于您当前手头上要完成的任务以及项目的规模。从本质上讲，这些工具都是非常类似的。您需要定义<em>依赖</em>、<em>目标</em>和<em>规则</em>。您必须告诉构建系统您具体的构建目标，系统的任务则是找到构建这些目标所需要的依赖，并根据规则构建所需的中间产物，直到最终目标被构建出来。理想的情况下，如果目标的依赖没有发生改动，并且我们可以从之前的构建中复用这些依赖，那么与其相关的构建规则并不会被执行。</p><p><code>make</code> 是最常用的构建系统之一，您会发现它通常被安装到了几乎所有基于 UNIX 的系统中。<code>make</code> 并不完美，但是对于中小型项目来说，它已经足够好了。当您执行 <code>make</code> 时，它会去参考当前目录下名为 <code>Makefile</code> 的文件。所有构建目标、相关依赖和规则都需要在该文件中定义，它看上去是这样的：</p><figure class="highlight make"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">paper.pdf: paper.tex plot-data.png</span></span><br><span class="line">pdflatex paper.tex</span><br><span class="line"></span><br><span class="line"><span class="section">plot-%.png: %.dat plot.py</span></span><br><span class="line">./plot.py -i <span class="variable">$*</span>.dat -o <span class="variable">$@</span></span><br></pre></td></tr></table></figure><p>这个文件中的指令，即如何使用右侧文件构建左侧文件的规则。或者，换句话说，冒号左侧的是构建目标，冒号右侧的是构建它所需的依赖。缩进的部分是从依赖构建目标时需要用到的一段命令。在 <code>make</code> 中，第一条指令还指明了构建的目的，如果您使用不带参数的 <code>make</code>，这便是我们最终的构建结果。或者，您可以使用这样的命令来构建其他目标：<code>make plot-data.png</code>。</p><p>规则中的 <code>%</code> 是一种模式，它会匹配其左右两侧相同的字符串。例如，如果目标是 <code>plot-foo.png</code>， <code>make</code> 会去寻找 <code>foo.dat</code> 和 <code>plot.py</code> 作为依赖。现在，让我们看看如果在一个空的源码目录中执行 <code>make</code> 会发生什么？</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">make</span></span><br><span class="line">make: *** No rule to make target &#x27;paper.tex&#x27;, needed by &#x27;paper.pdf&#x27;.  Stop.</span><br></pre></td></tr></table></figure><p><code>make</code> 会告诉我们，为了构建出 <code>paper.pdf</code>，它需要 <code>paper.tex</code>，但是并没有一条规则能够告诉它如何构建该文件。让我们构建它吧！</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">touch</span> paper.tex</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">make</span></span><br><span class="line">make: *** No rule to make target &#x27;plot-data.png&#x27;, needed by &#x27;paper.pdf&#x27;.  Stop.</span><br></pre></td></tr></table></figure><p>哟，有意思，我们是<strong>有</strong>构建 <code>plot-data.png</code> 的规则的，但是这是一条模式规则。因为源文件 <code>data.dat</code> 并不存在，因此 <code>make</code> 就会告诉您它不能构建 <code>plot-data.png</code>，让我们创建这些文件：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> paper.tex</span></span><br><span class="line">\documentclass&#123;article&#125;</span><br><span class="line">\usepackage&#123;graphicx&#125;</span><br><span class="line">\begin&#123;document&#125;</span><br><span class="line">\includegraphics[scale=0.65]&#123;plot-data.png&#125;</span><br><span class="line">\end&#123;document&#125;</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> plot.py</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/usr/bin/env python</span></span><br><span class="line">import matplotlib</span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">import numpy as np</span><br><span class="line">import argparse</span><br><span class="line"></span><br><span class="line">parser = argparse.ArgumentParser()</span><br><span class="line">parser.add_argument(&#x27;-i&#x27;, type=argparse.FileType(&#x27;r&#x27;))</span><br><span class="line">parser.add_argument(&#x27;-o&#x27;)</span><br><span class="line">args = parser.parse_args()</span><br><span class="line"></span><br><span class="line">data = np.loadtxt(args.i)</span><br><span class="line">plt.plot(data[:, 0], data[:, 1])</span><br><span class="line">plt.savefig(args.o)</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> data.dat</span></span><br><span class="line">1 1</span><br><span class="line">2 2</span><br><span class="line">3 3</span><br><span class="line">4 4</span><br><span class="line">5 8</span><br></pre></td></tr></table></figure><p>当我们执行 <code>make</code> 时会发生什么？</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">make</span></span><br><span class="line">./plot.py -i data.dat -o plot-data.png</span><br><span class="line">pdflatex paper.tex</span><br><span class="line">... lots of output ...</span><br></pre></td></tr></table></figure><p>看！PDF ！</p><p>如果再次执行 <code>make</code> 会怎样？</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">make</span></span><br><span class="line">make: &#x27;paper.pdf&#x27; is up to date.</span><br></pre></td></tr></table></figure><p>什么事情都没做！为什么？好吧，因为它什么都不需要做。make 回去检查之前的构建是因其依赖改变而需要被更新。让我们试试修改 <code>paper.tex</code> 在重新执行 <code>make</code>：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">vim paper.tex</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">make</span></span><br><span class="line">pdflatex paper.tex</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>注意 <code>make</code> 并<strong>没有</strong>重新构建 <code>plot.py</code>，因为没必要；<code>plot-data.png</code> 的所有依赖都没有发生改变。</p><h1 id="依赖管理"><a href="#依赖管理" class="headerlink" title="依赖管理"></a>依赖管理</h1><p>就您的项目来说，它的依赖可能本身也是其他的项目。您也许会依赖某些程序 (例如 <code>python</code>)、系统包 (例如 <code>openssl</code>) 或相关编程语言的库 (例如 <code>matplotlib</code>)。现在，大多数的依赖可以通过某些<strong>软件仓库</strong>来获取，这些仓库会在一个地方托管大量的依赖，我们则可以通过一套非常简单的机制来安装依赖。例如 Ubuntu 系统下面有 Ubuntu 软件包仓库，您可以通过 <code>apt</code> 这个工具来访问， RubyGems 则包含了 Ruby 的相关库，PyPi 包含了 Python 库， Arch Linux 用户贡献的库则可以在 Arch User Repository 中找到。</p><p>由于每个仓库、每种工具的运行机制都不太一样，因此我们并不会在本节课深入讲解具体的细节。我们会介绍一些通用的术语，例如<em>版本控制</em>。大多数被其他项目所依赖的项目都会在每次发布新版本时创建一个<em>版本号</em>。通常看上去像 8.1.3 或 64.1.20192004。版本号一般是数字构成的，但也并不绝对。版本号有很多用途，其中最重要的作用是保证软件能够运行。试想一下，假如我的库要发布一个新版本，在这个版本里面我重命名了某个函数。如果有人在我的库升级版本后，仍希望基于它构建新的软件，那么很可能构建会失败，因为它希望调用的函数已经不复存在了。有了版本控制就可以很好的解决这个问题，我们可以指定当前项目需要基于某个版本，甚至某个范围内的版本，或是某些项目来构建。这么做的话，即使某个被依赖的库发生了变化，依赖它的软件可以基于其之前的版本进行构建。</p><p>这样还并不理想！如果我们发布了一项和安全相关的升级，它并<em>没有</em>影响到任何公开接口（API），但是处于安全的考虑，依赖它的项目都应该立即升级，那应该怎么做呢？这也是版本号包含多个部分的原因。不同项目所用的版本号其具体含义并不完全相同，但是一个相对比较常用的标准是 <a href="https://semver.org/">语义版本号</a>，这种版本号具有不同的语义，它的格式是这样的：主版本号. 次版本号. 补丁号。相关规则有：</p><ul><li>如果新的版本没有改变 API，请将补丁号递增；</li><li>如果您添加了 API 并且该改动是向后兼容的，请将次版本号递增；</li><li>如果您修改了 API 但是它并不向后兼容，请将主版本号递增。</li></ul><p>这么做有很多好处。现在如果我们的项目是基于您的项目构建的，那么只要最新版本的主版本号只要没变就是安全的，次版本号不低于之前我们使用的版本即可。换句话说，如果我依赖的版本是 <code>1.3.7</code>，那么使用 <code>1.3.8</code>、<code>1.6.1</code>，甚至是 <code>1.3.0</code> 都是可以的。如果版本号是 <code>2.2.4</code> 就不一定能用了，因为它的主版本号增加了。我们可以将 Python 的版本号作为语义版本号的一个实例。您应该知道，Python 2 和 Python 3 的代码是不兼容的，这也是为什么 Python 的主版本号改变的原因。类似的，使用 Python 3.5 编写的代码在 3.7 上可以运行，但是在 3.4 上可能会不行。</p><p>使用依赖管理系统的时候，您可能会遇到锁文件（<em>lock files</em>）这一概念。锁文件列出了您当前每个依赖所对应的具体版本号。通常，您需要执行升级程序才能更新依赖的版本。这么做的原因有很多，例如避免不必要的重新编译、创建可复现的软件版本或禁止自动升级到最新版本（可能会包含 bug）。还有一种极端的依赖锁定叫做 <em>vendoring</em>，它会把您的依赖中的所有代码直接拷贝到您的项目中，这样您就能够完全掌控代码的任何修改，同时您也可以将自己的修改添加进去，不过这也意味着如果该依赖的维护者更新了某些代码，您也必须要自己去拉取这些更新。</p><h1 id="持续集成系统"><a href="#持续集成系统" class="headerlink" title="持续集成系统"></a>持续集成系统</h1><p>随着您接触到的项目规模越来越大，您会发现修改代码之后还有很多额外的工作要做。您可能需要上传一份新版本的文档、上传编译后的文件到某处、发布代码到 pypi，执行测试套件等等。或许您希望每次有人提交代码到 GitHub 的时候，他们的代码风格被检查过并执行过某些基准测试？如果您有这方面的需求，那么请花些时间了解一下持续集成。</p><p>持续集成，或者叫做 CI 是一种雨伞术语（umbrella term，涵盖了一组术语的术语），它指的是那些 “ 当您的代码变动时，自动运行的东西 “，市场上有很多提供各式各样 CI 工具的公司，这些工具大部分都是免费或开源的。比较大的有 Travis CI、Azure Pipelines 和 GitHub Actions。它们的工作原理都是类似的：您需要在代码仓库中添加一个文件，描述当前仓库发生任何修改时，应该如何应对。目前为止，最常见的规则是：如果有人提交代码，执行测试套件。当这个事件被触发时，CI 提供方会启动一个（或多个）虚拟机，执行您制定的规则，并且通常会记录下相关的执行结果。您可以进行某些设置，这样当测试套件失败时您能够收到通知或者当测试全部通过时，您的仓库主页会显示一个徽标。</p><p>本课程的网站基于 GitHub Pages 构建，这就是一个很好的例子。Pages 在每次 <code>master</code> 有代码更新时，会执行 Jekyll 博客软件，然后使您的站点可以通过某个 GitHub 域名来访问。对于我们来说这些事情太琐碎了，我现在我们只需要在本地进行修改，然后使用 git 提交代码，发布到远端。CI 会自动帮我们处理后续的事情。</p><h2 id="测试简介"><a href="#测试简介" class="headerlink" title="测试简介"></a>测试简介</h2><p>多数的大型软件都有 “ 测试套件 “。您可能已经对测试的相关概念有所了解，但是我们觉得有些测试方法和测试术语还是应该再次提醒一下：</p><ul><li>测试套件：所有测试的统称。</li><li>单元测试：一种 “ 微型测试 “，用于对某个封装的特性进行测试。</li><li>集成测试：一种 “ 宏观测试 “，针对系统的某一大部分进行，测试其不同的特性或组件是否能<em>协同</em>工作。</li><li>回归测试：一种实现特定模式的测试，用于保证之前引起问题的 bug 不会再次出现。</li><li>模拟（Mocking）: 使用一个假的实现来替换函数、模块或类型，屏蔽那些和测试不相关的内容。例如，您可能会 “ 模拟网络连接 “ 或 “ 模拟硬盘 “。</li></ul><h1 id="课后练习"><a href="#课后练习" class="headerlink" title="课后练习"></a>课后练习</h1><p>[习题解答](  &#x2F;  &#x2F;  )</p><ol><li><p>大多数的 makefiles 都提供了一个名为 <code>clean</code> 的构建目标，这并不是说我们会生成一个名为 <code>clean</code> 的文件，而是我们可以使用它清理文件，让 make 重新构建。您可以理解为它的作用是 “ 撤销 “ 所有构建步骤。在上面的 makefile 中为 <code>paper.pdf</code> 实现一个 <code>clean</code> 目标。您需要将构建目标设置为 <a href="https://www.gnu.org/software/make/manual/html_node/Phony-Targets.html">phony</a>。您也许会发现 <a href="https://git-scm.com/docs/git-ls-files"><code>git ls-files</code></a> 子命令很有用。其他一些有用的 make 构建目标可以在 <a href="https://www.gnu.org/software/make/manual/html_node/Standard-Targets.html#Standard-Targets">这里</a> 找到；</p></li><li><p>指定版本要求的方法很多，让我们学习一下 <a href="https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html">Rust的构建系统</a> 的依赖管理。大多数的包管理仓库都支持类似的语法。对于每种语法 (尖号、波浪号、通配符、比较、乘积)，构建一种场景使其具有实际意义；</p></li><li><p>Git 可以作为一个简单的 CI 系统来使用，在任何 git 仓库中的 <code>.git/hooks</code> 目录中，您可以找到一些文件（当前处于未激活状态），它们的作用和脚本一样，当某些事件发生时便可以自动执行。请编写一个 <a href="https://git-scm.com/docs/githooks#_pre_commit"><code>pre-commit</code></a> 钩子，它会在提交前执行 <code>make paper.pdf</code> 并在出现构建失败的情况拒绝您的提交。这样做可以避免产生包含不可构建版本的提交信息;</p></li><li><p>基于 <a href="https://pages.github.com/">GitHub Pages</a> 创建任意一个可以自动发布的页面。添加一个 <a href="https://github.com/features/actions">GitHub Action</a> 到该仓库，对仓库中的所有 shell 文件执行 <code>shellcheck</code> (<a href="https://github.com/marketplace/actions/shellcheck">方法之一</a>)；</p></li><li><p><a href="./https://help.github.com/en/actions/automating-your-workflow-with-github-actions/building-actions">构建属于您的</a> GitHub action，对仓库中所有的 &#96;&#96; 文件执行 <a href="http://proselint.com/"><code>proselint</code></a> 或 <a href="https://github.com/btford/write-good"><code>write-good</code></a>，在您的仓库中开启这一功能，提交一个包含错误的文件看看该功能是否生效。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 编程工具 </category>
          
          <category> 计算机教育缺失的一课 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机/编程工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>调试与性能分析</title>
      <link href="/posts/%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%95%99%E8%82%B2%E7%BC%BA%E5%A4%B1%E7%9A%84%E4%B8%80%E8%AF%BE/%E8%B0%83%E8%AF%95%E4%B8%8E%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90.html"/>
      <url>/posts/%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%95%99%E8%82%B2%E7%BC%BA%E5%A4%B1%E7%9A%84%E4%B8%80%E8%AF%BE/%E8%B0%83%E8%AF%95%E4%B8%8E%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90.html</url>
      
        <content type="html"><![CDATA[<p>代码不能完全按照您的想法运行，它只能完全按照您的写法运行，这是编程界的一条金科玉律。让您的写法符合您的想法是非常困难的。在这节课中，我们会传授给您一些非常有用技术，帮您处理代码中的 bug 和程序性能问题。</p><h1 id="调试代码"><a href="#调试代码" class="headerlink" title="调试代码"></a>调试代码</h1><h2 id="打印调试法与日志"><a href="#打印调试法与日志" class="headerlink" title="打印调试法与日志"></a>打印调试法与日志</h2><p>“ 最有效的 debug 工具就是细致的分析，配合恰当位置的打印语句 “ — Brian Kernighan, _Unix 新手入门_。</p><p>调试代码的第一种方法往往是在您发现问题的地方添加一些打印语句，然后不断重复此过程直到您获取了足够的信息并找到问题的根本原因。</p><p>另外一个方法是使用日志，而不是临时添加打印语句。日志较普通的打印语句有如下的一些优势：</p><ul><li>您可以将日志写入文件、socket 或者甚至是发送到远端服务器而不仅仅是标准输出；</li><li>日志可以支持严重等级（例如 INFO, DEBUG, WARN, ERROR 等)，这使您可以根据需要过滤日志；</li><li>对于新发现的问题，很可能您的日志中已经包含了可以帮助您定位问题的足够的信息。</li></ul><p>这里是一个包含日志的例程序：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CustomFormatter</span>(logging.Formatter):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Logging Formatter to add colors and count warning / errors&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    grey = <span class="string">&quot;\x1b[38;21m&quot;</span></span><br><span class="line">    yellow = <span class="string">&quot;\x1b[33;21m&quot;</span></span><br><span class="line">    red = <span class="string">&quot;\x1b[31;21m&quot;</span></span><br><span class="line">    bold_red = <span class="string">&quot;\x1b[31;1m&quot;</span></span><br><span class="line">    reset = <span class="string">&quot;\x1b[0m&quot;</span></span><br><span class="line">    <span class="built_in">format</span> = <span class="string">&quot;%(asctime)s - %(name)s - %(levelname)s - %(message)s (%(filename)s:%(lineno)d)&quot;</span></span><br><span class="line"></span><br><span class="line">    FORMATS = &#123;</span><br><span class="line">        logging.DEBUG: grey + <span class="built_in">format</span> + reset,</span><br><span class="line">        logging.INFO: grey + <span class="built_in">format</span> + reset,</span><br><span class="line">        logging.WARNING: yellow + <span class="built_in">format</span> + reset,</span><br><span class="line">        logging.ERROR: red + <span class="built_in">format</span> + reset,</span><br><span class="line">        logging.CRITICAL: bold_red + <span class="built_in">format</span> + reset</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">format</span>(<span class="params">self, record</span>):</span><br><span class="line">        log_fmt = self.FORMATS.get(record.levelno)</span><br><span class="line">        formatter = logging.Formatter(log_fmt)</span><br><span class="line">        <span class="keyword">return</span> formatter.<span class="built_in">format</span>(record)</span><br><span class="line"></span><br><span class="line"><span class="comment"># create logger with &#x27;spam_application&#x27;</span></span><br><span class="line">logger = logging.getLogger(<span class="string">&quot;Sample&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># create console handler with a higher log level</span></span><br><span class="line">ch = logging.StreamHandler()</span><br><span class="line">ch.setLevel(logging.DEBUG)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(sys.argv)&gt; <span class="number">1</span>:</span><br><span class="line">    <span class="keyword">if</span> sys.argv[<span class="number">1</span>] == <span class="string">&#x27;log&#x27;</span>:</span><br><span class="line">        ch.setFormatter(logging.Formatter(<span class="string">&#x27;%(asctime)s : %(levelname)s : %(name)s : %(message)s&#x27;</span>))</span><br><span class="line">    <span class="keyword">elif</span> sys.argv[<span class="number">1</span>] == <span class="string">&#x27;color&#x27;</span>:</span><br><span class="line">        ch.setFormatter(CustomFormatter())</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(sys.argv) &gt; <span class="number">2</span>:</span><br><span class="line">    logger.setLevel(logging.__getattribute__(sys.argv[<span class="number">2</span>]))</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    logger.setLevel(logging.DEBUG)</span><br><span class="line"></span><br><span class="line">logger.addHandler(ch)</span><br><span class="line"></span><br><span class="line"><span class="comment"># logger.debug(&quot;debug message&quot;)</span></span><br><span class="line"><span class="comment"># logger.info(&quot;info message&quot;)</span></span><br><span class="line"><span class="comment"># logger.warning(&quot;warning message&quot;)</span></span><br><span class="line"><span class="comment"># logger.error(&quot;error message&quot;)</span></span><br><span class="line"><span class="comment"># logger.critical(&quot;critical message&quot;)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">    i = random.randint(<span class="number">0</span>, <span class="number">10</span>)</span><br><span class="line">    <span class="keyword">if</span> i &lt;= <span class="number">4</span>:</span><br><span class="line">        logger.info(<span class="string">&quot;Value is &#123;&#125; - Everything is fine&quot;</span>.<span class="built_in">format</span>(i))</span><br><span class="line">    <span class="keyword">elif</span> i &lt;= <span class="number">6</span>:</span><br><span class="line">        logger.warning(<span class="string">&quot;Value is &#123;&#125; - System is getting hot&quot;</span>.<span class="built_in">format</span>(i))</span><br><span class="line">    <span class="keyword">elif</span> i &lt;= <span class="number">8</span>:</span><br><span class="line">        logger.error(<span class="string">&quot;Value is &#123;&#125; - Dangerous region&quot;</span>.<span class="built_in">format</span>(i))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        logger.critical(<span class="string">&quot;Maximum value reached&quot;</span>)</span><br><span class="line">    time.sleep(<span class="number">0.3</span>)</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ python logger.py</span><br><span class="line"><span class="comment"># Raw output as with just prints</span></span><br><span class="line">$ python logger.py <span class="built_in">log</span></span><br><span class="line"><span class="comment"># Log formatted output</span></span><br><span class="line">$ python logger.py <span class="built_in">log</span> ERROR</span><br><span class="line"><span class="comment"># Print only ERROR levels and above</span></span><br><span class="line">$ python logger.py color</span><br><span class="line"><span class="comment"># Color formatted output</span></span><br></pre></td></tr></table></figure><p>有很多技巧可以使日志的可读性变得更好，我最喜欢的一个是技巧是对其进行着色。到目前为止，您应该已经知道，以彩色文本显示终端信息时可读性更好。但是应该如何设置呢？</p><p><code>ls</code> 和 <code>grep</code> 这样的程序会使用 <a href="https://en.wikipedia.org/wiki/ANSI_escape_code">ANSI escape codes</a>，它是一系列的特殊字符，可以使您的 shell 改变输出结果的颜色。例如，执行 <code>echo -e &quot;\e[38;2;255;0;0mThis is red\e[0m&quot;</code> 会打印红色的字符串：<code>This is red</code> 。只要您的终端支持 <a href="https://gist.github.com/XVilka/8346728#terminals--true-color">真彩色</a>。如果您的终端不支持真彩色（例如 MacOS 的 Terminal. app），您可以使用支持更加广泛的 16 色，例如：<code>\e[31; 1 mThis is red\e[0m</code>。</p><p>下面这个脚本向您展示了如何在终端中打印多种颜色（只要您的终端支持真彩色）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env bash</span></span><br><span class="line"><span class="keyword">for</span> R <span class="keyword">in</span> $(<span class="built_in">seq</span> 0 20 255); <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">for</span> G <span class="keyword">in</span> $(<span class="built_in">seq</span> 0 20 255); <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">for</span> B <span class="keyword">in</span> $(<span class="built_in">seq</span> 0 20 255); <span class="keyword">do</span></span><br><span class="line">            <span class="built_in">printf</span> <span class="string">&quot;\e[38;2;<span class="variable">$&#123;R&#125;</span>;<span class="variable">$&#123;G&#125;</span>;<span class="variable">$&#123;B&#125;</span>m█\e[0m&quot;</span>;</span><br><span class="line">        <span class="keyword">done</span></span><br><span class="line">    <span class="keyword">done</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><h2 id="第三方日志系统"><a href="#第三方日志系统" class="headerlink" title="第三方日志系统"></a>第三方日志系统</h2><p>如果您正在构建大型软件系统，您很可能会使用到一些依赖，有些依赖会作为程序单独运行。如 Web 服务器、数据库或消息代理都是此类常见的第三方依赖。</p><p>和这些系统交互的时候，阅读它们的日志是非常必要的，因为仅靠客户端侧的错误信息可能并不足以定位问题。</p><p>幸运的是，大多数的程序都会将日志保存在您的系统中的某个地方。对于 UNIX 系统来说，程序的日志通常存放在 <code>/var/log</code>。例如， <a href="https://www.nginx.com/">NGINX</a> web 服务器就将其日志存放于 <code>/var/log/nginx</code>。</p><p>目前，系统开始使用 <strong>system log</strong>，您所有的日志都会保存在这里。大多数（但不是全部的）Linux 系统都会使用 <code>systemd</code>，这是一个系统守护进程，它会控制您系统中的很多东西，例如哪些服务应该启动并运行。<code>systemd</code> 会将日志以某种特殊格式存放于 <code>/var/log/journal</code>，您可以使用 <a href="http://man7.org/linux/man-pages/man1/journalctl.1.html"><code>journalctl</code></a> 命令显示这些消息。</p><p>类似地，在 macOS 系统中是 <code>/var/log/system.log</code>，但是有更多的工具会使用系统日志，它的内容可以使用 <a href="https://www.manpagez.com/man/1/log/"><code>log show</code></a> 显示。</p><p>对于大多数的 UNIX 系统，您也可以使用 <a href="http://man7.org/linux/man-pages/man1/dmesg.1.html"><code>dmesg</code></a> 命令来读取内核的日志。</p><p>如果您希望将日志加入到系统日志中，您可以使用 <a href="http://man7.org/linux/man-pages/man1/logger.1.html"><code>logger</code></a> 这个 shell 程序。下面这个例子显示了如何使用 <code>logger</code> 并且如何找到能够将其存入系统日志的条目。</p><p>不仅如此，大多数的编程语言都支持向系统日志中写日志。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">logger <span class="string">&quot;Hello Logs&quot;</span></span><br><span class="line"><span class="comment"># On macOS</span></span><br><span class="line"><span class="built_in">log</span> show --last 1m | grep Hello</span><br><span class="line"><span class="comment"># On Linux</span></span><br><span class="line">journalctl --since <span class="string">&quot;1m ago&quot;</span> | grep Hello</span><br></pre></td></tr></table></figure><p>正如我们在数据整理那节课上看到的那样，日志的内容可以非常的多，我们需要对其进行处理和过滤才能得到我们想要的信息。</p><p>如果您发现您需要对 <code>journalctl</code> 和 <code>log show</code> 的结果进行大量的过滤，那么此时可以考虑使用它们自带的选项对其结果先过滤一遍再输出。还有一些像 <a href="http://lnav.org/"><code>lnav</code></a> 这样的工具，它为日志文件提供了更好的展现和浏览方式。</p><h2 id="调试器"><a href="#调试器" class="headerlink" title="调试器"></a>调试器</h2><p>当通过打印已经不能满足您的调试需求时，您应该使用调试器。</p><p>调试器是一种可以允许我们和正在执行的程序进行交互的程序，它可以做到：</p><ul><li>当到达某一行时将程序暂停；</li><li>一次一条指令地逐步执行程序；</li><li>程序崩溃后查看变量的值；</li><li>满足特定条件时暂停程序；</li><li>其他高级功能。</li></ul><p>很多编程语言都有自己的调试器。Python 的调试器是 <a href="https://docs.python.org/3/library/pdb.html"><code>pdb</code></a>.</p><p>下面对 <code>pdb</code> 支持的命令进行简单的介绍：</p><ul><li><strong>l</strong>(ist) - 显示当前行附近的 11 行或继续执行之前的显示；</li><li><strong>s</strong>(tep) - 执行当前行，并在第一个可能的地方停止；</li><li><strong>n</strong>(ext) - 继续执行直到当前函数的下一条语句或者 return 语句；</li><li><strong>b</strong>(reak) - 设置断点（基于传入的参数）；</li><li><strong>p</strong>(rint) - 在当前上下文对表达式求值并打印结果。还有一个命令是<strong>pp</strong> ，它使用 <a href="https://docs.python.org/3/library/pprint.html"><code>pprint</code></a> 打印；</li><li><strong>r</strong>(eturn) - 继续执行直到当前函数返回；</li><li><strong>q</strong>(uit) - 退出调试器。</li></ul><p>让我们使用 <code>pdb</code> 来修复下面的 Python 代码（参考讲座视频）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">bubble_sort</span>(<span class="params">arr</span>):</span><br><span class="line">    n = <span class="built_in">len</span>(arr)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">if</span> arr[j] &gt; arr[j+<span class="number">1</span>]:</span><br><span class="line">                arr[j] = arr[j+<span class="number">1</span>]</span><br><span class="line">                arr[j+<span class="number">1</span>] = arr[j]</span><br><span class="line">    <span class="keyword">return</span> arr</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(bubble_sort([<span class="number">4</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">6</span>]))</span><br></pre></td></tr></table></figure><p>注意，因为 Python 是一种解释型语言，所以我们可以通过 <code>pdb</code> shell 执行命令。<br><a href="https://pypi.org/project/ipdb/"><code>ipdb</code></a> 是一种增强型的 <code>pdb</code> ，它使用 <a href="https://ipython.org/"><code>IPython</code></a> 作为 REPL 并开启了 tab 补全、语法高亮、更好的回溯和更好的内省，同时还保留了 <code>pdb</code> 模块相同的接口。</p><p>对于更底层的编程语言，您可能需要了解一下 <a href="https://www.gnu.org/software/gdb/"><code>gdb</code></a> ( 以及它的改进版 <a href="https://github.com/pwndbg/pwndbg"><code>pwndbg</code></a>) 和 <a href="https://lldb.llvm.org/"><code>lldb</code></a>。</p><p>它们都对类 C 语言的调试进行了优化，它允许您探索任意进程及其机器状态：寄存器、堆栈、程序计数器等。</p><h2 id="专门工具"><a href="#专门工具" class="headerlink" title="专门工具"></a>专门工具</h2><p>即使您需要调试的程序是一个二进制的黑盒程序，仍然有一些工具可以帮助到您。当您的程序需要执行一些只有操作系统内核才能完成的操作时，它需要使用 <a href="https://en.wikipedia.org/wiki/System_call">系统调用</a>。有一些命令可以帮助您追踪您的程序执行的系统调用。在 Linux 中可以使用 <a href="http://man7.org/linux/man-pages/man1/strace.1.html"><code>strace</code></a> ，在 macOS 和 BSD 中可以使用 <a href="http://dtrace.org/blogs/about/"><code>dtrace</code></a>。<code>dtrace</code> 用起来可能有些别扭，因为它使用的是它自有的 <code>D</code> 语言，但是我们可以使用一个叫做 <a href="https://www.manpagez.com/man/1/dtruss/"><code>dtruss</code></a> 的封装使其具有和 <code>strace</code> (更多信息参考 <a href="https://8thlight.com/blog/colin-jones/2015/11/06/dtrace-even-better-than-strace-for-osx.html">这里</a>) 类似的接口</p><p>下面的例子展现来如何使用 <code>strace</code> 或 <code>dtruss</code> 来显示 <code>ls</code> 执行时，对 <a href="http://man7.org/linux/man-pages/man2/stat.2.html"><code>stat</code></a> 系统调用进行追踪对结果。若需要深入了解 <code>strace</code>，<a href="https://blogs.oracle.com/linux/strace-the-sysadmins-microscope-v2">这篇文章</a> 值得一读。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># On Linux</span></span><br><span class="line">sudo strace -e lstat <span class="built_in">ls</span> -l &gt; /dev/null</span><br><span class="line">4</span><br><span class="line"><span class="comment"># On macOS</span></span><br><span class="line">sudo dtruss -t lstat64_extended <span class="built_in">ls</span> -l &gt; /dev/null</span><br></pre></td></tr></table></figure><p>有些情况下，我们需要查看网络数据包才能定位问题。像 <a href="http://man7.org/linux/man-pages/man1/tcpdump.1.html"><code>tcpdump</code></a> 和 <a href="https://www.wireshark.org/">Wireshark</a> 这样的网络数据包分析工具可以帮助您获取网络数据包的内容并基于不同的条件进行过滤。</p><p>对于 web 开发， Chrome&#x2F;Firefox 的开发者工具非常方便，功能也很强大：</p><ul><li>源码 - 查看任意站点的 HTML&#x2F;CSS&#x2F;JS 源码；</li><li>实时地修改 HTML, CSS, JS 代码 - 修改网站的内容、样式和行为用于测试（从这一点您也能看出来，网页截图是不可靠的）；</li><li>Javascript shell - 在 JS REPL 中执行命令；</li><li>网络 - 分析请求的时间线；</li><li>存储 - 查看 Cookies 和本地应用存储。</li></ul><h2 id="静态分析"><a href="#静态分析" class="headerlink" title="静态分析"></a>静态分析</h2><p>有些问题是您不需要执行代码就能发现的。例如，仔细观察一段代码，您就能发现某个循环变量覆盖了某个已经存在的变量或函数名；或是有个变量在被读取之前并没有被定义。<br>这种情况下 <a href="https://en.wikipedia.org/wiki/Static_program_analysis">静态分析</a> 工具就可以帮我们找到问题。静态分析会将程序的源码作为输入然后基于编码规则对其进行分析并对代码的正确性进行推理。</p><p>下面这段 Python 代码中存在几个问题。首先，我们的循环变量 <code>foo</code> 覆盖了之前定义的函数 <code>foo</code>。最后一行，我们还把 <code>bar</code> 错写成了 <code>baz</code>，因此当程序完成 <code>sleep</code> (一分钟) 后，执行到这一行的时候便会崩溃。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="number">42</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> foo <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">    <span class="built_in">print</span>(foo)</span><br><span class="line">bar = <span class="number">1</span></span><br><span class="line">bar *= <span class="number">0.2</span></span><br><span class="line">time.sleep(<span class="number">60</span>)</span><br><span class="line"><span class="built_in">print</span>(baz)</span><br></pre></td></tr></table></figure><p>静态分析工具可以发现此类的问题。当我们使用 <a href="https://pypi.org/project/pyflakes"><code>pyflakes</code></a> 分析代码的时候，我们会得到与这两处 bug 相关的错误信息。<a href="http://mypy-lang.org/"><code>mypy</code></a> 则是另外一个工具，它可以对代码进行类型检查。这里，<code>mypy</code> 会经过我们 <code>bar</code> 起初是一个 <code>int</code> ，然后变成了 <code>float</code>。这些问题都可以在不运行代码的情况下被发现。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ pyflakes foobar.py</span><br><span class="line">foobar.py:6: redefinition of unused <span class="string">&#x27;foo&#x27;</span> from line 3</span><br><span class="line">foobar.py:11: undefined name <span class="string">&#x27;baz&#x27;</span></span><br><span class="line"></span><br><span class="line">$ mypy foobar.py</span><br><span class="line">foobar.py:6: error: Incompatible types <span class="keyword">in</span> assignment (expression has <span class="built_in">type</span> <span class="string">&quot;int&quot;</span>, variable has <span class="built_in">type</span> <span class="string">&quot;Callable[[], Any]&quot;</span>)</span><br><span class="line">foobar.py:9: error: Incompatible types <span class="keyword">in</span> assignment (expression has <span class="built_in">type</span> <span class="string">&quot;float&quot;</span>, variable has <span class="built_in">type</span> <span class="string">&quot;int&quot;</span>)</span><br><span class="line">foobar.py:11: error: Name <span class="string">&#x27;baz&#x27;</span> is not defined</span><br><span class="line">Found 3 errors <span class="keyword">in</span> 1 file (checked 1 <span class="built_in">source</span> file)</span><br></pre></td></tr></table></figure><p>在 shell 工具那一节课的时候，我们介绍了 <a href="https://www.shellcheck.net/"><code>shellcheck</code></a>，这是一个类似的工具，但它是应用于 shell 脚本的。</p><p>大多数的编辑器和 IDE 都支持在编辑界面显示这些工具的分析结果、高亮有警告和错误的位置。<br>这个过程通常称为 <strong>code linting</strong> 。风格检查或安全检查的结果同样也可以进行相应的显示。</p><p>在 vim 中，有 <a href="https://vimawesome.com/plugin/ale"><code>ale</code></a> 或 <a href="https://vimawesome.com/plugin/syntastic"><code>syntastic</code></a> 可以帮助您做同样的事情。<br>在 Python 中， <a href="https://www.pylint.org/"><code>pylint</code></a> 和 <a href="https://pypi.org/project/pep8/"><code>pep8</code></a> 是两种用于进行风格检查的工具，而 <a href="https://pypi.org/project/bandit/"><code>bandit</code></a> 工具则用于检查安全相关的问题。</p><p>对于其他语言的开发者来说，静态分析工具可以参考这个列表：<a href="https://github.com/mre/awesome-static-analysis">Awesome Static Analysis</a> (您也许会对 <em>Writing</em> 一节感兴趣) 。对于 linters 则可以参考这个列表： <a href="https://github.com/caramelomartins/awesome-linters">Awesome Linters</a>。</p><p>对于风格检查和代码格式化，还有以下一些工具可以作为补充：用于 Python 的 <a href="https://github.com/psf/black"><code>black</code></a>、用于 Go 语言的 <code>gofmt</code>、用于 Rust 的 <code>rustfmt</code> 或是用于 JavaScript, HTML 和 CSS 的 <a href="https://prettier.io/"><code>prettier</code></a> 。这些工具可以自动格式化您的代码，这样代码风格就可以与常见的风格保持一致。<br>尽管您可能并不想对代码进行风格控制，标准的代码风格有助于方便别人阅读您的代码，也可以方便您阅读它的代码。</p><h1 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h1><p>即使您的代码能够像您期望的一样运行，但是如果它消耗了您全部的 CPU 和内存，那么它显然也不是个好程序。算法课上我们通常会介绍大 O 标记法，但却没教给我们如何找到程序中的热点。<br>鉴于 <a href="http://wiki.c2.com/?PrematureOptimization">过早的优化是万恶之源</a>，您需要学习性能分析和监控工具，它们会帮助您找到程序中最耗时、最耗资源的部分，这样您就可以有针对性的进行性能优化。</p><h2 id="计时"><a href="#计时" class="headerlink" title="计时"></a>计时</h2><p>和调试代码类似，大多数情况下我们只需要打印两处代码之间的时间即可发现问题。下面这个例子中，我们使用了 Python 的 <a href="https://docs.python.org/3/library/time.html"><code>time</code></a> 模块。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time, random</span><br><span class="line">n = random.randint(<span class="number">1</span>, <span class="number">10</span>) * <span class="number">100</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取当前时间 </span></span><br><span class="line">start = time.time()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行一些操作</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Sleeping for &#123;&#125; ms&quot;</span>.<span class="built_in">format</span>(n))</span><br><span class="line">time.sleep(n/<span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 比较当前时间和起始时间</span></span><br><span class="line"><span class="built_in">print</span>(time.time() - start)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Output</span></span><br><span class="line"><span class="comment"># Sleeping for 500 ms</span></span><br><span class="line"><span class="comment"># 0.5713930130004883</span></span><br></pre></td></tr></table></figure><p>不过，执行时间（wall clock time）也可能会误导您，因为您的电脑可能也在同时运行其他进程，也可能在此期间发生了等待。对于工具来说，需要区分真实时间、用户时间和系统时间。通常来说，用户时间 + 系统时间代表了您的进程所消耗的实际 CPU （更详细的解释可以参照 <a href="https://stackoverflow.com/questions/556405/what-do-real-user-and-sys-mean-in-the-output-of-time1">这篇文章</a>）。</p><ul><li>真实时间 - 从程序开始到结束流失掉的真实时间，包括其他进程的执行时间以及阻塞消耗的时间（例如等待 I&#x2F;O 或网络）；</li><li><em>User</em> - CPU 执行用户代码所花费的时间；</li><li><em>Sys</em> - CPU 执行系统内核代码所花费的时间。</li></ul><p>例如，试着执行一个用于发起 HTTP 请求的命令并在其前面添加 <a href="http://man7.org/linux/man-pages/man1/time.1.html"><code>time</code></a> 前缀。网络不好的情况下您可能会看到下面的输出结果。请求花费了 2 s 才完成，但是进程仅花费了 15 ms 的 CPU 用户时间和 12 ms 的 CPU 内核时间。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ time curl https://missing.csail.mit.edu &amp;&gt; /dev/null</span><br><span class="line">real    0m2.561s</span><br><span class="line">user    0m0.015s</span><br><span class="line">sys     0m0.012s</span><br></pre></td></tr></table></figure><h2 id="性能分析工具（profilers）"><a href="#性能分析工具（profilers）" class="headerlink" title="性能分析工具（profilers）"></a>性能分析工具（profilers）</h2><h3 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h3><p>大多数情况下，当人们提及性能分析工具的时候，通常指的是 CPU 性能分析工具。<br>CPU 性能分析工具有两种： 追踪分析器（_tracing_）及采样分析器（_sampling_）。<br>追踪分析器会记录程序的每一次函数调用，而采样分析器则只会周期性的监测（通常为每毫秒）您的程序并记录程序堆栈。它们使用这些记录来生成统计信息，显示程序在哪些事情上花费了最多的时间。如果您希望了解更多相关信息，可以参考 <a href="https://jvns.ca/blog/2017/12/17/how-do-ruby---python-profilers-work-">这篇</a> 介绍性的文章。</p><p>大多数的编程语言都有一些基于命令行的分析器，我们可以使用它们来分析代码。它们通常可以集成在 IDE 中，但是本节课我们会专注于这些命令行工具本身。</p><p>在 Python 中，我们使用 <code>cProfile</code> 模块来分析每次函数调用所消耗的时间。在下面的例子中，我们实现了一个基础的 grep 命令：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys, re</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">grep</span>(<span class="params">pattern, file</span>):</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(file, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="built_in">print</span>(file)</span><br><span class="line">        <span class="keyword">for</span> i, line <span class="keyword">in</span> <span class="built_in">enumerate</span>(f.readlines()):</span><br><span class="line">            pattern = re.<span class="built_in">compile</span>(pattern)</span><br><span class="line">            <span class="keyword">match</span> = pattern.search(line)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">match</span> <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;&#123;&#125;: &#123;&#125;&quot;</span>.<span class="built_in">format</span>(i, line), end=<span class="string">&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    times = <span class="built_in">int</span>(sys.argv[<span class="number">1</span>])</span><br><span class="line">    pattern = sys.argv[<span class="number">2</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(times):</span><br><span class="line">        <span class="keyword">for</span> file <span class="keyword">in</span> sys.argv[<span class="number">3</span>:]:</span><br><span class="line">            grep(pattern, file)</span><br></pre></td></tr></table></figure><p>我们可以使用下面的命令来对这段代码进行分析。通过它的输出我们可以知道，IO 消耗了大量的时间，编译正则表达式也比较耗费时间。因为正则表达式只需要编译一次，我们可以将其移动到 for 循环外面来改进性能。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ python -m cProfile -s tottime grep.py 1000 &#x27;^(import|\s*def)[^,]*$&#x27; *.py</span><br><span class="line"></span><br><span class="line">[omitted program output]</span><br><span class="line"></span><br><span class="line"> ncalls  tottime  percall  cumtime  percall filename:lineno(function)</span><br><span class="line">   8000    0.266    0.000    0.292    0.000 &#123;built-in method io.open&#125;</span><br><span class="line">   8000    0.153    0.000    0.894    0.000 grep.py:5(grep)</span><br><span class="line">  17000    0.101    0.000    0.101    0.000 &#123;built-in method builtins.print&#125;</span><br><span class="line">   8000    0.100    0.000    0.129    0.000 &#123;method &#x27;readlines&#x27; of &#x27;_io._IOBase&#x27; objects&#125;</span><br><span class="line">  93000    0.097    0.000    0.111    0.000 re.py:286(_compile)</span><br><span class="line">  93000    0.069    0.000    0.069    0.000 &#123;method &#x27;search&#x27; of &#x27;_sre.SRE_Pattern&#x27; objects&#125;</span><br><span class="line">  93000    0.030    0.000    0.141    0.000 re.py:231(compile)</span><br><span class="line">  17000    0.019    0.000    0.029    0.000 codecs.py:318(decode)</span><br><span class="line">      1    0.017    0.017    0.911    0.911 grep.py:3(&lt;module&gt;)</span><br><span class="line"></span><br><span class="line">[omitted lines]</span><br></pre></td></tr></table></figure><p>关于 Python 的 <code>cProfile</code> 分析器（以及其他一些类似的分析器），需要注意的是它显示的是每次函数调用的时间。看上去可能快到反直觉，尤其是如果您在代码里面使用了第三方的函数库，因为内部函数调用也会被看作函数调用。</p><p>更加符合直觉的显示分析信息的方式是包括每行代码的执行时间，这也是 _ 行分析器 _ 的工作。例如，下面这段 Python 代码会向本课程的网站发起一个请求，然后解析响应返回的页面中的全部 URL：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这个装饰器会告诉行分析器 </span></span><br><span class="line"><span class="comment"># 我们想要分析这个函数</span></span><br><span class="line"><span class="meta">@profile</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_urls</span>():</span><br><span class="line">    response = requests.get(<span class="string">&#x27;https://missing.csail.mit.edu&#x27;</span>)</span><br><span class="line">    s = BeautifulSoup(response.content, <span class="string">&#x27;lxml&#x27;</span>)</span><br><span class="line">    urls = []</span><br><span class="line">    <span class="keyword">for</span> url <span class="keyword">in</span> s.find_all(<span class="string">&#x27;a&#x27;</span>):</span><br><span class="line">        urls.append(url[<span class="string">&#x27;href&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    get_urls()</span><br></pre></td></tr></table></figure><p>如果我们使用 Python 的 <code>cProfile</code> 分析器，我们会得到超过 2500 行的输出结果，即使对其进行排序，我仍然搞不懂时间到底都花在哪了。如果我们使用 <a href="https://github.com/pyutils/line_profiler"><code>line_profiler</code></a>，它会基于行来显示时间：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ kernprof -l -v a.py</span><br><span class="line">Wrote profile results to urls.py.lprof</span><br><span class="line">Timer unit: 1e-06 s</span><br><span class="line"></span><br><span class="line">Total time: 0.636188 s</span><br><span class="line">File: a.py</span><br><span class="line">Function: get_urls at line 5</span><br><span class="line"></span><br><span class="line">Line <span class="comment">#  Hits         Time  Per Hit   % Time  Line Contents</span></span><br><span class="line">==============================================================</span><br><span class="line"> 5                                           @profile</span><br><span class="line"> 6                                           def get_urls():</span><br><span class="line"> 7         1     613909.0 613909.0     96.5      response = requests.get(<span class="string">&#x27;https://missing.csail.mit.edu&#x27;</span>)</span><br><span class="line"> 8         1      21559.0  21559.0      3.4      s = BeautifulSoup(response.content, <span class="string">&#x27;lxml&#x27;</span>)</span><br><span class="line"> 9         1          2.0      2.0      0.0      urls = []</span><br><span class="line">10        25        685.0     27.4      0.1      <span class="keyword">for</span> url <span class="keyword">in</span> s.find_all(<span class="string">&#x27;a&#x27;</span>):</span><br><span class="line">11        24         33.0      1.4      0.0          urls.append(url[<span class="string">&#x27;href&#x27;</span>])</span><br></pre></td></tr></table></figure><h3 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h3><p>像 C 或者 C++ 这样的语言，内存泄漏会导致您的程序在使用完内存后不去释放它。为了应对内存类的 Bug，我们可以使用类似 <a href="https://valgrind.org/">Valgrind</a> 这样的工具来检查内存泄漏问题。</p><p>对于 Python 这类具有垃圾回收机制的语言，内存分析器也是很有用的，因为对于某个对象来说，只要有指针还指向它，那它就不会被回收。</p><p>下面这个例子及其输出，展示了 <a href="https://pypi.org/project/memory-profiler/">memory-profiler</a> 是如何工作的（注意装饰器和 <code>line-profiler</code> 类似）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@profile</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">my_func</span>():</span><br><span class="line">    a = [<span class="number">1</span>] * (<span class="number">10</span> ** <span class="number">6</span>)</span><br><span class="line">    b = [<span class="number">2</span>] * (<span class="number">2</span> * <span class="number">10</span> ** <span class="number">7</span>)</span><br><span class="line">    <span class="keyword">del</span> b</span><br><span class="line">    <span class="keyword">return</span> a</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    my_func()</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ python -m memory_profiler example.py</span><br><span class="line">Line <span class="comment">#    Mem usage  Increment   Line Contents</span></span><br><span class="line">==============================================</span><br><span class="line">     3                           @profile</span><br><span class="line">     4      5.97 MB    0.00 MB   def my_func():</span><br><span class="line">     5     13.61 MB    7.64 MB       a = [1] * (10 ** 6)</span><br><span class="line">     6    166.20 MB  152.59 MB       b = [2] * (2 * 10 ** 7)</span><br><span class="line">     7     13.61 MB -152.59 MB       del b</span><br><span class="line">     8     13.61 MB    0.00 MB       <span class="built_in">return</span> a</span><br></pre></td></tr></table></figure><h3 id="事件分析"><a href="#事件分析" class="headerlink" title="事件分析"></a>事件分析</h3><p>在我们使用 <code>strace</code> 调试代码的时候，您可能会希望忽略一些特殊的代码并希望在分析时将其当作黑盒处理。<a href="http://man7.org/linux/man-pages/man1/perf.1.html"><code>perf</code></a> 命令将 CPU 的区别进行了抽象，它不会报告时间和内存的消耗，而是报告与您的程序相关的系统事件。</p><p>例如，<code>perf</code> 可以报告不佳的缓存局部性（poor cache locality）、大量的页错误（page faults）或活锁（livelocks）。下面是关于常见命令的简介：</p><ul><li><code>perf list</code> - 列出可以被 pref 追踪的事件；</li><li><code>perf stat COMMAND ARG1 ARG2</code> - 收集与某个进程或指令相关的事件；</li><li><code>perf record COMMAND ARG1 ARG2</code> - 记录命令执行的采样信息并将统计数据储存在 <code>perf.data</code> 中；</li><li><code>perf report</code> - 格式化并打印 <code>perf.data</code> 中的数据。</li></ul><h3 id="可视化"><a href="#可视化" class="headerlink" title="可视化"></a>可视化</h3><p>使用分析器来分析真实的程序时，由于软件的复杂性，其输出结果中将包含大量的信息。人类是一种视觉动物，非常不善于阅读大量的文字。因此很多工具都提供了可视化分析器输出结果的功能。</p><p>对于采样分析器来说，常见的显示 CPU 分析数据的形式是 <a href="http://www.brendangregg.com/flamegraphs.html">火焰图</a>，火焰图会在 Y 轴显示函数调用关系，并在 X 轴显示其耗时的比例。火焰图同时还是可交互的，您可以深入程序的某一具体部分，并查看其栈追踪（您可以尝试点击下面的图片）。</p><p><a href="http://www.brendangregg.com/FlameGraphs/cpu-bash-flamegraph.svg"><img src="/../../../img/blog/ce2d4aa6e3bdcbd15166776c3bbe1b60_MD5.svg" alt="FlameGraph"></a></p><p>调用图和控制流图可以显示子程序之间的关系，它将函数作为节点并把函数调用作为边。将它们和分析器的信息（例如调用次数、耗时等）放在一起使用时，调用图会变得非常有用，它可以帮助我们分析程序的流程。<br>在 Python 中您可以使用 <a href="http://pycallgraph.slowchop.com/en/master/"><code>pycallgraph</code></a> 来生成这些图片。</p><p><img src="/../../../img/blog/24b2b71d06a9deb24a621d430d7c7e49_MD5.png" alt="Call Graph"></p><h2 id="资源监控"><a href="#资源监控" class="headerlink" title="资源监控"></a>资源监控</h2><p>有时候，分析程序性能的第一步是搞清楚它所消耗的资源。程序变慢通常是因为它所需要的资源不够了。例如，没有足够的内存或者网络连接变慢的时候。</p><p>有很多很多的工具可以被用来显示不同的系统资源，例如 CPU 占用、内存使用、网络、磁盘使用等。</p><ul><li><strong>通用监控</strong> - 最流行的工具要数 <a href="https://htop.dev/"><code>htop</code></a>, 了，它是 <a href="http://man7.org/linux/man-pages/man1/top.1.html"><code>top</code></a> 的改进版。<code>htop</code> 可以显示当前运行进程的多种统计信息。<code>htop</code> 有很多选项和快捷键，常见的有：<code>&lt;F6&gt;</code> 进程排序、 <code>t</code> 显示树状结构和 <code>h</code> 打开或折叠线程。还可以留意一下 <a href="https://nicolargo.github.io/glances/"><code>glances</code></a> ，它的实现类似但是用户界面更好。如果需要合并测量全部的进程， <a href="http://dag.wiee.rs/home-made/dstat/"><code>dstat</code></a> 是也是一个非常好用的工具，它可以实时地计算不同子系统资源的度量数据，例如 I&#x2F;O、网络、 CPU 利用率、上下文切换等等；</li><li><strong>I&#x2F;O 操作</strong> - <a href="http://man7.org/linux/man-pages/man8/iotop.8.html"><code>iotop</code></a> 可以显示实时 I&#x2F;O 占用信息而且可以非常方便地检查某个进程是否正在执行大量的磁盘读写操作；</li><li><strong>磁盘使用</strong> - <a href="http://man7.org/linux/man-pages/man1/df.1.html"><code>df</code></a> 可以显示每个分区的信息，而 <a href="http://man7.org/linux/man-pages/man1/du.1.html"><code>du</code></a> 则可以显示当前目录下每个文件的磁盘使用情况（ <strong>d</strong>isk <strong>u</strong>sage）。<code>-h</code> 选项可以使命令以对人类（<strong>h</strong>uman）更加友好的格式显示数据；<a href="https://dev.yorhel.nl/ncdu"><code>ncdu</code></a> 是一个交互性更好的 <code>du</code> ，它可以让您在不同目录下导航、删除文件和文件夹；</li><li><strong>内存使用</strong> - <a href="http://man7.org/linux/man-pages/man1/free.1.html"><code>free</code></a> 可以显示系统当前空闲的内存。内存也可以使用 <code>htop</code> 这样的工具来显示；</li><li><strong>打开文件</strong> - <a href="http://man7.org/linux/man-pages/man8/lsof.8.html"><code>lsof</code></a> 可以列出被进程打开的文件信息。当我们需要查看某个文件是被哪个进程打开的时候，这个命令非常有用；</li><li><strong>网络连接和配置</strong> - <a href="http://man7.org/linux/man-pages/man8/ss.8.html"><code>ss</code></a> 能帮助我们监控网络包的收发情况以及网络接口的显示信息。<code>ss</code> 常见的一个使用场景是找到端口被进程占用的信息。如果要显示路由、网络设备和接口信息，您可以使用 <a href="http://man7.org/linux/man-pages/man8/ip.8.html"><code>ip</code></a> 命令。注意，<code>netstat</code> 和 <code>ifconfig</code> 这两个命令已经被前面那些工具所代替了。</li><li><strong>网络使用</strong> - <a href="https://github.com/raboof/nethogs"><code>nethogs</code></a> 和 <a href="http://www.ex-parrot.com/pdw/iftop/"><code>iftop</code></a> 是非常好的用于对网络占用进行监控的交互式命令行工具。</li></ul><p>如果您希望测试一下这些工具，您可以使用 <a href="https://linux.die.net/man/1/stress"><code>stress</code></a> 命令来为系统人为地增加负载。</p><h3 id="专用工具"><a href="#专用工具" class="headerlink" title="专用工具"></a>专用工具</h3><p>有时候，您只需要对黑盒程序进行基准测试，并依此对软件选择进行评估。<br>类似 <a href="https://github.com/sharkdp/hyperfine"><code>hyperfine</code></a> 这样的命令行可以帮您快速进行基准测试。例如，我们在 shell 工具和脚本那一节课中我们推荐使用 <code>fd</code> 来代替 <code>find</code>。我们这里可以用 <code>hyperfine</code> 来比较一下它们。</p><p>例如，下面的例子中，我们可以看到 <code>fd</code> 比 <code>find</code> 要快 20 倍。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ hyperfine --warmup 3 <span class="string">&#x27;fd -e jpg&#x27;</span> <span class="string">&#x27;find . -iname &quot;*. jpg&quot;&#x27;</span></span><br><span class="line">Benchmark <span class="comment">#1 : fd -e jpg</span></span><br><span class="line">  Time (mean ± σ):      51.4 ms ±   2.9 ms    [User: 121.0 ms, System: 160.5 ms]</span><br><span class="line">  Range (min … max):    44.2 ms …  60.1 ms    56 runs</span><br><span class="line"></span><br><span class="line">Benchmark <span class="comment">#2 : find . -iname &quot;*. jpg&quot;</span></span><br><span class="line">  Time (mean ± σ):      1.126 s ±  0.101 s    [User: 141.1 ms, System: 956.1 ms]</span><br><span class="line">  Range (min … max):    0.975 s …  1.287 s    10 runs</span><br><span class="line"></span><br><span class="line">Summary</span><br><span class="line">  <span class="string">&#x27;fd -e jpg&#x27;</span> ran</span><br><span class="line">   21.89 ± 2.33 <span class="built_in">times</span> faster than <span class="string">&#x27;find . -iname &quot;*. jpg&quot;&#x27;</span></span><br></pre></td></tr></table></figure><p>和 debug 一样，浏览器也包含了很多不错的性能分析工具，可以用来分析页面加载，让我们可以搞清楚时间都消耗在什么地方（加载、渲染、脚本等等）。更多关于 <a href="https://developer.mozilla.org/en-US/docs/Mozilla/Performance/Profiling_with_the_Built-in_Profiler">Firefox</a> 和 <a href="https://developers.google.com/web/tools/chrome-devtools/rendering-tools">Chrome</a> 的信息可以点击链接。</p><h1 id="课后练习"><a href="#课后练习" class="headerlink" title="课后练习"></a>课后练习</h1><p>[习题解答](  &#x2F;  &#x2F;  )</p><h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><ol><li><p>使用 Linux 上的 <code>journalctl</code> 或 macOS 上的 <code>log show</code> 命令来获取最近一天中超级用户的登录信息及其所执行的指令。如果找不到相关信息，您可以执行一些无害的命令，例如 <code>sudo ls</code> 然后再次查看。</p></li><li><p>学习 <a href="https://github.com/spiside/pdb-tutorial">这份</a> <code>pdb</code> 实践教程并熟悉相关的命令。更深入的信息您可以参考 <a href="https://realpython.com/python-debugging-pdb">这份</a> 教程。</p></li><li><p>安装 <a href="https://www.shellcheck.net/"><code>shellcheck</code></a> 并尝试对下面的脚本进行检查。这段代码有什么问题吗？请修复相关问题。在您的编辑器中安装一个 linter 插件，这样它就可以自动地显示相关警告信息。</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="comment">## Example: a typical script with several problems</span></span><br><span class="line"><span class="keyword">for</span> f <span class="keyword">in</span> $(<span class="built_in">ls</span> *. m 3 u)</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  grep -qi hq.*mp 3 <span class="variable">$f</span> \</span><br><span class="line">    &amp;&amp; <span class="built_in">echo</span> -e <span class="string">&#x27;Playlist $f contains a HQ file in mp 3 format&#x27;</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure></li><li><p>(进阶题) 请阅读 <a href="https://undo.io/resources/reverse-debugging-whitepaper/">可逆调试</a> 并尝试创建一个可以工作的例子（使用 <a href="https://rr-project.org/"><code>rr</code></a> 或 <a href="https://morepypy.blogspot.com/2016/07/reverse-debugging-for-python.html"><code>RevPDB</code></a>）。</p></li></ol><h2 id="性能分析-1"><a href="#性能分析-1" class="headerlink" title="性能分析"></a>性能分析</h2><ol><li><p><a href="/static/files/sorts.py">这里</a> 有一些排序算法的实现。请使用 <a href="https://docs.python.org/3/library/profile.html"><code>cProfile</code></a> 和 <a href="https://github.com/pyutils/line_profiler"><code>line_profiler</code></a> 来比较插入排序和快速排序的性能。两种算法的瓶颈分别在哪里？然后使用 <code>memory_profiler</code> 来检查内存消耗，为什么插入排序更好一些？然后再看看原地排序版本的快排。附加题：使用 <code>perf</code> 来查看不同算法的循环次数及缓存命中及丢失情况。</p></li><li><p>这里有一些用于计算斐波那契数列 Python 代码，它为计算每个数字都定义了一个函数：</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fib</span> <span class="number">0</span> (): <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fib</span> <span class="number">1</span> (): <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line">s = <span class="string">&quot;&quot;&quot;def fib&#123;&#125;(): return fib&#123;&#125;() + fib&#123;&#125;()&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">range</span> (<span class="number">2</span>, <span class="number">10</span>):</span><br><span class="line">        <span class="built_in">exec</span> (s.<span class="built_in">format</span> (n, n-<span class="number">1</span>, n-<span class="number">2</span>))</span><br><span class="line">    <span class="comment"># from functools import lru_cache</span></span><br><span class="line">    <span class="comment"># for n in range (10):</span></span><br><span class="line">    <span class="comment">#     exec (&quot;fib&#123;&#125; = lru_cache (1)(fib&#123;&#125;)&quot;.format (n, n))</span></span><br><span class="line">    <span class="built_in">print</span> (<span class="built_in">eval</span> (<span class="string">&quot;fib 9 ()&quot;</span>))</span><br></pre></td></tr></table></figure><p>  将代码拷贝到文件中使其变为一个可执行的程序。首先安装 <a href="http://pycallgraph.slowchop.com/en/master/"><code>pycallgraph</code></a> 和 <a href="http://graphviz.org/"><code>graphviz</code></a> (如果您能够执行 <code>dot</code>, 则说明已经安装了 GraphViz.)。并使用 <code>pycallgraph graphviz -- ./fib. py</code> 来执行代码并查看 <code>pycallgraph. png</code> 这个文件。<code>fib 0</code> 被调用了多少次？我们可以通过记忆法来对其进行优化。将注释掉的部分放开，然后重新生成图片。这回每个 <code>fibN</code> 函数被调用了多少次？</p></li><li><p>我们经常会遇到的情况是某个我们希望去监听的端口已经被其他进程占用了。让我们通过进程的 PID 查找相应的进程。首先执行 <code>python -m http. server 4444</code> 启动一个最简单的 web 服务器来监听 <code>4444</code> 端口。在另外一个终端中，执行 <code>lsof | grep LISTEN</code> 打印出所有监听端口的进程及相应的端口。找到对应的 PID 然后使用 <code>kill &lt;PID&gt;</code> 停止该进程。</p></li><li><p>限制进程资源也是一个非常有用的技术。执行 <code>stress -c 3</code> 并使用 <code>htop</code> 对 CPU 消耗进行可视化。现在，执行 <code>taskset --cpu-list 0,2 stress -c 3</code> 并可视化。<code>stress</code> 占用了 3 个 CPU 吗？为什么没有？阅读 <a href="http://man7.org/linux/man-pages/man1/taskset.1.html"><code>man taskset</code></a> 来寻找答案。附加题：使用 <a href="http://man7.org/linux/man-pages/man7/cgroups.7.html"><code>cgroups</code></a> 来实现相同的操作，限制 <code>stress -m</code> 的内存使用。</p></li><li><p>(进阶题) <code>curl ipinfo. io</code> 命令或执行 HTTP 请求并获取关于您 IP 的信息。打开 <a href="https://www.wireshark.org/">Wireshark</a> 并抓取 <code>curl</code> 发起的请求和收到的回复报文。（提示：可以使用 <code>http</code> 进行过滤，只显示 HTTP 报文）</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 编程工具 </category>
          
          <category> 计算机教育缺失的一课 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机/编程工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>版本控制</title>
      <link href="/posts/%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%95%99%E8%82%B2%E7%BC%BA%E5%A4%B1%E7%9A%84%E4%B8%80%E8%AF%BE/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6.html"/>
      <url>/posts/%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%95%99%E8%82%B2%E7%BC%BA%E5%A4%B1%E7%9A%84%E4%B8%80%E8%AF%BE/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6.html</url>
      
        <content type="html"><![CDATA[<p>版本控制系统 (VCSs) 是一类用于追踪源代码（或其他文件、文件夹）改动的工具。顾名思义，这些工具可以帮助我们管理代码的修改历史；不仅如此，它还可以让协作编码变得更方便。VCS 通过一系列的快照将某个文件夹及其内容保存了起来，每个快照都包含了文件或文件夹的完整状态。同时它还维护了快照创建者的信息以及每个快照的相关信息等等。</p><p>为什么说版本控制系统非常有用？即使您只是一个人进行编程工作，它也可以帮您创建项目的快照，记录每个改动的目的、基于多分支并行开发等等。和别人协作开发时，它更是一个无价之宝，您可以看到别人对代码进行的修改，同时解决由于并行开发引起的冲突。</p><p>现代的版本控制系统可以帮助您轻松地（甚至自动地）回答以下问题：</p><ul><li>当前模块是谁编写的？</li><li>这个文件的这一行是什么时候被编辑的？是谁作出的修改？修改原因是什么呢？</li><li>最近的 1000 个版本中，何时&#x2F;为什么导致了单元测试失败？</li></ul><p>尽管版本控制系统有很多，其事实上的标准则是 <strong>Git</strong> 。而这篇 <a href="https://xkcd.com/1597/">XKCD 漫画</a> 则反映出了人们对 Git 的评价：</p><p><img src="/../../../img/blog/b5c393ca721a0a801b0418fcd39c8d7b_MD5.png" alt="xkcd 1597"></p><p>因为 Git 接口的抽象泄漏（leaky abstraction）问题，通过自顶向下的方式（从命令行接口开始）学习 Git 可能会让人感到非常困惑。很多时候您只能死记硬背一些命令行，然后像使用魔法一样使用它们，一旦出现问题，就只能像上面那幅漫画里说的那样去处理了。</p><p>尽管 Git 的接口有些丑陋，但是它的底层设计和思想却是非常优雅的。丑陋的接口只能靠死记硬背，而优雅的底层设计则非常容易被人理解。因此，我们将通过一种自底向上的方式向您介绍 Git。我们会从数据模型开始，最后再学习它的接口。一旦您搞懂了 Git 的数据模型，再学习其接口并理解这些接口是如何操作数据模型的就非常容易了。</p><h1 id="Git-的数据模型"><a href="#Git-的数据模型" class="headerlink" title="Git 的数据模型"></a>Git 的数据模型</h1><p>进行版本控制的方法很多。Git 拥有一个经过精心设计的模型，这使其能够支持版本控制所需的所有特性，例如维护历史记录、支持分支和促进协作。</p><h2 id="快照"><a href="#快照" class="headerlink" title="快照"></a>快照</h2><p>Git 将顶级目录中的文件和文件夹作为集合，并通过一系列快照来管理其历史记录。在 Git 的术语里，文件被称作 Blob 对象（数据对象），也就是一组数据。目录则被称之为 “ 树 “，它将名字与 Blob 对象或树对象进行映射（使得目录中可以包含其他目录）。快照则是被追踪的最顶层的树。例如，一个树看起来可能是这样的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;root&gt; (tree)</span><br><span class="line">|</span><br><span class="line">+- foo (tree)</span><br><span class="line">|  |</span><br><span class="line">|  + bar.txt (blob, contents = &quot;hello world&quot;)</span><br><span class="line">|</span><br><span class="line">+- baz.txt (blob, contents = &quot;git is wonderful&quot;)</span><br></pre></td></tr></table></figure><p>这个顶层的树包含了两个元素，一个名为 “foo” 的树（它本身包含了一个 blob 对象 “bar. txt”），以及一个 blob 对象 “baz. txt”。</p><h2 id="历史记录建模：关联快照"><a href="#历史记录建模：关联快照" class="headerlink" title="历史记录建模：关联快照"></a>历史记录建模：关联快照</h2><p>版本控制系统和快照有什么关系呢？线性历史记录是一种最简单的模型，它包含了一组按照时间顺序线性排列的快照。不过处于种种原因，Git 并没有采用这样的模型。</p><p>在 Git 中，历史记录是一个由快照组成的有向无环图。有向无环图，听上去似乎是什么高大上的数学名词。不过不要怕，您只需要知道这代表 Git 中的每个快照都有一系列的 “ 父辈 “，也就是其之前的一系列快照。注意，快照具有多个 “ 父辈 “ 而非一个，因为某个快照可能由多个父辈而来。例如，经过合并后的两条分支。</p><p>在 Git 中，这些快照被称为 “ 提交 “。通过可视化的方式来表示这些历史提交记录时，看起来差不多是这样的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">o &lt;-- o &lt;-- o &lt;-- o</span><br><span class="line">            ^  </span><br><span class="line">             \</span><br><span class="line">              --- o &lt;-- o</span><br></pre></td></tr></table></figure><p>上面是一个 ASCII 码构成的简图，其中的 <code>o</code> 表示一次提交（快照）。</p><p>箭头指向了当前提交的父辈（这是一种 “ 在… 之前 “，而不是 “ 在… 之后 “ 的关系）。在第三次提交之后，历史记录分岔成了两条独立的分支。这可能因为此时需要同时开发两个不同的特性，它们之间是相互独立的。开发完成后，这些分支可能会被合并并创建一个新的提交，这个新的提交会同时包含这些特性。新的提交会创建一个新的历史记录，看上去像这样（最新的合并提交用粗体标记）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">o &lt;-- o &lt;-- o &lt;-- o &lt;---- o</span><br><span class="line">            ^            /</span><br><span class="line">             \          v</span><br><span class="line">              --- o &lt;-- o</span><br></pre></td></tr></table></figure><p>Git 中的提交是不可改变的。但这并不代表错误不能被修改，只不过这种 “ 修改 “ 实际上是创建了一个全新的提交记录。而引用（参见下文）则被更新为指向这些新的提交。</p><h2 id="数据模型及其伪代码表示"><a href="#数据模型及其伪代码表示" class="headerlink" title="数据模型及其伪代码表示"></a>数据模型及其伪代码表示</h2><p>以伪代码的形式来学习 Git 的数据模型，可能更加清晰：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 文件就是一组数据</span><br><span class="line">type blob = array&lt;byte&gt;</span><br><span class="line"></span><br><span class="line">// 一个包含文件和目录的目录</span><br><span class="line">type tree = map&lt;string, tree | blob&gt;</span><br><span class="line"></span><br><span class="line">// 每个提交都包含一个父辈，元数据和顶层树</span><br><span class="line">type commit = struct &#123;</span><br><span class="line">    parent: array&lt;commit&gt;</span><br><span class="line">    author: string</span><br><span class="line">    message: string</span><br><span class="line">    snapshot: tree</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一种简洁的历史模型。</p><h2 id="对象和内存寻址"><a href="#对象和内存寻址" class="headerlink" title="对象和内存寻址"></a>对象和内存寻址</h2><p>Git 中的对象可以是 blob、树或提交：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type object = blob | tree | commit</span><br></pre></td></tr></table></figure><p>Git 在储存数据时，所有的对象都会基于它们的 <a href="https://en.wikipedia.org/wiki/SHA-1">SHA-1 哈希</a> 进行寻址。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">objects = map&lt;string, object&gt;</span><br><span class="line"></span><br><span class="line">def store (object):</span><br><span class="line">    id = sha 1 (object)</span><br><span class="line">    objects[id] = object</span><br><span class="line"></span><br><span class="line">def load (id):</span><br><span class="line">    return objects[id]</span><br></pre></td></tr></table></figure><p>Blobs、树和提交都一样，它们都是对象。当它们引用其他对象时，它们并没有真正的在硬盘上保存这些对象，而是仅仅保存了它们的哈希值作为引用。</p><p>例如，<a href="#snapshots">上面</a> 例子中的树（可以通过 <code>git cat-file -p 698281bc680d1995c5f4caaf3359721a5a58d48d</code> 来进行可视化），看上去是这样的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">100644 blob 4448adbf7ecd394f42ae135bbeed9676e894af85    baz.txt</span><br><span class="line">040000 tree c68d233a33c5c06e0340e4c224f0afca87c8ce87    foo</span><br></pre></td></tr></table></figure><p>树本身会包含一些指向其他内容的指针，例如 <code>baz. txt</code> (blob) 和 <code>foo</code><br>(树)。如果我们用 <code>git cat-file -p 4448adbf7ecd394f42ae135bbeed9676e894af85</code>，即通过哈希值查看 baz. txt 的内容，会得到以下信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git is wonderful</span><br></pre></td></tr></table></figure><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>现在，所有的快照都可以通过它们的 SHA-1 哈希值来标记了。但这也太不方便了，谁也记不住一串 40 位的十六进制字符。</p><p>针对这一问题，Git 的解决方法是给这些哈希值赋予人类可读的名字，也就是引用（references）。引用是指向提交的指针。与对象不同的是，它是可变的（引用可以被更新，指向新的提交）。例如，<code>master</code> 引用通常会指向主分支的最新一次提交。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">references = map&lt;string, string&gt;</span><br><span class="line"></span><br><span class="line">def update_reference (name, id):</span><br><span class="line">    references[name] = id</span><br><span class="line"></span><br><span class="line">def read_reference (name):</span><br><span class="line">    return references[name]</span><br><span class="line"></span><br><span class="line">def load_reference (name_or_id):</span><br><span class="line">    if name_or_id in references:</span><br><span class="line">        return load (references[name_or_id])</span><br><span class="line">    else:</span><br><span class="line">        return load (name_or_id)</span><br></pre></td></tr></table></figure><p>这样，Git 就可以使用诸如 “master” 这样人类可读的名称来表示历史记录中某个特定的提交，而不需要在使用一长串十六进制字符了。</p><p>有一个细节需要我们注意，通常情况下，我们会想要知道 “ 我们当前所在位置 “，并将其标记下来。这样当我们创建新的快照的时候，我们就可以知道它的相对位置（如何设置它的 “ 父辈 “）。在 Git 中，我们当前的位置有一个特殊的索引，它就是 “HEAD”。</p><h2 id="仓库"><a href="#仓库" class="headerlink" title="仓库"></a>仓库</h2><p>最后，我们可以粗略地给出 Git 仓库的定义了：<code>对象</code> 和 <code>引用</code>。</p><p>在硬盘上，Git 仅存储对象和引用：因为其数据模型仅包含这些东西。所有的 <code>git</code> 命令都对应着对提交树的操作，例如增加对象，增加或删除引用。</p><p>当您输入某个指令时，请思考一下这条命令是如何对底层的图数据结构进行操作的。另一方面，如果您希望修改提交树，例如 “ 丢弃未提交的修改和将 ‘master’ 引用指向提交 <code>5d83 f9e</code> 时，有什么命令可以完成该操作（针对这个具体问题，您可以使用 <code>git checkout master; git reset --hard 5d83f9e</code>）</p><h1 id="暂存区"><a href="#暂存区" class="headerlink" title="暂存区"></a>暂存区</h1><p>Git 中还包括一个和数据模型完全不相关的概念，但它确是创建提交的接口的一部分。</p><p>就上面介绍的快照系统来说，您也许会期望它的实现里包括一个 “ 创建快照 “ 的命令，该命令能够基于当前工作目录的当前状态创建一个全新的快照。有些版本控制系统确实是这样工作的，但 Git 不是。我们希望简洁的快照，而且每次从当前状态创建快照可能效果并不理想。例如，考虑如下场景，您开发了两个独立的特性，然后您希望创建两个独立的提交，其中第一个提交仅包含第一个特性，而第二个提交仅包含第二个特性。或者，假设您在调试代码时添加了很多打印语句，然后您仅仅希望提交和修复 bug 相关的代码而丢弃所有的打印语句。</p><p>Git 处理这些场景的方法是使用一种叫做 “ 暂存区（staging area）” 的机制，它允许您指定下次快照中要包括那些改动。</p><h1 id="Git-的命令行接口"><a href="#Git-的命令行接口" class="headerlink" title="Git 的命令行接口"></a>Git 的命令行接口</h1><p>为了避免重复信息，我们将不会详细解释以下命令行。强烈推荐您阅读 <a href="https://git-scm.com/book/zh/v2">Pro Git 中文版</a> 或可以观看本讲座的视频来学习。</p><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><ul><li><code>git help &lt;command&gt;</code>: 获取 git 命令的帮助信息</li><li><code>git init</code>: 创建一个新的 git 仓库，其数据会存放在一个名为 <code>.git</code> 的目录下</li><li><code>git status</code>: 显示当前的仓库状态</li><li><code>git add &lt;filename&gt;</code>: 添加文件到暂存区</li><li><code>git commit</code>: 创建一个新的提交</li></ul><blockquote><ul><li>如何编写 <a href="https://tbaggery.com/2008/04/19/a-note-about-git-commit-messages.html">良好的提交信息</a>!</li><li>为何要 <a href="https://chris.beams.io/posts/git-commit/">编写良好的提交信息</a></li></ul></blockquote><ul><li><code>git log</code>: 显示历史日志</li><li><code>git log --all --graph --decorate</code>: 可视化历史记录（有向无环图）</li><li><code>git diff &lt;filename&gt;</code>: 显示与暂存区文件的差异</li><li><code>git diff &lt;revision&gt; &lt;filename&gt;</code>: 显示某个文件两个版本之间的差异</li><li><code>git checkout &lt;revision&gt;</code>: 更新 HEAD 和目前的分支</li></ul><h2 id="分支和合并"><a href="#分支和合并" class="headerlink" title="分支和合并"></a>分支和合并</h2><ul><li><code>git branch</code>: 显示分支</li><li><code>git branch &lt;name&gt;</code>: 创建分支</li><li><code>git checkout -b &lt;name&gt;</code>: 创建分支并切换到该分支</li></ul><blockquote><ul><li>相当于 <code>git branch &lt;name&gt;; git checkout &lt;name&gt;</code></li></ul></blockquote><ul><li><code>git merge &lt;revision&gt;</code>: 合并到当前分支</li><li><code>git mergetool</code>: 使用工具来处理合并冲突</li><li><code>git rebase</code>: 将一系列补丁变基（rebase）为新的基线</li></ul><h2 id="远端操作"><a href="#远端操作" class="headerlink" title="远端操作"></a>远端操作</h2><ul><li><code>git remote</code>: 列出远端</li><li><code>git remote add &lt;name&gt; &lt;url&gt;</code>: 添加一个远端</li><li><code>git push &lt;remote&gt; &lt;local branch&gt;:&lt;remote branch&gt;</code>: 将对象传送至远端并更新远端引用</li><li><code>git branch --set-upstream-to=&lt;remote&gt;/&lt;remote branch&gt;</code>: 创建本地和远端分支的关联关系</li><li><code>git fetch</code>: 从远端获取对象&#x2F;索引</li><li><code>git pull</code>: 相当于 <code>git fetch; git merge</code></li><li><code>git clone</code>: 从远端下载仓库</li></ul><h2 id="撤销"><a href="#撤销" class="headerlink" title="撤销"></a>撤销</h2><ul><li><code>git commit --amend</code>: 编辑提交的内容或信息</li><li><code>git reset HEAD &lt;file&gt;</code>: 恢复暂存的文件</li><li><code>git checkout -- &lt;file&gt;</code>: 丢弃修改</li><li><code>git restore</code>: git2.32 版本后取代 git reset 进行许多撤销操作</li></ul><h1 id="Git-高级操作"><a href="#Git-高级操作" class="headerlink" title="Git 高级操作"></a>Git 高级操作</h1><ul><li><code>git config</code>: Git 是一个 <a href="https://git-scm.com/docs/git-config">高度可定制的</a> 工具</li><li><code>git clone --depth=1</code>: 浅克隆（shallow clone），不包括完整的版本历史信息</li><li><code>git add -p</code>: 交互式暂存</li><li><code>git rebase -i</code>: 交互式变基</li><li><code>git blame</code>: 查看最后修改某行的人</li><li><code>git stash</code>: 暂时移除工作目录下的修改内容</li><li><code>git bisect</code>: 通过二分查找搜索历史记录</li><li><code>. gitignore</code>: <a href="https://git-scm.com/docs/gitignore">指定</a> 故意不追踪的文件</li></ul><h1 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h1><ul><li><strong>图形用户界面</strong>: Git 的 <a href="https://git-scm.com/downloads/guis">图形用户界面客户端</a> 有很多，但是我们自己并不使用这些图形用户界面的客户端，我们选择使用命令行接口</li><li><strong>Shell 集成</strong>: 将 Git 状态集成到您的 shell 中会非常方便。(<a href="https://github.com/olivierverdier/zsh-git-prompt">zsh</a>, <a href="https://github.com/magicmonty/bash-git-prompt">bash</a>)。<a href="https://github.com/ohmyzsh/ohmyzsh">Oh My Zsh</a> 这样的框架中一般以及集成了这一功能</li><li><strong>编辑器集成</strong>: 和上面一条类似，将 Git 集成到编辑器中好处多多。<a href="https://github.com/tpope/vim-fugitive">fugitive.vim</a> 是 Vim 中集成 GIt 的常用插件</li><li><strong>工作流</strong>: 我们已经讲解了数据模型与一些基础命令，但还没讨论到进行大型项目时的一些惯例 (有 <a href="https://nvie.com/posts/a-successful-git-branching-model/">很多</a><a href="https://www.endoflineblog.com/gitflow-considered-harmful">不同的</a><a href="https://www.atlassian.com/git/tutorials/comparing-workflows/gitflow-workflow">处理方法</a>)</li><li><strong>GitHub</strong>: Git 并不等同于 GitHub。在 GitHub 中您需要使用一个被称作 <a href="https://help.github.com/en/github/collaborating-with-issues-and-pull-requests/about-pull-requests">拉取请求（pull request）</a> 的方法来向其他项目贡献代码</li><li><strong>其他 Git 提供商</strong>: GitHub 并不是唯一的。还有像 <a href="https://about.gitlab.com/">GitLab</a> 和 <a href="https://bitbucket.org/">BitBucket</a> 这样的平台。</li></ul><h1 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h1><ul><li><a href="https://git-scm.com/book/en/v2">Pro Git</a> ，<strong>强烈推荐</strong>！学习前五章的内容可以教会您流畅使用 Git 的绝大多数技巧，因为您已经理解了 Git 的数据模型。后面的章节提供了很多有趣的高级主题。（<a href="https://git-scm.com/book/zh/v2">Pro Git 中文版</a>）；</li><li><a href="https://ohshitgit.com/">Oh Shit, Git!?!</a> ，简短的介绍了如何从 Git 错误中恢复；</li><li><a href="https://eagain.net/articles/git-for-computer-scientists/">Git for Computer Scientists</a> ，简短的介绍了 Git 的数据模型，与本文相比包含较少量的伪代码以及大量的精美图片；</li><li><a href="https://jwiegley.github.io/git-from-the-bottom-up/">Git from the Bottom Up</a> 详细的介绍了 Git 的实现细节，而不仅仅局限于数据模型。好奇的同学可以看看；</li><li><a href="https://smusamashah.github.io/blog/2017/10/14/explain-git-in-simple-words">How to explain git in simple words</a>；</li><li><a href="https://learngitbranching.js.org/">Learn Git Branching</a> 通过基于浏览器的游戏来学习 Git ；</li></ul><h1 id="课后练习"><a href="#课后练习" class="headerlink" title="课后练习"></a>课后练习</h1><p>[习题解答](  &#x2F;  &#x2F;  )</p><ol><li><p>如果您之前从来没有用过 Git，推荐您阅读 <a href="https://git-scm.com/book/en/v2">Pro Git</a> 的前几章，或者完成像 <a href="https://learngitbranching.js.org/">Learn Git Branching</a> 这样的教程。重点关注 Git 命令和数据模型相关内容；</p></li><li><p>Fork <a href="https://github.com/missing-semester-cn/missing-semester-cn.github.io.git">本课程网站的仓库</a></p><ol><li><p>将版本历史可视化并进行探索</p></li><li><p>是谁最后修改了 <code>README. md</code> 文件？（提示：使用 <code>git log</code> 命令并添加合适的参数）</p></li><li><p>最后一次修改 <code>_config. yml</code> 文件中 <code>collections:</code> 行时的提交信息是什么？（提示：使用 <code>git blame</code> 和 <code>git show</code>）</p></li></ol></li><li><p>使用 Git 时的一个常见错误是提交本不应该由 Git 管理的大文件，或是将含有敏感信息的文件提交给 Git 。尝试向仓库中添加一个文件并添加提交信息，然后将其从历史中删除 ( <a href="https://help.github.com/articles/removing-sensitive-data-from-a-repository/">这篇文章也许会有帮助</a>)；</p></li><li><p>从 GitHub 上克隆某个仓库，修改一些文件。当您使用 <code>git stash</code> 会发生什么？当您执行 <code>git log --all --oneline</code> 时会显示什么？通过 <code>git stash pop</code> 命令来撤销 <code>git stash</code> 操作，什么时候会用到这一技巧？</p></li><li><p>与其他的命令行工具一样，Git 也提供了一个名为 <code>~/. gitconfig</code> 配置文件 (或 dotfile)。请在 <code>~/. gitconfig</code> 中创建一个别名，使您在运行 <code>git graph</code> 时，您可以得到 <code>git log --all --graph --decorate --oneline</code> 的输出结果；</p></li><li><p>您可以通过执行 <code>git config --global core. excludesfile ~/. gitignore_global</code> 在 <code>~/. gitignore_global</code> 中创建全局忽略规则。配置您的全局 gitignore 文件来自动忽略系统或编辑器的临时文件，例如 <code>. DS_Store</code>；</p></li><li><p>克隆 <a href="https://github.com/missing-semester-cn/missing-semester-cn.github.io.git">本课程网站的仓库</a>，找找有没有错别字或其他可以改进的地方，在 GitHub 上发起拉取请求（Pull Request）；</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 编程工具 </category>
          
          <category> 计算机教育缺失的一课 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机/编程工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>命令行环境</title>
      <link href="/posts/%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%95%99%E8%82%B2%E7%BC%BA%E5%A4%B1%E7%9A%84%E4%B8%80%E8%AF%BE/%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%8E%AF%E5%A2%83.html"/>
      <url>/posts/%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%95%99%E8%82%B2%E7%BC%BA%E5%A4%B1%E7%9A%84%E4%B8%80%E8%AF%BE/%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%8E%AF%E5%A2%83.html</url>
      
        <content type="html"><![CDATA[<h1 id="任务控制"><a href="#任务控制" class="headerlink" title="任务控制"></a>任务控制</h1><p>某些情况下我们需要中断正在执行的任务，比如当一个命令需要执行很长时间才能完成时（假设我们在使用 <code>find</code> 搜索一个非常大的目录结构）。大多数情况下，我们可以使用 <code>Ctrl-C</code> 来停止命令的执行。但是它的工作原理是什么呢？为什么有的时候会无法结束进程？</p><h2 id="结束进程"><a href="#结束进程" class="headerlink" title="结束进程"></a>结束进程</h2><p>您的 shell 会使用 UNIX 提供的信号机制执行进程间通信。当一个进程接收到信号时，它会停止执行、处理该信号并基于信号传递的信息来改变其执行。就这一点而言，信号是一种<em>软件中断</em>。</p><p>在上面的例子中，当我们输入 <code>Ctrl-C</code> 时，shell 会发送一个 <code>SIGINT</code> 信号到进程。</p><p>下面这个 Python 程序向您展示了捕获信号 <code>SIGINT</code> 并忽略它的基本操作，它并不会让程序停止。为了停止这个程序，我们需要使用 <code>SIGQUIT</code> 信号，通过输入 <code>Ctrl-\</code> 可以发送该信号。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="keyword">import</span> signal, time</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">handler</span>(<span class="params">signum, time</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\nI got a SIGINT, but I am not stopping&quot;</span>)</span><br><span class="line"></span><br><span class="line">signal.signal(signal.SIGINT, handler)</span><br><span class="line">i = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    time.sleep(<span class="number">.1</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\r&#123;&#125;&quot;</span>.<span class="built_in">format</span>(i), end=<span class="string">&quot;&quot;</span>)</span><br><span class="line">    i += <span class="number">1</span></span><br></pre></td></tr></table></figure><p>如果我们向这个程序发送两次 <code>SIGINT</code> ，然后再发送一次 <code>SIGQUIT</code>，程序会有什么反应？注意 <code>^</code> 是我们在终端输入 <code>Ctrl</code> 时的表示形式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ python sigint.py</span><br><span class="line">24^C</span><br><span class="line">I got a SIGINT, but I am not stopping</span><br><span class="line">26^C</span><br><span class="line">I got a SIGINT, but I am not stopping</span><br><span class="line">30^\[1]    39913 quit       python sigint.pyƒ</span><br></pre></td></tr></table></figure><p>尽管 <code>SIGINT</code> 和 <code>SIGQUIT</code> 都常常用来发出和终止程序相关的请求。<code>SIGTERM</code> 则是一个更加通用的、也更加优雅地退出信号。为了发出这个信号我们需要使用 <a href="https://www.man7.org/linux/man-pages/man1/kill.1.html"><code>kill</code></a> 命令, 它的语法是： <code>kill -TERM &lt;PID&gt;</code>。</p><h2 id="暂停和后台执行进程"><a href="#暂停和后台执行进程" class="headerlink" title="暂停和后台执行进程"></a>暂停和后台执行进程</h2><p>信号可以让进程做其他的事情，而不仅仅是终止它们。例如，<code>SIGSTOP</code> 会让进程暂停。在终端中，键入 <code>Ctrl-Z</code> 会让 shell 发送 <code>SIGTSTP</code> 信号，<code>SIGTSTP</code> 是 Terminal Stop 的缩写（即 <code>terminal</code> 版本的 SIGSTOP）。</p><p>我们可以使用 <a href="https://www.man7.org/linux/man-pages/man1/fg.1p.html"><code>fg</code></a> 或 <a href="http://man7.org/linux/man-pages/man1/bg.1p.html"><code>bg</code></a> 命令恢复暂停的工作。它们分别表示在前台继续或在后台继续。</p><p><a href="http://man7.org/linux/man-pages/man1/jobs.1p.html"><code>jobs</code></a> 命令会列出当前终端会话中尚未完成的全部任务。您可以使用 pid 引用这些任务（也可以用 <a href="https://www.man7.org/linux/man-pages/man1/pgrep.1.html"><code>pgrep</code></a> 找出 pid）。更加符合直觉的操作是您可以使用百分号 + 任务编号（<code>jobs</code> 会打印任务编号）来选取该任务。如果要选择最近的一个任务，可以使用 <code>$!</code> 这一特殊参数。</p><p>还有一件事情需要掌握，那就是命令中的 <code>&amp;</code> 后缀可以让命令在直接在后台运行，这使得您可以直接在 shell 中继续做其他操作，不过它此时还是会使用 shell 的标准输出，这一点有时会比较恼人（这种情况可以使用 shell 重定向处理）。</p><p>让已经在运行的进程转到后台运行，您可以键入 <code>Ctrl-Z</code> ，然后紧接着再输入 <code>bg</code>。注意，后台的进程仍然是您的终端进程的子进程，一旦您关闭终端（会发送另外一个信号 <code>SIGHUP</code>），这些后台的进程也会终止。为了防止这种情况发生，您可以使用 <a href="https://www.man7.org/linux/man-pages/man1/nohup.1.html"><code>nohup</code></a> (一个用来忽略 <code>SIGHUP</code> 的封装) 来运行程序。针对已经运行的程序，可以使用 <code>disown</code> 。除此之外，您可以使用终端多路复用器来实现，下一章节我们会进行详细地探讨。</p><p>下面这个简单的会话中展示来了些概念的应用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">$ sleep 1000</span><br><span class="line">^Z</span><br><span class="line">[1]  + 18653 suspended  sleep 1000</span><br><span class="line"></span><br><span class="line">$ nohup sleep 2000 &amp;</span><br><span class="line">[2] 18745</span><br><span class="line">appending output to nohup.out</span><br><span class="line"></span><br><span class="line">$ jobs</span><br><span class="line">[1]  + suspended  sleep 1000</span><br><span class="line">[2]  - running    nohup sleep 2000</span><br><span class="line"></span><br><span class="line">$ bg %1</span><br><span class="line">[1]  - 18653 continued  sleep 1000</span><br><span class="line"></span><br><span class="line">$ jobs</span><br><span class="line">[1]  - running    sleep 1000</span><br><span class="line">[2]  + running    nohup sleep 2000</span><br><span class="line"></span><br><span class="line">$ kill -STOP %1</span><br><span class="line">[1]  + 18653 suspended (signal)  sleep 1000</span><br><span class="line"></span><br><span class="line">$ jobs</span><br><span class="line">[1]  + suspended (signal)  sleep 1000</span><br><span class="line">[2]  - running    nohup sleep 2000</span><br><span class="line"></span><br><span class="line">$ kill -SIGHUP %1</span><br><span class="line">[1]  + 18653 hangup     sleep 1000</span><br><span class="line"></span><br><span class="line">$ jobs</span><br><span class="line">[2]  + running    nohup sleep 2000</span><br><span class="line"></span><br><span class="line">$ kill -SIGHUP %2</span><br><span class="line"></span><br><span class="line">$ jobs</span><br><span class="line">[2]  + running    nohup sleep 2000</span><br><span class="line"></span><br><span class="line">$ kill %2</span><br><span class="line">[2]  + 18745 terminated  nohup sleep 2000</span><br><span class="line"></span><br><span class="line">$ jobs</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>SIGKILL</code> 是一个特殊的信号，它不能被进程捕获并且它会马上结束该进程。不过这样做会有一些副作用，例如留下孤儿进程。</p><p>您可以在 <a href="https://en.wikipedia.org/wiki/Signal_" title="IPC">这里</a> 或输入 <a href="https://www.man7.org/linux/man-pages/man7/signal.7.html"><code>man signal</code></a> 或使用 <code>kill -l</code> 来获取更多关于信号的信息。</p><h1 id="终端多路复用"><a href="#终端多路复用" class="headerlink" title="终端多路复用"></a>终端多路复用</h1><p>当您在使用命令行时，您通常会希望同时执行多个任务。举例来说，您可以想要同时运行您的编辑器，并在终端的另外一侧执行程序。尽管再打开一个新的终端窗口也能达到目的，使用终端多路复用器则是一种更好的办法。</p><p>像 <a href="https://www.man7.org/linux/man-pages/man1/tmux.1.html"><code>tmux</code></a> 这类的终端多路复用器可以允许我们基于面板和标签分割出多个终端窗口，这样您便可以同时与多个 shell 会话进行交互。</p><p>不仅如此，终端多路复用使我们可以分离当前终端会话并在将来重新连接。</p><p>这让您操作远端设备时的工作流大大改善，避免了 <code>nohup</code> 和其他类似技巧的使用。</p><p>现在最流行的终端多路器是 <a href="https://www.man7.org/linux/man-pages/man1/tmux.1.html"><code>tmux</code></a>。<code>tmux</code> 是一个高度可定制的工具，您可以使用相关快捷键创建多个标签页并在它们间导航。</p><p><code>tmux</code> 的快捷键需要我们掌握，它们都是类似 <code>&lt;C-b&gt; x</code> 这样的组合，即需要先按下 <code>Ctrl+b</code>，松开后再按下 <code>x</code>。<code>tmux</code> 中对象的继承结构如下：</p><ul><li><strong>会话</strong> - 每个会话都是一个独立的工作区，其中包含一个或多个窗口<br>  - <code>tmux</code> 开始一个新的会话<br>  - <code>tmux new -s NAME</code> 以指定名称开始一个新的会话<br>  - <code>tmux ls</code> 列出当前所有会话<br>  - 在 <code>tmux</code> 中输入 <code>&lt;C-b&gt; d</code> ，将当前会话分离<br>  - <code>tmux a</code> 重新连接最后一个会话。您也可以通过 <code>-t</code> 来指定具体的会话</li><li><strong>窗口</strong> - 相当于编辑器或是浏览器中的标签页，从视觉上将一个会话分割为多个部分<br>  - <code>&lt;C-b&gt; c</code> 创建一个新的窗口，使用 <code>&lt;C-d&gt;</code> 关闭<br>  - <code>&lt;C-b&gt; N</code> 跳转到第 <em>N</em> 个窗口，注意每个窗口都是有编号的<br>  - <code>&lt;C-b&gt; p</code> 切换到前一个窗口<br>  - <code>&lt;C-b&gt; n</code> 切换到下一个窗口<br>  - <code>&lt;C-b&gt; ,</code> 重命名当前窗口<br>  - <code>&lt;C-b&gt; w</code> 列出当前所有窗口</li><li><strong>面板</strong> - 像 vim 中的分屏一样，面板使我们可以在一个屏幕里显示多个 shell<br>  - <code>&lt;C-b&gt; &quot;</code> 水平分割<br>  - <code>&lt;C-b&gt; %</code> 垂直分割<br>  - <code>&lt;C-b&gt; &lt;方向&gt;</code> 切换到指定方向的面板，&lt;方向&gt; 指的是键盘上的方向键<br>  - <code>&lt;C-b&gt; z</code> 切换当前面板的缩放<br>  - <code>&lt;C-b&gt; [</code> 开始往回卷动屏幕。您可以按下空格键来开始选择，回车键复制选中的部分<br>  - <code>&lt;C-b&gt; &lt;空格&gt;</code> 在不同的面板排布间切换</li></ul><p>扩展阅读：<br><a href="https://www.hamvocke.com/blog/a-quick-and-easy-guide-to-tmux/">这里</a> 是一份 <code>tmux</code> 快速入门教程， <a href="http://linuxcommand.org/lc3_adv_termmux.php">而这一篇</a> 文章则更加详细，它包含了 <code>screen</code> 命令。您也许想要掌握 <a href="https://www.man7.org/linux/man-pages/man1/screen.1.html"><code>screen</code></a> 命令，因为在大多数 UNIX 系统中都默认安装有该程序。</p><h1 id="别名"><a href="#别名" class="headerlink" title="别名"></a>别名</h1><p>输入一长串包含许多选项的命令会非常麻烦。因此，大多数 shell 都支持设置别名。shell 的别名相当于一个长命令的缩写，shell 会自动将其替换成原本的命令。例如，bash 中的别名语法如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">alias</span> alias_name=<span class="string">&quot;command_to_alias arg1 arg2&quot;</span></span><br></pre></td></tr></table></figure><p>注意， <code>=</code> 两边是没有空格的，因为 <a href="https://www.man7.org/linux/man-pages/man1/alias.1p.html"><code>alias</code></a> 是一个 shell 命令，它只接受一个参数。</p><p>别名有许多很方便的特性:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建常用命令的缩写</span></span><br><span class="line"><span class="built_in">alias</span> ll=<span class="string">&quot;ls -lh&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 能够少输入很多</span></span><br><span class="line"><span class="built_in">alias</span> gs=<span class="string">&quot;git status&quot;</span></span><br><span class="line"><span class="built_in">alias</span> gc=<span class="string">&quot;git commit&quot;</span></span><br><span class="line"><span class="built_in">alias</span> v=<span class="string">&quot;vim&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 手误打错命令也没关系</span></span><br><span class="line"><span class="built_in">alias</span> sl=<span class="built_in">ls</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 重新定义一些命令行的默认行为</span></span><br><span class="line"><span class="built_in">alias</span> <span class="built_in">mv</span>=<span class="string">&quot;mv -i&quot;</span>           <span class="comment"># -i prompts before overwrite</span></span><br><span class="line"><span class="built_in">alias</span> <span class="built_in">mkdir</span>=<span class="string">&quot;mkdir -p&quot;</span>     <span class="comment"># -p make parent dirs as needed</span></span><br><span class="line"><span class="built_in">alias</span> <span class="built_in">df</span>=<span class="string">&quot;df -h&quot;</span>           <span class="comment"># -h prints human readable format</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 别名可以组合使用</span></span><br><span class="line"><span class="built_in">alias</span> la=<span class="string">&quot;ls -A&quot;</span></span><br><span class="line"><span class="built_in">alias</span> lla=<span class="string">&quot;la -l&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在忽略某个别名</span></span><br><span class="line">\<span class="built_in">ls</span></span><br><span class="line"><span class="comment"># 或者禁用别名</span></span><br><span class="line"><span class="built_in">unalias</span> la</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取别名的定义</span></span><br><span class="line"><span class="built_in">alias</span> ll</span><br><span class="line"><span class="comment"># 会打印 ll=&#x27;ls -lh&#x27;</span></span><br></pre></td></tr></table></figure><p>值得注意的是，在默认情况下 shell 并不会保存别名。为了让别名持续生效，您需要将配置放进 shell 的启动文件里，像是 <code>.bashrc</code> 或 <code>.zshrc</code>，下一节我们就会讲到。</p><h1 id="配置文件（Dotfiles）"><a href="#配置文件（Dotfiles）" class="headerlink" title="配置文件（Dotfiles）"></a>配置文件（Dotfiles）</h1><p>很多程序的配置都是通过纯文本格式的被称作<em>点文件</em>的配置文件来完成的（之所以称为点文件，是因为它们的文件名以 <code>.</code> 开头，例如 <code>~/.vimrc</code>。也正因为此，它们默认是隐藏文件，<code>ls</code> 并不会显示它们）。</p><p>shell 的配置也是通过这类文件完成的。在启动时，您的 shell 程序会读取很多文件以加载其配置项。根据 shell 本身的不同，您从登录开始还是以交互的方式完成这一过程可能会有很大的不同。关于这一话题，<a href="https://blog.flowblok.id.au/2013-02/shell-startup-scripts.html">这里</a> 有非常好的资源</p><p>对于 <code>bash</code> 来说，在大多数系统下，您可以通过编辑 <code>.bashrc</code> 或 <code>.bash_profile</code> 来进行配置。在文件中您可以添加需要在启动时执行的命令，例如上文我们讲到过的别名，或者是您的环境变量。</p><p>实际上，很多程序都要求您在 shell 的配置文件中包含一行类似 <code>export PATH=&quot;$PATH:/path/to/program/bin&quot;</code> 的命令，这样才能确保这些程序能够被 shell 找到。</p><p>还有一些其他的工具也可以通过<em>点文件</em>进行配置：</p><ul><li><code>bash</code> - <code>~/.bashrc</code>, <code>~/.bash_profile</code></li><li><code>git</code> - <code>~/.gitconfig</code></li><li><code>vim</code> - <code>~/.vimrc</code> 和 <code>~/.vim</code> 目录</li><li><code>ssh</code> - <code>~/.ssh/config</code></li><li><code>tmux</code> - <code>~/.tmux.conf</code></li></ul><p>我们应该如何管理这些配置文件呢，它们应该在它们的文件夹下，并使用版本控制系统进行管理，然后通过脚本将其 <strong>符号链接</strong> 到需要的地方。这么做有如下好处：</p><ul><li><strong>安装简单</strong>: 如果您登录了一台新的设备，在这台设备上应用您的配置只需要几分钟的时间；</li><li><strong>可移植性</strong>: 您的工具在任何地方都以相同的配置工作</li><li><strong>同步</strong>: 在一处更新配置文件，可以同步到其他所有地方</li><li><strong>变更追踪</strong>: 您可能要在整个程序员生涯中持续维护这些配置文件，而对于长期项目而言，版本历史是非常重要的</li></ul><p>配置文件中需要放些什么？您可以通过在线文档和 <a href="https://en.wikipedia.org/wiki/Man_page">帮助手册</a> 了解所使用工具的设置项。另一个方法是在网上搜索有关特定程序的文章，作者们在文章中会分享他们的配置。还有一种方法就是直接浏览其他人的配置文件：您可以在这里找到无数的 <a href="https://github.com/search?o=desc&q=dotfiles&s=stars&type=Repositories">dotfiles 仓库</a> —— 其中最受欢迎的那些可以在 <a href="https://github.com/mathiasbynens/dotfiles">这里</a> 找到（我们建议您不要直接复制别人的配置）。<a href="https://dotfiles.github.io/">这里</a> 也有一些非常有用的资源。</p><h2 id="可移植性"><a href="#可移植性" class="headerlink" title="可移植性"></a>可移植性</h2><p>配置文件的一个常见的痛点是它可能并不能在多种设备上生效。例如，如果您在不同设备上使用的操作系统或者 shell 是不同的，则配置文件是无法生效的。或者，有时您仅希望特定的配置只在某些设备上生效。</p><p>有一些技巧可以轻松达成这些目的。如果配置文件 if 语句，则您可以借助它针对不同的设备编写不同的配置。例如，您的 shell 可以这样做：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [[ <span class="string">&quot;<span class="subst">$(uname)</span>&quot;</span> == <span class="string">&quot;Linux&quot;</span> ]]; <span class="keyword">then</span> &#123;do_something&#125;; <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用和 shell 相关的配置时先检查当前 shell 类型</span></span><br><span class="line"><span class="keyword">if</span> [[ <span class="string">&quot;<span class="variable">$SHELL</span>&quot;</span> == <span class="string">&quot;zsh&quot;</span> ]]; <span class="keyword">then</span> &#123;do_something&#125;; <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 您也可以针对特定的设备进行配置</span></span><br><span class="line"><span class="keyword">if</span> [[ <span class="string">&quot;<span class="subst">$(hostname)</span>&quot;</span> == <span class="string">&quot;myServer&quot;</span> ]]; <span class="keyword">then</span> &#123;do_something&#125;; <span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p>如果配置文件支持 include 功能，您也可以多加利用。例如：<code>~/.gitconfig</code> 可以这样编写：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[include]</span><br><span class="line">    path = ~/.gitconfig_local</span><br></pre></td></tr></table></figure><p>然后我们可以在日常使用的设备上创建配置文件 <code>~/.gitconfig_local</code> 来包含与该设备相关的特定配置。您甚至应该创建一个单独的代码仓库来管理这些与设备相关的配置。</p><p>如果您希望在不同的程序之间共享某些配置，该方法也适用。例如，如果您想要在 <code>bash</code> 和 <code>zsh</code> 中同时启用一些别名，您可以把它们写在 <code>.aliases</code> 里，然后在这两个 shell 里应用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Test if ~/.aliases exists and source it</span></span><br><span class="line"><span class="keyword">if</span> [ -f ~/.aliases ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">source</span> ~/.aliases</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><h1 id="远端设备"><a href="#远端设备" class="headerlink" title="远端设备"></a>远端设备</h1><p>对于程序员来说，在他们的日常工作中使用远程服务器已经非常普遍了。如果您需要使用远程服务器来部署后端软件或您需要一些计算能力强大的服务器，您就会用到安全 shell（SSH）。和其他工具一样，SSH 也是可以高度定制的，也值得我们花时间学习它。</p><p>通过如下命令，您可以使用 <code>ssh</code> 连接到其他服务器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh foo@bar.mit.edu</span><br></pre></td></tr></table></figure><p>这里我们尝试以用户名 <code>foo</code> 登录服务器 <code>bar.mit.edu</code>。服务器可以通过 URL 指定（例如 <code>bar.mit.edu</code>），也可以使用 IP 指定（例如 <code>foobar@192.168.1.42</code>）。后面我们会介绍如何修改 ssh 配置文件使我们可以用类似 <code>ssh bar</code> 这样的命令来登录服务器。</p><h2 id="执行命令"><a href="#执行命令" class="headerlink" title="执行命令"></a>执行命令</h2><p> <code>ssh</code> 的一个经常被忽视的特性是它可以直接远程执行命令。<br><code>ssh foobar@server ls</code> 可以直接在用 foobar 的命令下执行 <code>ls</code> 命令。<br>想要配合管道来使用也可以， <code>ssh foobar@server ls | grep PATTERN</code> 会在本地查询远端 <code>ls</code> 的输出而 <code>ls | ssh foobar@server grep PATTERN</code> 会在远端对本地 <code>ls</code> 输出的结果进行查询。</p><h2 id="SSH-密钥"><a href="#SSH-密钥" class="headerlink" title="SSH 密钥"></a>SSH 密钥</h2><p>基于密钥的验证机制使用了密码学中的公钥，我们只需要向服务器证明客户端持有对应的私钥，而不需要公开其私钥。这样您就可以避免每次登录都输入密码的麻烦了秘密就可以登录。不过，私钥 (通常是 <code>~/.ssh/id_rsa</code> 或者 <code>~/.ssh/id_ed25519</code>) 等效于您的密码，所以一定要好好保存它。</p><h3 id="密钥生成"><a href="#密钥生成" class="headerlink" title="密钥生成"></a>密钥生成</h3><p>使用 <a href="http://man7.org/linux/man-pages/man1/ssh-keygen.1.html"><code>ssh-keygen</code></a> 命令可以生成一对密钥：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -o -a 100 -t ed25519 -f ~/.ssh/id_ed25519</span><br></pre></td></tr></table></figure><p>您可以为密钥设置密码，防止有人持有您的私钥并使用它访问您的服务器。您可以使用 <a href="https://www.man7.org/linux/man-pages/man1/ssh-agent.1.html"><code>ssh-agent</code></a> 或 <a href="https://linux.die.net/man/1/gpg-agent"><code>gpg-agent</code></a> ，这样就不需要每次都输入该密码了。</p><p>如果您曾经配置过使用 SSH 密钥推送到 GitHub，那么可能您已经完成了 <a href="https://help.github.com/articles/connecting-to-github-with-ssh/">这里</a> 介绍的这些步骤，并且已经有了一个可用的密钥对。要检查您是否持有密码并验证它，您可以运行 <code>ssh-keygen -y -f /path/to/key</code>.</p><h3 id="基于密钥的认证机制"><a href="#基于密钥的认证机制" class="headerlink" title="基于密钥的认证机制"></a>基于密钥的认证机制</h3><p><code>ssh</code> 会查询 <code>.ssh/authorized_keys</code> 来确认那些用户可以被允许登录。您可以通过下面的命令将一个公钥拷贝到这里：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> .ssh/id_ed25519.pub | ssh foobar@remote <span class="string">&#x27;cat &gt;&gt; ~/.ssh/authorized_keys&#x27;</span></span><br></pre></td></tr></table></figure><p>如果支持 <code>ssh-copy-id</code> 的话，可以使用下面这种更简单的解决方案：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-copy-id -i .ssh/id_ed25519.pub foobar@remote</span><br></pre></td></tr></table></figure><h2 id="通过-SSH-复制文件"><a href="#通过-SSH-复制文件" class="headerlink" title="通过 SSH 复制文件"></a>通过 SSH 复制文件</h2><p>使用 ssh 复制文件有很多方法：</p><ul><li><code>ssh+tee</code>, 最简单的方法是执行 <code>ssh</code> 命令，然后通过这样的方法利用标准输入实现 <code>cat localfile | ssh remote_server tee serverfile</code>。回忆一下，<a href="https://www.man7.org/linux/man-pages/man1/tee.1.html"><code>tee</code></a> 命令会将标准输出写入到一个文件；</li><li><a href="https://www.man7.org/linux/man-pages/man1/scp.1.html"><code>scp</code></a> ：当需要拷贝大量的文件或目录时，使用 <code>scp</code> 命令则更加方便，因为它可以方便的遍历相关路径。语法如下：<code>scp path/to/local_file remote_host:path/to/remote_file</code>；</li><li><a href="https://www.man7.org/linux/man-pages/man1/rsync.1.html"><code>rsync</code></a> 对 <code>scp</code> 进行了改进，它可以检测本地和远端的文件以防止重复拷贝。它还可以提供一些诸如符号连接、权限管理等精心打磨的功能。甚至还可以基于 <code>--partial</code> 标记实现断点续传。<code>rsync</code> 的语法和 <code>scp</code> 类似；</li></ul><h2 id="端口转发"><a href="#端口转发" class="headerlink" title="端口转发"></a>端口转发</h2><p>很多情况下我们都会遇到软件需要监听特定设备的端口。如果是在您的本机，可以使用 <code>localhost:PORT</code> 或 <code>127.0.0.1:PORT</code>。但是如果需要监听远程服务器的端口该如何操作呢？这种情况下远端的端口并不会直接通过网络暴露给您。</p><p>此时就需要进行 <em>端口转发</em>。端口转发有两种，一种是本地端口转发和远程端口转发（参见下图，该图片引用自这篇 <a href="https://unix.stackexchange.com/questions/115897/whats-ssh-port-forwarding-and-whats-the-difference-between-ssh-local-and-remot">StackOverflow 文章</a>）中的图片。</p><p><strong>本地端口转发</strong><br><img src="https://i.stack.imgur.com/a28N8.png" alt="Local Port Forwarding" title="本地端口转发"></p><p><strong>远程端口转发</strong><br><img src="https://i.stack.imgur.com/4iK3b.png" alt="Remote Port Forwarding" title="远程端口转发"></p><p>常见的情景是使用本地端口转发，即远端设备上的服务监听一个端口，而您希望在本地设备上的一个端口建立连接并转发到远程端口上。例如，我们在远端服务器上运行 Jupyter notebook 并监听 <code>8888</code> 端口。然后，建立从本地端口 <code>9999</code> 的转发，使用 <code>ssh -L 9999:localhost:8888 foobar@remote_server</code> 。这样只需要访问本地的 <code>localhost:9999</code> 即可。</p><h2 id="SSH-配置"><a href="#SSH-配置" class="headerlink" title="SSH 配置"></a>SSH 配置</h2><p>我们已经介绍了很多参数。为它们创建一个别名是个好想法，我们可以这样做：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">alias</span> my_server=<span class="string">&quot;ssh -i ~/.id_ed25519 --port 2222 -L 9999:localhost:8888 foobar@remote_server</span></span><br></pre></td></tr></table></figure><p>不过，更好的方法是使用 <code>~/.ssh/config</code>.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Host vm</span><br><span class="line">    User foobar</span><br><span class="line">    HostName 172.16.174.141</span><br><span class="line">    Port 2222</span><br><span class="line">    IdentityFile ~/.ssh/id_ed25519</span><br><span class="line">    LocalForward 9999 localhost:8888</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在配置文件中也可以使用通配符</span></span><br><span class="line">Host *.mit.edu</span><br><span class="line">    User foobaz</span><br></pre></td></tr></table></figure><p>这么做的好处是，使用 <code>~/.ssh/config</code> 文件来创建别名，类似 <code>scp</code>、<code>rsync</code> 和 <code>mosh</code> 的这些命令都可以读取这个配置并将设置转换为对应的命令行选项。</p><p>注意，<code>~/.ssh/config</code> 文件也可以被当作配置文件，而且一般情况下也是可以被导入其他配置文件的。不过，如果您将其公开到互联网上，那么其他人都将会看到您的服务器地址、用户名、开放端口等等。这些信息可能会帮助到那些企图攻击您系统的黑客，所以请务必三思。</p><p>服务器侧的配置通常放在 <code>/etc/ssh/sshd_config</code>。您可以在这里配置免密认证、修改 ssh 端口、开启 X 11 转发等等。您也可以为每个用户单独指定配置。</p><h2 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h2><p>连接远程服务器的一个常见痛点是遇到由关机、休眠或网络环境变化导致的掉线。如果连接的延迟很高也很让人讨厌。<a href="https://mosh.org/">Mosh</a>（即 mobile shell ）对 ssh 进行了改进，它允许连接漫游、间歇连接及智能本地回显。</p><p>有时将一个远端文件夹挂载到本地会比较方便， <a href="https://github.com/libfuse/sshfs">sshfs</a> 可以将远端服务器上的一个文件夹挂载到本地，然后您就可以使用本地的编辑器了。</p><h1 id="课后练习"><a href="#课后练习" class="headerlink" title="课后练习"></a>课后练习</h1><p>[习题解答](  &#x2F;  &#x2F;  )</p><h2 id="任务控制-1"><a href="#任务控制-1" class="headerlink" title="任务控制"></a>任务控制</h2><ol><li><p>我们可以使用类似 <code>ps aux | grep</code> 这样的命令来获取任务的 pid ，然后您可以基于 pid 来结束这些进程。但我们其实有更好的方法来做这件事。在终端中执行 <code>sleep 10000</code> 这个任务。然后用 <code>Ctrl-Z</code> 将其切换到后台并使用 <code>bg</code> 来继续允许它。现在，使用 <a href="https://www.man7.org/linux/man-pages/man1/pgrep.1.html"><code>pgrep</code></a> 来查找 pid 并使用 <a href="https://www.man7.org/linux/man-pages/man1/pgrep.1.html"><code>pkill</code></a> 结束进程而不需要手动输入 pid。(提示：: 使用 <code>-af</code> 标记)。</p></li><li><p>如果您希望某个进程结束后再开始另外一个进程，应该如何实现呢？在这个练习中，我们使用 <code>sleep 60 &amp;</code> 作为先执行的程序。一种方法是使用 <a href="http://man7.org/linux/man-pages/man1/wait.1p.html"><code>wait</code></a> 命令。尝试启动这个休眠命令，然后待其结束后再执行 <code>ls</code> 命令。</p></li></ol><blockquote><p>但是，如果我们在不同的 bash 会话中进行操作，则上述方法就不起作用了。因为 <code>wait</code> 只能对子进程起作用。之前我们没有提过的一个特性是，<code>kill</code> 命令成功退出时其状态码为 0 ，其他状态则是非 0。<code>kill -0</code> 则不会发送信号，但是会在进程不存在时返回一个不为 0 的状态码。请编写一个 bash 函数 <code>pidwait</code> ，它接受一个 pid 作为输入参数，然后一直等待直到该进程结束。您需要使用 <code>sleep</code> 来避免浪费 CPU 性能。</p></blockquote><h2 id="终端多路复用-1"><a href="#终端多路复用-1" class="headerlink" title="终端多路复用"></a>终端多路复用</h2><ol><li>请完成这个 <code>tmux</code> <a href="https://www.hamvocke.com/blog/a-quick-and-easy-guide-to-tmux/">教程</a> 参考 <a href="https://www.hamvocke.com/blog/a-guide-to-customizing-your-tmux-conf/">这些步骤</a> 来学习如何自定义 <code>tmux</code>。</li></ol><h2 id="别名-1"><a href="#别名-1" class="headerlink" title="别名"></a>别名</h2><ol><li><p>创建一个 <code>dc</code> 别名，它的功能是当我们错误的将 <code>cd</code> 输入为 <code>dc</code> 时也能正确执行。</p></li><li><p>执行 <code>history | awk &#39;&#123;$1=&quot;&quot;;print substr($0,2)&#125;&#39; | sort | uniq -c | sort -n | tail -n 10</code> 来获取您最常用的十条命令，尝试为它们创建别名。注意：这个命令只在 Bash 中生效，如果您使用 ZSH，使用 <code>history 1</code> 替换 <code>history</code>。</p></li></ol><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p>让我们帮助您进一步学习配置文件：</p><ol><li><p>为您的配置文件新建一个文件夹，并设置好版本控制</p></li><li><p>在其中添加至少一个配置文件，比如说您的 shell，在其中包含一些自定义设置（可以从设置 <code>$PS 1</code> 开始）。</p></li><li><p>建立一种在新设备进行快速安装配置的方法（无需手动操作）。最简单的方法是写一个 shell 脚本对每个文件使用 <code>ln -s</code>，也可以使用 <a href="https://dotfiles.github.io/utilities/">专用工具</a></p></li><li><p>在新的虚拟机上测试该安装脚本。</p></li><li><p>将您现有的所有配置文件移动到项目仓库里。</p></li><li><p>将项目发布到 GitHub。</p></li></ol><h2 id="远端设备-1"><a href="#远端设备-1" class="headerlink" title="远端设备"></a>远端设备</h2><p>进行下面的练习需要您先安装一个 Linux 虚拟机（如果已经安装过则可以直接使用），如果您对虚拟机尚不熟悉，可以参考 <a href="https://hibbard.eu/install-ubuntu-virtual-box/">这篇教程</a> 来进行安装。</p><ol><li><p>前往 <code>~/.ssh/</code> 并查看是否已经存在 SSH 密钥对。如果不存在，请使用 <code>ssh-keygen -o -a 100 -t ed25519</code> 来创建一个。建议为密钥设置密码然后使用 <code>ssh-agent</code>，更多信息可以参考 <a href="https://www.ssh.com/ssh/agent">这里</a>；</p></li><li><p>在 <code>.ssh/config</code> 加入下面内容：</p></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Host vm</span><br><span class="line">    User username_goes_here</span><br><span class="line">    HostName ip_goes_here</span><br><span class="line">    IdentityFile ~/.ssh/id_ed25519</span><br><span class="line">    LocalForward 9999 localhost:8888</span><br></pre></td></tr></table></figure><ol><li><p>使用 <code>ssh-copy-id vm</code> 将您的 ssh 密钥拷贝到服务器。</p></li><li><p>使用 <code>python -m http.server 8888</code> 在您的虚拟机中启动一个 Web 服务器并通过本机的 <code>http://localhost:9999</code> 访问虚拟机上的 Web 服务器</p></li><li><p>使用 <code>sudo vim /etc/ssh/sshd_config</code> 编辑 SSH 服务器配置，通过修改 <code>PasswordAuthentication</code> 的值来禁用密码验证。通过修改 <code>PermitRootLogin</code> 的值来禁用 root 登录。然后使用 <code>sudo service sshd restart</code> 重启 <code>ssh</code> 服务器，然后重新尝试。</p></li><li><p>(附加题) 在虚拟机中安装 <a href="https://mosh.org/"><code>mosh</code></a> 并启动连接。然后断开服务器&#x2F;虚拟机的网络适配器。mosh 可以恢复连接吗？</p></li><li><p>(附加题) 查看 <code>ssh</code> 的 <code>-N</code> 和 <code>-f</code> 选项的作用，找出在后台进行端口转发的命令是什么？</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 编程工具 </category>
          
          <category> 计算机教育缺失的一课 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机/编程工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据整理</title>
      <link href="/posts/%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%95%99%E8%82%B2%E7%BC%BA%E5%A4%B1%E7%9A%84%E4%B8%80%E8%AF%BE/%E6%95%B0%E6%8D%AE%E6%95%B4%E7%90%86.html"/>
      <url>/posts/%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%95%99%E8%82%B2%E7%BC%BA%E5%A4%B1%E7%9A%84%E4%B8%80%E8%AF%BE/%E6%95%B0%E6%8D%AE%E6%95%B4%E7%90%86.html</url>
      
        <content type="html"><![CDATA[<h1 id="数据整理"><a href="#数据整理" class="headerlink" title="数据整理"></a>数据整理</h1><p>您是否曾经有过这样的需求，将某种格式存储的数据转换成另外一种格式? 肯定有过，对吧！<br>这也正是我们这节课所要讲授的主要内容。具体来讲，我们需要不断地对数据进行处理，直到得到我们想要的最终结果。</p><p>在之前的课程中，其实我们已经接触到了一些数据整理的基本技术。可以这么说，每当您使用管道运算符的时候，其实就是在进行某种形式的数据整理。</p><p>例如这样一条命令 <code>journalctl | grep -i intel</code>，它会找到所有包含 intel (不区分大小写) 的系统日志。您可能并不认为这是数据整理，但是它确实将某种形式的数据（全部系统日志）转换成了另外一种形式的数据（仅包含 intel 的日志）。大多数情况下，数据整理需要您能够明确哪些工具可以被用来达成特定数据整理的目的，并且明白如何组合使用这些工具。</p><p>让我们从头讲起。既然是学习数据整理，那有两样东西自然是必不可少的：用来整理的数据以及相关的应用场景。日志处理通常是一个比较典型的使用场景，因为我们经常需要在日志中查找某些信息，这种情况下通读日志是不现实的。现在，让我们研究一下系统日志，看看哪些用户曾经尝试过登录我们的服务器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh myserver journalctl</span><br></pre></td></tr></table></figure><p>内容太多了。现在让我们把涉及 sshd 的信息过滤出来：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh myserver journalctl | grep sshd</span><br></pre></td></tr></table></figure><p>注意，这里我们使用管道将一个远程服务器上的文件传递给本机的 <code>grep</code> 程序！<br><code>ssh</code> 太牛了，下一节课我们会讲授命令行环境，届时我们会详细讨论 <code>ssh</code> 的相关内容。此时我们打印出的内容，仍然比我们需要的要多得多，读起来也非常费劲。我们来改进一下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh myserver <span class="string">&#x27;journalctl | grep sshd | grep &quot;Disconnected from&quot;&#x27;</span> | less</span><br></pre></td></tr></table></figure><p>多出来的引号是什么作用呢？这么说吧，我们的日志是一个非常大的文件，把这么大的文件流直接传输到我们本地的电脑上再进行过滤是对流量的一种浪费。因此我们采取另外一种方式，我们先在远端机器上过滤文本内容，然后再将结果传输到本机。 <code>less</code> 为我们创建来一个文件分页器，使我们可以通过翻页的方式浏览较长的文本。为了进一步节省流量，我们甚至可以将当前过滤出的日志保存到文件中，这样后续就不需要再次通过网络访问该文件了：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ssh myserver <span class="string">&#x27;journalctl | grep sshd | grep &quot;Disconnected from&quot;&#x27;</span> &gt; ssh.log</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">less ssh.log</span></span><br></pre></td></tr></table></figure><p>过滤结果中仍然包含不少没用的数据。我们有很多办法可以删除这些无用的数据，但是让我们先研究一下 <code>sed</code> 这个非常强大的工具。</p><p><code>sed</code> 是一个基于文本编辑器 <code>ed</code> 构建的 “ 流编辑器 “ 。在 <code>sed</code> 中，您基本上是利用一些简短的命令来修改文件，而不是直接操作文件的内容（尽管您也可以选择这样做）。相关的命令行非常多，但是最常用的是 <code>s</code>，即<em>替换</em>命令，例如我们可以这样写：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ssh myserver journalctl</span><br><span class="line"> | grep sshd</span><br><span class="line"> | grep <span class="string">&quot;Disconnected from&quot;</span></span><br><span class="line"> | sed <span class="string">&#x27;s/.*Disconnected from //&#x27;</span></span><br></pre></td></tr></table></figure><p>上面这段命令中，我们使用了一段简单的<em>正则表达式</em>。正则表达式是一种非常强大的工具，可以让我们基于某种模式来对字符串进行匹配。<code>s</code> 命令的语法如下：<code>s/REGEX/SUBSTITUTION/</code>, 其中 <code>REGEX</code> 部分是我们需要使用的正则表达式，而 <code>SUBSTITUTION</code> 是用于替换匹配结果的文本。</p><h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><p>正则表达式非常常见也非常有用，值得您花些时间去理解它。让我们从这一句正则表达式开始学习： <code>/.*Disconnected from /</code>。正则表达式通常以（尽管并不总是） <code>/</code> 开始和结束。大多数的 ASCII 字符都表示它们本来的含义，但是有一些字符确实具有表示匹配行为的 “ 特殊 “ 含义。不同字符所表示的含义，根据正则表达式的实现方式不同，也会有所变化，这一点确实令人沮丧。常见的模式有：</p><ul><li><code>.</code> 除换行符之外的 “ 任意单个字符 “</li><li><code>*</code> 匹配前面字符零次或多次</li><li><code>+</code> 匹配前面字符一次或多次</li><li><code>[abc]</code> 匹配 <code>a</code>, <code>b</code> 和 <code>c</code> 中的任意一个</li><li><code>(RX1|RX2)</code> 任何能够匹配 <code>RX1</code> 或 <code>RX2</code> 的结果</li><li><code>^</code> 行首</li><li><code>$</code> 行尾</li></ul><p><code>sed</code> 的正则表达式有些时候是比较奇怪的，它需要你在这些模式前添加 <code>\</code> 才能使其具有特殊含义。或者，您也可以添加 <code>-E</code> 选项来支持这些匹配。</p><p>回过头我们再看 <code>/.*Disconnected from /</code>，我们会发现这个正则表达式可以匹配任何以若干任意字符开头，并接着包含 “Disconnected from “ 的字符串。这也正式我们所希望的。但是请注意，正则表达式并不容易写对。如果有人将 “Disconnected from” 作为自己的用户名会怎样呢？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Jan 17 03:13:00 thesquareplanet.com sshd[2631]: Disconnected from invalid user Disconnected from 46.97.239.16 port 55920 [preauth]</span><br></pre></td></tr></table></figure><p>正则表达式会如何匹配？<code>*</code> 和 <code>+</code> 在默认情况下是贪婪模式，也就是说，它们会尽可能多的匹配文本。因此对上述字符串的匹配结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">46.97.239.16 port 55920 [preauth]</span><br></pre></td></tr></table></figure><p>这可不是我们想要的结果。对于某些正则表达式的实现来说，您可以给 <code>*</code> 或 <code>+</code> 增加一个 <code>?</code> 后缀使其变成非贪婪模式，但是很可惜 <code>sed</code> 并不支持该后缀。不过，我们可以切换到<br>perl 的命令行模式，该模式支持编写这样的正则表达式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -pe <span class="string">&#x27;s/.*?Disconnected from //&#x27;</span></span><br></pre></td></tr></table></figure><p>让我们回到 <code>sed</code> 命令并使用它完成后续的任务，毕竟对于这一类任务，<code>sed</code> 是最常见的工具。<code>sed</code> 还可以非常方便的做一些事情，例如打印匹配后的内容，一次调用中进行多次替换搜索等。但是这些内容我们并不会在此进行介绍。<code>sed</code> 本身是一个非常全能的工具，但是在具体功能上往往能找到更好的工具作为替代品。</p><p>好的，我们还需要去掉用户名后面的后缀，应该如何操作呢？</p><p>想要匹配用户名后面的文本，尤其是当这里的用户名可以包含空格时，这个问题变得非常棘手！这里我们需要做的是匹配<em>一整行</em>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">| sed -E <span class="string">&#x27;s/.*Disconnected from (invalid |authenticating )?user .* [^ ]+ port [0-9]+( \[preauth\])?$//&#x27;</span></span><br></pre></td></tr></table></figure><p>让我们借助正则表达式在线调试工具 <a href="https://regex101.com/r/qqbZqh/2">regex debugger</a> 来理解这段表达式。OK，开始的部分和以前是一样的，随后，我们匹配两种类型的 “user”（在日志中基于两种前缀区分）。再然后我们匹配属于用户名的所有字符。接着，再匹配任意一个单词（<code>[^ ]+</code> 会匹配任意非空且不包含空格的序列）。紧接着后面匹配单 “port” 和它后面的一串数字，以及可能存在的后缀 <code>[preauth]</code>，最后再匹配行尾。</p><p>注意，这样做的话，即使用户名是 “Disconnected from”，对匹配结果也不会有任何影响，您知道这是为什么吗？</p><p>问题还没有完全解决，日志的内容全部被替换成了空字符串，整个日志的内容因此都被删除了。我们实际上希望能够将用户名<em>保留</em>下来。对此，我们可以使用 “ 捕获组（capture groups）” 来完成。被圆括号内的正则表达式匹配到的文本，都会被存入一系列以编号区分的捕获组中。捕获组的内容可以在替换字符串时使用（有些正则表达式的引擎甚至支持替换表达式本身），例如 <code>\1</code>、 <code>\2</code>、<code>\3</code> 等等，因此可以使用如下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">| sed -E <span class="string">&#x27;s/.*Disconnected from (invalid |authenticating )?user (.*) [^ ]+ port [0-9]+( \[preauth\])?$/\2/&#x27;</span></span><br></pre></td></tr></table></figure><p>想必您已经意识到了，为了完成某种匹配，我们最终可能会写出非常复杂的正则表达式。例如，这里有一篇关于如何匹配电子邮箱地址的文章 <a href="https://www.regular-expressions.info/email.html">e-mail address</a>，匹配电子邮箱可一点 <a href="https://emailregex.com/">也不简单</a>。网络上还有很多关于如何匹配电子邮箱地址的 <a href="https://stackoverflow.com/questions/201323/how-to-validate-an-email-address-using-a-regular-expression/1917982">讨论</a>。人们还为其编写了 <a href="https://fightingforalostcause.net/content/misc/2006/compare-email-regex.php">测试用例</a> 及 <a href="https://mathiasbynens.be/demo/url-regex">测试矩阵</a>。您甚至可以编写一个用于判断一个数 <a href="https://www.noulakaz.net/2007/03/18/a-regular-expression-to-check-for-prime-numbers/">是否为质数</a> 的正则表达式。</p><p>正则表达式是出了名的难以写对，但是它仍然会是您强大的常备工具之一。</p><h2 id="回到数据整理"><a href="#回到数据整理" class="headerlink" title="回到数据整理"></a>回到数据整理</h2><p>OK，现在我们有如下表达式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ssh myserver journalctl</span><br><span class="line"> | grep sshd</span><br><span class="line"> | grep <span class="string">&quot;Disconnected from&quot;</span></span><br><span class="line"> | sed -E <span class="string">&#x27;s/.*Disconnected from (invalid |authenticating )?user (.*) [^ ]+ port [0-9]+( \[preauth\])?$/\2/&#x27;</span></span><br></pre></td></tr></table></figure><p><code>sed</code> 还可以做很多各种各样有趣的事情，例如文本注入：(使用 <code>i</code> 命令)，打印特定的行 (使用 <code>p</code> 命令)，基于索引选择特定行等等。详情请见 <code>man sed</code>!</p><p>现在，我们已经得到了一个包含用户名的列表，列表中的用户都曾经尝试过登录我们的系统。但这还不够，让我们过滤出那些最常出现的用户：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ssh myserver journalctl</span><br><span class="line"> | grep sshd</span><br><span class="line"> | grep <span class="string">&quot;Disconnected from&quot;</span></span><br><span class="line"> | sed -E <span class="string">&#x27;s/.*Disconnected from (invalid |authenticating )?user (.*) [^ ]+ port [0-9]+( \[preauth\])?$/\2/&#x27;</span></span><br><span class="line"> | <span class="built_in">sort</span> | <span class="built_in">uniq</span> -c</span><br></pre></td></tr></table></figure><p><code>sort</code> 会对其输入数据进行排序。<code>uniq -c</code> 会把连续出现的行折叠为一行并使用出现次数作为前缀。我们希望按照出现次数排序，过滤出最常出现的用户名：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ssh myserver journalctl</span><br><span class="line"> | grep sshd</span><br><span class="line"> | grep <span class="string">&quot;Disconnected from&quot;</span></span><br><span class="line"> | sed -E <span class="string">&#x27;s/.*Disconnected from (invalid |authenticating )?user (.*) [^ ]+ port [0-9]+( \[preauth\])?$/\2/&#x27;</span></span><br><span class="line"> | <span class="built_in">sort</span> | <span class="built_in">uniq</span> -c</span><br><span class="line"> | <span class="built_in">sort</span> -nk1,1 | <span class="built_in">tail</span> -n10</span><br></pre></td></tr></table></figure><p><code>sort -n</code> 会按照数字顺序对输入进行排序（默认情况下是按照字典序排序<br><code>-k1,1</code> 则表示 “ 仅基于以空格分割的第一列进行排序 “。<code>,n</code> 部分表示 “ 仅排序到第 n 个部分 “，默认情况是到行尾。就本例来说，针对整个行进行排序也没有任何问题，我们这里主要是为了学习这一用法！</p><p>如果我们希望得到登录次数最少的用户，我们可以使用 <code>head</code> 来代替 <code>tail</code>。或者使用 <code>sort -r</code> 来进行倒序排序。</p><p>相当不错。但我们只想获取用户名，而且不要一行一个地显示。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ssh myserver journalctl</span><br><span class="line"> | grep sshd</span><br><span class="line"> | grep <span class="string">&quot;Disconnected from&quot;</span></span><br><span class="line"> | sed -E <span class="string">&#x27;s/.*Disconnected from (invalid |authenticating )?user (.*) [^ ]+ port [0-9]+( \[preauth\])?$/\2/&#x27;</span></span><br><span class="line"> | <span class="built_in">sort</span> | <span class="built_in">uniq</span> -c</span><br><span class="line"> | <span class="built_in">sort</span> -nk1,1 | <span class="built_in">tail</span> -n10</span><br><span class="line"> | awk <span class="string">&#x27;&#123;print $2&#125;&#x27;</span> | <span class="built_in">paste</span> -sd,</span><br></pre></td></tr></table></figure><p>如果您使用的是 MacOS：注意这个命令并不能配合 MacOS 系统默认的 BSD <code>paste</code> 使用。参考 <a href="https://missing-semester-cn.github.io/2020/course-shell/">课程概览与 shell</a> 的习题内容获取更多相关信息。</p><p>我们可以利用 <code>paste</code> 命令来合并行 (<code>-s</code>)，并指定一个分隔符进行分割 (<code>-d</code>)，那 <code>awk</code> 的作用又是什么呢？</p><h2 id="awk-–-另外一种编辑器"><a href="#awk-–-另外一种编辑器" class="headerlink" title="awk – 另外一种编辑器"></a>awk – 另外一种编辑器</h2><p><code>awk</code> 其实是一种编程语言，只不过它碰巧非常善于处理文本。关于 <code>awk</code> 可以介绍的内容太多了，限于篇幅，这里我们仅介绍一些基础知识。</p><p>首先， <code>&#123;print $2&#125;</code> 的作用是什么？ <code>awk</code> 程序接受一个模式串（可选），以及一个代码块，指定当模式匹配时应该做何种操作。默认当模式串即匹配所有行（上面命令中当用法）。<br>在代码块中，<code>$0</code> 表示整行的内容，<code>$1</code> 到 <code>$n</code> 为一行中的 n 个区域，区域的分割基于 <code>awk</code> 的域分隔符（默认是空格，可以通过 <code>-F</code> 来修改）。在这个例子中，我们的代码意思是：对于每一行文本，打印其第二个部分，也就是用户名。</p><p>让我们康康，还有什么炫酷的操作可以做。让我们统计一下所有以 <code>c</code> 开头，以 <code>e</code> 结尾，并且仅尝试过一次登录的用户。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">| awk <span class="string">&#x27;$1 == 1 &amp;&amp; $2 ~ /^c[^ ]*e$/ &#123; print $2 &#125;&#x27;</span> | <span class="built_in">wc</span> -l</span><br></pre></td></tr></table></figure><p>让我们好好分析一下。首先，注意这次我们为 <code>awk</code> 指定了一个匹配模式串（也就是 <code>&#123;…&#125;</code> 前面的那部分内容）。该匹配要求文本的第一部分需要等于 1（这部分刚好是 <code>uniq -c</code> 得到的计数值），然后其第二部分必须满足给定的一个正则表达式。代码块中的内容则表示打印用户名。然后我们使用 <code>wc -l</code> 统计输出结果的行数。</p><p>不过，既然 <code>awk</code> 是一种编程语言，那么则可以这样：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span> &#123; rows = <span class="number">0</span> &#125;</span><br><span class="line"><span class="variable">$1</span> == <span class="number">1</span> &amp;&amp; <span class="variable">$2</span> ~ <span class="regexp">/^c[^ ]*e$/</span> &#123; rows += <span class="variable">$1</span> &#125;</span><br><span class="line"><span class="keyword">END</span> &#123; print rows &#125;</span><br></pre></td></tr></table></figure><p><code>BEGIN</code> 也是一种模式，它会匹配输入的开头（ <code>END</code> 则匹配结尾）。然后，对每一行第一个部分进行累加，最后将结果输出。事实上，我们完全可以抛弃 <code>grep</code> 和 <code>sed</code> ，因为 <code>awk</code> 就可以 <a href="https://backreference.org/2010/02/10/idiomatic-awk">解决所有问题</a>。至于怎么做，就留给读者们做课后练习吧。</p><h2 id="分析数据"><a href="#分析数据" class="headerlink" title="分析数据"></a>分析数据</h2><p>想做数学计算也是可以的！例如这样，您可以将每行的数字加起来：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">| <span class="built_in">paste</span> -sd+ | bc -l</span><br></pre></td></tr></table></figure><p>下面这种更加复杂的表达式也可以：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;2*(<span class="subst">$(data | paste -sd+)</span>)&quot;</span> | bc -l</span><br></pre></td></tr></table></figure><p>您可以通过多种方式获取统计数据。如果已经安装了 R 语言，<a href="https://github.com/nferraz/st"><code>st</code></a> 是个不错的选择：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ssh myserver journalctl</span><br><span class="line"> | grep sshd</span><br><span class="line"> | grep <span class="string">&quot;Disconnected from&quot;</span></span><br><span class="line"> | sed -E <span class="string">&#x27;s/.*Disconnected from (invalid |authenticating )?user (.*) [^ ]+ port [0-9]+( \[preauth\])?$/\2/&#x27;</span></span><br><span class="line"> | <span class="built_in">sort</span> | <span class="built_in">uniq</span> -c</span><br><span class="line"> | awk <span class="string">&#x27;&#123;print $1&#125;&#x27;</span> | R --slave -e <span class="string">&#x27;x &lt;- scan(file=&quot;stdin&quot;, quiet=TRUE); summary(x)&#x27;</span></span><br></pre></td></tr></table></figure><p>R 也是一种编程语言，它非常适合被用来进行数据分析和 <a href="https://ggplot2.tidyverse.org/">绘制图表</a>。这里我们不会讲的特别详细，您只需要知道 <code>summary</code> 可以打印某个向量的统计结果。我们将输入的一系列数据存放在一个向量后，利用 R 语言就可以得到我们想要的统计数据。</p><p>如果您希望绘制一些简单的图表， <code>gnuplot</code> 可以帮助到您：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ssh myserver journalctl</span><br><span class="line"> | grep sshd</span><br><span class="line"> | grep <span class="string">&quot;Disconnected from&quot;</span></span><br><span class="line"> | sed -E <span class="string">&#x27;s/.*Disconnected from (invalid |authenticating )?user (.*) [^ ]+ port [0-9]+( \[preauth\])?$/\2/&#x27;</span></span><br><span class="line"> | <span class="built_in">sort</span> | <span class="built_in">uniq</span> -c</span><br><span class="line"> | <span class="built_in">sort</span> -nk1,1 | <span class="built_in">tail</span> -n10</span><br><span class="line"> | gnuplot -p -e <span class="string">&#x27;set boxwidth 0.5; plot &quot;-&quot; using 1:xtic(2) with boxes&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="利用数据整理来确定参数"><a href="#利用数据整理来确定参数" class="headerlink" title="利用数据整理来确定参数"></a>利用数据整理来确定参数</h2><p>有时候您要利用数据整理技术从一长串列表里找出你所需要安装或移除的东西。我们之前讨论的相关技术配合 <code>xargs</code> 即可实现：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rustup toolchain list | grep nightly | grep -vE <span class="string">&quot;nightly-x86&quot;</span> | sed <span class="string">&#x27;s/-x86.*//&#x27;</span> | xargs rustup toolchain uninstall</span><br></pre></td></tr></table></figure><h2 id="整理二进制数据"><a href="#整理二进制数据" class="headerlink" title="整理二进制数据"></a>整理二进制数据</h2><p>虽然到目前为止我们的讨论都是基于文本数据，但对于二进制文件其实同样有用。例如我们可以用 ffmpeg 从相机中捕获一张图片，将其转换成灰度图后通过 SSH 将压缩后的文件发送到远端服务器，并在那里解压、存档并显示。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -loglevel panic -i /dev/video0 -frames 1 -f image2 -</span><br><span class="line"> | convert - -colorspace gray -</span><br><span class="line"> | gzip</span><br><span class="line"> | ssh mymachine <span class="string">&#x27;gzip -d | tee copy.jpg | env DISPLAY=:0 feh -&#x27;</span></span><br></pre></td></tr></table></figure><h1 id="课后练习"><a href="#课后练习" class="headerlink" title="课后练习"></a>课后练习</h1><p>[习题解答](  &#x2F;  &#x2F;  )</p><ol><li><p>学习一下这篇简短的 <a href="https://regexone.com/">交互式正则表达式教程</a>.</p></li><li><p>统计 words 文件 (<code>/usr/share/dict/words</code>) 中包含至少三个 <code>a</code> 且不以 <code>&#39;s</code> 结尾的单词个数。这些单词中，出现频率前三的末尾两个字母是什么？ <code>sed</code> 的 <code>y</code> 命令，或者 <code>tr</code> 程序也许可以帮你解决大小写的问题。共存在多少种词尾两字母组合？还有一个很有挑战性的问题：哪个组合从未出现过？</p></li><li><p>进行原地替换听上去很有诱惑力，例如：<br>  <code>sed s/REGEX/SUBSTITUTION/ input.txt &gt; input.txt</code>。但是这并不是一个明智的做法，为什么呢？还是说只有 <code>sed</code> 是这样的? 查看 <code>man sed</code> 来完成这个问题</p></li><li><p>找出您最近十次开机的开机时间平均数、中位数和最长时间。在 Linux 上需要用到 <code>journalctl</code> ，而在 macOS 上使用 <code>log show</code>。找到每次起到开始和结束时的时间戳。在 Linux 上类似这样操作：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Logs begin at ...</span><br></pre></td></tr></table></figure><p>  和</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemd[577]: Startup finished in ...</span><br></pre></td></tr></table></figure><p>  在 macOS 上, <a href="https://eclecticlight.co/2018/03/21/macos-unified-log-3-finding-your-way/">查找</a>:</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">=== system boot:</span><br></pre></td></tr></table></figure><p>  和</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Previous shutdown cause: 5</span><br></pre></td></tr></table></figure></li><li><p>查看之前三次重启启动信息中不同的部分 (参见 <code>journalctl</code> 的 <code>-b</code> 选项)。将这一任务分为几个步骤，首先获取之前三次启动的启动日志，也许获取启动日志的命令就有合适的选项可以帮助您提取前三次启动的日志，亦或者您可以使用 <code>sed &#39;0,/STRING/d&#39;</code> 来删除 <code>STRING</code> 匹配到的字符串前面的全部内容。然后，过滤掉每次都不相同的部分，例如时间戳。下一步，重复记录输入行并对其计数 (可以使用 <code>uniq</code> )。最后，删除所有出现过 3 次的内容（因为这些内容是三次启动日志中的重复部分）。</p></li><li><p>在网上找一个类似 <a href="https://stats.wikimedia.org/EN/TablesWikipediaZZ.htm">这个</a> 或者 <a href="https://ucr.fbi.gov/crime-in-the-u.s/2016/crime-in-the-u.s.-2016/topic-pages/tables/table-1">这个</a> 的数据集。或者从 <a href="https://www.springboard.com/blog/free-public-data-sets-data-science-project/">这里</a> 找一些。使用 <code>curl</code> 获取数据集并提取其中两列数据，如果您想要获取的是 HTML 数据，那么 <a href="https://github.com/EricChiang/pup"><code>pup</code></a> 可能会更有帮助。对于 JSON 类型的数据，可以试试 <a href="https://stedolan.github.io/jq/"><code>jq</code></a>。请使用一条指令来找出其中一列的最大值和最小值，用另外一条指令计算两列之间差的总和。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 编程工具 </category>
          
          <category> 计算机教育缺失的一课 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机/编程工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Shell</title>
      <link href="/posts/%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%95%99%E8%82%B2%E7%BC%BA%E5%A4%B1%E7%9A%84%E4%B8%80%E8%AF%BE/Shell.html"/>
      <url>/posts/%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%95%99%E8%82%B2%E7%BC%BA%E5%A4%B1%E7%9A%84%E4%B8%80%E8%AF%BE/Shell.html</url>
      
        <content type="html"><![CDATA[<h1 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h1><p><a href="https://missing-semester-cn.github.io/">计算机教育中缺失的一课 · the missing semester of your cs education (missing-semester-cn.github.io)</a></p><h1 id="The-Shell"><a href="#The-Shell" class="headerlink" title="The Shell"></a>The Shell</h1><h2 id="shell-是什么？"><a href="#shell-是什么？" class="headerlink" title="shell 是什么？"></a>shell 是什么？</h2><p>如今的计算机有着多种多样的交互接口让我们可以进行指令的的输入，从炫酷的图像用户界面（GUI），语音输入甚至是 AR&#x2F;VR 都已经无处不在。 这些交互接口可以覆盖 80% 的使用场景，但是它们也从根本上限制了您的操作方式——你不能点击一个不存在的按钮或者是用语音输入一个还没有被录入的指令。 为了充分利用计算机的能力，我们不得不回到最根本的方式，使用文字接口：Shell</p><p>几乎所有您能够接触到的平台都支持某种形式的 shell，有些甚至还提供了多种 shell 供您选择。虽然它们之间有些细节上的差异，但是其核心功能都是一样的：它允许你执行程序，输入并获取某种半结构化的输出。</p><p>本节课我们会使用 Bourne Again SHell, 简称 “bash” 。 这是被最广泛使用的一种 shell，它的语法和其他的 shell 都是类似的。打开 shell _提示符_（您输入指令的地方），您首先需要打开 <em>终端</em> 。您的设备通常都已经内置了终端，或者您也可以安装一个，非常简单。</p><h2 id="使用-shell"><a href="#使用-shell" class="headerlink" title="使用 shell"></a>使用 shell</h2><p>当您打开终端时，您会看到一个提示符，它看起来一般是这个样子的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">missing:~$</span><br></pre></td></tr></table></figure><p>这是 shell 最主要的文本接口。它告诉你，你的主机名是 <code>missing</code> 并且您当前的工作目录（”current working directory”）或者说您当前所在的位置是 <code>~</code> (表示 “home”)。 <code>$</code> 符号表示您现在的身份不是 root 用户（稍后会介绍）。在这个提示符中，您可以输入 <em>命令</em> ，命令最终会被 shell 解析。最简单的命令是执行一个程序：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">missing:~$date</span><br><span class="line">Fri 10 Jan 2020 11:49:31 AM EST</span><br><span class="line">missing:~$</span><br></pre></td></tr></table></figure><p>这里，我们执行了 <code>date</code> 这个程序，不出意料地，它打印出了当前的日期和时间。然后，shell 等待我们输入其他命令。我们可以在执行命令的同时向程序传递 <em>参数</em> ：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">missing:~$echo hello</span><br><span class="line">hello</span><br></pre></td></tr></table></figure><p>上例中，我们让 shell 执行 <code>echo</code> ，同时指定参数 <code>hello</code>。<code>echo</code> 程序将该参数打印出来。 shell 基于空格分割命令并进行解析，然后执行第一个单词代表的程序，并将后续的单词作为程序可以访问的参数。如果您希望传递的参数中包含空格（例如一个名为 My Photos 的文件夹），您要么用使用单引号，双引号将其包裹起来，要么使用转义符号 <code>\</code> 进行处理（<code>My\ Photos</code>）。</p><p>但是，shell 是如何知道去哪里寻找 <code>date</code> 或 <code>echo</code> 的呢？其实，类似于 Python 或 Ruby，shell 是一个编程环境，所以它具备变量、条件、循环和函数（下一课进行讲解）。当你在 shell 中执行命令时，您实际上是在执行一段 shell 可以解释执行的简短代码。如果你要求 shell 执行某个指令，但是该指令并不是 shell 所了解的编程关键字，那么它会去咨询 <em>环境变量</em> <code>$PATH</code>，它会列出当 shell 接到某条指令时，进行程序搜索的路径：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">missing:~$echo $PATH</span><br><span class="line">/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin</span><br><span class="line">missing:~$which echo</span><br><span class="line">/bin/echo</span><br><span class="line">missing:~$/bin/echo $PATH</span><br><span class="line">/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin</span><br></pre></td></tr></table></figure><p>当我们执行 <code>echo</code> 命令时，shell 了解到需要执行 <code>echo</code> 这个程序，随后它便会在 <code>$PATH</code> 中搜索由 <code>:</code> 所分割的一系列目录，基于名字搜索该程序。当找到该程序时便执行（假定该文件是 _可执行程序_，后续课程将详细讲解）。确定某个程序名代表的是哪个具体的程序，可以使用 <code>which</code> 程序。我们也可以绕过 <code>$PATH</code>，通过直接指定需要执行的程序的路径来执行该程序</p><h2 id="在-shell-中导航"><a href="#在-shell-中导航" class="headerlink" title="在 shell 中导航"></a>在 shell 中导航</h2><p>shell 中的路径是一组被分割的目录，在 Linux 和 macOS 上使用 <code>/</code> 分割，而在 Windows 上是 <code>\</code>。路径 <code>/</code> 代表的是系统的根目录，所有的文件夹都包括在这个路径之下，在 Windows 上每个盘都有一个根目录（例如： <code>C:\</code>）。 我们假设您在学习本课程时使用的是 Linux 文件系统。如果某个路径以 <code>/</code> 开头，那么它是一个 _绝对路径_，其他的都是 <em>相对路径</em> 。相对路径是指相对于当前工作目录的路径，当前工作目录可以使用 <code>pwd</code> 命令来获取。此外，切换目录需要使用 <code>cd</code> 命令。在路径中，<code>.</code> 表示的是当前目录，而 <code>..</code> 表示上级目录：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">missing:~$pwd</span><br><span class="line">/home/missing</span><br><span class="line">missing:~$cd /home</span><br><span class="line">missing:/home$pwd</span><br><span class="line">/home</span><br><span class="line">missing:/home$cd ..</span><br><span class="line">missing:/$pwd</span><br><span class="line">/</span><br><span class="line">missing:/$cd ./home</span><br><span class="line">missing:/home$pwd</span><br><span class="line">/home</span><br><span class="line">missing:/home$cd missing</span><br><span class="line">missing:~$pwd</span><br><span class="line">/home/missing</span><br><span class="line">missing:~$../../bin/echo hello</span><br><span class="line">hello</span><br></pre></td></tr></table></figure><p>注意，shell 会实时显示当前的路径信息。您可以通过配置 shell 提示符来显示各种有用的信息，这一内容我们会在后面的课程中进行讨论。</p><p>一般来说，当我们运行一个程序时，如果我们没有指定路径，则该程序会在当前目录下执行。例如，我们常常会搜索文件，并在需要时创建文件。</p><p>为了查看指定目录下包含哪些文件，我们使用 <code>ls</code> 命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">missing:~$ls</span><br><span class="line">missing:~$cd ..</span><br><span class="line">missing:/home$ls</span><br><span class="line">missing</span><br><span class="line">missing:/home$cd ..</span><br><span class="line">missing:/$ls</span><br><span class="line">bin</span><br><span class="line">boot</span><br><span class="line">dev</span><br><span class="line">etc</span><br><span class="line">home</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>除非我们利用第一个参数指定目录，否则 <code>ls</code> 会打印当前目录下的文件。大多数的命令接受标记和选项（带有值的标记），它们以 <code>-</code> 开头，并可以改变程序的行为。通常，在执行程序时使用 <code>-h</code> 或 <code>--help</code> 标记可以打印帮助信息，以便了解有哪些可用的标记或选项。例如，<code>ls --help</code> 的输出如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-l                         use a long listing format</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">missing:~$ls -l /home</span><br><span class="line">drwxr-xr-x 1 missing  users  4096 Jun 15  2019 missing</span><br></pre></td></tr></table></figure><p>这个参数可以更加详细地列出目录下文件或文件夹的信息。首先，本行第一个字符 <code>d</code> 表示 <code>missing</code> 是一个目录。然后接下来的九个字符，每三个字符构成一组。 （<code>rwx</code>）. 它们分别代表了文件所有者（<code>missing</code>），用户组（<code>users</code>） 以及其他所有人具有的权限。其中 <code>-</code> 表示该用户不具备相应的权限。从上面的信息来看，只有文件所有者可以修改（<code>w</code>），<code>missing</code> 文件夹 （例如，添加或删除文件夹中的文件）。为了进入某个文件夹，用户需要具备该文件夹以及其父文件夹的 “ 搜索 “ 权限（以 “ 可执行 “：<code>x</code>）权限表示。为了列出它的包含的内容，用户必须对该文件夹具备读权限（<code>r</code>）。对于文件来说，权限的意义也是类似的。注意，<code>/bin</code> 目录下的程序在最后一组，即表示所有人的用户组中，均包含 <code>x</code> 权限，也就是说任何人都可以执行这些程序。</p><p>在这个阶段，还有几个趁手的命令是您需要掌握的，例如 <code>mv</code>（用于重命名或移动文件）、 <code>cp</code>（拷贝文件）以及 <code>mkdir</code>（新建文件夹）。</p><p>如果您想要知道关于程序参数、输入输出的信息，亦或是想要了解它们的工作方式，请试试 <code>man</code> 这个程序。它会接受一个程序名作为参数，然后将它的文档（用户手册）展现给您。注意，使用 <code>q</code> 可以退出该程序。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">missing:~$man ls</span><br></pre></td></tr></table></figure><h2 id="在程序间创建连接"><a href="#在程序间创建连接" class="headerlink" title="在程序间创建连接"></a>在程序间创建连接</h2><p>在 shell 中，程序有两个主要的 “ 流 “：它们的输入流和输出流。 当程序尝试读取信息时，它们会从输入流中进行读取，当程序打印信息时，它们会将信息输出到输出流中。 通常，一个程序的输入输出流都是您的终端。也就是，您的键盘作为输入，显示器作为输出。 但是，我们也可以重定向这些流！</p><p>最简单的重定向是 <code>&lt; file</code> 和 <code>&gt; file</code>。这两个命令可以将程序的输入输出流分别重定向到文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">missing:~$echo hello &gt; hello.txt</span><br><span class="line">missing:~$cat hello.txt</span><br><span class="line">hello</span><br><span class="line">missing:~$cat &lt; hello.txt</span><br><span class="line">hello</span><br><span class="line">missing:~$cat &lt; hello.txt &gt; hello2.txt</span><br><span class="line">missing:~$cat hello2.txt</span><br><span class="line">hello</span><br></pre></td></tr></table></figure><p>您还可以使用 <code>&gt;&gt;</code> 来向一个文件追加内容。使用管道（ <em>pipes</em> ），我们能够更好的利用文件重定向。 <code>|</code> 操作符允许我们将一个程序的输出和另外一个程序的输入连接起来：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">missing:~$ls -l / | tail -n1</span><br><span class="line">drwxr-xr-x 1 root  root  4096 Jun 20  2019 var</span><br><span class="line">missing:~$curl --head --silent google.com | grep --ignore-case content-length | cut --delimiter=&#x27; &#x27; -f2</span><br><span class="line">219</span><br></pre></td></tr></table></figure><p>我们会在数据清理一章中更加详细的探讨如何更好的利用管道。</p><h2 id="一个功能全面又强大的工具"><a href="#一个功能全面又强大的工具" class="headerlink" title="一个功能全面又强大的工具"></a>一个功能全面又强大的工具</h2><p>对于大多数的类 Unix 系统，有一类用户是非常特殊的，那就是：根用户（root user）。 您应该已经注意到了，在上面的输出结果中，根用户几乎不受任何限制，他可以创建、读取、更新和删除系统中的任何文件。 通常在我们并不会以根用户的身份直接登录系统，因为这样可能会因为某些错误的操作而破坏系统。 取而代之的是我们会在需要的时候使用 <code>sudo</code> 命令。顾名思义，它的作用是让您可以以 su（super user 或 root 的简写）的身份执行一些操作。 当您遇到拒绝访问（permission denied）的错误时，通常是因为此时您必须是根用户才能操作。然而，请再次确认您是真的要执行此操作。</p><p>有一件事情是您必须作为根用户才能做的，那就是向 <code>sysfs</code> 文件写入内容。系统被挂载在 <code>/sys</code> 下，<code>sysfs</code> 文件则暴露了一些内核（kernel）参数。 因此，您不需要借助任何专用的工具，就可以轻松地在运行期间配置系统内核。<strong>注意 Windows 和 macOS 没有这个文件</strong></p><p>例如，您笔记本电脑的屏幕亮度写在 <code>brightness</code> 文件中，它位于</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/sys/class/backlight</span><br></pre></td></tr></table></figure><p>通过将数值写入该文件，我们可以改变屏幕的亮度。现在，蹦到您脑袋里的第一个想法可能是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$sudo find -L /sys/class/backlight -maxdepth 2 -name &#x27;*brightness*&#x27;</span><br><span class="line">/sys/class/backlight/thinkpad_screen/brightness</span><br><span class="line">$cd /sys/class/backlight/thinkpad_screen</span><br><span class="line">$sudo echo 3 &gt; brightness</span><br><span class="line">An error occurred while redirecting file &#x27;brightness&#x27;</span><br><span class="line">open: Permission denied</span><br></pre></td></tr></table></figure><p>出乎意料的是，我们还是得到了一个错误信息。毕竟，我们已经使用了 <code>sudo</code> 命令！关于 shell，有件事我们必须要知道。<code>|</code>、<code>&gt;</code>、和 <code>&lt;</code> 是通过 shell 执行的，而不是被各个程序单独执行。 <code>echo</code> 等程序并不知道 <code>|</code> 的存在，它们只知道从自己的输入输出流中进行读写。 对于上面这种情况， <em>shell</em> (权限为您的当前用户) 在设置 <code>sudo echo</code> 前尝试打开 brightness 文件并写入，但是系统拒绝了 shell 的操作因为此时 shell 不是根用户。</p><p>明白这一点后，我们可以这样操作：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$echo 3 | sudo tee brightness</span><br></pre></td></tr></table></figure><p>因为打开 <code>/sys</code> 文件的是 <code>tee</code> 这个程序，并且该程序以 <code>root</code> 权限在运行，因此操作可以进行。 这样您就可以在 <code>/sys</code> 中愉快地玩耍了，例如修改系统中各种 LED 的状态（路径可能会有所不同）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$echo 1 | sudo tee /sys/class/leds/input6::scrolllock/brightness</span><br></pre></td></tr></table></figure><h2 id="课后练习"><a href="#课后练习" class="headerlink" title="课后练习"></a>课后练习</h2><p><a href="https://missing-semester-cn.github.io/missing-notes-and-solutions/2020/solutions//course-shell-solution">习题解答</a> 本课程中的每节课都包含一系列练习题。有些题目是有明确目的的，另外一些则是开放题，例如 “ 尝试使用 X 和 Y”，我们强烈建议您一定要动手实践，用于尝试这些内容。 此外，我们没有为这些练习题提供答案。如果有任何困难，您可以发送邮件给我们并描述你已经做出的尝试，我们会设法帮您解答。</p><ol><li><p>本课程需要使用类 Unix shell，例如 Bash 或 ZSH。如果您在 Linux 或者 MacOS 上面完成本课程的练习，则不需要做任何特殊的操作。如果您使用的是 Windows，则您不应该使用 cmd 或是 Powershell；您可以使用 <a href="https://docs.microsoft.com/en-us/windows/wsl/">Windows Subsystem for Linux</a> 或者是 Linux 虚拟机。使用 <code>echo $SHELL</code> 命令可以查看您的 shell 是否满足要求。如果打印结果为 <code>/bin/bash</code> 或 <code>/usr/bin/zsh</code> 则是可以的。</p></li><li><p>在 <code>/tmp</code> 下新建一个名为 <code>missing</code> 的文件夹。</p></li><li><p>用 <code>man</code> 查看程序 <code>touch</code> 的使用手册。</p></li><li><p>用 <code>touch</code> 在 <code>missing</code> 文件夹中新建一个叫 <code>semester</code> 的文件。</p></li><li><p>将以下内容一行一行地写入 <code>semester</code> 文件：</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line"></span><br><span class="line">curl --head --silent https://missing.csail.mit.edu</span><br></pre></td></tr></table></figure><blockquote><p>第一行可能有点棘手， <code>#</code> 在 Bash 中表示注释，而 <code>!</code> 即使被双引号（<code>&quot;</code>）包裹也具有特殊的含义。 单引号（<code>&#39;</code>）则不一样，此处利用这一点解决输入问题。更多信息请参考 <a href="https://www.gnu.org/software/bash/manual/html_node/Quoting.html">Bash quoting 手册</a></p></blockquote><ol><li><p>尝试执行这个文件。例如，将该脚本的路径（<code>./semester</code>）输入到您的 shell 中并回车。如果程序无法执行，请使用 <code>ls</code> 命令来获取信息并理解其不能执行的原因。</p></li><li><p>查看 <code>chmod</code> 的手册 (例如，使用 <code>man chmod</code> 命令)</p></li><li><p>使用 <code>chmod</code> 命令改变权限，使 <code>./semester</code> 能够成功执行，不要使用 <code>sh semester</code> 来执行该程序。您的 shell 是如何知晓这个文件需要使用 <code>sh</code> 来解析呢？更多信息请参考：<a href="https://en.wikipedia.org/wiki/Shebang_" title="Unix">shebang</a></p></li><li><p>使用 <code>|</code> 和 <code>&gt;</code> ，将 <code>semester</code> 文件输出的最后更改日期信息，写入主目录下的 <code>last-modified.txt</code> 的文件中</p></li><li><p>写一段命令来从 <code>/sys</code> 中获取笔记本的电量信息，或者台式机 CPU 的温度。注意：macOS 并没有 sysfs，所以 Mac 用户可以跳过这一题。</p></li></ol><h1 id="Shell-工具"><a href="#Shell-工具" class="headerlink" title="Shell 工具"></a>Shell 工具</h1><h2 id="查看命令如何使用"><a href="#查看命令如何使用" class="headerlink" title="查看命令如何使用"></a>查看命令如何使用</h2><p>看到这里，您可能会有疑问，我们应该如何为特定的命令找到合适的标记呢？例如 <code>ls -l</code>, <code>mv -i</code> 和 <code>mkdir -p</code>。更普遍的是，给您一个命令行，您应该怎样了解如何使用这个命令行并找出它的不同的选项呢？ 一般来说，您可能会先去网上搜索答案，但是，UNIX 可比 StackOverflow 出现的早，因此我们的系统里其实早就包含了可以获取相关信息的方法。</p><p>在上一节中我们介绍过，最常用的方法是为对应的命令行添加 <code>-h</code> 或 <code>--help</code> 标记。另外一个更详细的方法则是使用 <code>man</code> 命令。<a href="https://man7.org/linux/man-pages/man1/man.1.html"><code>man</code></a> 命令是手册（manual）的缩写，它提供了命令的用户手册。</p><p>例如，<code>man rm</code> 会输出命令 <code>rm</code> 的说明，同时还有其标记列表，包括之前我们介绍过的 <code>-i</code>。 事实上，目前我们给出的所有命令的说明链接，都是网页版的 Linux 命令手册。即使是您安装的第三方命令，前提是开发者编写了手册并将其包含在了安装包中。在交互式的、基于字符处理的终端窗口中，一般也可以通过 <code>:help</code> 命令或键入 <code>?</code> 来获取帮助。</p><p>有时候手册内容太过详实，让我们难以在其中查找哪些最常用的标记和语法。 <a href="https://tldr.sh/">TLDR pages</a> 是一个很不错的替代品，它提供了一些案例，可以帮助您快速找到正确的选项。</p><p>例如，自己就常常在 tldr 上搜索 <a href="https://tldr.ostera.io/tar"><code>tar</code></a> 和 <a href="https://tldr.ostera.io/ffmpeg"><code>ffmpeg</code></a> 的用法。</p><h2 id="查找文件"><a href="#查找文件" class="headerlink" title="查找文件"></a>查找文件</h2><p>程序员们面对的最常见的重复任务就是查找文件或目录。所有的类 UNIX 系统都包含一个名为 <a href="https://man7.org/linux/man-pages/man1/find.1.html"><code>find</code></a> 的工具，它是 shell 上用于查找文件的绝佳工具。<code>find</code> 命令会递归地搜索符合条件的文件，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 查找所有名称为src的文件夹</span><br><span class="line">find . -name src -type d</span><br><span class="line"># 查找所有文件夹路径中包含test的python文件</span><br><span class="line">find . -path &#x27;*/test/*.py&#x27; -type f</span><br><span class="line"># 查找前一天修改的所有文件</span><br><span class="line">find . -mtime -1</span><br><span class="line"># 查找所有大小在500k至10M的tar.gz文件</span><br><span class="line">find . -size +500k -size -10M -name &#x27;*.tar.gz&#x27;</span><br></pre></td></tr></table></figure><p>除了列出所寻找的文件之外，find 还能对所有查找到的文件进行操作。这能极大地简化一些单调的任务。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 删除全部扩展名为.tmp 的文件</span><br><span class="line">find . -name &#x27;*.tmp&#x27; -exec rm &#123;&#125; \;</span><br><span class="line"># 查找全部的 PNG 文件并将其转换为 JPG</span><br><span class="line">find . -name &#x27;*.png&#x27; -exec convert &#123;&#125; &#123;&#125;.jpg \;</span><br></pre></td></tr></table></figure><p>尽管 <code>find</code> 用途广泛，它的语法却比较难以记忆。例如，为了查找满足模式 <code>PATTERN</code> 的文件，您需要执行 <code>find -name &#39;*PATTERN*&#39;</code> (如果您希望模式匹配时是不区分大小写，可以使用 <code>-iname</code> 选项）</p><p>您当然可以使用 alias 设置别名来简化上述操作，但 shell 的哲学之一便是寻找（更好用的）替代方案。 记住，shell 最好的特性就是您只是在调用程序，因此您只要找到合适的替代程序即可（甚至自己编写）。</p><p>例如，<a href="https://github.com/sharkdp/fd"><code>fd</code></a> 就是一个更简单、更快速、更友好的程序，它可以用来作为 <code>find</code> 的替代品。它有很多不错的默认设置，例如输出着色、默认支持正则匹配、支持 unicode 并且我认为它的语法更符合直觉。以模式 <code>PATTERN</code> 搜索的语法是 <code>fd PATTERN</code>。</p><p>大多数人都认为 <code>find</code> 和 <code>fd</code> 已经很好用了，但是有的人可能想知道，我们是不是可以有更高效的方法，例如不要每次都搜索文件而是通过编译索引或建立数据库的方式来实现更加快速地搜索。</p><p>这就要靠 <a href="https://man7.org/linux/man-pages/man1/locate.1.html"><code>locate</code></a> 了。 <code>locate</code> 使用一个由 <a href="https://man7.org/linux/man-pages/man1/updatedb.1.html"><code>updatedb</code></a> 负责更新的数据库，在大多数系统中 <code>updatedb</code> 都会通过 <a href="https://man7.org/linux/man-pages/man8/cron.8.html"><code>cron</code></a> 每日更新。这便需要我们在速度和时效性之间作出权衡。而且，<code>find</code> 和类似的工具可以通过别的属性比如文件大小、修改时间或是权限来查找文件，<code>locate</code> 则只能通过文件名。 <a href="https://unix.stackexchange.com/questions/60205/locate-vs-find-usage-pros-and-cons-of-each-other">这里</a> 有一个更详细的对比。</p><h2 id="查找代码"><a href="#查找代码" class="headerlink" title="查找代码"></a>查找代码</h2><p>查找文件是很有用的技能，但是很多时候您的目标其实是查看文件的内容。一个最常见的场景是您希望查找具有某种模式的全部文件，并找它们的位置。</p><p>为了实现这一点，很多类 UNIX 的系统都提供了 <a href="https://man7.org/linux/man-pages/man1/grep.1.html"><code>grep</code></a> 命令，它是用于对输入文本进行匹配的通用工具。它是一个非常重要的 shell 工具，我们会在后续的数据清理课程中深入的探讨它。</p><p><code>grep</code> 有很多选项，这也使它成为一个非常全能的工具。其中我经常使用的有 <code>-C</code> ：获取查找结果的上下文（Context）；<code>-v</code> 将对结果进行反选（Invert），也就是输出不匹配的结果。举例来说， <code>grep -C 5</code> 会输出匹配结果前后五行。当需要搜索大量文件的时候，使用 <code>-R</code> 会递归地进入子目录并搜索所有的文本文件。</p><p>但是，我们有很多办法可以对 <code>grep -R</code> 进行改进，例如使其忽略 <code>.git</code> 文件夹，使用多 CPU 等等。</p><p>因此也出现了很多它的替代品，包括 <a href="https://beyondgrep.com/">ack</a>, <a href="https://github.com/ggreer/the_silver_searcher">ag</a> 和 <a href="https://github.com/BurntSushi/ripgrep">rg</a>。它们都特别好用，但是功能也都差不多，我比较常用的是 ripgrep (<code>rg</code>) ，因为它速度快，而且用法非常符合直觉。例子如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 查找所有使用了 requests 库的文件</span><br><span class="line">rg -t py &#x27;import requests&#x27;</span><br><span class="line"># 查找所有没有写 shebang 的文件（包含隐藏文件）</span><br><span class="line">rg -u --files-without-match &quot;^#!&quot;</span><br><span class="line"># 查找所有的foo字符串，并打印其之后的5行</span><br><span class="line">rg foo -A 5</span><br><span class="line"># 打印匹配的统计信息（匹配的行和文件的数量）</span><br><span class="line">rg --stats PATTERN</span><br></pre></td></tr></table></figure><p>与 <code>find</code>&#x2F;<code>fd</code> 一样，重要的是你要知道有些问题使用合适的工具就会迎刃而解，而具体选择哪个工具则不是那么重要。</p><h2 id="查找-shell-命令"><a href="#查找-shell-命令" class="headerlink" title="查找 shell 命令"></a>查找 shell 命令</h2><p>目前为止，我们已经学习了如何查找文件和代码，但随着你使用 shell 的时间越来越久，您可能想要找到之前输入过的某条命令。首先，按向上的方向键会显示你使用过的上一条命令，继续按上键则会遍历整个历史记录。</p><p><code>history</code> 命令允许您以程序员的方式来访问 shell 中输入的历史命令。这个命令会在标准输出中打印 shell 中的里面命令。如果我们要搜索历史记录，则可以利用管道将输出结果传递给 <code>grep</code> 进行模式搜索。 <code>history | grep find</code> 会打印包含 find 子串的命令。</p><p>对于大多数的 shell 来说，您可以使用 <code>Ctrl+R</code> 对命令历史记录进行回溯搜索。敲 <code>Ctrl+R</code> 后您可以输入子串来进行匹配，查找历史命令行。</p><p>反复按下就会在所有搜索结果中循环。在 <a href="https://github.com/zsh-users/zsh-history-substring-search">zsh</a> 中，使用方向键上或下也可以完成这项工作。</p><p><code>Ctrl+R</code> 可以配合 <a href="https://github.com/junegunn/fzf/wiki/Configuring-shell-key-bindings#ctrl-r">fzf</a> 使用。<code>fzf</code> 是一个通用对模糊查找工具，它可以和很多命令一起使用。这里我们可以对历史命令进行模糊查找并将结果以赏心悦目的格式输出。</p><p>另外一个和历史命令相关的技巧我喜欢称之为<strong>基于历史的自动补全</strong>。 这一特性最初是由 <a href="https://fishshell.com/">fish</a> shell 创建的，它可以根据您最近使用过的开头相同的命令，动态地对当前对 shell 命令进行补全。这一功能在 <a href="https://github.com/zsh-users/zsh-autosuggestions">zsh</a> 中也可以使用，它可以极大的提高用户体验。</p><p>你可以修改 shell history 的行为，例如，如果在命令的开头加上一个空格，它就不会被加进 shell 记录中。当你输入包含密码或是其他敏感信息的命令时会用到这一特性。 为此你需要在 <code>.bashrc</code> 中添加 <code>HISTCONTROL=ignorespace</code> 或者向 <code>.zshrc</code> 添加 <code>setopt HIST_IGNORE_SPACE</code>。 如果你不小心忘了在前面加空格，可以通过编辑。<code>bash_history</code> 或 <code>.zhistory</code> 来手动地从历史记录中移除那一项。</p><h2 id="文件夹导航"><a href="#文件夹导航" class="headerlink" title="文件夹导航"></a>文件夹导航</h2><p>之前对所有操作我们都默认一个前提，即您已经位于想要执行命令的目录下，但是如何才能高效地在目录 间随意切换呢？有很多简便的方法可以做到，比如设置 alias，使用 <a href="https://man7.org/linux/man-pages/man1/ln.1.html">ln -s</a> 创建符号连接等。而开发者们已经想到了很多更为精妙的解决方案。</p><p>由于本课程的目的是尽可能对你的日常习惯进行优化。因此，我们可以使用 <a href="https://github.com/clvv/fasd"><code>fasd</code></a> 和 <a href="https://github.com/wting/autojump">autojump</a> 这两个工具来查找最常用或最近使用的文件和目录。</p><p>Fasd 基于 <a href="https://developer.mozilla.org/en-US/docs/Mozilla/Tech/Places/Frecency_algorithm"><em>frecency</em></a> 对文件和文件排序，也就是说它会同时针对频率（_frequency_）和时效（_recency_）进行排序。默认情况下，<code>fasd</code> 使用命令 <code>z</code> 帮助我们快速切换到最常访问的目录。例如， 如果您经常访问 <code>/home/user/files/cool_project</code> 目录，那么可以直接使用 <code>z cool</code> 跳转到该目录。对于 autojump，则使用 <code>j cool</code> 代替即可。</p><p>还有一些更复杂的工具可以用来概览目录结构，例如 <a href="https://linux.die.net/man/1/tree"><code>tree</code></a>, <a href="https://github.com/Canop/broot"><code>broot</code></a> 或更加完整的文件管理器，例如 <a href="https://github.com/jarun/nnn"><code>nnn</code></a> 或 <a href="https://github.com/ranger/ranger"><code>ranger</code></a>。</p><h1 id="课后练习-1"><a href="#课后练习-1" class="headerlink" title="课后练习"></a>课后练习</h1><p><a href="https://missing-semester-cn.github.io/missing-notes-and-solutions/2020/solutions//shell-tools-solution">习题解答</a></p><ol><li>阅读 <a href="https://man7.org/linux/man-pages/man1/ls.1.html"><code>man ls</code></a> ，然后使用 <code>ls</code> 命令进行如下操作：</li></ol><ul><li>所有文件（包括隐藏文件）</li><li>文件打印以人类可以理解的格式输出 (例如，使用 454M 而不是 454279954)</li><li>文件以最近访问顺序排序</li><li>以彩色文本显示输出结果</li></ul><p>典型输出如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-rw-r--r--   1 user group 1.1M Jan 14 09:53 baz</span><br><span class="line">drwxr-xr-x   5 user group  160 Jan 14 09:53 .</span><br><span class="line">-rw-r--r--   1 user group  514 Jan 14 06:42 bar</span><br><span class="line">-rw-r--r--   1 user group 106M Jan 13 12:12 foo</span><br><span class="line">drwx------+ 47 user group 1.5K Jan 12 18:08 ..</span><br></pre></td></tr></table></figure><ol><li><p>编写两个 bash 函数 <code>marco</code> 和 <code>polo</code> 执行下面的操作。 每当你执行 <code>marco</code> 时，当前的工作目录应当以某种形式保存，当执行 <code>polo</code> 时，无论现在处在什么目录下，都应当 <code>cd</code> 回到当时执行 <code>marco</code> 的目录。 为了方便 debug，你可以把代码写在单独的文件 <code>marco.sh</code> 中，并通过 <code>source marco.sh</code> 命令，（重新）加载函数。</p></li><li><p>假设您有一个命令，它很少出错。因此为了在出错时能够对其进行调试，需要花费大量的时间重现错误并捕获输出。 编写一段 bash 脚本，运行如下的脚本直到它出错，将它的标准输出和标准错误流记录到文件，并在最后输出所有内容。 加分项：报告脚本在失败前共运行了多少次。</p> <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env bash</span></span><br><span class="line"></span><br><span class="line"> n=$(( RANDOM % <span class="number">100</span> ))</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> [[ n -eq 42 ]]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;Something went wrong&quot;</span></span><br><span class="line">   &gt;&amp;2 <span class="built_in">echo</span> <span class="string">&quot;The error was using magic numbers&quot;</span></span><br><span class="line">    <span class="built_in">exit</span> 1</span><br><span class="line"> <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"> <span class="built_in">echo</span> <span class="string">&quot;Everything went according to plan&quot;</span></span><br></pre></td></tr></table></figure></li><li><p>本节课我们讲解的 <code>find</code> 命令中的 <code>-exec</code> 参数非常强大，它可以对我们查找的文件进行操作。但是，如果我们要对所有文件进行操作呢？例如创建一个 zip 压缩文件？我们已经知道，命令行可以从参数或标准输入接受输入。在用管道连接命令时，我们将标准输出和标准输入连接起来，但是有些命令，例如 <code>tar</code> 则需要从参数接受输入。这里我们可以使用 <a href="https://man7.org/linux/man-pages/man1/xargs.1.html"><code>xargs</code></a> 命令，它可以使用标准输入中的内容作为参数。 例如 <code>ls | xargs rm</code> 会删除当前目录中的所有文件。</p></li></ol><blockquote><p>您的任务是编写一个命令，它可以递归地查找文件夹中所有的 HTML 文件，并将它们压缩成 zip 文件。注意，即使文件名中包含空格，您的命令也应该能够正确执行（提示：查看 <code>xargs</code> 的参数 <code>-d</code>，译注：MacOS 上的 <code>xargs</code> 没有 <code>-d</code>，<a href="https://github.com/missing-semester/missing-semester/issues/93">查看这个issue</a>）</p></blockquote><p>如果您使用的是 MacOS，请注意默认的 BSD <code>find</code> 与 <a href="https://en.wikipedia.org/wiki/List_of_GNU_Core_Utilities_commands">GNU coreutils</a> 中的是不一样的。你可以为 <code>find</code> 添加 <code>-print0</code> 选项，并为 <code>xargs</code> 添加 <code>-0</code> 选项。作为 Mac 用户，您需要注意 mac 系统自带的命令行工具和 GNU 中对应的工具是有区别的；如果你想使用 GNU 版本的工具，也可以使用 <a href="https://formulae.brew.sh/formula/coreutils">brew 来安装</a>。</p><ol><li>（进阶）编写一个命令或脚本递归的查找文件夹中最近使用的文件。更通用的做法，你可以按照最近的使用时间列出文件吗？</li></ol>]]></content>
      
      
      <categories>
          
          <category> 编程工具 </category>
          
          <category> 计算机教育缺失的一课 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机/编程工具/shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客部署</title>
      <link href="/posts/%E7%BD%91%E7%BB%9C/%E5%8D%9A%E5%AE%A2%E9%85%8D%E7%BD%AE/%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2.html"/>
      <url>/posts/%E7%BD%91%E7%BB%9C/%E5%8D%9A%E5%AE%A2%E9%85%8D%E7%BD%AE/%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2.html</url>
      
        <content type="html"><![CDATA[<p><a href="https://blog.17lai.site/posts/5311b619/#%E5%90%84%E7%A7%8D%E9%83%A8%E7%BD%B2%E6%96%B9%E5%BC%8F">基于Hexo的matery主题搭建博客增强部署篇4 | 夜法之书 (17lai.site)</a></p><h1 id="在-CloudFlare-workers-部署"><a href="#在-CloudFlare-workers-部署" class="headerlink" title="在 CloudFlare workers 部署"></a>在 CloudFlare workers 部署</h1><p><a href="https://sleele.com/2021/01/01/cloudflare-workers-site-deploy/#%E9%83%A8%E7%BD%B2%E9%9D%99%E6%80%81%E7%BD%91%E7%AB%99%E8%87%B3Cloudflare_Workers_Site">将静态网站部署到Cloudflare Workers Site | sleele的博客</a></p><h2 id="安装-Wrangler"><a href="#安装-Wrangler" class="headerlink" title="安装 Wrangler"></a>安装 Wrangler</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install @cloudflare/wrangler -g</span><br></pre></td></tr></table></figure><h2 id="在-hexo-项目下初始化-wrangler"><a href="#在-hexo-项目下初始化-wrangler" class="headerlink" title="在 hexo 项目下初始化 wrangler"></a>在 hexo 项目下初始化 wrangler</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wrangler init --site my-static-site # 其中 my-static-site 是目录名称</span><br></pre></td></tr></table></figure><p>初始化 wrangler 后，修改 wrangler 配置文件 <code>wrangler.toml</code>，填写 bucket &#x3D; “.&#x2F;public”，<code>bucket</code> 是存放生成好的网站静态文件的目录，对于 Hexo 而言默认是 <code>./public</code> 目录下。如果你想部署别的静态网页，都可以将文件地址放入 <code>./public</code> 文件内</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name</span> = <span class="string">&quot;worker-hexo&quot;</span></span><br><span class="line"><span class="attr">type</span> = <span class="string">&quot;webpack&quot;</span></span><br><span class="line"><span class="attr">route</span> = <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="attr">zone_id</span> = <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="attr">usage_model</span> = <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="attr">compatibility_flags</span> = []</span><br><span class="line"><span class="attr">workers_dev</span> = <span class="literal">true</span></span><br><span class="line"><span class="attr">site</span> = &#123;bucket = <span class="string">&quot;./public&quot;</span>,entry-point = <span class="string">&quot;workers-site&quot;</span>&#125;</span><br><span class="line"><span class="attr">compatibility_date</span> = <span class="string">&quot;2023-11-29&quot;</span></span><br></pre></td></tr></table></figure><h2 id="创建-Cloudflare-API-Token"><a href="#创建-Cloudflare-API-Token" class="headerlink" title="创建 Cloudflare API Token"></a>创建 Cloudflare API Token</h2><p>新建一个 API Token，选择「Edit Cloudflare Workers」模板。并将不需要的两个权限——「Account Settings」和「User’s Details」删去。</p><p><a href="https://dash.cloudflare.com/profile/api-tokens">https://dash.cloudflare.com/profile/api-tokens</a><br>将生成的 API Token 保存好，这串字符之后不会再出现。</p><h2 id="使用-API-Token-登录-Cloudflare-API-Token"><a href="#使用-API-Token-登录-Cloudflare-API-Token" class="headerlink" title="使用 API Token 登录 Cloudflare API Token"></a>使用 API Token 登录 Cloudflare API Token</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wrangler config</span><br><span class="line"># 复制刚刚的Token，回车登录</span><br></pre></td></tr></table></figure><h2 id="部署静态网站至-Cloudflare-Workers-Site"><a href="#部署静态网站至-Cloudflare-Workers-Site" class="headerlink" title="部署静态网站至 Cloudflare Workers Site"></a>部署静态网站至 Cloudflare Workers Site</h2><p>如果前期的所有步骤都没有问题，就可以将 hexo 部署到 Cloudflare Workers Site 上了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 上传并发布 </span><br><span class="line">wrangler publish</span><br></pre></td></tr></table></figure><p>注意，免费版本的 Workers Plan 有每天 100,000 次的访问限制（100,000 requests per day ），免费额度适合小站部署（流量大容易翻车）</p><h2 id="自定义域名"><a href="#自定义域名" class="headerlink" title="自定义域名"></a>自定义域名</h2><p>可在对应的 workers 界面绑定域名</p><h1 id="其他方式"><a href="#其他方式" class="headerlink" title="其他方式"></a>其他方式</h1><ul><li><a href="https://blog.csdn.net/kuizuo12/article/details/124716488">Vercel部署个人博客_愧怍12的博客-CSDN博客</a></li><li><a href="https://juejin.cn/post/7281257305176588343">Vercel部署高级用法教程 - 掘金 (juejin.cn)</a></li><li>但 vercel 似乎无法正确解析带有 + 的 url, 且 Vercel 的 CNAME 值有 CAA 记录，这个 CAA 记录限制了证书颁发机构</li><li><a href="https://zhuanlan.zhihu.com/p/55252024">手把手教你使用Netlify部署博客及部署自动化 - 知乎 (zhihu.com)</a><br>然后在域名提供商那里添加 CNAME 记录如下<br><img src="/../../../img/blog/butterfly%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE-1.png"><br>可用该网站来检测速度 <a href="https://boce.aliyun.com/detect/ping">阿里云网站运维检测平台 (aliyun.com)</a><br>如果该域名本身没有 SSL 证书，但是你将其 CNAME 记录跳转到另一个有 SSL 证书且已经部署的域名，是可以实现 HTTPS 访问的。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 网络 </category>
          
          <category> 博客配置 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>选择配置</title>
      <link href="/posts/%E7%BD%91%E7%BB%9C/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8/%E9%80%89%E6%8B%A9%E9%85%8D%E7%BD%AE.html"/>
      <url>/posts/%E7%BD%91%E7%BB%9C/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8/%E9%80%89%E6%8B%A9%E9%85%8D%E7%BD%AE.html</url>
      
        <content type="html"><![CDATA[<h1 id="云计算的一些基本概念"><a href="#云计算的一些基本概念" class="headerlink" title="云计算的一些基本概念"></a>云计算的一些基本概念</h1><p>每家服务商对云服务器的叫法不同，阿里云叫 ECS，AWS 叫 EC2，Azure 就叫虚拟机，其实都是一种东西。所谓 ECS 或是 EC，指的就是 Elastic Compute Service，说人话就是可以扩展性能的云服务器。有时候我们还会接触到 VPS 这个概念，即 Virtual Private Server 个人虚拟化服务器，按我和 AWS 工作人员的聊天记录，云服务器和 VPS 区别在于 VPS 相当于打包的云服务器，即云服务器 + 硬盘 + 流量&#x3D;VPS。</p><p>相比较云服务器，一般来说 VPS 不支持扩展，但价格相对便宜一点，更合适个人使用。不过对于消费者我们不需要关注这些，我们主要考虑<strong>价格、性能、网络、稳定</strong>四个指标就行。</p><p>目前云计算的服务商可太多了，选择厂商时也不能光图便宜，收钱跑路的事也不是没有。在服务器价格堪比白菜的今天，还是尽可能选择大厂的产品好一点。选择云服务器的时候，要看看对方提供给你的机器性能，除了指标之外你需要考虑下这些 ECS&#x2F;VPS 是用了什么样的虚拟化技术，常见的有：</p><ul><li>KVM 和 Xen：支持各种操作系统，包括 Linux、Windows 等。</li><li>OpenVZ：仅支持 Linux，因为它依赖于宿主机的内核。</li></ul><p>一般来说，首选 KVM 和 Xen，尽量不选 OpenVZ 的机器，因为 OpenVZ 是容器化的虚拟机服务，出现<strong>超卖</strong>(即把一份资源同时卖给多个人) 的情况是不可避免的，这样用户的体验好的了吗？</p><p>另一方面我前面说了，服务器买的就是机器 + 网络。买云服务考虑的另一个大头就是网络，看你主要要拿机器做什么，如果都是国内业务，机器一定要离你越近越好，要不然你往机器上传下载东西能卡到你怀疑人生，当然也有的人不需要传东西，在哪就无所谓了。要走国外的流量，还需要研究线路的选择，这个事情比较复杂，我们在这里简单引用下网上的结论：</p><blockquote><p>线路排名一般情况下 CN2 GIA &gt; AS9929 &gt; AS4837 &gt; CN2 GT，具体也要看本地网络。</p></blockquote><p>最后就是带宽问题，根据你的需要考虑是按固定带宽合适，还是按流量计费合适，这都涉及到个人业务类型的不同，选择合适又省钱的方案即可。<br><strong>实战：以阿里云为例</strong></p><p>首先，阿里云支持所有个人用户免费试用 3 个月云 ECS，任何个人用户都可申请，详见：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://free.aliyun.com/?spm=5176.28508143.J_4VYgf18xNlTAyFFbOuOQe.13.e939154affazg3&amp;scm=20140722.M_10076474._.V_1</span><br></pre></td></tr></table></figure><p>个人免费试用结束后，在校生还可以进行学生身份认证，继续试用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://developer.aliyun.com/plan/student?spm=5176.28261954.J_7341193060.2.563a2fde1D6yBR&amp;scm=20140722.S_card@@%E5%85%B6%E4%BB%96@@2796646.S_card0.ID_card@@%E5%85%B6%E4%BB%96@@2796646-RL_%E9%AB%98%E6%A0%A1%E8%AE%A1%E5%88%92-LOC_search~UND~card~UND~item-OR_ser-V_3-P0_0</span><br></pre></td></tr></table></figure><p>这样个人版免费试用 3 个月 + 完成学生认证 1 个月 + 完成 ECS 实验认证 6 个月，共免费 10 个月，高校学生通用权益面向所有中国高校学生开放，具体包括中国大陆及港澳台地区专科、本科、硕士、博士、在职研究生等在校学生。</p><p>完成学生认证还能获得 300 无门槛优惠券，一年内有效。如果要是阿里云的合作院校 (包括清华大学、北京大学、浙江大学、上海交通大学、中国科学技术大学、华南理工大学和香港科技大学) 还能拿到 3 折优惠。</p>]]></content>
      
      
      <categories>
          
          <category> 网络 </category>
          
          <category> 云服务器 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>快捷键</title>
      <link href="/posts/%E5%BD%92%E6%A1%A3/%E5%BF%AB%E6%8D%B7%E9%94%AE.html"/>
      <url>/posts/%E5%BD%92%E6%A1%A3/%E5%BF%AB%E6%8D%B7%E9%94%AE.html</url>
      
        <content type="html"><![CDATA[<h1 id="windows-快捷键"><a href="#windows-快捷键" class="headerlink" title="windows 快捷键"></a>windows 快捷键</h1><p><a href="https://www.bilibili.com/read/cv28139330/">来源</a></p><ul><li>快速显示桌面 Win+D 键</li></ul><blockquote><p>只要按下 Windows+D 键，所有的窗口都会缩小，桌面就出现了。如果你想再看看刚才的窗口，再单击 Windows+D 键就行。</p></blockquote><ul><li>开启文件管理器 Win+E 键</li><li>快速锁定计算机 Win+L 键</li><li>开启 Emoji 图标 Win+.键</li><li>打开剪切板 Win+V 键</li><li>开启 Windows 设置 Win+I 键</li><li>快速打开投影选项 Win+P 键</li><li>打开 Windows 运行 Win+R 键</li><li>打开系统搜索 Win+S 键</li><li>打开电脑常用管理工具 Win+X 键</li></ul><blockquote><p>按快捷键 Windows+X 键，可以打开 Windows 系统常用管理工具集合，每个工具名称选项后面都有一个字母，当按 Win+X 键后，再按对应的工具名称代替字母，就可以打开该工具界面。</p></blockquote><ul><li>桌面展示多任务窗口 Win+Tab 键</li><li>快速截图，Windows+Shift+S</li><li>打开小组件，Win+W 键</li></ul>]]></content>
      
      
      <categories>
          
          <category> 归档 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>dot语言</title>
      <link href="/posts/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/dot%E8%AF%AD%E8%A8%80.html"/>
      <url>/posts/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/dot%E8%AF%AD%E8%A8%80.html</url>
      
        <content type="html"><![CDATA[<h1 id="UML-绘制-dot-语言"><a href="#UML-绘制-dot-语言" class="headerlink" title="UML 绘制 -dot 语言"></a>UML 绘制 -dot 语言</h1><h2 id="DOT-语言基础"><a href="#DOT-语言基础" class="headerlink" title="DOT 语言基础"></a>DOT 语言基础</h2><h3 id="基本的-DOT-文件"><a href="#基本的-DOT-文件" class="headerlink" title="基本的 DOT 文件"></a>基本的 DOT 文件</h3><p>demo01.dot</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">digraph demo&#123;</span><br><span class="line">    A-&gt;B[dir<span class="operator">=</span>both]<span class="comment">;</span></span><br><span class="line">    B-&gt;C[dir<span class="operator">=</span>none]<span class="comment">;</span></span><br><span class="line">    C-&gt;D[dir<span class="operator">=</span>back]<span class="comment">;</span></span><br><span class="line">    D-&gt;A[dir<span class="operator">=</span>forward]<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="从-DOT-文件生成图像"><a href="#从-DOT-文件生成图像" class="headerlink" title="从 DOT 文件生成图像"></a>从 DOT 文件生成图像</h3><p><code>dot demo01.dot –Tpng –o demo01.png</code></p><p><img src="/../../img/blog/74874464eb38dc31e7f31a7b7d592c80_MD5.png" alt="渲染结果" title="渲染结果"></p><h2 id="PlantUML"><a href="#PlantUML" class="headerlink" title="PlantUML"></a>PlantUML</h2><p>PlantUML 是基于 Graphviz 的一个开源项目，并支持快速绘制：</p><ul><li>时序图</li><li>用例图</li><li>类图</li><li>活动图 (here is the new syntax),</li><li>组件图</li><li>状态图</li><li>Deployment diagram,</li><li>对象图</li><li>wireframe graphical interface</li></ul><p>可以生成 png,svg,Latex 格式的图片，可以作为插件使用：</p><ul><li>Intellij idea</li><li>Eclipse</li><li>NetBeans</li><li>Ckeditor</li><li>TinyMCE Editor</li><li>Sublime Text Editor</li><li>Vim</li><li>Emacs</li><li>Atom</li><li>….</li></ul><p>下面说一下 Sublime Text 安装 PlantUML 的过程：</p><ul><li>下载 PlantUML for Sublime 插件，并解压</li><li>通过 Preferences -&gt; Browse Packages … 打开 sublime 的 Packages 目录，解压后的插件放在 Packages 目录下</li><li>重启 Sublime</li><li>为了简化使用，可以在 Sublime 里配置个快捷键。打开 Preferences -&gt; Key Binding - User，添加一个快捷键：<br>  { “keys”: [“alt+d”], “command”: “display_diagrams”}</li></ul><p>上面的代码配置成按住 Alt + d 来生成 PlantUML 图片，你可以修改成你自己喜欢的按键。</p><p>参考自使用 Sublime + PlantUML 高效地画图</p><h2 id="画状态图"><a href="#画状态图" class="headerlink" title="画状态图"></a>画状态图</h2><blockquote><p>我这里以状态图为例，如果你需要画其他图，到 PlantUML 查看</p></blockquote><h3 id="简单状态图"><a href="#简单状态图" class="headerlink" title="简单状态图"></a>简单状态图</h3><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@startuml</span></span><br><span class="line"></span><br><span class="line">[*] --&gt; State1</span><br><span class="line">State1 --&gt; [*]</span><br><span class="line"><span class="attribute">State1 </span>: this is a string</span><br><span class="line"><span class="attribute">State1 </span>: this is another string</span><br><span class="line"></span><br><span class="line">State1 -&gt; State2</span><br><span class="line">State2 --&gt; [*]</span><br><span class="line"></span><br><span class="line"><span class="variable">@enduml</span></span><br></pre></td></tr></table></figure><p>快捷键 <code>alt+d</code></p><p><img src="/../../img/blog/14dfa837bb59e55fd868092f1f8ee21f_MD5.png" alt="简单状态图" title="简单状态图"></p><h3 id="合成状态"><a href="#合成状态" class="headerlink" title="合成状态"></a>合成状态</h3><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">@startuml</span><br><span class="line">scale <span class="number">350</span> width</span><br><span class="line">[*] --&gt; NotShooting</span><br><span class="line"></span><br><span class="line"><span class="keyword">state</span> NotShooting &#123;</span><br><span class="line">  [*] --&gt; Idle</span><br><span class="line">  Idle --&gt; Configuring : EvConfig</span><br><span class="line">  Configuring --&gt; Idle : EvConfig</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">state</span> Configuring &#123;</span><br><span class="line">  [*] --&gt; NewValueSelection</span><br><span class="line">  NewValueSelection --&gt; NewValuePreview : EvNewValue</span><br><span class="line">  NewValuePreview --&gt; NewValueSelection : EvNewValueRejected</span><br><span class="line">  NewValuePreview --&gt; NewValueSelection : EvNewValueSaved</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">state</span> NewValuePreview &#123;</span><br><span class="line">     State1 -&gt; State2</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure><ul><li>scale 350 width,指定图的宽度为 350，等比例缩放</li></ul><p><img src="/../../img/blog/8889e96d393176baca71128ae43a3f8c_MD5.png" alt="合成状态图" title="合成状态图"></p><h2 id="长名字"><a href="#长名字" class="headerlink" title="长名字"></a>长名字</h2><p>如果状态的名称过长，使用 state 关键字</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">@startuml</span><br><span class="line">scale <span class="number">600</span> width</span><br><span class="line"></span><br><span class="line">[*] -&gt; State1</span><br><span class="line">S<span class="function"><span class="title">tate1</span> --&gt;</span> State2 : Succeeded</span><br><span class="line">S<span class="function"><span class="title">tate1</span> --&gt;</span> [*] : Aborted</span><br><span class="line">S<span class="function"><span class="title">tate2</span> --&gt;</span> State3 : Succeeded</span><br><span class="line">S<span class="function"><span class="title">tate2</span> --&gt;</span> [*] : Aborted</span><br><span class="line">state State3 &#123;</span><br><span class="line">  state <span class="string">&quot;Accumulate Enough Data\nLong State Name&quot;</span> <span class="keyword">as</span> long1</span><br><span class="line">  long1 : Just a test</span><br><span class="line">  [*] --&gt; long1</span><br><span class="line">  <span class="function"><span class="title">long1</span> --&gt;</span> long1 : New Data</span><br><span class="line">  <span class="function"><span class="title">long1</span> --&gt;</span> ProcessData : Enough Data</span><br><span class="line">&#125;</span><br><span class="line">S<span class="function"><span class="title">tate3</span> --&gt;</span> State3 : Failed</span><br><span class="line">S<span class="function"><span class="title">tate3</span> --&gt;</span> [*] : Succeeded / Save Result</span><br><span class="line">S<span class="function"><span class="title">tate3</span> --&gt;</span> [*] : Aborted</span><br><span class="line"> </span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure><p><img src="/../../img/blog/57d3a5dd32692daa220db432b336e265_MD5.png" alt="长名字" title="长名字"></p><h2 id="并发状态"><a href="#并发状态" class="headerlink" title="并发状态"></a>并发状态</h2><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@startuml</span></span><br><span class="line">[*] --&gt; Active</span><br><span class="line"></span><br><span class="line">state Active &#123;</span><br><span class="line">  <span class="selector-attr">[*]</span> <span class="selector-tag">-</span>&gt; <span class="selector-tag">NumLockOff</span></span><br><span class="line">  <span class="selector-tag">NumLockOff</span> <span class="selector-tag">--</span>&gt; <span class="selector-tag">NumLockOn</span> : <span class="selector-tag">EvNumLockPressed</span></span><br><span class="line">  <span class="selector-tag">NumLockOn</span> <span class="selector-tag">--</span>&gt; <span class="selector-tag">NumLockOff</span> : <span class="selector-tag">EvNumLockPressed</span></span><br><span class="line">  <span class="selector-tag">--</span></span><br><span class="line">  <span class="selector-attr">[*]</span> <span class="selector-tag">-</span>&gt; <span class="selector-tag">CapsLockOff</span></span><br><span class="line">  <span class="selector-tag">CapsLockOff</span> <span class="selector-tag">--</span>&gt; <span class="selector-tag">CapsLockOn</span> : <span class="selector-tag">EvCapsLockPressed</span></span><br><span class="line">  <span class="selector-tag">CapsLockOn</span> <span class="selector-tag">--</span>&gt; <span class="selector-tag">CapsLockOff</span> : <span class="selector-tag">EvCapsLockPressed</span></span><br><span class="line">  <span class="selector-tag">--</span></span><br><span class="line">  <span class="selector-attr">[*]</span> <span class="selector-tag">-</span>&gt; <span class="selector-tag">ScrollLockOff</span></span><br><span class="line">  <span class="selector-tag">ScrollLockOff</span> <span class="selector-tag">--</span>&gt; <span class="selector-tag">ScrollLockOn</span> : <span class="selector-tag">EvCapsLockPressed</span></span><br><span class="line">  <span class="selector-tag">ScrollLockOn</span> <span class="selector-tag">--</span>&gt; <span class="selector-tag">ScrollLockOff</span> : <span class="selector-tag">EvCapsLockPressed</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">@enduml</span></span><br></pre></td></tr></table></figure><ul><li>用 – 作为分隔符来合成并发状态。</li></ul><p><img src="/../../img/blog/caefc3b72183028882bff59b4e6c746f_MD5.png" alt="并发状态" title="并发状态"></p><h2 id="箭头方向"><a href="#箭头方向" class="headerlink" title="箭头方向"></a>箭头方向</h2><ul><li>使用 -&gt;定义水平箭头，也可以使用下列格式强制设置箭头方向：<br>1)-down-&gt; (default arrow)<br>2)-right-&gt; or -&gt;<br>3)-left-&gt;<br>4)-up-&gt;</li></ul><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@startuml</span></span><br><span class="line">[*] -up-&gt; First</span><br><span class="line">First -&gt; Second</span><br><span class="line">Second --&gt; Third</span><br><span class="line">Third --&gt; Fourth</span><br><span class="line">Fourth -left-&gt; Last</span><br><span class="line"><span class="variable">@enduml</span></span><br></pre></td></tr></table></figure><p><img src="/../../img/blog/73cca000c91a0ff919c227bd1fe40b37_MD5.png" alt="箭头方向" title="箭头方向"></p><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>关键字：</p><ul><li>note left of</li><li>note right of</li><li>note top of</li><li>note bottom of</li></ul><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@startuml</span></span><br><span class="line"></span><br><span class="line">[*] --&gt; Active</span><br><span class="line">Active --&gt; Inactive</span><br><span class="line"></span><br><span class="line">note left of <span class="attribute">Active </span>: this is a short\nnote</span><br><span class="line"></span><br><span class="line">note right of Inactive</span><br><span class="line">  A note can also</span><br><span class="line">  be defined on</span><br><span class="line">  several lines</span><br><span class="line">end note</span><br><span class="line"></span><br><span class="line"><span class="variable">@enduml</span></span><br></pre></td></tr></table></figure><p><img src="/../../img/blog/70c94bcabe4036a70541501974ccd747_MD5.png"></p><ul><li>浮动注释</li></ul><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@startuml</span></span><br><span class="line"></span><br><span class="line">state foo</span><br><span class="line">note <span class="string">&quot;This is a floating note&quot;</span> as N1</span><br><span class="line"></span><br><span class="line"><span class="variable">@enduml</span></span><br></pre></td></tr></table></figure><p><img src="/../../img/blog/13f5a6ff290b369a2105fb5c2956c6db_MD5.png"></p><ul><li>合成状态的注释</li></ul><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@startuml</span><br><span class="line"></span><br><span class="line">[*] --&gt; NotShooting</span><br><span class="line"></span><br><span class="line"><span class="keyword">state</span> <span class="string">&quot;Not Shooting State&quot;</span> as NotShooting &#123;</span><br><span class="line">  <span class="keyword">state</span> <span class="string">&quot;Idle mode&quot;</span> as Idle</span><br><span class="line">  <span class="keyword">state</span> <span class="string">&quot;Configuring mode&quot;</span> as Configuring</span><br><span class="line">  [*] --&gt; Idle</span><br><span class="line">  Idle --&gt; Configuring : EvConfig</span><br><span class="line">  Configuring --&gt; Idle : EvConfig</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">note right of NotShooting : This is a note <span class="keyword">on</span> a composite <span class="keyword">state</span></span><br><span class="line"></span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure><p><img src="/../../img/blog/5f2c463f9e29caf59e32adbeaaaa326d_MD5.png"></p><h2 id="主题修改"><a href="#主题修改" class="headerlink" title="主题修改"></a>主题修改</h2><ul><li>使用 skinparam 命令改变字体和颜色。</li></ul><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">@startuml</span><br><span class="line">skinparam backgroundColor LightYellow</span><br><span class="line">skinparam state &#123;</span><br><span class="line">  StartColor MediumBlue</span><br><span class="line">  EndColor Red</span><br><span class="line">  BackgroundColor #e0f</span><br><span class="line">  BackgroundColor<span class="symbol">&lt;&lt;Warning&gt;&gt;</span> #aaa</span><br><span class="line">  FontColor<span class="symbol">&lt;&lt;Warning&gt;&gt;</span> Orange</span><br><span class="line">  BorderColor Orange</span><br><span class="line">  FontName Monaco</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[*] <span class="comment">--&gt; NotShooting</span></span><br><span class="line"></span><br><span class="line">state &quot;Not Shooting State&quot; <span class="keyword">as</span> NotShooting &#123;</span><br><span class="line">  state &quot;Idle mode&quot; <span class="keyword">as</span> Idle <span class="symbol">&lt;&lt;Warning&gt;&gt;</span></span><br><span class="line">  state &quot;Configuring mode&quot; <span class="keyword">as</span> Configuring</span><br><span class="line">  [*] <span class="comment">--&gt; Idle</span></span><br><span class="line">  Idle <span class="comment">--&gt; Configuring : EvConfig</span></span><br><span class="line">  Configuring <span class="comment">--&gt; Idle : EvConfig</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">NotShooting <span class="comment">--&gt; [*]</span></span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure><p><img src="/../../img/blog/081500d0764e88c7966714f64c229846_MD5.png"></p><p>有一个网站，可以实时预览 <a href="https://www.planttext.com/">PlantText UML Editor</a></p><h1 id="使用-graphviz-绘图"><a href="#使用-graphviz-绘图" class="headerlink" title="使用 graphviz 绘图"></a>使用 graphviz 绘图</h1><h2 id="Graphviz-简介"><a href="#Graphviz-简介" class="headerlink" title="Graphviz 简介"></a>Graphviz 简介</h2><p>本文介绍一个高效而简洁的绘图工具 <code>graphviz</code>。<code>graphviz</code> 是贝尔实验室开发的一个开源的工具包，它使用一个特定的 <code>DSL</code> (领域特定语言): <code>dot</code> 作为脚本语言，然后使用布局引擎来解析此脚本，并完成自动布局。<code>graphviz</code> 提供丰富的导出格式，如常用的图片格式，SVG，PDF 格式等。<br><code>graphviz</code> 中包含了众多的布局器：</p><ul><li><code>dot</code> 默认布局方式，主要用于有向图</li><li><code>neato</code> 基于 spring-model (又称 force-based) 算法</li><li><code>twopi</code> 径向布局</li><li><code>circo</code> 圆环布局</li><li><code>fdp</code> 用于无向图</li></ul><p><code>graphviz</code> 的设计初衷是对 <code>有向图/无向图</code> 等进行自动布局，开发人员使用 dot 脚本定义图形元素，然后选择算法进行布局，最终导出结果。<br>首先，在 dot 脚本中定义图的顶点和边，顶点和边都具有各自的属性，比如形状，颜色，填充模式，字体，样式等。然后使用合适的布局算法进行布局。布局算法除了绘制各个顶点和边之外，需要尽可能的将顶点均匀的分布在画布上，并且尽可能的减少边的交叉 (如果交叉过多，就很难看清楚顶点之间的关系了)。所以使用 <code>graphviz</code> 的一般流程为：</p><ul><li>定义一个图，并向图中添加需要的顶点和边</li><li>为顶点和边添加样式</li><li>使用布局引擎进行绘制</li></ul><p>一旦熟悉这种开发模式，就可以快速的将你的想法绘制出来。配合一个良好的编辑器 (vim&#x2F;emacs) 等，可以极大的提高开发效率，与常见的 GUI 应用的所见即所得模式对应，此模式称为所思即所得。比如在我的机器上，使用 Sublime Text 编辑 <code>dot</code> 脚本，然后将 <code>F7/Cmd-B</code> 映射为调用 <code>dot引擎</code> 去绘制当前脚本，并打开一个新的窗口来显示运行结果：<br><img src="/../../img/blog/7ad541744727621ce1e239645f0b0789_MD5.png"><br>对于开发人员而言，经常会用到的图形绘制可能包括：函数调用关系，一个复杂的数据结构，系统的模块组成，抽象语法树等。</p><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><p>graphviz 包含 3 中元素，<code>图</code>，<code>顶点</code> 和 <code>边</code>。每个元素都可以具有各自的属性，用来定义字体，样式，颜色，形状等。下面是一些简单的示例，可以帮助我们快速的了解 graphviz 的基本用法。</p><h3 id="第一个-Graphviz-图"><a href="#第一个-Graphviz-图" class="headerlink" title="第一个 Graphviz 图"></a>第一个 Graphviz 图</h3><p>比如，要绘制一个有向图，包含 4 个节点 <code>a,b,c,d</code>。其中 <code>a</code> 指向 <code>b</code>，<code>b</code> 和 <code>c</code> 指向 <code>d</code>。可以定义下列脚本：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">digraph abc&#123;</span><br><span class="line">a;</span><br><span class="line">b;</span><br><span class="line">c;</span><br><span class="line">d;</span><br><span class="line"> </span><br><span class="line">a -&gt; b;</span><br><span class="line">b -&gt; d;</span><br><span class="line">c -&gt; d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 <code>dot</code> 布局方式，绘制出来的效果如下：<br><img src="/../../img/blog/b99b503eb30fd8f4f804167926fd2b0d_MD5.gif"><br>默认的顶点中的文字为定义顶点变量的名称，形状为椭圆。边的默认样式为黑色实线箭头，我们可以在脚本中做一下修改，将顶点改为 <code>方形</code>，边改为 <code>虚线</code>。</p><h3 id="定义顶点和边的样式"><a href="#定义顶点和边的样式" class="headerlink" title="定义顶点和边的样式"></a>定义顶点和边的样式</h3><p>在 <code>digraph</code> 的花括号内，添加顶点和边的新定义：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">node [shape=&quot;record&quot;];</span><br><span class="line">edge [style=&quot;dashed&quot;];</span><br></pre></td></tr></table></figure><p>则绘制的效果如下：<br><img src="/../../img/blog/4e52eacca5026225fd829601d6f697fb_MD5.gif"></p><h3 id="进一步修改顶点和边样式"><a href="#进一步修改顶点和边样式" class="headerlink" title="进一步修改顶点和边样式"></a>进一步修改顶点和边样式</h3><p>进一步，我们将顶点 <code>a</code> 的颜色改为 <code>淡绿色</code>，并将 <code>c</code> 到 <code>d</code> 的边改为 <code>红色</code>，脚本如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">digraph abc&#123;</span><br><span class="line">node [shape=&quot;record&quot;];</span><br><span class="line">edge [style=&quot;dashed&quot;];</span><br><span class="line"> </span><br><span class="line">a [style=&quot;filled&quot;, color=&quot;black&quot;, fillcolor=&quot;chartreuse&quot;];</span><br><span class="line">b;</span><br><span class="line">c;</span><br><span class="line">d;</span><br><span class="line"> </span><br><span class="line">a -&gt; b;</span><br><span class="line">b -&gt; d;</span><br><span class="line">c -&gt; d [color=&quot;red&quot;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>绘制的结果如下：<br><img src="/../../img/blog/771137c47d5a0770518f7162af0ae504_MD5.gif"><br>应当注意到，顶点和边都接受属性的定义，形式为在顶点和边的定义之后加上一个由方括号括起来的 <code>key-value</code> 列表，每个 <code>key-value</code> 对由逗号隔开。如果图中顶点和边采用统一的风格，则可以在图定义的首部定义 <code>node</code>, <code>edge</code> 的属性。比如上图中，定义所有的顶点为方框，所有的边为虚线，在具体的顶点和边之后定义的属性将覆盖此全局属性。如特定与 <code>a</code> 的绿色，<code>c</code> 到 <code>d</code> 的边的红色。</p><h3 id="以图片为节点"><a href="#以图片为节点" class="headerlink" title="以图片为节点"></a>以图片为节点</h3><p>除了颜色，节点还可以使用图片。不过需要注意的是，在使用图片作为节点的时候，需要将本来的形状设置为 <code>none</code>，并且将 <code>label</code> 置为空字符串，避免出现文字对图片的干扰。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">digraph abc&#123;</span><br><span class="line">node [shape=&quot;record&quot;];</span><br><span class="line">edge [style=&quot;dashed&quot;];</span><br><span class="line"> </span><br><span class="line">a [style=&quot;filled&quot;, color=&quot;black&quot;, fillcolor=&quot;chartreuse&quot;];</span><br><span class="line">b;</span><br><span class="line">c [shape=&quot;none&quot;, image=&quot;logos/browser-icon-chrome-resized.png&quot;, label=&quot;&quot;];</span><br><span class="line">d;</span><br><span class="line"> </span><br><span class="line">a -&gt; b;</span><br><span class="line">b -&gt; d;</span><br><span class="line">c -&gt; d [color=&quot;red&quot;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/../../img/blog/e673f5edaf4987f14a187fc08892d72d_MD5.png"></p><h2 id="子图的绘制"><a href="#子图的绘制" class="headerlink" title="子图的绘制"></a>子图的绘制</h2><p>graphviz 支持子图，即图中的部分节点和边相对对立 (软件的模块划分经常如此)。比如，我们可以将顶点 c 和 d 归为一个子图：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">digraph abc&#123;</span><br><span class="line">node [shape=&quot;record&quot;];</span><br><span class="line">edge [style=&quot;dashed&quot;];</span><br><span class="line"> </span><br><span class="line">a [style=&quot;filled&quot;, color=&quot;black&quot;, fillcolor=&quot;chartreuse&quot;];</span><br><span class="line">b;</span><br><span class="line"> </span><br><span class="line">    subgraph cluster_cd&#123;</span><br><span class="line">    label=&quot;c and d&quot;;</span><br><span class="line">    bgcolor=&quot;mintcream&quot;;</span><br><span class="line">    c;</span><br><span class="line">    d;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">a -&gt; b;</span><br><span class="line">b -&gt; d;</span><br><span class="line">c -&gt; d [color=&quot;red&quot;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将 <code>c</code> 和 <code>d</code> 划分到 <code>cluster_cd</code> 这个子图中，标签为 <code>c and d</code>, 并添加背景色，以方便与主图区分开，绘制结果如下：<br><img src="/../../img/blog/fe829a415f4567d8294e30b6d54ec7ba_MD5.gif"><br>应该注意的是，子图的名称必须以 <code>cluster</code> 开头，否则 <code>graphviz</code> 无法设别。</p><h3 id="数据结构的可视化"><a href="#数据结构的可视化" class="headerlink" title="数据结构的可视化"></a>数据结构的可视化</h3><p>实际开发中，经常要用到的是对复杂数据结构的描述，<code>graphviz</code> 提供完善的机制来绘制此类图形。</p><h4 id="一个-Hash-表的数据结构"><a href="#一个-Hash-表的数据结构" class="headerlink" title="一个 Hash 表的数据结构"></a>一个 Hash 表的数据结构</h4><p>比如一个 hash 表的内容，可能具有下列结构：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">st_hash_type</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> (*compare) ();</span><br><span class="line">    <span class="type">int</span> (*hash) ();</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">st_table_entry</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> hash;</span><br><span class="line">    <span class="type">char</span> *key;</span><br><span class="line">    <span class="type">char</span> *record;</span><br><span class="line">    st_table_entry *next;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">st_table</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">st_hash_type</span> *<span class="title">type</span>;</span></span><br><span class="line">    <span class="type">int</span> num_bins; <span class="comment">/* slot count */</span></span><br><span class="line">    <span class="type">int</span> num_entries; <span class="comment">/* total number of entries */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">st_table_entry</span> **<span class="title">bins</span>;</span> <span class="comment">/* slot */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="绘制-Hash-表的数据结构"><a href="#绘制-Hash-表的数据结构" class="headerlink" title="绘制 Hash 表的数据结构"></a>绘制 Hash 表的数据结构</h4><p>从代码上看，由于结构体存在引用关系，不够清晰，如果层次较多，则很难以记住各个结构之间的关系，我们可以通过下图来更清楚的展示：<br><img src="/../../img/blog/12a33ca70cb0bcf5621219fe4cec1a0a_MD5.gif"><br>脚本如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">digraph st2&#123;</span><br><span class="line">fontname = &quot;Verdana&quot;;</span><br><span class="line">fontsize = 10;</span><br><span class="line">rankdir=TB;</span><br><span class="line"> </span><br><span class="line">node [fontname = &quot;Verdana&quot;, fontsize = 10, color=&quot;skyblue&quot;, shape=&quot;record&quot;];</span><br><span class="line"> </span><br><span class="line">edge [fontname = &quot;Verdana&quot;, fontsize = 10, color=&quot;crimson&quot;, style=&quot;solid&quot;];</span><br><span class="line"> </span><br><span class="line">st_hash_type [label=&quot;&#123;&lt;head&gt;st_hash_type|(*compare)|(*hash)&#125;&quot;];</span><br><span class="line">st_table_entry [label=&quot;&#123;&lt;head&gt;st_table_entry|hash|key|record|&lt;next&gt;next&#125;&quot;];</span><br><span class="line">st_table [label=&quot;&#123;st_table|&lt;type&gt;type|num_bins|num_entries|&lt;bins&gt;bins&#125;&quot;];</span><br><span class="line"> </span><br><span class="line">st_table:bins -&gt; st_table_entry:head;</span><br><span class="line">st_table:type -&gt; st_hash_type:head;</span><br><span class="line">st_table_entry:next -&gt; st_table_entry:head [style=&quot;dashed&quot;, color=&quot;forestgreen&quot;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>应该注意到，在顶点的形状为 <code>record</code> 的时候，<code>label</code> 属性的语法比较奇怪，但是使用起来非常灵活。比如，用竖线 “|” 隔开的串会在绘制出来的节点中展现为一条分隔符。用 <code>&lt;&gt;</code> 括起来的串称为锚点，当一个节点具有多个锚点的时候，这个特性会非常有用，比如节点 <code>st_table</code> 的 <code>type</code> 属性指向 <code>st_hash_type</code>，第 4 个属性指向 <code>st_table_entry</code> 等，都是通过锚点来实现的。<br>我们发现，使用默认的 <code>dot</code> 布局后，绿色的这条边覆盖了数据结构 <code>st_table_entry</code>，并不美观，因此可以使用别的布局方式来重新布局，如使用 <code>circo</code> 算法：<br><img src="/../../img/blog/e3cb870ad854cb6d856c765d6b256ca0_MD5.gif"><br>则可以得到更加合理的布局结果。</p><h3 id="Hash-表的实例"><a href="#Hash-表的实例" class="headerlink" title="Hash 表的实例"></a>Hash 表的实例</h3><p>另外，这个 hash 表的一个实例如下：<br><img src="/../../img/blog/3809051b78163ea25b528cdf8d5026e3_MD5.gif"><br>脚本如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">digraph st&#123;</span><br><span class="line">fontname = &quot;Verdana&quot;;</span><br><span class="line">fontsize = 10;</span><br><span class="line">rankdir = LR;</span><br><span class="line">rotate = 90;</span><br><span class="line"> </span><br><span class="line">node [ shape=&quot;record&quot;, width=.1, height=.1];</span><br><span class="line">node [fontname = &quot;Verdana&quot;, fontsize = 10, color=&quot;skyblue&quot;, shape=&quot;record&quot;];</span><br><span class="line"> </span><br><span class="line">edge [fontname = &quot;Verdana&quot;, fontsize = 10, color=&quot;crimson&quot;, style=&quot;solid&quot;];</span><br><span class="line">node [shape=&quot;plaintext&quot;];</span><br><span class="line"> </span><br><span class="line">st_table [label=&lt;</span><br><span class="line">    &lt;table border=&quot;0&quot; cellborder=&quot;1&quot; cellspacing=&quot;0&quot; align=&quot;left&quot;&gt;</span><br><span class="line">    &lt;tr&gt;</span><br><span class="line">    &lt;td&gt;st_table&lt;/td&gt;</span><br><span class="line">    &lt;/tr&gt;</span><br><span class="line">    &lt;tr&gt;</span><br><span class="line">    &lt;td&gt;num_bins=5&lt;/td&gt;</span><br><span class="line">    &lt;/tr&gt;</span><br><span class="line">    &lt;tr&gt;</span><br><span class="line">    &lt;td&gt;num_entries=3&lt;/td&gt;</span><br><span class="line">    &lt;/tr&gt;</span><br><span class="line">    &lt;tr&gt;</span><br><span class="line">    &lt;td port=&quot;bins&quot;&gt;bins&lt;/td&gt;</span><br><span class="line">    &lt;/tr&gt;</span><br><span class="line">    &lt;/table&gt;</span><br><span class="line">&gt;];</span><br><span class="line"> </span><br><span class="line">node [shape=&quot;record&quot;];</span><br><span class="line">num_bins [label=&quot; &lt;b1&gt; | &lt;b2&gt; | &lt;b3&gt; | &lt;b4&gt; | &lt;b5&gt; &quot;, height=2];</span><br><span class="line">node[ width=2 ];</span><br><span class="line"> </span><br><span class="line">entry_1 [label=&quot;&#123;&lt;e&gt;st_table_entry|&lt;next&gt;next&#125;&quot;];</span><br><span class="line">entry_2 [label=&quot;&#123;&lt;e&gt;st_table_entry|&lt;next&gt;null&#125;&quot;];</span><br><span class="line">entry_3 [label=&quot;&#123;&lt;e&gt;st_table_entry|&lt;next&gt;null&#125;&quot;];</span><br><span class="line"> </span><br><span class="line">st_table:bins -&gt; num_bins:b1;</span><br><span class="line">num_bins:b1 -&gt; entry_1:e;</span><br><span class="line">entry_1:next -&gt; entry_2:e;</span><br><span class="line">num_bins:b3 -&gt; entry_3:e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上例中可以看到，节点的 <code>label</code> 属性支持类似于 <code>HTML</code> 语言中的 TABLE 形式的定义，通过行列的数目来定义节点的形状，从而使得节点的组成更加灵活。</p><h3 id="软件模块组成图"><a href="#软件模块组成图" class="headerlink" title="软件模块组成图"></a>软件模块组成图</h3><p>Apache httpd 模块关系<br><img src="/../../img/blog/2befb398276e7bdfba84ff65de32a786_MD5.gif"><br>在实际的开发中，随着系统功能的完善，软件整体的结构会越来越复杂，通常开发人员会将软件划分为可理解的多个子模块，各个子模块通过协作，完成各种各样的需求。<br>下面有个例子，是某软件设计时的一个草稿：<br><img src="/../../img/blog/9f04472ca0960627d840020534ab1397_MD5.gif"><br>IDP 支持层为一个相对独立的子系统，其中包括如数据库管理器，配置信息管理器等模块，另外为了提供更大的灵活性，将很多其他的模块抽取出来作为外部模块，而支持层提供一个模块管理器，来负责加载&#x2F;卸载这些外部的模块集合。<br>这些模块间的关系较为复杂，并且有部分模块关系密切，应归类为一个子系统中，上图对应的 <code>dot</code> 脚本为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">digraph idp_modules&#123;</span><br><span class="line"> </span><br><span class="line">rankdir = TB;</span><br><span class="line">fontname = &quot;Microsoft YaHei&quot;;</span><br><span class="line">fontsize = 12;</span><br><span class="line"> </span><br><span class="line">node [ fontname = &quot;Microsoft YaHei&quot;, fontsize = 12, shape = &quot;record&quot; ]; </span><br><span class="line">edge [ fontname = &quot;Microsoft YaHei&quot;, fontsize = 12 ];</span><br><span class="line"> </span><br><span class="line">    subgraph cluster_sl&#123;</span><br><span class="line">        label=&quot;IDP支持层&quot;;</span><br><span class="line">        bgcolor=&quot;mintcream&quot;;</span><br><span class="line">        node [shape=&quot;Mrecord&quot;, color=&quot;skyblue&quot;, style=&quot;filled&quot;];</span><br><span class="line">        network_mgr [label=&quot;网络管理器&quot;];</span><br><span class="line">        log_mgr [label=&quot;日志管理器&quot;];</span><br><span class="line">        module_mgr [label=&quot;模块管理器&quot;];</span><br><span class="line">        conf_mgr [label=&quot;配置管理器&quot;];</span><br><span class="line">        db_mgr [label=&quot;数据库管理器&quot;];</span><br><span class="line">    &#125;;</span><br><span class="line"> </span><br><span class="line">    subgraph cluster_md&#123;</span><br><span class="line">        label=&quot;可插拔模块集&quot;;</span><br><span class="line">        bgcolor=&quot;lightcyan&quot;;</span><br><span class="line">        node [color=&quot;chartreuse2&quot;, style=&quot;filled&quot;];</span><br><span class="line">        mod_dev [label=&quot;开发支持模块&quot;];</span><br><span class="line">        mod_dm [label=&quot;数据建模模块&quot;];</span><br><span class="line">        mod_dp [label=&quot;部署发布模块&quot;];</span><br><span class="line">    &#125;;</span><br><span class="line"> </span><br><span class="line">mod_dp -&gt; mod_dev [label=&quot;依赖...&quot;];</span><br><span class="line">mod_dp -&gt; mod_dm [label=&quot;依赖...&quot;];</span><br><span class="line">mod_dp -&gt; module_mgr [label=&quot;安装...&quot;, color=&quot;yellowgreen&quot;, arrowhead=&quot;none&quot;];</span><br><span class="line">mod_dev -&gt; mod_dm [label=&quot;依赖...&quot;];</span><br><span class="line">mod_dev -&gt; module_mgr [label=&quot;安装...&quot;, color=&quot;yellowgreen&quot;, arrowhead=&quot;none&quot;];</span><br><span class="line">mod_dm -&gt; module_mgr [label=&quot;安装...&quot;, color=&quot;yellowgreen&quot;, arrowhead=&quot;none&quot;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="状态图"><a href="#状态图" class="headerlink" title="状态图"></a>状态图</h3><p>有限自动机示意图<br><img src="/../../img/blog/4524e3fd3dbec4dc95770ca17e113fcc_MD5.gif"><br>上图是一个简易有限自动机，接受 <code>a</code> 及 <code>a</code> 结尾的任意长度的串。其脚本定义如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">digraph automata_0 &#123;</span><br><span class="line">size = &quot;8.5, 11&quot;;</span><br><span class="line">fontname = &quot;Microsoft YaHei&quot;;</span><br><span class="line">fontsize = 10;</span><br><span class="line"> </span><br><span class="line">node [shape = circle, fontname = &quot;Microsoft YaHei&quot;, fontsize = 10];</span><br><span class="line">edge [fontname = &quot;Microsoft YaHei&quot;, fontsize = 10];</span><br><span class="line"> </span><br><span class="line">0 [ style = filled, color=lightgrey ];</span><br><span class="line">2 [ shape = doublecircle ];</span><br><span class="line"> </span><br><span class="line">0 -&gt; 2 [ label = &quot;a &quot; ];</span><br><span class="line">0 -&gt; 1 [ label = &quot;other &quot; ];</span><br><span class="line">1 -&gt; 2 [ label = &quot;a &quot; ];</span><br><span class="line">1 -&gt; 1 [ label = &quot;other &quot; ];</span><br><span class="line">2 -&gt; 2 [ label = &quot;a &quot; ];</span><br><span class="line">2 -&gt; 1 [ label = &quot;other &quot; ];</span><br><span class="line"> </span><br><span class="line">&quot;Machine: a&quot; [ shape = plaintext ];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>形状值为 plaintext 的表示不用绘制边框，仅展示纯文本内容，这个在绘图中，绘制指示性的文本时很有用，如上图中的 <code>Machine: a</code>。</p><h3 id="OSGi-中模块的生命周期图"><a href="#OSGi-中模块的生命周期图" class="headerlink" title="OSGi 中模块的生命周期图"></a>OSGi 中模块的生命周期图</h3><p>OSGi 中，模块具有生命周期，从安装到卸载，可能的状态具有已安装，已就绪，正在启动，已启动，正在停止，已卸载等。如下图所示：<br><img src="/../../img/blog/7447c00aa1d954a54cf4e9f277959905_MD5.gif"><br>对应的脚本如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">digraph module_lc&#123;</span><br><span class="line">rankdir=TB;</span><br><span class="line">fontname = &quot;Microsoft YaHei&quot;;</span><br><span class="line">fontsize = 12;</span><br><span class="line"> </span><br><span class="line">node [fontname = &quot;Microsoft YaHei&quot;, fontsize = 12, shape = &quot;Mrecord&quot;, color=&quot;skyblue&quot;, style=&quot;filled&quot;]; </span><br><span class="line">edge [fontname = &quot;Microsoft YaHei&quot;, fontsize = 12, color=&quot;darkgreen&quot; ];</span><br><span class="line"> </span><br><span class="line">installed [label=&quot;已安装状态&quot;];</span><br><span class="line">resolved [label=&quot;已就绪状态&quot;];</span><br><span class="line">uninstalled [label=&quot;已卸载状态&quot;];</span><br><span class="line">starting [label=&quot;正在启动&quot;];</span><br><span class="line">active [label=&quot;已激活(运行)状态&quot;];</span><br><span class="line">stopping [label=&quot;正在停止&quot;];</span><br><span class="line">start [label=&quot;&quot;, shape=&quot;circle&quot;, width=0.5, fixedsize=true, style=&quot;filled&quot;, color=&quot;black&quot;];</span><br><span class="line"> </span><br><span class="line">start -&gt; installed [label=&quot;安装&quot;];</span><br><span class="line">installed -&gt; uninstalled [label=&quot;卸载&quot;];</span><br><span class="line">installed -&gt; resolved [label=&quot;准备&quot;];</span><br><span class="line">installed -&gt; installed [label=&quot;更新&quot;];</span><br><span class="line">resolved -&gt; installed [label=&quot;更新&quot;];</span><br><span class="line">resolved -&gt; uninstalled [label=&quot;卸载&quot;];</span><br><span class="line">resolved -&gt; starting [label=&quot;启动&quot;];</span><br><span class="line">starting -&gt; active [label=&quot;&quot;];</span><br><span class="line">active -&gt; stopping [label=&quot;停止&quot;];</span><br><span class="line">stopping -&gt; resolved [label=&quot;&quot;]; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="其他实例"><a href="#其他实例" class="headerlink" title="其他实例"></a>其他实例</h2><p>一棵简单的抽象语法树 (AST)<br>表达式 <code>(3+4)*5</code> 在编译时期，会形成一棵语法树，一边在计算时，先计算 <code>3+4</code> 的值，最后与 5 相乘。<br><img src="/../../img/blog/0b07148c9b17e090e58a50cc7abbcf9d_MD5.gif"><br>对应的脚本如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">digraph ast&#123;</span><br><span class="line">fontname = &quot;Microsoft YaHei&quot;;</span><br><span class="line">fontsize = 10;</span><br><span class="line"> </span><br><span class="line">node [shape = circle, fontname = &quot;Microsoft YaHei&quot;, fontsize = 10];</span><br><span class="line">edge [fontname = &quot;Microsoft YaHei&quot;, fontsize = 10];</span><br><span class="line">node [shape=&quot;plaintext&quot;];</span><br><span class="line"> </span><br><span class="line">mul [label=&quot;mul(*)&quot;];</span><br><span class="line">add [label=&quot;add(+)&quot;];</span><br><span class="line"> </span><br><span class="line">add -&gt; 3</span><br><span class="line">add -&gt; 4;</span><br><span class="line">mul -&gt; add;</span><br><span class="line">mul -&gt; 5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="简单的-UML-类图"><a href="#简单的-UML-类图" class="headerlink" title="简单的 UML 类图"></a>简单的 UML 类图</h3><p>下面是一简单的 UML 类图，<code>Dog</code> 和 <code>Cat</code> 都是 <code>Animal</code> 的子类，<code>Dog</code> 和 <code>Cat</code> 同属一个包，且有可能有联系 <code>(0..n)</code>。<br><img src="/../../img/blog/e5cfa1d03e1920983c78f7e753014b20_MD5.gif"><br>脚本：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">digraph G&#123;</span><br><span class="line"> </span><br><span class="line">fontname = &quot;Courier New&quot;</span><br><span class="line">fontsize = 10</span><br><span class="line"> </span><br><span class="line">node [ fontname = &quot;Courier New&quot;, fontsize = 10, shape = &quot;record&quot; ];</span><br><span class="line">edge [ fontname = &quot;Courier New&quot;, fontsize = 10 ];</span><br><span class="line"> </span><br><span class="line">Animal [ label = &quot;&#123;Animal |+ name : String\l+ age : int\l|+ die() : void\l&#125;&quot; ];</span><br><span class="line"> </span><br><span class="line">    subgraph clusterAnimalImpl&#123;</span><br><span class="line">        bgcolor=&quot;yellow&quot;</span><br><span class="line">        Dog [ label = &quot;&#123;Dog||+ bark() : void\l&#125;&quot; ];</span><br><span class="line">        Cat [ label = &quot;&#123;Cat||+ meow() : void\l&#125;&quot; ];</span><br><span class="line">    &#125;;</span><br><span class="line"> </span><br><span class="line">edge [ arrowhead = &quot;empty&quot; ];</span><br><span class="line"> </span><br><span class="line">Dog-&gt;Animal;</span><br><span class="line">Cat-&gt;Animal;</span><br><span class="line">Dog-&gt;Cat [arrowhead=&quot;none&quot;, label=&quot;0..*&quot;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="状态图-1"><a href="#状态图-1" class="headerlink" title="状态图"></a>状态图</h3><p><img src="/../../img/blog/ad495299eb1919018e96a0f6f47882a8_MD5.gif"><br>脚本：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">digraph finite_state_machine &#123;</span><br><span class="line">rankdir = LR;</span><br><span class="line">size = &quot;8,5&quot;</span><br><span class="line"> </span><br><span class="line">node [shape = doublecircle]; </span><br><span class="line"> </span><br><span class="line">LR_0 LR_3 LR_4 LR_8;</span><br><span class="line"> </span><br><span class="line">node [shape = circle];</span><br><span class="line"> </span><br><span class="line">LR_0 -&gt; LR_2 [ label = &quot;SS(B)&quot; ];</span><br><span class="line">LR_0 -&gt; LR_1 [ label = &quot;SS(S)&quot; ];</span><br><span class="line">LR_1 -&gt; LR_3 [ label = &quot;S($end)&quot; ];</span><br><span class="line">LR_2 -&gt; LR_6 [ label = &quot;SS(b)&quot; ];</span><br><span class="line">LR_2 -&gt; LR_5 [ label = &quot;SS(a)&quot; ];</span><br><span class="line">LR_2 -&gt; LR_4 [ label = &quot;S(A)&quot; ];</span><br><span class="line">LR_5 -&gt; LR_7 [ label = &quot;S(b)&quot; ];</span><br><span class="line">LR_5 -&gt; LR_5 [ label = &quot;S(a)&quot; ];</span><br><span class="line">LR_6 -&gt; LR_6 [ label = &quot;S(b)&quot; ];</span><br><span class="line">LR_6 -&gt; LR_5 [ label = &quot;S(a)&quot; ];</span><br><span class="line">LR_7 -&gt; LR_8 [ label = &quot;S(b)&quot; ];</span><br><span class="line">LR_7 -&gt; LR_5 [ label = &quot;S(a)&quot; ];</span><br><span class="line">LR_8 -&gt; LR_6 [ label = &quot;S(b)&quot; ];</span><br><span class="line">LR_8 -&gt; LR_5 [ label = &quot;S(a)&quot; ];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="时序图"><a href="#时序图" class="headerlink" title="时序图"></a>时序图</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">digraph G &#123; </span><br><span class="line">    rankdir=&quot;LR&quot;; </span><br><span class="line">    node[shape=&quot;point&quot;, width=0, height=0]; </span><br><span class="line">    edge[arrowhead=&quot;none&quot;, style=&quot;dashed&quot;] </span><br><span class="line">    &#123; </span><br><span class="line">        rank=&quot;same&quot;; </span><br><span class="line">        edge[style=&quot;solided&quot;];</span><br><span class="line">        LC[shape=&quot;plaintext&quot;]; </span><br><span class="line">        LC -&gt; step00 -&gt; step01 -&gt; step02 -&gt; step03 -&gt; step04 -&gt; step05; </span><br><span class="line">    &#125; </span><br><span class="line">    &#123; </span><br><span class="line">        rank=&quot;same&quot;; </span><br><span class="line">        edge[style=&quot;solided&quot;];</span><br><span class="line">        Agency[shape=&quot;plaintext&quot;];</span><br><span class="line">        Agency -&gt; step10 -&gt; step11 -&gt; step12 -&gt; step13 -&gt; step14 -&gt; step15; </span><br><span class="line">    &#125; </span><br><span class="line">    &#123; </span><br><span class="line">        rank=&quot;same&quot;; </span><br><span class="line">        edge[style=&quot;solided&quot;];</span><br><span class="line">        Agent[shape=&quot;plaintext&quot;];</span><br><span class="line">        Agent -&gt; step20 -&gt; step21 -&gt; step22 -&gt; step23 -&gt; step24 -&gt; step25; </span><br><span class="line">    &#125; </span><br><span class="line">    step00 -&gt; step10 [label=&quot;sends email new custumer&quot;, arrowhead=&quot;normal&quot;]; </span><br><span class="line">    step11 -&gt; step01 [label=&quot;declines&quot;, arrowhead=&quot;normal&quot;]; </span><br><span class="line">    step12 -&gt; step02 [label=&quot;accepts&quot;, arrowhead=&quot;normal&quot;]; </span><br><span class="line">    step13 -&gt; step23 [label=&quot;forward to&quot;, arrowhead=&quot;normal&quot;]; </span><br><span class="line">    step24 -&gt; step14; </span><br><span class="line">    step14 -&gt; step04 [arrowhead=&quot;normal&quot;]; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>rankdir=&quot;LR&quot;</code> 表示，布局从左 <code>L</code> 到右 <code>R</code>。可以看到，在代码中有 <code>&#123;&#125;</code> 括起来的部分。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123; </span><br><span class="line">    rank=&quot;same&quot;; </span><br><span class="line">    edge[style=&quot;solided&quot;];</span><br><span class="line">    Agency[shape=&quot;plaintext&quot;];</span><br><span class="line">    Agency -&gt; step10 -&gt; step11 -&gt; step12 -&gt; step13 -&gt; step14 -&gt; step15; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每一个 <code>rank=&quot;same&quot;</code> 的 block 中的所有节点都会在同一条线上。我们设置了所有的线为虚线，但是在该 block 中，将线改为 <code>solided</code>。<br><img src="/../../img/blog/e2e975df8269fb35db1608ded52aa67f_MD5.png"></p><h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><p><a href="https://max.book118.com/html/2017/0513/106648582.shtm">Graphviz中文教程指南.pdf (book118.com)</a></p><p>事实上，从 <code>dot</code> 的语法及上述的示例中，很容易看出，dot 脚本很容易被其他语言生成。比如，使用一些简单的数据库查询就可以生成数据库中的 ER 图的 dot 脚本。<br>如果你追求高效的开发速度，并希望快速的将自己的想法画出来，那么 <code>graphviz</code> 是一个很不错的选择。<br>当然，<code>graphviz</code> 也有一定的局限，比如绘制时序图 (序列图) 就很难实现。<code>graphviz</code> 的节点出现在画布上的位置事实上是不确定的，依赖于所使用的布局算法，而不是在脚本中出现的位置，这可能使刚开始接触 <code>graphviz</code> 的开发人员有点不适应。<code>graphviz</code> 的强项在于自动布局，当图中的顶点和边的数目变得很多的时候，才能很好的体会这一特性的好处：<br><img src="/../../img/blog/afab2574c523235e7ade49f26ccb1580_MD5.gif"><br>比如上图，或者较上图更复杂的图，如果采用手工绘制显然是不可能的，只能通过 <code>graphviz</code> 提供的自动布局引擎来完成。如果仅用于展示模块间的关系，子模块与子模块间通信的方式，模块的逻辑位置等，<code>graphviz</code> 完全可以胜任，但是如果图中对象的物理位置必须是准确的，如节点 A 必须位于左上角，节点 B 必须与 A 相邻等特性，使用 <code>graphviz</code> 则很难做到。毕竟，它的强项是自动布局，事实上，所有的节点对与布局引擎而言，权重在初始时都是相同的，只是在渲染之后，节点的大小，形状等特性才会影响权重。<br>本文只是初步介绍了 <code>graphviz</code> 的简单应用，如图的定义，顶点&#x2F;边的属性定义，如果运行等，事实上还有很多的属性，如画布的大小，字体的选择，颜色列表等，大家可以通过 <code>graphviz</code> 的官网来找到更详细的资料。<br>文中的代码都已经在 <a href="https://github.com/abruzzi/graphviz-scripts">Github</a> 上。</p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机/编程语言/dot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>xmake使用</title>
      <link href="/posts/%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7/Xmake/xmake%E4%BD%BF%E7%94%A8.html"/>
      <url>/posts/%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7/Xmake/xmake%E4%BD%BF%E7%94%A8.html</url>
      
        <content type="html"><![CDATA[<h1 id="clion"><a href="#clion" class="headerlink" title="clion"></a>clion</h1><p><a href="https://blog.csdn.net/m0_69086552/article/details/130444581">xmake配合clion用指南-CSDN博客</a><br><a href="https://zhuanlan.zhihu.com/p/640701847">Xmake 新手教程 - 知乎 (zhihu.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> 编程工具 </category>
          
          <category> Xmake </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Git提交规范引入指南</title>
      <link href="/posts/%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7/Git/Git%E6%8F%90%E4%BA%A4%E8%A7%84%E8%8C%83%E5%BC%95%E5%85%A5%E6%8C%87%E5%8D%97.html"/>
      <url>/posts/%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7/Git/Git%E6%8F%90%E4%BA%A4%E8%A7%84%E8%8C%83%E5%BC%95%E5%85%A5%E6%8C%87%E5%8D%97.html</url>
      
        <content type="html"><![CDATA[<p><a href="https://juejin.cn/post/6844903793033756680">超详细的Git提交规范引入指南 - 掘金 (juejin.cn)</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">feat - 新功能 feature  </span><br><span class="line">fix - 修复 bug  </span><br><span class="line">docs - 文档注释  </span><br><span class="line">style - 代码格式(不影响代码运行的变动)  </span><br><span class="line">refactor - 重构、优化(既不增加新功能，也不是修复bug)  </span><br><span class="line">perf - 性能优化  </span><br><span class="line">test - 增加测试  </span><br><span class="line">chore - 构建过程或辅助工具的变动  </span><br><span class="line">revert - 回退  </span><br><span class="line">build - 打包</span><br></pre></td></tr></table></figure><p><a href="https://www.conventionalcommits.org/zh-hans/v1.0.0/">约定式提交 (conventionalcommits.org)</a></p>]]></content>
      
      
      <categories>
          
          <category> 编程工具 </category>
          
          <category> Git </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>flutter</title>
      <link href="/posts/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/flutter.html"/>
      <url>/posts/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/flutter.html</url>
      
        <content type="html"><![CDATA[<h1 id="开发"><a href="#开发" class="headerlink" title="开发"></a>开发</h1><ul><li><a href="https://book.flutterchina.club/">第二版序 | 《Flutter实战·第二版》 (flutterchina.club)</a></li></ul><h1 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h1><ul><li><a href="https://isar.dev/zh/">主页 | Isar 数据库</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机/编程语言/dart </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cloudflare</title>
      <link href="/posts/%E7%BD%91%E7%BB%9C/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8/cloudflare.html"/>
      <url>/posts/%E7%BD%91%E7%BB%9C/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8/cloudflare.html</url>
      
        <content type="html"><![CDATA[<h1 id="在-CloudFlare-上解析自己的域名"><a href="#在-CloudFlare-上解析自己的域名" class="headerlink" title="在 CloudFlare 上解析自己的域名"></a>在 CloudFlare 上解析自己的域名</h1><p>在我们获取到域名的时候，我们首先需要将域名设置 DNS 记录。而作为世界最大的免费 CDN 提供商的 CloudFlare，旗下自然会有 DNS 解析服务。在这篇教程中，我来和大家一起将域名绑定至 CloudFlare 上并解析。</p><h2 id="准备材料"><a href="#准备材料" class="headerlink" title="准备材料"></a>准备材料</h2><ul><li>一枚域名</li><li>一枚邮箱（最好是 gmail、outlook 之类的常用邮箱）</li></ul><h2 id="部署步骤"><a href="#部署步骤" class="headerlink" title="部署步骤"></a>部署步骤</h2><ul><li>打开 CloudFlare 的官网：<a href="https://dash.cloudflare.com/">https://dash.cloudflare.com/</a> ，如果没账户的可以点击 “Sign up” 进行注册。如有账户输入邮箱及密码即可</li></ul><p><a href="https://cdn.jsdelivr.net/gh/Misaka-blog/imgs@main/20230303190104.png"><img src="/../../../img/blog/f802feb65b8566bfe6ae18dcfd24f1cd_MD5.png"></a></p><ul><li>点击 “Add site” 按钮</li></ul><p>[<img src="/../../../img/blog/747f2a8c91fba51126981ebf5415e91b_MD5.png">](..&#x2F;..&#x2F;..&#x2F;img&#x2F;blog&#x2F;747 f 2 a 8 c 91 fba 51126981 ebf 5415 e 91 b_MD 5. png)</p><ul><li>输入自己的域名，点击 “Add site” 按钮</li></ul><p>[<img src="/../../../img/blog/ed2f08154eb37ab584cfda8dd31a961e_MD5.png">](..&#x2F;..&#x2F;..&#x2F;img&#x2F;blog&#x2F;ed 2 f 08154 eb 37 ab 584 cfda 8 dd 31 a 961 e_MD 5. png)</p><ul><li>选择计划。一般选择 Free 的。点击 “Continue”</li></ul><p>[<img src="/../../../img/blog/db6434e3c9185c140b37127c2ee093aa_MD5.png">](..&#x2F;..&#x2F;..&#x2F;img&#x2F;blog&#x2F;db 6434 e 3 c 9185 c 140 b 37127 c 2 ee 093 aa_MD 5. png)</p><ul><li>设置 DNS 记录。可以先在这里设置，也可以点击 “Continue” 跳过</li></ul><p>[<img src="/../../../img/blog/379454efb1c1c26bbd8bceb2fd33f098_MD5.png">](..&#x2F;..&#x2F;..&#x2F;img&#x2F;blog&#x2F;379454 efb 1 c 1 c 26 bbd 8 bceb 2 fd 33 f 098_MD 5. png)</p><ul><li><p>按照提示修改 CloudFlare 的 DNS 服务器。<br><a href="https://help.aliyun.com/zh/dws/user-guide/change-dns-servers-for-a-domain-name">如何修改域名的DNS_域名-阿里云帮助中心 (aliyun.com)</a><br>[<img src="/../../../img/blog/f097765c33bc36ffde5035bee327920d_MD5.png">](..&#x2F;..&#x2F;..&#x2F;img&#x2F;blog&#x2F;f 097765 c 33 bc 36 ffde 5035 bee 327920 d_MD 5. png)</p></li><li><p>点击 “Check nameservers” 检查 DNS 解析状态</p></li></ul><p>[<img src="/../../../img/blog/108fcd0a8d2accc07f107eb2e36d35c1_MD5.png">](..&#x2F;..&#x2F;..&#x2F;img&#x2F;blog&#x2F;108 fcd 0 a 8 d 2 accc 07 f 107 eb 2 e 36 d 35 c 1_MD 5. png)</p><ul><li>如出现类似此邮件，即为设置成功</li></ul><p><a href="https://cdn.jsdelivr.net/gh/Misaka-blog/imgs@main/20230303191402.png"><img src="/../../../img/blog/17c9924add3c42dc76dd2decd738ad26_MD5.png"></a></p>]]></content>
      
      
      <categories>
          
          <category> 网络 </category>
          
          <category> 云服务器 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>终端编辑器配置</title>
      <link href="/posts/%E6%9C%AC%E5%9C%B0/%E7%BB%88%E7%AB%AF%E7%BC%96%E8%BE%91%E5%99%A8%E9%85%8D%E7%BD%AE.html"/>
      <url>/posts/%E6%9C%AC%E5%9C%B0/%E7%BB%88%E7%AB%AF%E7%BC%96%E8%BE%91%E5%99%A8%E9%85%8D%E7%BD%AE.html</url>
      
        <content type="html"><![CDATA[<h1 id="helix"><a href="#helix" class="headerlink" title="helix"></a>helix</h1><h2 id="官方文档"><a href="#官方文档" class="headerlink" title="官方文档"></a>官方文档</h2><ul><li><a href="https://docs.helix-editor.com/configuration.html">Configuration (helix-editor.com)</a></li><li><a href="https://zjp-cn.github.io/helix-book/title-page.html">Helix - Helix Book 中文翻译 (较旧)</a></li></ul><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="shell"><a href="#shell" class="headerlink" title="shell"></a>shell</h3><ul><li><a href="https://github.com/helix-editor/helix/discussions/6209">Using PowerShell core as shell</a></li><li><a href="https://github.com/helix-editor/helix/discussions/7455">shell编码问题</a></li><li><a href="https://github.com/helix-editor/helix/discussions/8776">使用nushell</a></li></ul><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>即使 Helix 在零配置下也可以使用，如果想要更加符合自己的习惯还是需要一些配置。 <a href="https://link.zhihu.com/?target=https://github.com/erasin/helix-config">erasin&#x2F;helix-config</a> 是我自己正在使用的配置文件。</p><p>在 Helix 中,加载配置的顺序是 <code>默认配置</code> –&gt;&gt; <code>.config/helix/</code> 中自定义配置 –&gt; <code>self-project/.helix/</code> 项目文件夹下自定义配置。在三层配置这种常规设计基本上可以满足各种使用的情况了。</p><p>配置文件结构主要有：</p><ul><li>config.toml &lt;– 编辑器配置</li><li>language.toml &lt;– 语言支持配置</li><li>themes&#x2F; &lt;– 自定义主题<ul><li>self-theme1.toml</li></ul></li><li>icons&#x2F; &lt;– 自定义图标<ul><li>self-icons.toml</li></ul></li></ul><h3 id="config-toml"><a href="#config-toml" class="headerlink" title="config.toml"></a>config.toml</h3><p>配置主要提供 true-color 支持,自定义显示,以及自定义键盘布局。在编辑器器中使用 <code>:set-option</code> 可以看到配置选项,或者阅读官方文档配置。</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">theme</span> = <span class="string">&quot;zed_onedark&quot;</span></span><br><span class="line"><span class="comment"># icons = &quot;nerd&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># editor 编辑器</span></span><br><span class="line"><span class="section">[editor]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 真彩支持</span></span><br><span class="line"><span class="attr">true-color</span> = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 光标样式</span></span><br><span class="line"><span class="section">[editor.cursor-shape]</span></span><br><span class="line"><span class="attr">insert</span> = <span class="string">&quot;bar&quot;</span></span><br><span class="line"><span class="attr">normal</span> = <span class="string">&quot;block&quot;</span></span><br><span class="line"><span class="attr">select</span> = <span class="string">&quot;underline&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 状态栏定义</span></span><br><span class="line"><span class="section">[editor.statusline]</span></span><br><span class="line"><span class="comment"># [#2869] file-type-icon</span></span><br><span class="line"><span class="attr">left</span> = [<span class="string">&quot;mode&quot;</span>, <span class="string">&quot;spacer&quot;</span>, <span class="string">&quot;spinner&quot;</span>, <span class="string">&quot;spacer&quot;</span>,  <span class="string">&quot;file-name&quot;</span>, <span class="string">&quot;file-modification-indicator&quot;</span>]</span><br><span class="line"><span class="attr">center</span> = [<span class="string">&quot;diagnostics&quot;</span>,<span class="string">&quot;workspace-diagnostics&quot;</span>]</span><br><span class="line"><span class="attr">right</span> = [<span class="string">&quot;position-percentage&quot;</span>, <span class="string">&quot;file-encoding&quot;</span>,  <span class="string">&quot;file-type&quot;</span>, ]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 键盘布局</span></span><br><span class="line"><span class="section">[keys.normal]</span></span><br><span class="line"><span class="comment"># use `li` or remap `after insert`</span></span><br><span class="line"><span class="attr">a</span> = [<span class="string">&quot;move_char_right&quot;</span>,<span class="string">&quot;insert_mode&quot;</span>]</span><br><span class="line"><span class="attr">&quot;C-s&quot;</span> = <span class="string">&quot;:write&quot;</span>  <span class="comment"># 原保存跳转列表位置，修改为 C-j</span></span><br><span class="line"><span class="attr">&quot;C-j&quot;</span> = [<span class="string">&quot;save_selection&quot;</span>]</span><br><span class="line"><span class="attr">&quot;C-r&quot;</span> = <span class="string">&quot;:reload&quot;</span></span><br><span class="line"><span class="attr">&quot;C-z&quot;</span> = <span class="string">&quot;normal_mode&quot;</span>     <span class="comment"># replace suspend</span></span><br><span class="line"><span class="attr">&quot;C-q&quot;</span> = <span class="string">&quot;:quit&quot;</span></span><br><span class="line"><span class="attr">&quot;A-/&quot;</span> = <span class="string">&quot;toggle_comments&quot;</span></span><br><span class="line"><span class="attr">&quot;\\&quot;</span> = <span class="string">&quot;:reflow&quot;</span> <span class="comment"># |</span></span><br><span class="line"><span class="attr">&quot;X&quot;</span> = <span class="string">&quot;extend_line_above&quot;</span></span><br><span class="line"><span class="attr">&quot;Z&quot;</span> = &#123; <span class="string">&quot;Z&quot;</span> = [<span class="string">&quot;:quit&quot;</span>] &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># space mode</span></span><br><span class="line"><span class="section">[keys.normal.space]</span></span><br><span class="line"><span class="attr">&quot;x&quot;</span> = <span class="string">&quot;:buffer-close&quot;</span></span><br><span class="line"><span class="attr">&quot;w&quot;</span> = &#123; <span class="string">&quot;r&quot;</span> = <span class="string">&quot;:config-reload&quot;</span> &#125;</span><br><span class="line"><span class="attr">&quot;.&quot;</span> = <span class="string">&quot;file_picker_in_current_buffer_directory&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="section">[keys.insert]</span></span><br><span class="line"><span class="comment"># macos 自动切换到英文环境</span></span><br><span class="line"><span class="comment"># &quot;esc&quot; = [&quot;:sh macism com.apple.keylayout.ABC&quot;, &quot;normal_mode&quot;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># [keys.select]</span></span><br></pre></td></tr></table></figure><p>Helix 提供 <a href="https://link.zhihu.com/?target=https://docs.helix-editor.com/keymap.html">keymap</a> 和 <a href="https://link.zhihu.com/?target=https://docs.helix-editor.com/commands.html">commands</a> 命令, 这些命令在自定义键盘布局中自由组合，命令组会顺序处理。比如 <code>a = [&quot;move_char_right&quot;,&quot;insert_mode&quot;]</code> Helix 中 <code>a</code> 默认为选区追加, 将其覆盖为字符向后移动一位编辑模式。详细的请参看 <a href="https://link.zhihu.com/?target=https://docs.helix-editor.com/configuration.html">配置文档</a> 。</p><h2 id="lsp"><a href="#lsp" class="headerlink" title="lsp"></a>lsp</h2><p>通过 <code>hx --health language</code> 检查 lsp<br>内置语言支持 Tree-Sitter 查看项目的 <a href="https://link.zhihu.com/?target=https://github.com/helix-editor/helix/blob/master/languages.toml">languages.toml</a> 可以看到支持的语言。<br><a href="https://github.com/helix-editor/helix/wiki/How-to-install-the-default-language-servers">How to install the default language servers · helix-editor&#x2F;helix Wiki</a><br>编写 <code>languages.toml</code>，保存在 <code>~/.config/helix/</code> 路径下。参考官网的配置就好，内容如下：</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[[language]]</span></span><br><span class="line"><span class="attr">name</span> = <span class="string">&quot;rust&quot;</span></span><br><span class="line"><span class="attr">auto-format</span> = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># If this doesn&#x27;t work, you might be on a older release version which handles this differently.</span></span><br><span class="line"><span class="comment"># Try using [language.config.check] instead of [language-server.rust-analyzer.config.check]</span></span><br><span class="line"><span class="section">[language-server.rust-analyzer.config.check]</span></span><br><span class="line"><span class="attr">command</span> = <span class="string">&quot;clippy&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># [[grammar]]</span></span><br><span class="line"><span class="comment"># name = &quot;rust&quot;</span></span><br><span class="line"><span class="comment"># source = &#123; git = &quot;https://github.com/tree-sitter/tree-sitter-rust&quot;, rev = &quot;????&quot; &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 下这是复制粘贴来的。</span></span><br><span class="line"><span class="section">[[language]]</span></span><br><span class="line"><span class="attr">name</span> = <span class="string">&quot;python&quot;</span></span><br><span class="line"><span class="attr">scope</span> = <span class="string">&quot;source.python&quot;</span></span><br><span class="line"><span class="attr">injection-regex</span> = <span class="string">&quot;python&quot;</span></span><br><span class="line"><span class="attr">file-types</span> = [<span class="string">&quot;py&quot;</span>,<span class="string">&quot;pyi&quot;</span>,<span class="string">&quot;py3&quot;</span>,<span class="string">&quot;pyw&quot;</span>,<span class="string">&quot;ptl&quot;</span>,<span class="string">&quot;.pythonstartup&quot;</span>,<span class="string">&quot;.pythonrc&quot;</span>,<span class="string">&quot;SConstruct&quot;</span>]</span><br><span class="line"><span class="attr">shebangs</span> = [<span class="string">&quot;python&quot;</span>]</span><br><span class="line"><span class="attr">roots</span> = [<span class="string">&quot;setup.py&quot;</span>, <span class="string">&quot;setup.cfg&quot;</span>, <span class="string">&quot;pyproject.toml&quot;</span>]</span><br><span class="line"><span class="attr">comment-token</span> = <span class="string">&quot;#&quot;</span></span><br><span class="line"><span class="attr">language-server</span> = &#123; command = <span class="string">&quot;pyright-langserver&quot;</span>, args = [<span class="string">&quot;--stdio&quot;</span>] &#125;</span><br><span class="line"><span class="attr">indent</span> = &#123; tab-width = <span class="number">4</span>, unit = <span class="string">&quot;    &quot;</span> &#125;</span><br><span class="line"><span class="comment"># will get &quot;Async jobs timed out&quot; errors if this empty config is not added</span></span><br><span class="line"><span class="attr">config</span> = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># [language-server.pyright-langserver.config.check]</span></span><br><span class="line"><span class="comment"># command = &quot;clippy&quot;</span></span><br></pre></td></tr></table></figure><p>在配置文件中 “<code>[[grammar]]</code>“ 底下有指定要安装某个语言的 LSP 服务器，但是我不理解其中一些配置参数。这个配置文件的内容我是仿照 <a href="https://docs.helix-editor.com/languages.html">Languages (helix-editor.com)</a> 复制粘贴的。</p><h3 id="自定义语言支持"><a href="#自定义语言支持" class="headerlink" title="自定义语言支持"></a>自定义语言支持</h3><p>如果有自定义的特殊语言支持,一种是提交 issues 到官方项目寻求帮助,另外一种是自己动手处理,具体可以分解以下步骤:</p><ol><li><p>向 <code>languages.toml</code> 中追加语言和语言的 tree-sitter 实现。</p></li><li><p>向 <code>runtime/queries/</code> 下对语言 <code>hightlights.scm</code> 高亮支持 , <code>textobjects.scm</code> 文本选择支持, <code>indents.scm</code> 缩进支持。</p></li><li><p>如果是在 helix 项目中提交代码,需要执行 <code>cargo xtask docgen</code> 来生成文档支持, 自定义的则不需要这一步。</p></li><li><p><code>hx -g fetch &amp; hx -g build</code> 会自动拉去配置 tree-sitter 并编译。之后就可以测试了。</p></li></ol><h2 id="可参考"><a href="#可参考" class="headerlink" title="可参考"></a>可参考</h2><ul><li><a href="https://erasin.wang/helix/tutor">helix editor 中文教程 - 编程与开发</a></li><li><a href="https://github.com/Rhylan2333/my_helix_editor_config/tree/master">GitHub - Rhylan2333&#x2F;my_helix_editor_config: 适合我的Helix编辑器配置文件。</a></li></ul><h1 id="neovim"><a href="#neovim" class="headerlink" title="neovim"></a>neovim</h1><h2 id="windows"><a href="#windows" class="headerlink" title="windows"></a>windows</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>安装必要组件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scoop install neovim neovide git lazygit gcc ripgrep fd unzip tree-sitter luarocks</span><br></pre></td></tr></table></figure><p>下载并安装 LazyVim 配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/LazyVim/starter $env:LOCALAPPDATA\nvim --depth=1</span><br></pre></td></tr></table></figure><p>为了显示 Neovim 界面中的图标，需要安装一款 <a href="https://www.nerdfonts.com/font-downloads">Nerd Font</a> 字体，这里选择 <a href="https://github.com/ryanoasis/nerd-fonts/releases/download/v3.0.2/UbuntuMono.zip">UbuntuMono Nerd Font</a> 字体。可以通过 Scoop 进行安装：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scoop bucket add nerd-fonts</span><br><span class="line">scoop install UbuntuMono-NF</span><br></pre></td></tr></table></figure><p>在配置文件 <code>$env:LOCALAPPDATA\nvim\lua\config\options.lua</code> 中添加下行代码来设置字体：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> opt = vim.opt</span><br><span class="line"> </span><br><span class="line">opt.guifont = <span class="string">&quot;UbuntuMono Nerd Font:h12&quot;</span></span><br></pre></td></tr></table></figure><p>在命令行中使用 <code>neovide</code> 命令就可以启动 Neovim 了。值得注意的是， Neovide 只要使用参数 <code>--wsl</code> 就可以在 WSL 环境中运行，不过这时 LazyVim 的配置也需要安装到 WSL 环境中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/LazyVim/starter ~/.config/nvim --depth=1</span><br></pre></td></tr></table></figure><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>程序第一次运行时会自动下载和安装插件。如果遇到网络问题而导致安装失败也没关系，按下 <code>R</code> （大写）重新安装直至成功为止。所有插件安装成功后， <code>nvim-treesitter</code> 还会继续安装组件，等所有插件和组件安装完毕后，按下 <code>q</code> 退出安装界面。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="https://www.fournoas.com/posts/neovim-on-windows/">Windows 下使用 Neovim · 白汤四物 (fournoas.com)</a></li><li><a href="https://www.cnblogs.com/zwyyy456/p/17479396.html">Neovim 的配置与使用 - zwyyy456 (cnblogs.com)</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 本地 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机/编程工具/shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nodejs管理</title>
      <link href="/posts/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/nodejs%E7%AE%A1%E7%90%86.html"/>
      <url>/posts/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/nodejs%E7%AE%A1%E7%90%86.html</url>
      
        <content type="html"><![CDATA[<h1 id="nvm-管理-node-版本"><a href="#nvm-管理-node-版本" class="headerlink" title="nvm 管理 node 版本"></a>nvm 管理 node 版本</h1><h2 id="设置国内镜像"><a href="#设置国内镜像" class="headerlink" title="设置国内镜像"></a>设置国内镜像</h2><p>终端输入：</p><p>设置 npm_mirror:</p><p><code>nvm npm_mirror https://npmmirror.com/mirrors/npm/</code></p><p> 设置 node_mirror:</p><p><code>nvm node_mirror https://npmmirror.com/mirrors/node/</code></p><h2 id="全局安装-npm"><a href="#全局安装-npm" class="headerlink" title="全局安装 npm"></a>全局安装 npm</h2><p>安装 node 的时候，npm 其实也已经一起安装了。因为 nvm 可以管理多个版本的 node，如果每次添加一个 node 版本都要安装一堆的包很麻烦，如果有一个 npm 可以让各个版本的 node 共用，就不会这么麻烦了。</p><p>简单的三步就可以配置一个全局的 npm。</p><ol><li><p><code>npm config set prefix E:\nvm\npm</code> &#x2F;&#x2F;配置用 npm 下载包时全局安装的包路径。</p></li><li><p><code>npm install npm -g</code> &#x2F;&#x2F;安装全局 npm，不同的 node 都使用这个 npm。想更新全局的 npm 的话首先删除全局路径 (就是上一行命令的地址，可以使用 npm config ls 查看) 下的 npm，再执行一次这个命令即可。</p></li><li><p>在用户变量中添加 <code>NPM_HOME = E:\nvm\npm</code>，path 中添加%NPM_HOME%。这里需要注意的是，%NPM_HOME% 要添加在%NVM_SYMLINK% 之前，避免 npm 访问到的是 nodejs 中自带的 npm 包管理工具。</p></li></ol><h2 id="使用-nvm-管理版本（nvm-常用命令）"><a href="#使用-nvm-管理版本（nvm-常用命令）" class="headerlink" title="使用 nvm 管理版本（nvm 常用命令）"></a>使用 nvm 管理版本（nvm 常用命令）</h2><p><strong>nvm install latest</strong> 安装最新版本 node.js<br><strong>nvm use 版本号</strong> 使用某一具体版本，例如 ：nvm use 14.3.0<br><strong>nvm list</strong> 列出当前已安装的所有版本<br><strong>nvm ls</strong> 列出当前已安装的所有版本<br><strong>nvm uninstall 版本号</strong> 卸载某一具体版本，例如：nvm use 14.3.0<br><strong>nvm ls-remote</strong> Mac 版本中,列出全部可以安装的 node 版本<br><strong>nvm ls available</strong> windows 版本,列出全部可以安装的 node 版本<br><strong>nvm current</strong> 显示当前的版本<br><strong>nvm alias</strong> 给不同的版本号添加别名<br><strong>nvm unalias</strong> 删除已定义的别名<br><strong>nvm reinstall-packages</strong> 在当前版本 node 环境下，重新全局安装指定版本号的 npm 包</p><h1 id="nrm-使用详解"><a href="#nrm-使用详解" class="headerlink" title="nrm 使用详解"></a>nrm 使用详解</h1><p><a href="https://github.com/Pana/nrm" title=" https://github.com/Pana/nrm">nrm</a>（NPM registry manager）是 npm 的镜像源管理工具，使用它可以快速切换 npm 源。</p><ul><li>全局安装</li></ul><p><code>$ npm i -g nrm</code></p><ul><li>查看版本</li></ul><p><code>$ nrm -V</code></p><ul><li>查看所有源</li></ul><p>其中 <code>*</code> 号表示当前使用的源。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ nrm ls</span><br><span class="line"></span><br><span class="line">* npm -------- https://registry.npmjs.org/</span><br><span class="line">  yarn ------- https://registry.yarnpkg.com/</span><br><span class="line">  cnpm ------- http://r.cnpmjs.org/</span><br><span class="line">  taobao ----- https://www.npmmirror.com/</span><br><span class="line">  nj --------- https://registry.nodejitsu.com/</span><br><span class="line">  npmMirror -- https://skimdb.npmjs.com/registry/</span><br><span class="line">  edunpm ----- http://registry.enpmjs.org/</span><br></pre></td></tr></table></figure><p>或者通过 <code>nrm current</code> 命令查看当前源的名称。</p><ul><li>切换源</li></ul><p>其中 <code>&lt;registry&gt;</code> 就是上面命令所列出来的名称。</p><p>相比上面的命令，是不是方便好记多了。</p><p><code>$ nrm use &lt;registry&gt; # 例如 nrm use taobao</code></p><blockquote><p>注意切换源之后，我们安装依赖仍使用 <code>npm i &lt;name&gt;</code> 的方式来进行安装。</p></blockquote><ul><li>添加源</li></ul><p>适用于企业内部定制的私有源，<code>&lt;registry&gt;</code> 表示源名称，<code>&lt;url&gt;</code> 表示源地址。</p><p><code>$ nrm add &lt;registry&gt; &lt;url&gt;</code></p><ul><li>删除源</li></ul><p><code>$ nrm del &lt;registry&gt;</code></p><ul><li>测试源的响应时间</li></ul><p><code>$ nrm test &lt;registry&gt;</code></p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机/编程语言/语言环境配置 </tag>
            
            <tag> 计算机/编程语言/nodejs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>归档2</title>
      <link href="/posts/%E5%BD%92%E6%A1%A3/%E5%BD%92%E6%A1%A32.html"/>
      <url>/posts/%E5%BD%92%E6%A1%A3/%E5%BD%92%E6%A1%A32.html</url>
      
        <content type="html"><![CDATA[<h1 id="如何将-C-盘中-QQ-与微信数据（聊天记录）迁移到其他工作盘"><a href="#如何将-C-盘中-QQ-与微信数据（聊天记录）迁移到其他工作盘" class="headerlink" title="如何将 C 盘中 QQ 与微信数据（聊天记录）迁移到其他工作盘"></a>如何将 C 盘中 QQ 与微信数据（聊天记录）迁移到其他工作盘</h1><p>1.QQ 数据迁移 (聊天记录等)</p><p>第一步：打开 QQ 界面，点击左下角的菜单栏，弹出菜单栏窗口，点击 “ 设置 “，如下图：</p><p><img src="/../../img/blog/049d8d4e9777256eab9f06d96e8c033a_MD5.webp"></p><p>第二步：弹出窗口如下图，选择 “ 文件管理 “ 栏目，我们会看到默认接收的文件及保存的文档都存放在 C 盘（占用空间比较大哦），选择其他空余的磁盘目录。点击 “ 更改目录 “ 即可。</p><p><img src="/../../img/blog/4be393b0810eef9b055f34138c7f2dfa_MD5.webp"></p><p>第三步：修改完毕会弹出如下图所示的迁移窗口</p><p><img src="/../../img/blog/cdc3ef3a0db65e59209f473ab3dcd9ae_MD5.webp"></p><p>2.微信数据迁移 (聊天记录等)</p><p>第一步：打开电脑微信，同理，点击菜单栏的设置</p><p><img src="/../../img/blog/6fab39cc1bd1d8c9c2919fa709b69a6a_MD5.webp"></p><p>第二步：弹出窗口如下图，选择 “ 文件管理 “ 栏目，我们会看到微信文件地默认保存位置都存放在 C 盘（占用空间比较大哦），选择其他空余的磁盘目录，点击 “ 更改 “ 即可。</p><p><img src="/../../img/blog/37bd5bac9f1cb95b31f1ca0f14298bb7_MD5.webp"></p><p>第三步：修改完毕会弹出如下图所示的迁移窗口</p><p><img src="/../../img/blog/038b9498df9dad80194ed61406fc4e01_MD5.webp"></p><p>经过 QQ 与微信数据（聊天记录）迁移，看看你的 C 盘是不是空出来了很多。</p><h1 id="Windows-11-22H2-开启-DoH（DNS-over-HTTPS）"><a href="#Windows-11-22H2-开启-DoH（DNS-over-HTTPS）" class="headerlink" title="Windows 11 22H2 开启 DoH（DNS over HTTPS）"></a>Windows 11 22H2 开启 DoH（DNS over HTTPS）</h1><p><a href="https://zhuanlan.zhihu.com/p/590105276">Windows 11 22H2开启 DoH（DNS over HTTPS） - 知乎 (zhihu.com)</a><br><a href="https://www.icoa.cn/a/953.html">Edge 和 Chrome 浏览器设置 DoH 加密 DNS 的方法-逍遥峡谷 (icoa.cn)</a></p><h1 id="在-Windows-11-中卸载-Microsoft-Edge-和阻止-Microsoft-Edge-重新安装"><a href="#在-Windows-11-中卸载-Microsoft-Edge-和阻止-Microsoft-Edge-重新安装" class="headerlink" title="在 Windows 11 中卸载 Microsoft Edge 和阻止 Microsoft Edge 重新安装"></a>在 Windows 11 中卸载 Microsoft Edge 和阻止 Microsoft Edge 重新安装</h1><p><a href="https://www.sysgeek.cn/windows-11-uninstall-microsoft-edge/">https://www.sysgeek.cn/windows-11-uninstall-microsoft-edge/</a></p><h1 id="gitbook-两个-bug-解决方法与修复工具"><a href="#gitbook-两个-bug-解决方法与修复工具" class="headerlink" title="gitbook 两个 bug 解决方法与修复工具"></a>gitbook 两个 bug 解决方法与修复工具</h1><p><a href="https://www.imxqy.com/soft/gitbook-repair.html">https://www.imxqy.com/soft/gitbook-repair.html</a></p><h1 id="在-Windows-上运行-Andriod-应用：WSA-安装说明"><a href="#在-Windows-上运行-Andriod-应用：WSA-安装说明" class="headerlink" title="在 Windows 上运行 Andriod 应用：WSA 安装说明"></a>在 Windows 上运行 Andriod 应用：WSA 安装说明</h1><p><a href="https://sysin.org/blog/wsa-install">https://sysin.org/blog/wsa-install</a></p>]]></content>
      
      
      <categories>
          
          <category> 归档 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Clion配置</title>
      <link href="/posts/%E6%9C%AC%E5%9C%B0/Clion%E9%85%8D%E7%BD%AE.html"/>
      <url>/posts/%E6%9C%AC%E5%9C%B0/Clion%E9%85%8D%E7%BD%AE.html</url>
      
        <content type="html"><![CDATA[<h1 id="主题推荐"><a href="#主题推荐" class="headerlink" title="主题推荐"></a>主题推荐</h1><p>我推荐使用新 UI + onedark 的组合（我目前所使用的）。</p><p>效果如下：</p><p><img src="/../../img/blog/88e12615834ebf321da6affceb85ca9b_MD5.webp" alt="主题1"></p><p>如果你使用的是旧版本的 UI，我之前经常使用的主题有以下三个：</p><ol><li><p>Atom Material Icons 效果大概如下，这个一个用于将文件夹颜色更明亮的插件，新 UI 暂时不可用<img src="/../../img/blog/9fc7eb29ba080b68a52f75c538ab550f_MD5.webp" alt="fileicon"></p></li><li><p>material-theme-ui：插件主页 <a href="https://link.juejin.cn/?target=https://plugins.jetbrains.com/plugin/8006-material-theme-ui" title="https://plugins.jetbrains.com/plugin/8006-material-theme-ui">plugins.jetbrains.com&#x2F;plugin&#x2F;8006…</a></p></li><li><p>one-dark-theme：插件主页 <a href="https://link.juejin.cn/?target=https://plugins.jetbrains.com/plugin/11938-one-dark-theme" title="https://plugins.jetbrains.com/plugin/11938-one-dark-theme">plugins.jetbrains.com&#x2F;plugin&#x2F;1193…</a></p></li></ol><h1 id="编辑器与-clang-format-设置"><a href="#编辑器与-clang-format-设置" class="headerlink" title="编辑器与 clang-format 设置"></a>编辑器与 clang-format 设置</h1><h2 id="鼠标滚轮改变字体大小"><a href="#鼠标滚轮改变字体大小" class="headerlink" title="鼠标滚轮改变字体大小"></a>鼠标滚轮改变字体大小</h2><p>Editor -&gt; General -&gt; Change font size with Ctrl+Mouse Wheel 打上勾就行。</p><p><img src="/../../img/blog/38d048c74f31da95d2718f2a160fc77a_MD5.webp" alt="mouse control"></p><h2 id="clang-format-的使用"><a href="#clang-format-的使用" class="headerlink" title="clang-format 的使用"></a>clang-format 的使用</h2><p>关于 clang-format 是什么，我截一段 chatgpt 的回答。</p><p><img src="/../../img/blog/7419f7ee138374a549afd555cdfb27c4_MD5.webp" alt="clang-format简介"></p><p>CLion 是自带 clang-format 的，你只需要开启即可，他会自动扫描项目根目录下的 clang-format 文件进行相应的格式化，开启后你每次创建一个新项目他也会自动生成一个 clang-format 文件到项目根目录，这个文件配置是根据 CLion 默认的格式化的格式来的，如果想要更改格式化风格，只需要更改 clang-formt 配置文件即可。</p><p>一般来说，我们只需要配置基本风格就行，一个.clang-format 文件大概长这样：</p><p><img src="/../../img/blog/1006bda458606b389bd355cb22603d24_MD5.webp" alt=".clang-format"></p><p>一般来说没有什么特殊需求，那么就只需要填写 BasedOnStyle 即可，是 Google 风格还是 LLVM 风格还是 Microsoft 风格，都取决于上述的前三行代码，后面的都可以不用写。我这个配置文件是想要使用 Google 的格式化风格，但是 Googel 风格默认的代码边距太短了，所以进行了一系列的调整。</p><p>下面是 CLion 如何开启 clang-format，开启后 CLion 对代码的格式化将会以你项目根目录的 clang-format 文件为主。</p><p><img src="/../../img/blog/22d7bda4a10573bfba11ef3a28ff984e_MD5.webp" alt="clang-format1"></p><h3 id="我的-clang-format-配置"><a href="#我的-clang-format-配置" class="headerlink" title="我的 .clang-format 配置"></a>我的 .clang-format 配置</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br></pre></td><td class="code"><pre><span class="line">BasedOnStyle: Google</span><br><span class="line">Language: Cpp</span><br><span class="line">AccessModifierOffset: -3</span><br><span class="line">AlignAfterOpenBracket: Align</span><br><span class="line">AlignConsecutiveMacros: AcrossComments</span><br><span class="line">AlignConsecutiveAssignments: AcrossComments</span><br><span class="line">AlignConsecutiveDeclarations: AcrossComments</span><br><span class="line">AlignEscapedNewlines: Left</span><br><span class="line">AlignOperands: true</span><br><span class="line">AlignTrailingComments: true</span><br><span class="line">AllowAllArgumentsOnNextLine: true</span><br><span class="line">AllowAllParametersOfDeclarationOnNextLine: true</span><br><span class="line">AllowShortBlocksOnASingleLine: Always</span><br><span class="line">AllowShortCaseLabelsOnASingleLine: true</span><br><span class="line">AllowShortFunctionsOnASingleLine: All</span><br><span class="line">AllowShortLambdasOnASingleLine: All</span><br><span class="line">AllowShortIfStatementsOnASingleLine: AllIfsAndElse</span><br><span class="line">AllowShortLoopsOnASingleLine: true</span><br><span class="line">AlwaysBreakAfterReturnType: None</span><br><span class="line">AlwaysBreakBeforeMultilineStrings: false</span><br><span class="line">AlwaysBreakTemplateDeclarations: Yes</span><br><span class="line">BinPackArguments: true</span><br><span class="line">BinPackParameters: true</span><br><span class="line">BraceWrapping:</span><br><span class="line">  AfterCaseLabel: false</span><br><span class="line">  AfterClass: true</span><br><span class="line">  AfterControlStatement: Always</span><br><span class="line">  AfterEnum: false</span><br><span class="line">  AfterFunction: true</span><br><span class="line">  AfterNamespace: false</span><br><span class="line">  AfterObjCDeclaration: false</span><br><span class="line">  AfterStruct: true</span><br><span class="line">  AfterUnion: true</span><br><span class="line">  AfterExternBlock: true</span><br><span class="line">  BeforeCatch: true</span><br><span class="line">  BeforeElse: true</span><br><span class="line"></span><br><span class="line">BreakBeforeBinaryOperators: None</span><br><span class="line">BreakBeforeBraces: Custom</span><br><span class="line">BreakBeforeInheritanceComma: false</span><br><span class="line">BreakInheritanceList: BeforeColon</span><br><span class="line">BreakBeforeTernaryOperators: true</span><br><span class="line">BreakConstructorInitializersBeforeComma: false</span><br><span class="line">BreakConstructorInitializers: BeforeColon</span><br><span class="line">BreakAfterJavaFieldAnnotations: false</span><br><span class="line">BreakStringLiterals: true</span><br><span class="line">ColumnLimit: 80</span><br><span class="line">CommentPragmas: &quot;^ NOLINT:&quot;</span><br><span class="line">CompactNamespaces: false</span><br><span class="line">ConstructorInitializerIndentWidth: 2</span><br><span class="line">ContinuationIndentWidth: 2</span><br><span class="line">Cpp11BracedListStyle: true</span><br><span class="line">DeriveLineEnding: true</span><br><span class="line">DerivePointerAlignment: true</span><br><span class="line">DisableFormat: false</span><br><span class="line">ExperimentalAutoDetectBinPacking: false</span><br><span class="line">FixNamespaceComments: true</span><br><span class="line">ForEachMacros:</span><br><span class="line">  - foreach</span><br><span class="line">  - Q_FOREACH</span><br><span class="line">  - BOOST_FOREACH</span><br><span class="line">IncludeBlocks: Regroup</span><br><span class="line">IncludeCategories:</span><br><span class="line">  - Regex: &#x27;^&lt;ext/.*.h&gt;&#x27;</span><br><span class="line">    Priority: 2</span><br><span class="line">    SortPriority: 0</span><br><span class="line">  - Regex: &#x27;^&lt;.*.h&gt;&#x27;</span><br><span class="line">    Priority: 1</span><br><span class="line">    SortPriority: 0</span><br><span class="line">  - Regex: &quot;^&lt;.*&quot;</span><br><span class="line">    Priority: 2</span><br><span class="line">    SortPriority: 0</span><br><span class="line">  - Regex: &quot;.*&quot;</span><br><span class="line">    Priority: 3</span><br><span class="line">    SortPriority: 0</span><br><span class="line">IncludeIsMainRegex: &quot;([-_](test|unittest))?$&quot;</span><br><span class="line">IncludeIsMainSourceRegex: &quot;&quot;</span><br><span class="line">IndentCaseLabels: true</span><br><span class="line">IndentGotoLabels: true</span><br><span class="line">IndentPPDirectives: None</span><br><span class="line">IndentWidth: 3</span><br><span class="line">IndentWrappedFunctionNames: false</span><br><span class="line">JavaScriptQuotes: Leave</span><br><span class="line">JavaScriptWrapImports: true</span><br><span class="line">KeepEmptyLinesAtTheStartOfBlocks: false</span><br><span class="line">MacroBlockBegin: &quot;&quot;</span><br><span class="line">MacroBlockEnd: &quot;&quot;</span><br><span class="line">MaxEmptyLinesToKeep: 1</span><br><span class="line">NamespaceIndentation: None</span><br><span class="line">ObjCBinPackProtocolList: Never</span><br><span class="line">ObjCBlockIndentWidth: 4</span><br><span class="line">ObjCSpaceAfterProperty: false</span><br><span class="line">ObjCSpaceBeforeProtocolList: true</span><br><span class="line">PenaltyBreakAssignment: 2</span><br><span class="line">PenaltyBreakBeforeFirstCallParameter: 1</span><br><span class="line">PenaltyBreakComment: 300</span><br><span class="line">PenaltyBreakFirstLessLess: 120</span><br><span class="line">PenaltyBreakString: 1000</span><br><span class="line">PenaltyBreakTemplateDeclaration: 10</span><br><span class="line">PenaltyExcessCharacter: 1000000</span><br><span class="line">PenaltyReturnTypeOnItsOwnLine: 200</span><br><span class="line">PointerAlignment: Right</span><br><span class="line">RawStringFormats:</span><br><span class="line">  - Language: Cpp</span><br><span class="line">    Delimiters:</span><br><span class="line">      - cc</span><br><span class="line">      - CC</span><br><span class="line">      - cpp</span><br><span class="line">      - Cpp</span><br><span class="line">      - CPP</span><br><span class="line">      - &quot;c++&quot;</span><br><span class="line">      - &quot;C++&quot;</span><br><span class="line">    CanonicalDelimiter: &quot;&quot;</span><br><span class="line">    BasedOnStyle: google</span><br><span class="line">  - Language: TextProto</span><br><span class="line">    Delimiters:</span><br><span class="line">      - pb</span><br><span class="line">      - PB</span><br><span class="line">      - proto</span><br><span class="line">      - PROTO</span><br><span class="line">    EnclosingFunctions:</span><br><span class="line">      - EqualsProto</span><br><span class="line">      - EquivToProto</span><br><span class="line">      - PARSE_PARTIAL_TEXT_PROTO</span><br><span class="line">      - PARSE_TEST_PROTO</span><br><span class="line">      - PARSE_TEXT_PROTO</span><br><span class="line">      - ParseTextOrDie</span><br><span class="line">      - ParseTextProtoOrDie</span><br><span class="line">    CanonicalDelimiter: &quot;&quot;</span><br><span class="line">    BasedOnStyle: google</span><br><span class="line">ReflowComments: true</span><br><span class="line">SortIncludes: CaseInsensitive</span><br><span class="line">SortUsingDeclarations: false</span><br><span class="line">SpaceAfterCStyleCast: false</span><br><span class="line">SpaceAfterLogicalNot: false</span><br><span class="line">SpaceAfterTemplateKeyword: true</span><br><span class="line">SpaceBeforeAssignmentOperators: true</span><br><span class="line">SpaceBeforeCpp11BracedList: false</span><br><span class="line">SpaceBeforeCtorInitializerColon: true</span><br><span class="line">SpaceBeforeInheritanceColon: true</span><br><span class="line">SpaceBeforeParens: ControlStatements</span><br><span class="line">SpaceBeforeRangeBasedForLoopColon: true</span><br><span class="line">SpaceInEmptyBlock: false</span><br><span class="line">SpaceInEmptyParentheses: false</span><br><span class="line">SpacesBeforeTrailingComments: 3</span><br><span class="line">SpacesInAngles: false</span><br><span class="line">SpacesInConditionalStatement: false</span><br><span class="line">SpacesInContainerLiterals: false</span><br><span class="line">SpacesInCStyleCastParentheses: false</span><br><span class="line">SpacesInParentheses: false</span><br><span class="line">SpacesInSquareBrackets: false</span><br><span class="line">SpaceBeforeSquareBrackets: false</span><br><span class="line">Standard: Auto</span><br><span class="line">StatementMacros:</span><br><span class="line">  - Q_UNUSED</span><br><span class="line">  - QT_REQUIRE_VERSION</span><br><span class="line">TabWidth: 4</span><br></pre></td></tr></table></figure><h1 id="编译工具链设置"><a href="#编译工具链设置" class="headerlink" title="编译工具链设置"></a>编译工具链设置</h1><h2 id="编译工具链的添加与解释"><a href="#编译工具链的添加与解释" class="headerlink" title="编译工具链的添加与解释"></a>编译工具链的添加与解释</h2><p>这个配置是进行 C++ 开发的关键，因为这个编译工具链就意味着 C++ 的编译环境。</p><p>按下图点开对应的信息，如果你任何编译工具链都没有添加，由于新版本的 CLion 它会自带一个 mingw 的编译套件，所以默认会有一个 CLion 自带的 mingw 编译工具链，如下图所示我的编译工具链稍微有点丰富，有 msvc、g++、clang++、mingw，作为一个刚刚入门学编程的新手，我建议编译工具链这一块暂时就没必要了解了，但在 CLion 中编译的具体配置流程我认为还是有必要讲清楚。<img src="/../../img/blog/e2c771d0ded72e510ad702f4cb46fc6a_MD5.webp" alt="bianyi"></p><p>CLion 中添加编译工具链非常简单，你本机把对应工具链的路径加入到了环境变量，那么在你点击 <code>+</code> 对应编译链类型后，会自动扫描到，如果实在没有扫描到，那么也可以自己填入对应的路径，整个编译链包括：</p><ol><li><p>cmake，用于跨平台以及简化底层编译脚本的工具。</p></li><li><p>cmake 生成更底层的编译命令 (对应上述的 Build Tool)，比如 gmake 也就是解析. makefile 文件进行命令执行，比如 ninja 解析 .ninja 文件进行命令执行（编译速度比 makefile 更快，亲身体验）。</p></li><li><p>C 语言的编译器 (clang&#x2F;gcc&#x2F;cl 等等)。</p></li><li><p>C++ 的编译器 (clang++&#x2F;g++&#x2F;cl 等等)。</p></li></ol><p>如果是 mingw，那么上述的一套都是包含的，只需要把 Toolset 这个选项选择为 mingw 对应的目录即可，选择好后，CLion 会自动识别上述四件套的位置。</p><p>接下来简单介绍如何添加一些工具链：</p><ul><li>安装 msvc 编译工具链：直接到官网下载 VS2022，然后安装对应 C++ 环境，打开 CLion 后添加 msvc 环境时就会自动识别。官网：<a href="https://link.juejin.cn/?target=https://visualstudio.microsoft.com/zh-hans/vs/" title="https://visualstudio.microsoft.com/zh-hans/vs/">visualstudio.microsoft.com&#x2F;zh-hans&#x2F;vs&#x2F;</a></li></ul><p>其实对于我们 C++ 程序员而言，最需要的就是一个 Linux 环境，因为很多底层的系统调用是不在 C++ 标准之内的，C++ 想要做到跨平台很难，所以我们需要把开发环境切换到 Linux 系统，正好 windows 提供了 Linux 子系统，也就是 wsl，完美的解决了这个问题，不要考虑日常的使用和开发环境我们到底选哪个了，我全都要！</p><p>而 CLion 对 wsl 的适配程度和正常的本机开发几乎没有任何区别，我们只需要现在 Windows 上安装 wsl2 后，CLion 便可以自动识别你本机的 wsl 环境了，但是你有了 wsl，并不意味着你有了对应的编译链，之前说了，编译链是包括四个东西的，你需要一一手动再 wsl 上先安装好，CLion 会自动识别到的，如果识别不到，由于是通过 <code>apt install</code> 命令安装的，大家应该都清楚在具体那个目录下，实在不清楚可以使用 <code>which</code> 命令。</p><ul><li>安装 wsl2：其实 wsl2 的安装已经被简化到了极致，在 powershell 中 <code>wsl --install</code> 即可。 具体的官方文档如下 <a href="https://link.juejin.cn/?target=https://learn.microsoft.com/zh-cn/windows/wsl/install" title="https://learn.microsoft.com/zh-cn/windows/wsl/install">learn.microsoft.com&#x2F;zh-cn&#x2F;windo…</a> ，一篇非常简练的博客教程：<a href="https://link.juejin.cn/?target=https://zhuanlan.zhihu.com/p/438255467" title="https://zhuanlan.zhihu.com/p/438255467">zhuanlan.zhihu.com&#x2F;p&#x2F;438255467</a>，如果安装遇到问题（大概率网络问题），请自行谷歌或百度或 bing 或 chatgpt。</li><li>如果需要使用 CLion 进行 Qt 开发，可以查看视频讲解：<a href="https://link.juejin.cn/?target=https://www.bilibili.com/video/BV18q4y1i7kV/" title="https://www.bilibili.com/video/BV18q4y1i7kV/">www.bilibili.com/video/BV18q…</a> ，对应的配置信息：<a href="https://link.juejin.cn/?target=https://gitee.com/yuexingqin/template_qtclion" title="https://gitee.com/yuexingqin/template_qtclion">gitee.com&#x2F;yuexingqin&#x2F;…</a></li><li>如果需要使用 CLion 进行 STM32 开发，那么可以查看稚晖君在知乎写的博客教程：<a href="https://link.juejin.cn/?target=https://zhuanlan.zhihu.com/p/145801160" title="https://zhuanlan.zhihu.com/p/145801160">zhuanlan.zhihu.com&#x2F;p&#x2F;145801160</a></li></ul><h2 id="cmake-配置项的添加与解释"><a href="#cmake-配置项的添加与解释" class="headerlink" title="cmake 配置项的添加与解释"></a>cmake 配置项的添加与解释</h2><p>解释完上述编译链后，我们发现 CLion 中有个很明显的 <code>default</code> 字眼，这个有什么用呢？</p><p>如果排在第一个的编译链，会被设置为默认编译链，如果想要其他的编译链为默认，点击上移即可。</p><p>至于具体的作用，别急，先等我讲完 CLion 中 cmake 配置项的处理。</p><p><img src="/../../img/blog/be20d186f43d21e980bb5a66c92d58bd_MD5.webp" alt="clion1"></p><p>如上图所示，第二个 <code>CMake</code> 选项就是我们现在要讲的东西，而这两个正好也是整个开发环境中最重要的东西，第一个编译工具链决定了 CLion 中已经识别了本机有哪些编译环境，而第二个 <code>CMake</code> 选项，则是用于配置 cmake 基于哪些配置项生成。</p><p>所以我们现在应该了解了 CLion 是如何去编译项目生成可执行文件的了。</p><ol><li><p>通过 cmake 配置选项运行整个项目的 CMakeList.txt</p></li><li><p>生成 makefile 或其他底层脚本后再通过对应的工具去执行这个脚本</p></li><li><p>运行编译好的程序</p></li></ol><p>而我们现在讲的就是添加 cmake 配置选项，如果你手动敲 cmake 命令的话，那样对应的就是命令行参数了。</p><p><img src="/../../img/blog/e8cae55de729fc524cfc69218e494ab9_MD5.webp" alt="clion3"></p><p>上述图片中已经解释了一些配置的作用。这些配置项一般是不常改动，使用默认值就行，比如 <code>Build options</code> 是执行最后的脚本所用的参数，默认为 <code>-j 12</code>，比如如果是 makefile，那么就是 <code>make -j12</code>。</p><p>下面是大家可能需要进行一些配置的选项：</p><ol><li><p>Build type：这是程序最终编译的类型，意味着编译器该以何种程度对源代码进行优化，比如 Debug 版本一般再 gcc 中对应 o2 的优化，release 版本对应 o3 的优化，两者一般存在 10 倍左右的性能差距。</p></li><li><p>Toolchain：这是前面所说的编译工具链，一般来说，想要切换编译器，你切换这个选项就行了，默认使用 default 工具链。</p></li><li><p>Generator：这是前面所说的工具链中的较为底层的脚本的运行工具，可以是 makefile 或者 ninja，不选的话也是默认工具链里的那个。</p></li><li><p>CMake options：这个是 cmake 运行时可以加入的命令行参数，比如我们可以 -D 来定义对应的变量控制对应的 cmake 行为，甚至于前面的 Build type 我们完全可以不写（当然这是 CLion，这个空必须得被填充），然后使用 -DCMAKE_BUILD_TYPE&#x3D;Release，这个变量可以决定最终 cmake 生成的执行脚本是按照 release 的标准去运行的，又比如 -DBUILD_SHARED_LIBS&#x3D;ON，那么最终是会生成动态库而不是静态库，我上图中的 -DENABLE_TEST&#x3D;ON 是内部的 cmake 有定义一个变量默认为 OFF 值，如果为 ON 时会加入测试代码为子项目。</p></li></ol><p>现在 cmake 在 CLion 中的配置项已经讲完了，简单实践一下来体验之前讲的 CLion 到整个运行的流程，我这里就直接配图了：</p><ol><li><p>通过 cmake 配置选项运行整个项目的 CMakeList.txt。<img src="/../../img/blog/4a465ad3b52d1bff6147583d7661fc75_MD5.webp" alt="clion4"></p></li><li><p>生成 makefile 或其他底层脚本后再通过对应的工具去执行这个脚本。我们先看一眼上一步 cmake 生成的文件（放出了两个不同的配置项产生的脚本，第一个使用的 Generator 为 ninja，第二个使用的为 gmake）：<img src="/../../img/blog/ab4d9f999e9c03e883f62955143b8f7c_MD5.webp" alt="clion5"> 如果想要继续执行这个脚本，应该在 CLion 中执行对应的源代码，CLion 会自动识别入口点函数，然后给出可执行的按钮，如图：<img src="/../../img/blog/de8e460363e1c84849bf05e20d615f9e_MD5.webp" alt="clion6"> 点击执行后，不仅会直接对应的 makefile 或 build. ninja 还会顺便把这个程序运行到 CLion 内置的终端环境中。</p></li><li><p>运行编译好的程序：这一步已经在第二步一并执行了。</p></li></ol><p>理解了这三步以及 cmake 的配置之后，我相信如果突然间 CLion 不出现执行程序的按钮，或者一个外部的项目我们无法跑起来，那么我们肯定是会有对应的排查思路了。比如没有执行程序的按钮，那可能对应的 cmake 配置项你还没设置好，如果外部项目跑不起来，你可以把那四个编译工具链中的某个换其他的环境试试？</p><h1 id="cmake-的使用与实战"><a href="#cmake-的使用与实战" class="headerlink" title="cmake 的使用与实战"></a>cmake 的使用与实战</h1><p>经过上述文字和图片讲解，我们很自然的想到，整个 CLion 运行 C++ 代码其实就是在运行 cmake 和 makefile(或 build.ninja)，第二个过程我们参与不了，但是第一个 cmake 的编写过程我们却需要一直接触。</p><p>下面用 CLion 新建项目自动生成的 cmake 模板来简单对 cmake 语法热热身。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cmake_minimum_required(VERSION 3.22)</span><br><span class="line">project(untitled)</span><br><span class="line"></span><br><span class="line">set(CMAKE_CXX_STANDARD 17)</span><br><span class="line"></span><br><span class="line">add_executable(untitled main.cpp)</span><br></pre></td></tr></table></figure><ul><li><code>cmake_minimum_required</code> 命令：规定了编译本项目的 cmake 工具至少需要 3.22 版本。</li><li><code>project</code> 命令：规定了本项目的项目名称，同时也根据这个传入的值生成了一堆变量，常用的如下：</li></ul><ol><li><p><code>PROJECT_NAME</code> ：项目名称</p></li><li><p><code>PROJECT_BINARY_DIR</code> ：项目的二进制文件目录，即编译后的可执行文件和库文件的输出目录</p></li><li><p><code>PROJECT_SOURCE_DIR</code> ：项目的源文件目录，即包含 CMakeLists.txt 文件的目录</p></li></ol><p>举个简单例子说明上述变量的作用： 比如一个测试的子项目中的 CMakeList.txt，可能需要写下面的语句（先不管 file 命令），由于是作为直接的子项目，那么里面肯定不会存在 project 语句，所以 PROJECT_SOURCE_DIR 变量表示的仍然是整个项目的根目录，直接通过 <code>$&#123;&#125;</code> 的形式来使用它即可，这样就不需要关心相对或绝对路径了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">file(GLOB SONIC_TEST_FILES</span><br><span class="line">     &quot;$&#123;PROJECT_SOURCE_DIR&#125;/tests/*.h&quot;</span><br><span class="line">     &quot;$&#123;PROJECT_SOURCE_DIR&#125;/tests/*.cpp&quot;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><ul><li><code>set</code> 命令：设置对应变量为对应的值，该变量存在，则修改该变量的值，如果不存在则会创建并初始化为对应的值，这里对 set 的使用是设置了 CMAKE_CXX_STANDARD 变量为 17，这个变量可以控制最终编译采用的 C++ 版本，这里是使用 C++17。</li><li><code>add_executable</code> 命令：这是用于生成可执行程序的命令，第一个参数为该执行程序最终编译后生成的文件名，后面跟着的都是需要编译的源代码。</li></ul><p>对于新手而言，其实不太需要自己手写 cmake，因为 CLion 会在你新建源文件的时候把相应源文件添加到 add_excutable 命令的后面，但项目稍微大一点或者说引入了很多外部库，那么大概率会抛弃 CLion 的这种自动化了。</p><h2 id="常用的-cmake-变量（入门）"><a href="#常用的-cmake-变量（入门）" class="headerlink" title="常用的 cmake 变量（入门）"></a>常用的 cmake 变量（入门）</h2><p>下面只列出了部分变量的作用，更多的变量请查看文档：<a href="https://link.juejin.cn/?target=https://cmake.org/cmake/help/latest/manual/cmake-variables.7.html" title="https://cmake.org/cmake/help/latest/manual/cmake-variables.7.html">cmake.org&#x2F;cmake&#x2F;help&#x2F;…</a></p><ul><li><code>PROJECT_NAME</code> ：项目名称</li><li><code>PROJECT_BINARY_DIR</code> ：项目的二进制文件目录，即编译后的可执行文件和库文件的输出目录</li><li><code>PROJECT_SOURCE_DIR</code> ：项目的源文件目录，即包含 CMakeLists.txt 文件的目录</li><li><code>CMAKE_BINARY_DIR</code> ：当前 CMake 运行的二进制文件目录，通常和 PROJECT_BINARY_DIR 是同一个目录</li><li><code>CMAKE_SOURCE_DIR</code> ：当前 CMake 运行的源文件目录，通常和 PROJECT_SOURCE_DIR 是同一个目录</li><li><code>CMAKE_C_STANDARD</code> ：指定 C 语言的标准版本</li><li><code>CMAKE_CXX_STANDARD</code> ：指定 C++ 语言的标准版本</li><li><code>CMAKE_CXX_FLAGS</code> ：指定编译 C++ 代码时使用的编译选项</li><li><code>CMAKE_C_FLAGS</code> ：指定编译 C 代码时使用的编译选项</li><li><code>CMAKE_EXE_LINKER_FLAGS</code> ：指定链接可执行文件时使用的链接选项</li><li><code>CMAKE_SYSTEM_NAME</code> ：指定当前操作系统名称（如 Windows、Linux 等）</li><li><code>CMAKE_SYSTEM_PROCESSOR</code> ：指定当前处理器的类型（如 x86、x86_64 等）</li><li><code>CMAKE_CXX_COMPILER_ID</code> ：指定了当前使用的 C++ 编译器，同理可得 C 的编译器对应的名字。</li></ul><p>对这些变量做一个简单的实践：</p><ol><li>通过 message 打印出 PROJECT_BINARY_DIR、PROJECT_SOURCE_DIR、CMAKE_BINARY_DIR、CMAKE_SOURCE_DIR 来加以验证。 目录结构：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">  ├── CMakeLists.txt</span><br><span class="line">  ├── main.cpp</span><br><span class="line">  └── sub</span><br><span class="line">      └── CMakeLists.txt</span><br></pre></td></tr></table></figure><p>cmake:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">main:</span><br><span class="line">    cmake_minimum_required(VERSION 3.14)</span><br><span class="line">    project(main)</span><br><span class="line">    </span><br><span class="line">    add_subdirectory(sub)</span><br><span class="line">    </span><br><span class="line">    message(STATUS &quot;main:$&#123;PROJECT_NAME&#125;\n  pro-src:$&#123;PROJECT_SOURCE_DIR&#125;\n pro-bin:$&#123;PROJECT_BINARY_DIR&#125;\n cmake-src:$&#123;CMAKE_SOURCE_DIR&#125;\n cmake-bin:$&#123;CMAKE_BINARY_DIR&#125;&quot;)</span><br><span class="line">    </span><br><span class="line">    sub:</span><br><span class="line">    project(sub)</span><br><span class="line">    </span><br><span class="line">    message(STATUS &quot;sub:$&#123;PROJECT_NAME&#125;\n  pro-src:$&#123;PROJECT_SOURCE_DIR&#125;\n pro-bin:$&#123;PROJECT_BINARY_DIR&#125;\n cmake-src:$&#123;CMAKE_SOURCE_DIR&#125;\n cmake-bin:$&#123;CMAKE_BINARY_DIR&#125;&quot;)</span><br></pre></td></tr></table></figure><p>打印信息如下：我们发现 CMake 对应的变量没有变化，而 Prject 有了变量，因为我们在 sub 也使用了 project 命令。<br>        <img src="/../../img/blog/ab5b458791433d39b9dff10131e59101_MD5.webp" alt="clion7"></p><ol><li>通过变量检测环境执行不同的 cmake 代码：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#判断当前的操作系统</span><br><span class="line">if (CMAKE_SYSTEM_NAME MATCHES &quot;Linux&quot;)</span><br><span class="line">    target_link_libraries(my-logger PUBLIC fmt-header-only pthread)</span><br><span class="line">    message(STATUS &quot;Now is Linux&quot;)</span><br><span class="line">elseif (CMAKE_SYSTEM_NAME MATCHES &quot;Windows&quot;)</span><br><span class="line">    target_link_libraries(my-logger PUBLIC fmt-header-only ws2_32)</span><br><span class="line">    message(STATUS &quot;Now is windows&quot;)</span><br><span class="line">endif ()</span><br><span class="line">#判断当前使用的编译器</span><br><span class="line">if (CMAKE_CXX_COMPILER_ID STREQUAL &quot;GNU&quot;)</span><br><span class="line">  # Do something for GCC</span><br><span class="line">elseif (CMAKE_CXX_COMPILER_ID STREQUAL &quot;Intel&quot;)</span><br><span class="line">  # Do something for Intel C++</span><br><span class="line">elseif (CMAKE_CXX_COMPILER_ID STREQUAL &quot;Microsoft&quot;)</span><br><span class="line">  # Do something for Microsoft Visual C++</span><br><span class="line">elseif (CMAKE_CXX_COMPILER_ID STREQUAL &quot;Clang&quot;)</span><br><span class="line">  # Do something for Clang</span><br><span class="line">endif()</span><br><span class="line"></span><br><span class="line">#判断当前的系统架构</span><br><span class="line">if (CMAKE_SYSTEM_PROCESSOR MATCHES &quot;i|x86|x86_64|AMD64&quot;)</span><br><span class="line">  # Do something for x86 architecture</span><br><span class="line">elseif (CMAKE_SYSTEM_PROCESSOR MATCHES &quot;^(arm|aarch64)&quot;)</span><br><span class="line">  # Do something for ARM architecture</span><br><span class="line">elseif (CMAKE_SYSTEM_PROCESSOR MATCHES &quot;^(mips|mipsel|mips64)&quot;)</span><br><span class="line">  # Do something for MIPS architecture</span><br><span class="line">elseif (CMAKE_SYSTEM_PROCESSOR MATCHES &quot;^(powerpc|ppc64)&quot;)</span><br><span class="line">  # Do something for PowerPC architecture</span><br><span class="line">endif()</span><br></pre></td></tr></table></figure><ol><li>通过调整链接时的 flag 防止动态链接，因为如果你是使用 Windows 平台下的编译工具链，CLion 有些时候最终链接并不是采用静态链接，导致你最终生成的可执行程序没法直接执行，这个时候你就需要使用下面的命令来强制静态链接了：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set(CMAKE_EXE_LINKER_FLAGS &quot;-static&quot;)</span><br></pre></td></tr></table></figure><h2 id="常用的-cmake-命令（入门）"><a href="#常用的-cmake-命令（入门）" class="headerlink" title="常用的 cmake 命令（入门）"></a>常用的 cmake 命令（入门）</h2><p>下列只列出了部分命令，如果你以后有需要用到的其他命令，请前往官网进行查询：<a href="https://link.juejin.cn/?target=https://cmake.org/cmake/help/latest/manual/cmake-commands.7.html" title="https://cmake.org/cmake/help/latest/manual/cmake-commands.7.html">cmake.org&#x2F;cmake&#x2F;help&#x2F;…</a></p><p>我个人较为常用的命令：</p><ol><li><p><a href="https://link.juejin.cn/?target=https://cmake.org/cmake/help/latest/command/project.html" title="https://cmake.org/cmake/help/latest/command/project.html">project</a>：用于定义项目名称、版本号和语言。</p></li><li><p><a href="https://link.juejin.cn/?target=https://cmake.org/cmake/help/latest/command/add_executable.html" title="https://cmake.org/cmake/help/latest/command/add_executable.html">add_executable</a>：用于添加可执行文件。第一个参数很重要，被称为 target，可以作为 target_xxx 命令的接收对象。</p></li><li><p><a href="https://link.juejin.cn/?target=https://cmake.org/cmake/help/latest/command/add_library.html" title="https://cmake.org/cmake/help/latest/command/add_library.html">add_library</a>：用于添加库文件，可以创建静态库或动态库。第一个参数很重要，被称为 target，可以作为 target_xxx 命令的接收对象。简单使用如下</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">add_library(test_lib a.cc b.cc) #默认生成静态库  </span><br><span class="line">add_library(test_lib SHARED a.cc b.cc) #默认生成静态库</span><br></pre></td></tr></table></figure><ol><li><p><a href="https://link.juejin.cn/?target=https://cmake.org/cmake/help/latest/command/add_definitions.html" title="https://cmake.org/cmake/help/latest/command/add_definitions.html">add_definitions</a>：用于添加宏定义，注意该命令没有执行顺序的问题，只要改项目中用了该命令定义宏，那么所有的源代码都会被定义这个宏 <code>add_definitions(-DFOO -DBAR …)</code> 。</p></li><li><p><a href="https://link.juejin.cn/?target=https://cmake.org/cmake/help/latest/command/add_subdirectory.html" title="https://cmake.org/cmake/help/latest/command/add_subdirectory.html">add_subdirectory</a>：用于添加子项目目录，如果有该条语句，就先会跑去执行子项目的 cmake 代码，这样会导致一些需要执行后立马生效的语句作用不到，比如 include_directories 和 link_directories 如果执行在这条语句后面，则他们添加的目录在子项目中无法生效。有些命令如 target_include_directories 和 target_link_directories 是根据目标 target 是否被链接使用来生效的，所以这些命令的作用范围与执行顺序无关，且恰好同一个 cmake 项目中产生的库文件是可以直接通过名称链接的，无论链接对象是在子目录还是父目录</p></li><li><p><a href="https://link.juejin.cn/?target=https://cmake.org/cmake/help/latest/command/target_link_libraries.html" title="https://cmake.org/cmake/help/latest/command/target_link_libraries.html">target_link_libraries</a>：用于将可执行文件或库文件链接到库文件或可执行文件。身为 target_xxx 的一员，很明显第二个参数也可以进行权限控制。</p></li><li><p><a href="https://link.juejin.cn/?target=https://cmake.org/cmake/help/latest/command/include_directories.html" title="https://cmake.org/cmake/help/latest/command/include_directories.html">include_directories</a>：用于指定头文件搜索路径，优点是简单直接，缺点是无法进行权限控制，一旦被执行后，后续的所有代码都能搜索到对应的文件路径。</p></li><li><p><a href="https://link.juejin.cn/?target=https://cmake.org/cmake/help/latest/command/target_include_directories.html" title="https://cmake.org/cmake/help/latest/command/target_include_directories.html">target_include_directories</a>：指定头文件搜索路径，并将搜索路径关联到一个 target 上，这里的 target 一般是指生成可执行程序命令里的 target 或者生成库文件的 target，与上一个命令的不同点在于可以设置导出权限，比如现在我写了一个项目，这个项目引入了其他库，但是我不想让其他库的符号暴露出去（毕竟使用这个项目的人只关注这个项目的接口，不需要关注其他依赖的接口）可以通过 PRIVATE 将头文件搜索目录设置不导出的权限。</p></li><li><p><a href="https://link.juejin.cn/?target=https://cmake.org/cmake/help/latest/command/link_directories.html" title="https://cmake.org/cmake/help/latest/command/link_directories.html">link_directories</a>：与前面的 include_directories 命令类似，添加的是库的搜索路径。</p></li><li><p><a href="https://link.juejin.cn/?target=https://cmake.org/cmake/help/latest/command/target_link_directories.html" title="https://cmake.org/cmake/help/latest/command/target_link_directories.html">target_link_directories</a>：和前面的 include 版本一样的，只是改成了库路径。</p></li><li><p>if\elseif\endif ，在编程语言立马已经用烂了，现在主要是了解 if(condition) 中的条件到底如何判断的，以及内部都支持哪些操作，比如大于等于啥的，这方面直接看官方文档吧，非常好懂：<a href="https://link.juejin.cn/?target=https://cmake.org/cmake/help/latest/command/if.html" title="https://cmake.org/cmake/help/latest/command/if.html">cmake.org&#x2F;cmake&#x2F;help&#x2F;…</a></p></li><li><p><a href="https://link.juejin.cn/?target=https://cmake.org/cmake/help/latest/command/aux_source_directory.html" title="https://cmake.org/cmake/help/latest/command/aux_source_directory.html">aux_source_directory</a>：这个指令简单实用，第一个参数传递一个文件目录，它会扫描这里面所有的源文件放到第二个参数定义的变量名中。注意第一个参数只能是文件夹。</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aux_source_directory($&#123;PROJECT_SOURCE_DIR&#125; SRC)</span><br></pre></td></tr></table></figure><ol><li><a href="https://link.juejin.cn/?target=https://cmake.org/cmake/help/latest/command/file.html" title="https://cmake.org/cmake/help/latest/command/file.html">file</a>：可以说是上面那个命令的增强版本，但如果熟悉这个命令的朋友肯定很快站出来反对，因为这个命令实在是太强大了，你如果翻一翻这个官方文档就会发现它具备几乎文件系统的所有功能，什么读写文件啊，什么从网上下载文件，本地上传文件之类的它都有，计算文件的相对路径，路径转化等等。但我们平时用到的最多的命令还是用来获取文件到变量里。比如 file(GLOB FILES “ 文件路径表示 1” “ 文件路径表示 2” …) GLOB 会产生一个由所有匹配 globbing 表达式的文件组成的列表，并将其保存到第二个参数定义的变量中。Globbing 表达式与正则表达式类似，但更简单，比如如果要实现前一个命令的功能可以这么写：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file(GLOB SRC &quot;$&#123;PROJECT_SOURCE_DIR&#125;/*.cc&quot;)</span><br></pre></td></tr></table></figure><p>如果 GLOB 换成 GLOB_RECURSE ，那么上述命令将递归的搜寻其子目录的所有符合条件的文件，而不仅仅是一个层级。</p><ol><li><a href="https://link.juejin.cn/?target=https://cmake.org/cmake/help/latest/command/execute_process.html" title="https://cmake.org/cmake/help/latest/command/execute_process.html">execute_process</a>：用于执行外部的命令，如下的示例代码是执行 git clone 命令，执行命令的工作目录在 <code>$&#123;CMAKE_BINARY_DIR&#125;/deps/</code></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">execute_process(COMMAND git clone https://github.com/&lt;username&gt;/&lt;repository&gt;.git</span><br><span class="line">                WORKING_DIRECTORY $&#123;CMAKE_BINARY_DIR&#125;/deps/&lt;repository&gt;)</span><br></pre></td></tr></table></figure><ol><li><p><a href="https://link.juejin.cn/?target=https://cmake.org/cmake/help/latest/command/message.html" title="https://cmake.org/cmake/help/latest/command/message.html">message</a>：打印出信息用于 debug。</p></li><li><p><a href="https://link.juejin.cn/?target=https://cmake.org/cmake/help/latest/command/option.html" title="https://cmake.org/cmake/help/latest/command/option.html">option</a>：用于快速设置定义变量并赋值为对应的 bool 值，常被用于判断某些操作是否执行。</p></li><li><p><a href="https://link.juejin.cn/?target=https://cmake.org/cmake/help/latest/command/find_package.html%23id5" title="https://cmake.org/cmake/help/latest/command/find_package.html#id5">find_package</a>：用于查找外界的 package，其实就是查找外界对应的 <code>&lt;package&gt;Config.cmake</code> 和 <code>Find&lt;package&gt;.cmake</code> 文件，这些文件里有外界包对应的变量信息以及库和头文件的各种路径信息。我们需要注意一些有关 <code>find_package</code> 命令查找 Config.cmake 路径的变量：</p></li></ol><ul><li><code>CMAKE_PREFIX_PATH</code> 变量是一个路径列表，CMake 会在这些路径中搜索包的 <code>Config.cmake</code> 文件。</li><li><code>&lt;Package&gt;_DIR</code> 变量是指向包的 <code>Config.cmake</code> 文件的路径。如果你手动设置了这个变量，那么 <code>find_package</code> 命令就可以找到包的信息。</li></ul><p>同时他的一些常用参数如下：</p><ul><li><code>CONFIG</code> ：显式指定 find_package 去查找 <code>&lt;package&gt;Config.cmake</code> 文件，一般只要你在变量里面指定了 <code>&lt;package&gt;Config.cmake</code> 的路径，那么该参数填不填都没差别。我建议最好还是带上该参数比较好。</li><li><code>REQUIRED</code> ：该参数表示如果没找到，那么直接产生 cmake 错误，退出 cmake 执行过程，如果没有 REQUIRED，则即使没找到也不会终止编译。</li><li><code>PATHS</code> ：这个参数的效果和前面的变量类似，也是指定查找的路径。</li><li><code>COMPONENTS</code> ：用于指定查找的模块，模块分离在不同的文件中，需要使用哪个就指定哪个模块。典型的就是使用 Qt 时的 cmake 代码，比如 <code>find_package(Qt5 COMPONENT Core Gui Widgets REQUIRED)</code> 。</li><li>VERSION：可能有很多个不同版本的包，则需要通过该参数来指定，如：<code>find_package(XXX VERSION 1.2.3)</code>。</li></ul><ol><li><a href="https://link.juejin.cn/?target=https://cmake.org/cmake/help/latest/command/include.html" title="https://cmake.org/cmake/help/latest/command/include.html">include</a>：从文件或模块加载并运行 CMake 代码。我用这个命令实际上只是为了使用 <a href="https://link.juejin.cn/?target=https://cmake.org/cmake/help/latest/module/FetchContent.html%23id1" title="https://cmake.org/cmake/help/latest/module/FetchContent.html#id1">FetchContent</a><a href="https://link.juejin.cn/?target=https://cmake.org/cmake/help/latest/module/FetchContent.html%23fetchcontent" title="https://cmake.org/cmake/help/latest/module/FetchContent.html#fetchcontent">¶</a> 这个 module 的功能，该功能是从 cmake3.11 开始支持的，使用该 module 前需要通过 include 命令加载该模块，命令如下：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">include(FetchContent)</span><br></pre></td></tr></table></figure><ol><li><a href="https://link.juejin.cn/?target=https://cmake.org/cmake/help/latest/module/FetchContent.html%23id1" title="https://cmake.org/cmake/help/latest/module/FetchContent.html#id1">FetchContent</a>：这是一个模块功能，它用来从代码仓库中拉取代码，例如我要把最近写的日志库引入到当前的项目中使用（注意这中间不会有任何代理，所以拉取 GitHub 的仓库可能失败）：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">include(FetchContent)#引入功能模块</span><br><span class="line"></span><br><span class="line">FetchContent_Declare(</span><br><span class="line">        my-logger   #项目名称</span><br><span class="line">        GIT_REPOSITORY https://github.com/ACking-you/my-logger.git #仓库地址</span><br><span class="line">        GIT_TAG        v1.6.2  #仓库的版本tag</span><br><span class="line">        GIT_SHALLOW TRUE    #是否只拉取最新的记录</span><br><span class="line">)</span><br><span class="line">FetchContent_MakeAvailable(my-logger)</span><br><span class="line"></span><br><span class="line">add_excutable(main $&#123;SRC&#125;)</span><br><span class="line">#链接到程序进行使用</span><br><span class="line">target_link_libraries(main my-logger)</span><br></pre></td></tr></table></figure><p>这样引入第三方库的好处显而易见，优点类似于包管理的效果了，但缺少了最关键的中心仓库来确保资源的有效和稳定。参考 golang 再做个 proxy 层级就好了。 同样可以拉取最新的 googletest 可以使用下列语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">FetchContent_Declare(</span><br><span class="line">        googletest</span><br><span class="line">        GIT_REPOSITORY https://github.com/google/googletest.git</span><br><span class="line">        GIT_TAG        release-1.12.1</span><br><span class="line">        GIT_SHALLOW TRUE</span><br><span class="line">)</span><br><span class="line"># For Windows: Prevent overriding the parent project&#x27;s compiler/linker settings</span><br><span class="line">set(gtest_force_shared_crt ON CACHE BOOL &quot;&quot; FORCE)</span><br><span class="line">FetchContent_MakeAvailable(googletest)</span><br><span class="line"></span><br><span class="line">target_link_libraries(main gtest_main)</span><br></pre></td></tr></table></figure><ol><li><a href="https://link.juejin.cn/?target=https://cmake.org/cmake/help/latest/command/function.html" title="https://cmake.org/cmake/help/latest/command/function.html">function&#x2F;endfunction</a> ：在 cmake 中用于定义函数，复用 cmake 代码的命令。第一个参数为函数的名称，后面为参数的名称，使用参数和使用变量时一样的，但是如果参数是列表类型，则在传入的时候就会被展开，然后与函数参数依次对应，多余的参数被 <code>ARGN</code> 参数吸收。</li></ol><p>更多较为常用的命令：</p><ul><li><a href="https://link.juejin.cn/?target=https://cmake.org/cmake/help/latest/command/add_custom_command.html" title="https://cmake.org/cmake/help/latest/command/add_custom_command.html">add_custom_command</a>：添加自定义规则命令，同样也是执行外界命令，但多了根据依赖和产物判断执行时机的作用。</li><li><a href="https://link.juejin.cn/?target=https://cmake.org/cmake/help/latest/command/install.html" title="https://cmake.org/cmake/help/latest/command/install.html">install</a>：添加 install 操作。</li><li><a href="https://link.juejin.cn/?target=https://cmake.org/cmake/help/latest/command/string.html" title="https://cmake.org/cmake/help/latest/command/string.html">string</a>：对 string 的所有操作，比如字符串替换啥的。</li><li><a href="https://link.juejin.cn/?target=https://cmake.org/cmake/help/latest/command/list.html" title="https://cmake.org/cmake/help/latest/command/list.html">list</a>：对 list 的所有操作，比如列表处理之类的。</li><li><a href="https://link.juejin.cn/?target=https://cmake.org/cmake/help/latest/command/foreach.html" title="https://cmake.org/cmake/help/latest/command/foreach.html">foreach</a>：cmake 中的 for 循环。</li><li>…</li></ul><p>利用上述命令实现 Qt 开发中调用 uic 工具把 大量的 <code>.ui</code> 文件转化为 <code>.cpp</code> 和 <code>.h</code> 文件，并实现当 ui 文件更新时或 <code>.cpp/.h</code> 文件不存在时才创建对应的 <code>.cpp/.h</code> 文件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#函数功能实现</span><br><span class="line">function(get_ui_source)</span><br><span class="line">foreach (item $&#123;ARGN&#125;)</span><br><span class="line">set(UIC_EXE_PATH $&#123;VCPKG_ROOT&#125;/installed/x64-windows/tools/qt5/bin/uic.exe)</span><br><span class="line">get_filename_component(name $&#123;item&#125; NAME_WLE)</span><br><span class="line">string(PREPEND name &quot;ui_&quot;)</span><br><span class="line">set(output_h $&#123;PROJECT_SOURCE_DIR&#125;/ui_gen/$&#123;name&#125;.h)</span><br><span class="line">set(output_cpp $&#123;PROJECT_SOURCE_DIR&#125;/ui_gen/$&#123;name&#125;.cpp)</span><br><span class="line">file(TIMESTAMP $&#123;item&#125; ui_time)</span><br><span class="line">#当.h 文件已经存在时，仅当.ui 文件被更新了才重新生成.h 文件</span><br><span class="line">if (EXISTS $&#123;output_h&#125;)</span><br><span class="line">file(TIMESTAMP $&#123;output_h&#125; h_time)</span><br><span class="line">if (ui_time GREATER h_time)</span><br><span class="line">execute_process(COMMAND $&#123;UIC_EXE_PATH&#125; $&#123;item&#125; -o $&#123;output_h&#125;)</span><br><span class="line">endif ()</span><br><span class="line">else ()</span><br><span class="line">execute_process(COMMAND $&#123;UIC_EXE_PATH&#125; $&#123;item&#125; -o $&#123;output_h&#125;)</span><br><span class="line">endif ()</span><br><span class="line">#当.cpp 文件已经存在时，仅当.ui 文件被更新了才重新生成.cpp 文件</span><br><span class="line">if (EXISTS $&#123;output_cpp&#125;)</span><br><span class="line">file(TIMESTAMP $&#123;output_cpp&#125; cpp_time)</span><br><span class="line">if (ui_time GREATER cpp_time)</span><br><span class="line">execute_process(COMMAND $&#123;UIC_EXE_PATH&#125; $&#123;item&#125; -o $&#123;output_cpp&#125;)</span><br><span class="line">endif ()</span><br><span class="line">else ()</span><br><span class="line">execute_process(COMMAND $&#123;UIC_EXE_PATH&#125; $&#123;item&#125; -o $&#123;output_cpp&#125;)</span><br><span class="line">endif ()</span><br><span class="line">endforeach ()</span><br><span class="line">endfunction()</span><br><span class="line"></span><br><span class="line">get_ui_source($&#123;UI_FILES&#125;) #功能的使用</span><br></pre></td></tr></table></figure><h1 id="ideaVim-的使用与设置"><a href="#ideaVim-的使用与设置" class="headerlink" title="ideaVim 的使用与设置"></a>ideaVim 的使用与设置</h1><p>关于 vim 的基本操作，这里就不细讲，网络上大把大把的教程，我这里只讲在 CLion 中怎么使用 vim，怎么配置 vim 让它在 CLion 中更好用。</p><p>在使用 ideaVim 前，我们需要先下载 IdeaVim 这个拓展，ideaVim 的链接：<a href="https://link.juejin.cn/?target=https://plugins.jetbrains.com/plugin/164-ideavim" title="https://plugins.jetbrains.com/plugin/164-ideavim">plugins.jetbrains.com&#x2F;plugin&#x2F;164-…</a>，下载好后，应该是默认启用了的。</p><p>一、配置 ctrl+c 和 ctrl+v 和 ctrl+a 防止这些你常用的快捷键被 vim 占用</p><p><img src="/../../img/blog/ea65ef8d63700932304f37cd6a03b3ce_MD5.webp" alt="clion8"></p><p><img src="/../../img/blog/9b6f9bdd71f86623aa79f719cd9bb29c_MD5.webp" alt="clion8"></p><p>二、配置.ideavimrc。</p><p>点击 <code>Open ~/.ideavimrc</code> 后，加入下面的配置（这是我个人使用的配置）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">let mapleader = &quot;,&quot;</span><br><span class="line">let g:mapleader = &quot;,&quot;</span><br><span class="line">set timeoutlen=300</span><br><span class="line"></span><br><span class="line">&quot; general</span><br><span class="line">imap jk &lt;Esc&gt;</span><br><span class="line">imap kj &lt;Esc&gt;</span><br><span class="line">vnoremap q &lt;Esc&gt;</span><br><span class="line">nmap &lt;C-o&gt; :action Back&lt;CR&gt;</span><br><span class="line">nmap &lt;C-i&gt; :action Forward&lt;CR&gt;</span><br><span class="line">nnoremap &lt;Leader&gt;r :&lt;C-u&gt;action RenameElement&lt;CR&gt;</span><br><span class="line"></span><br><span class="line">&quot; Redo</span><br><span class="line">nnoremap U &lt;C-r&gt;</span><br><span class="line"></span><br><span class="line">&quot; code editing</span><br><span class="line">nnoremap == :&lt;C-u&gt;action ReformatCode&lt;CR&gt;</span><br><span class="line">vnoremap == :&lt;C-u&gt;action ReformatCode&lt;CR&gt;</span><br><span class="line">nnoremap cc :&lt;C-u&gt;action CommentByLineComment&lt;CR&gt;</span><br><span class="line">vnoremap cc :&lt;C-u&gt;action CommentByLineComment&lt;CR&gt;</span><br><span class="line"></span><br><span class="line">&quot; Run and debug</span><br><span class="line">nnoremap \r :action RunClass&lt;cr&gt;</span><br><span class="line">nnoremap \i :&lt;C-u&gt;action OptimizeImports&lt;CR&gt;</span><br><span class="line">nnoremap \R :action Run&lt;cr&gt;</span><br><span class="line"></span><br><span class="line">nnoremap [[ :action MethodUp&lt;cr&gt;</span><br><span class="line">nnoremap ]] :action MethodDown&lt;cr&gt; </span><br></pre></td></tr></table></figure><p>加入后点击右上角的小图标进行刷新即可。</p><p><img src="/../../img/blog/bd92c93c5430e968753dbdc0787e958c_MD5.webp" alt="ideavim"></p><p>上述配置文件实现了下面的功能：</p><ol><li><p>按下 j+k 或者 k+j 将会退出插入模式。</p></li><li><p>在可视模式下按 q 退出。</p></li><li><p>ctrl+o 可以实现指针回退到上一次的位置，ctrl+i 前进到上次的位置。可以类比为 VS 李的前进和后退按钮（一般查看定义查看的比较深，可以使用该命令回退或前进）。</p></li><li><p>, + r 可以实现 CLion 中的重构变量名。</p></li><li><p>U 取消撤销（由于 vim 中按 u 是撤销，而取消撤销需要 ctrl+r，这让人很不习惯）</p></li><li><p>&#x3D; + &#x3D;实现代码格式化。</p></li><li><p>c + c 实现代码注释</p></li><li><p>[ + [跳转到前一个函数位置</p></li><li><p>] + ] 跳转到下一个函数位置</p></li><li><p>\ + r 运行当前的可执行程序（如果当前代码段里面有运行按钮的话）</p></li><li><p>\ + R 运行当前可执行程序，这个是直接相当于按了右上角的三角按钮运行</p></li><li><p>\ + i 优化导入的包</p></li></ol><p>C++ 后端</p><ul><li><a href="https://circlereader.com/">官方主页</a></li><li><a href="https://circlereader.com/download">下载新版</a></li><li><a href="https://support.qq.com/products/317910">问题反馈</a></li><li><a href="https://circlereader.com/donate">捐赠支持 ❤️</a></li></ul><p>浏览器扩展 Circle 阅读助手排版，版权归 juejin.cn 所有</p>]]></content>
      
      
      <categories>
          
          <category> 本地 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>归档1</title>
      <link href="/posts/%E5%BD%92%E6%A1%A3/%E5%BD%92%E6%A1%A31.html"/>
      <url>/posts/%E5%BD%92%E6%A1%A3/%E5%BD%92%E6%A1%A31.html</url>
      
        <content type="html"><![CDATA[<h1 id="油猴脚本访问本地文件"><a href="#油猴脚本访问本地文件" class="headerlink" title="油猴脚本访问本地文件"></a>油猴脚本访问本地文件</h1><h2 id="Chrome-浏览器如何开启文件访问权限"><a href="#Chrome-浏览器如何开启文件访问权限" class="headerlink" title="Chrome 浏览器如何开启文件访问权限"></a>Chrome 浏览器如何开启文件访问权限</h2><p>点击右侧三个点 -》更多工具 -》拓展程序 -》详情</p><p><img src="/../../img/blog/4273299c4c579271d48f0ac66f0c88a7_MD5.png" alt="图片.png" title="图片.png"></p><p>打开允许访问文件网址</p><p><img src="/../../img/blog/0f54277cfaba5532eec2d80e0ac5e5ac_MD5.png" alt="图片.png" title="图片.png"></p><h2 id="火狐浏览器如何开启文件访问权限"><a href="#火狐浏览器如何开启文件访问权限" class="headerlink" title="火狐浏览器如何开启文件访问权限"></a>火狐浏览器如何开启文件访问权限</h2><p>FireFox 默认没有提供一个页面可以设置这个选项，但可以通过修改浏览器的配置项，来达到目地。</p><p>具体方法如下：</p><p>I: 在地址栏输入 <code>about:config</code> 并回车, 进入配置项页面 (可能会有一个警告页面，直接点击按钮进入就好了）。</p><p>II: 配置以下三项</p><table><thead><tr><th>条目名称</th><th>值</th><th>提醒</th></tr></thead><tbody><tr><td>capability.policy.policynames</td><td>localfilelinks</td><td>-</td></tr><tr><td>capability.policy.localfilelinks.sites</td><td>moz-extension:&#x2F;&#x2F;612ab18c-c29e-4211-bd50-3f208d227db7</td><td>这个值，你应该使用自己拿到的 <code>扩展标识</code>, 如果你允许多个扩展的话，这里用空格隔开</td></tr><tr><td>capability.policy.localfilelinks.checkloaduri.enabled</td><td>allAccess</td><td>-</td></tr></tbody></table><p>这样操作:</p><p>复制条目名称，粘帖到搜索栏进行搜索, 如果搜索到，就双击修改它的值就行了。</p><p>如果没有搜索到，就鼠标右键 &gt; 新建 &gt; 字符串 (String)，把 <code>条目名称</code> 和 <code>值</code> 依次粘帖进去即可。</p><h2 id="打开-Tampermonkey-文件访问地址"><a href="#打开-Tampermonkey-文件访问地址" class="headerlink" title="打开 Tampermonkey 文件访问地址"></a>打开 Tampermonkey 文件访问地址</h2><p>打开设置 -》高级</p><p><img src="/../../img/blog/d79d945c4e0e893c85f498c0bccb994a_MD5.png" alt="图片.png" title="图片.png"></p><p>进入安全项 -》允许脚本访问本地文件，选择所有本地文件，修改后保存</p><p><img src="/../../img/blog/fbc81377c82c6f738e61cf3c66931d67_MD5.png" alt="图片.png" title="图片.png"></p><h2 id="修改脚本"><a href="#修改脚本" class="headerlink" title="修改脚本"></a>修改脚本</h2><p>在脚本中添加以下内容并保存</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// @match          file:///*</span><br></pre></td></tr></table></figure><h1 id="CSDN-下载文章"><a href="#CSDN-下载文章" class="headerlink" title="CSDN 下载文章"></a>CSDN 下载文章</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">(function doPrint()&#123;      </span><br><span class="line">&#x27;use strict&#x27;;</span><br><span class="line">var articleBox = $(&quot;div.article_content&quot;);</span><br><span class="line">articleBox.removeAttr(&quot;style&quot;);</span><br><span class="line">var head_str = &quot;&quot;;       </span><br><span class="line">var foot_str = &quot;&quot;;   </span><br><span class="line">var older = document.body.innerHTML;       </span><br><span class="line">var title= document.getElementsByClassName(&#x27;article-title-box&#x27;)[0].innerHTML; </span><br><span class="line">var main_body = document.getElementsByClassName(&#x27;article_content&#x27;)[0].innerHTML;</span><br><span class="line">document.body.innerHTML = head_str + title + main_body + foot_str;</span><br><span class="line">$(&quot;#mainBox&quot;).width(&quot;100%&quot;);</span><br><span class="line">document.getElementsByTagName(&#x27;body&#x27;)[0].style.zoom=0.8;     </span><br><span class="line">window.print();</span><br><span class="line">document.body.innerHTML = older;</span><br><span class="line">return false;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/p1279030826/article/details/106602341">【新】CSDN文章一键打印、输出PDF（自动阅读全文、全清爽模式）csdn打印_JavonPeng的博客-CSDN博客</a></p><h1 id="kms-激活-office-visio2019"><a href="#kms-激活-office-visio2019" class="headerlink" title="kms 激活 office+visio2019"></a>kms 激活 office+visio2019</h1><p><a href="https://www.cnblogs.com/shan333/p/14894774.html">kms 激活 office+visio2019</a></p><h2 id="一、kms-激活-office-2019"><a href="#一、kms-激活-office-2019" class="headerlink" title="一、kms 激活 office 2019"></a><strong>一、kms 激活 office 2019</strong></h2><p>1、<strong>卸载干净 office 有关产品</strong>：先把自己电脑上所有关于 office 的产品卸载干净，然后才开始使用 office tool 安装和激活 office 2019；</p><p>2、<strong>下载 office Tool plus 工具</strong>：下载那个比较全的那个包吧，最大那个 [即<strong>第一个安装包</strong>]；官网： <a href="https://otp.landian.vip/zh-cn/download.html">https://otp.landian.vip/zh-cn/download.html</a></p><p>3、<strong>解压 office tool plus 工具包，移除残留的旧 office</strong>：先解压 office Tool plus 工具包，利用 office Tool plus 工具 [Office Tool Plus. exe]，先把自己电脑的老版本 office 卸载了:  双击 Office Tool Plus. exe，选择  <strong>工具箱 -》修复工具 -》移除 office-》使用 office Tool plus 移除 office-》开始</strong></p><p>4、<strong>部署</strong>：点击  <strong>部署</strong></p><p><img src="/../../img/blog/39f707e55ae7cc259c78dc8feedff9cf_MD5.png"></p><p><strong>按上图，选好、设置好后，点击当前页面右上角的开始部署</strong></p><p>5、<strong>激活</strong>：点击  <strong>激活</strong></p><p><img src="/../../img/blog/34e7f96c985852aa6812ba0c920ba89a_MD5.png"></p><p><strong>按上图，</strong>  选好、填好，点击当前页面右上角的激活</p><p><strong>✿  密钥管理填写   NMMKJ-6 RK 4 F-KMJVX-8 D 9 MJ-6 MWKP，KMS 服务器，填写 kms. 03 k. org</strong></p><p>■ 备用的秘钥： N 9 J 9 Q-Q 7 MMP-XDDM 6-63 KKP-76 FPM</p><p>■ 备用的 KMS 主机： <a href="https://catqu.com/?p=111">kms.catqu.com</a></p><p><strong>▷  注意细节：复制粘贴的时候，不要多复制了空格哈~</strong></p><hr><h2 id="二、kms-激活-visio-2019"><a href="#二、kms-激活-visio-2019" class="headerlink" title="二、kms 激活 visio 2019"></a><strong>二、kms 激活 visio 2019</strong></h2><p>1、安装 visio 2019，同样部署、激活：<br>部署时选择 + 添加产品：选择 visio 专业版 2019 批量版</p><p>然后那些系数，就用安装 office 时的系数，点击开始部署，部署完就激活：</p><p><img src="/../../img/blog/003beba19ea0eeea637c70aa9f54f72b_MD5.png"></p><p><strong>密钥管理填写   9 BGNQ-K 37 YR-RQHF 2-38 RQ 3-7 VCBB，KMS 服务器，填写 kms. 03 k. org</strong></p><hr><h2 id="三、注意事项："><a href="#三、注意事项：" class="headerlink" title="三、注意事项："></a><strong>三、注意事项：</strong></h2><p><strong>仅批量版 (Volume) 支持 KMS 激活</strong>，<strong>零售版 (Retail) 不支持使用 KMS 激活。</strong>    <strong>KMS 有效期为 180 天，正常情况下系统会自动续期，所以不用担心过期，除非服务器挂了。</strong></p><p>除了使用这些公网 KMS 外，还可自行搭建 KMS 使用，具体请自行查找相关资料。</p><p>部分 KMS 可能会因为地区问题在某些地方不可用，建议使用前自行检测可用性。</p><p><strong>使用 KMS 激活并不会显著影响 Office 的功能，</strong>无法登录账号是因为 Windows 系统太旧、Internet Explorer 问题或者网络问题，与使用 KMS 无关。</p><hr><h2 id="四、KMS-地址列表"><a href="#四、KMS-地址列表" class="headerlink" title="四、KMS 地址列表"></a><strong>四、KMS 地址列表</strong></h2><p><strong>■ 好用、常用几个如下：</strong></p><p><strong>****</strong><a href="https://03k.org/kms.html">kms.03k.org</a><strong>****</strong></p><p><strong><strong>**</strong></strong><a href="https://catqu.com/?p=111">kms.catqu.com</a><strong><strong>**</strong></strong></p><p><strong><a href="https://www.ghpym.com/kms.html">kms.ghpym.com</a></strong></p><p>参考文章： <a href="https://juejin.cn/post/6844903746485354504">https://juejin.cn/post/6844903746485354504</a> 《安装和激活 Office 2019》</p><p><a href="https://www.coolhub.top/tech-articles/kms_list.html">https://www.coolhub.top/tech-articles/kms_list.html</a> 《KMS 地址列表》</p><h1 id="visio-使用"><a href="#visio-使用" class="headerlink" title="visio 使用"></a>visio 使用</h1><p><a href="https://zhuanlan.zhihu.com/p/341329517">visio教程：如何调整连接线上文字的位置</a><br><a href="https://blog.csdn.net/zz603976046/article/details/109079481">visio如何使箭头指向插图的任意一处</a></p><h1 id="坚果云清除"><a href="#坚果云清除" class="headerlink" title="坚果云清除"></a>坚果云清除</h1><p> <strong>文件资源管理器图标删除</strong></p><p>使用电脑应用管理删除坚果云</p><p><strong>Windows 清理桌面右键菜单中新增选项中的多余选项</strong></p><p>在卸载坚果云时一开始没注意，最近在使用的时候发现右键新增的里面出现了 <code>.nol</code> 等坚果云的文件，于是找了一下能删除多余选项的方法。感觉自己以后还能用到所以记下来方便自己查阅。</p><ol><li><p>找到需要删去选项对应的扩展名</p></li><li><p>打开注册表编辑器</p></li><li><p><code>HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Explorer\Discardable\PostSetup\ShellNew\Classes</code></p><p> <img src="/../../img/blog/%E5%9D%9A%E6%9E%9C%E4%BA%91%E6%B8%85%E9%99%A4-1.png"></p></li><li><p>删去其中你不要的扩展名</p><p> <img src="/../../img/blog/65510735567700606.png"></p></li><li><p>按照以上步骤操作完成后，发现已经消失的残留项再次出现，说明软件卸载后，注册表未清理干净。请按照以下路径寻找【<code>HKEY_CLASSES_ROOT\.gf\ShellNew</code>】，右键单击【NullFile】，左键单击【删除（D）】。</p></li></ol><p>[<img src="/../../img/blog/06701246621604386.png"></p><blockquote><p>我自己并没有出现 <code>NullFile</code> 选项，我选择将整个 ShellNew 都给删去了</p></blockquote><p>此时回到桌面查看右键新建菜单应该已经清理完毕</p><h1 id="病毒免杀工具"><a href="#病毒免杀工具" class="headerlink" title="病毒免杀工具"></a>病毒免杀工具</h1><h2 id="Backdoor-factory"><a href="#Backdoor-factory" class="headerlink" title="Backdoor-factory"></a>Backdoor-factory</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p><a href="https://github.com/secretsquirrel/the-backdoor-factory">secretsquirrel&#x2F;the-backdoor-factory: Patch PE, ELF, Mach-O binaries with shellcode new version in development, available only to sponsors (github.com)</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker pull secretsquirrel/the-backdoor-factory</span><br><span class="line">sudo docker run -it -v /home/icefjl:/home/tmp:Z secretsquirrel/the-backdoor-factory bash</span><br></pre></td></tr></table></figure><h3 id="⾸先检查宿主能否被⽀持-“-插入-“shellcode。"><a href="#⾸先检查宿主能否被⽀持-“-插入-“shellcode。" class="headerlink" title="⾸先检查宿主能否被⽀持 “ 插入 “shellcode。"></a>⾸先检查宿主能否被⽀持 “ 插入 “shellcode。</h3><p>主要使⽤下⾯两个参数 -f：指定测试程序 -S：检查该程序是否支持<br>检查命令: .&#x2F;backdoor. py -f &#x2F;root&#x2F;putty. exe -S</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -no-pie hello.c -o hello</span><br></pre></td></tr></table></figure><h3 id="搜索该⽂件可⽤的-Code-Caves-代码缝隙"><a href="#搜索该⽂件可⽤的-Code-Caves-代码缝隙" class="headerlink" title="搜索该⽂件可⽤的 Code Caves (代码缝隙)"></a>搜索该⽂件可⽤的 Code Caves (代码缝隙)</h3><p>使⽤命令 .&#x2F;backdoor. py -f test. exe -c -l 600<br>-c：code cave (代码裂缝) -l：代码裂缝大小</p><h3 id="获取该⽂件的可⽤-Payload"><a href="#获取该⽂件的可⽤-Payload" class="headerlink" title="获取该⽂件的可⽤ Payload"></a>获取该⽂件的可⽤ Payload</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./backdoor.py -f /root/putty.exe -s -show</span><br></pre></td></tr></table></figure><h2 id="Metaspoit"><a href="#Metaspoit" class="headerlink" title="Metaspoit"></a>Metaspoit</h2><h3 id="使⽤-Backdoor-的-user-supplied-shellcode-模块加载⾃定义的-Shellcode"><a href="#使⽤-Backdoor-的-user-supplied-shellcode-模块加载⾃定义的-Shellcode" class="headerlink" title="使⽤ Backdoor 的 user_supplied_shellcode 模块加载⾃定义的 Shellcode"></a>使⽤ Backdoor 的 user_supplied_shellcode 模块加载⾃定义的 Shellcode</h3><p>先⽤ msfvenom ⽣成 raw 格式的 shellcode<br>再使用 backdoor 的 user_supplied_shellcode 模块加载⾃定义的 shellcode</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./backdoor.py -f /home/tmp/ -s user_supplied_shellcode -U /home/tmp/tp1.shell -o payload2</span><br></pre></td></tr></table></figure><h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><p>运行下面的命令来初始化其数据库。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo mfsdb init</span><br></pre></td></tr></table></figure><p>通过运行下面的命令来启动 Metasploit。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ msfconsole</span><br></pre></td></tr></table></figure><h3 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h3><p>MSF 框架由多个模块组成，几个主要模块及其具体功能如下。</p><ol><li><p>Auxiliaries（辅助模块）</p><p> 该模块不会直接在测试者和目标主机之间建立访问，它们只会负责执行扫描、嗅探、识别等相关功能以辅助渗透测试。</p></li><li><p>Exploit（漏洞利用模块）</p><p> 漏洞利用模块用于以允许框架执行任意代码的方式利用漏洞。执行的任意代码称为有效载荷。</p></li><li><p>Payload（攻击载荷模块）</p><p> 在 Metasploit 漏洞利用模块的上下文中，有效负载模块封装了作为漏洞利用成功结果而执行的任意代码（shellcode）。这通常涉及创建 Metasploit 会话，但可能会执行代码，例如添加用户帐户，或执行一个简单的 pingback 命令来验证代码是否成功针对易受攻击的目标执行。</p></li><li><p>Post（后期渗透模块）</p><p> 该模块主要用于在取得目标系统远程控制权后，进行一系列的后渗透攻击动作，如获取敏感信息、实施跳板攻击等。</p></li><li><p>Encoders（编码工具模块）</p><p> 编码器接收有效载荷的原始字节并运行某种编码算法，例如按位异或。这些模块对于编码诸如空字节之类的不良字符非常有用。</p></li></ol><p>使用 MSF 渗透测试时，可以综合使用以上模块，对目标系统进行侦察并发动攻击，大致的步骤如下所示。</p><ul><li>扫描目标机系统，寻找可用漏洞。</li><li>选择并配置一个漏洞利用模块。</li><li>选择并配置一个攻击载荷模块。</li><li>选择一个编码技术，用来绕过杀毒软件的查杀。</li><li>渗透攻击。</li></ul><h3 id="Msfvenom"><a href="#Msfvenom" class="headerlink" title="Msfvenom"></a>Msfvenom</h3><p><a href="https://blog.csdn.net/RFZ_322/article/details/123367668">(13 条消息) Kali 利用 msf 渗透 Windows 电脑（超详细）_kali msf_HonkerG 的博客-CSDN 博客</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat test1.elf | msfvenom -p - -a x64 --platform linux -e x86/shikata_ga_nai -f elf -o test1e.elf</span><br></pre></td></tr></table></figure><h2 id="免杀项目"><a href="#免杀项目" class="headerlink" title="免杀项目"></a>免杀项目</h2><h3 id="专利"><a href="#专利" class="headerlink" title="专利"></a>专利</h3><ul><li><a href="https://github.com/scmanjarrez/pymetangine">scmanjarrez&#x2F;pymetangine: A python metamorphic engine for PE&#x2F;PE+ files. (github.com)</a></li><li><a href="https://github.com/OmegaPointZero/Caveman">https://github.com/OmegaPointZero/Caveman</a></li><li><a href="https://github.com/guitmz/ezuri">https://github.com/guitmz/ezuri</a></li><li><a href="https://github.com/sebastiencs/Packer_ELF">sebastiencs&#x2F;Packer_ELF: ELF packer - x86_64 (github.com)</a></li></ul><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul><li><a href="https://github.com/jakuta-tech/GhostShell">https://github.com/jakuta-tech/GhostShell</a></li><li><a href="https://github.com/elfmaster/maya">https://github.com/elfmaster/maya</a></li><li><a href="https://github.com/wdblair/packitup">https://github.com/wdblair/packitup</a></li><li><a href="https://github.com/invokr/elf-stuff">https://github.com/invokr/elf-stuff</a></li><li><a href="https://github.com/terminaldweller/mutator">https://github.com/terminaldweller/mutator</a></li><li><a href="https://github.com/compilepeace/KAAL_BHAIRAV">https://github.com/compilepeace/KAAL_BHAIRAV</a></li><li><a href="https://github.com/AidenPearce369/elfxtract">https://github.com/AidenPearce369/elfxtract</a></li></ul><h1 id="vscode-和-vs2019-代码行数统计"><a href="#vscode-和-vs2019-代码行数统计" class="headerlink" title="vscode 和 vs2019 代码行数统计"></a>vscode 和 vs2019 代码行数统计</h1><h2 id="1、vscode-代码行数统计"><a href="#1、vscode-代码行数统计" class="headerlink" title="1、vscode 代码行数统计"></a>1、vscode 代码行数统计</h2><p>按 Ctrl+Shift+X 在插件市场搜索 VS Code Counter 点击安装<br>按住按 Ctrl+Shift+P 在命令输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Count lines in workspace</span><br></pre></td></tr></table></figure><p><img src="/../../img/blog/d42fe65ec918b634c00fa3a605acfc78_MD5.png"><br><img src="/../../img/blog/bcf1882238e3552922259a84188023ef_MD5.png"></p><h2 id="2、Visual-Studio-代码行数统计"><a href="#2、Visual-Studio-代码行数统计" class="headerlink" title="2、Visual Studio 代码行数统计"></a>2、Visual Studio 代码行数统计</h2><p>选中解决方案<br>按 [Ctrl+Shift+F] 弹出查找窗口（不统计以#号开头、以&#x2F;开头的代码和空行）<br>1、输入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b*[^:b#/]+.*$</span><br></pre></td></tr></table></figure><p>2、选择使用正则表达式<br><img src="/../../img/blog/eed9780aadfde534a667b8c9153de5a8_MD5.png"></p><h1 id="1-1-1-1（App）"><a href="#1-1-1-1（App）" class="headerlink" title="1.1.1.1（App）"></a>1.1.1.1（App）</h1><ul><li><a href="https://limbopro.com/archives/956.html">1.1.1.1（App）- Cloudflare DNS &amp; 免费 WARP+ VPN 以及一键刷 Cloudflare warp+ 无限（24PB+）邀请流量 - 毒奶 - 欢迎使用代理访问本站。 (limbopro.com)</a></li><li><a href="https://zhuanlan.zhihu.com/p/636708211">Cloudflare 加入及创建零信任zero trust团队 - 知乎 (zhihu.com)</a></li><li><a href="https://www.chaipip.com/">高精度IP地址查询|查IP|IP地址查询|IP定位|精确定位|百度高精度IP-www.chaipip.com</a></li><li><a href="https://dmesg.app/cf-zero-trust.html">使用 Cloudflare Zero Trust 创建大内网 | 土豆不好吃 (dmesg.app)</a></li><li><a href="https://neko-warp.nloli.xyz/">NEKOWARP (nloli.xyz)</a></li><li><a href="https://www.noiseblog.top/posts/166c7215/">基于Cloudflare Warp+Clash无限流量上网工具 | Noise&amp;Blog (noiseblog.top)</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 归档 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C语言自制编译器</title>
      <link href="/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/C%E8%AF%AD%E8%A8%80%E8%87%AA%E5%88%B6%E7%BC%96%E8%AF%91%E5%99%A8.html"/>
      <url>/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/C%E8%AF%AD%E8%A8%80%E8%87%AA%E5%88%B6%E7%BC%96%E8%AF%91%E5%99%A8.html</url>
      
        <content type="html"><![CDATA[<h1 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h1><p><a href="https://www.sigbus.info/compilerbook">低レイヤを知りたい人のためのCコンパイラ作成入門 (sigbus.info)</a></p><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a><a href="#%E3%81%AF%E3%81%98%E3%82%81%E3%81%AB">介绍</a></h1><p>这本书的内容太多了，无法包含在一本书中。在本书中，我们将创建一个将 C 语言编写的源代码转换为汇编语言的程序，即 C 编译器。编译器本身也是使用 C 开发的。直接目标是能够自托管，即使用自制编译器编译自己的源代码。</p><p>在本书中，我决定在整本书中以渐进的方式解释各个主题，以免使编译器的解释变得过于困难。原因如下：</p><p>编译器在概念上可以分为多个阶段：解析、中间传递和代码生成。常见的教科书方法是在章节中解释每个主题，但采用这种方法的书籍往往会变得过于狭窄和深入，使读者难以理解。</p><p>另外，采用创建每个阶段的开发方法，直到所有阶段都完成后才能运行编译器，因此在整个阶段开始工作之前很难注意到您的理解或代码是否存在明确的错误。缺点是你不能。首先，在您自己创建之前，您并不真正知道下一阶段的输入预计是什么，因此您并不真正知道上一阶段要输出什么。另一个问题是很难保持积极性，因为在代码完成之前你根本无法编译任何代码。</p><p>在本书中，我决定采取不同的方法来避免这个陷阱。在本书的前面，您将使用非常简单的语言规范来实现 “ 专有语言 “。该语言非常简单，您无需了解如何编写编译器即可实现它。之后，读者将通过本书不断为 “ 专有语言 “ 添加功能，最终将其发展成与 C 语言一致的东西。</p><p>在这种增量开发方法中，您逐步创建编译器，进行少量提交。通过这种开发方法，编译器在每次提交时总是在某种意义上 “ 完整 “。在一个阶段，它可能只能做一个计算器级别的事情，在另一个阶段，它可能是 C 的一个非常有限的子集，在另一个阶段，它可能是一种几乎可以称为 C 的语言。关键是，在每个阶段，我们的目标都是建立一种具有合理规范的语言，以匹配当时的完成水平。在开发过程中，我们不会只强调某些功能，使其看起来像 C 语言。</p><p>我们还会根据发展阶段分阶段讲解数据结构、算法、计算机科学知识。</p><p>增量开发实现的目标是，在阅读本书的任何时间点，读者都对如何在该级别创建合理的语言有统一的了解。这比只对编译器创建的某些主题进行极其详细的状态要好得多。当您读完本书时，您将精通所有主题。</p><p>本书还解释了如何从头开始编写大型程序。创建大型程序的技能是一种不同于学习数据结构和算法的独特技能，但我认为解释此类事情的书籍并不多。而且，即使有人向你解释，除非你亲自体验，否则你也不会真正知道一种开发方法是好是坏。本书旨在使您在将自己的语言开发为 C 语言的过程中，能够给您带来良好开发方法的实践经验。</p><p>如果作者的计划成功的话，通过阅读本书，读者不仅会学到创建编译器和 CPU 指令集的技术，还会学到如何将大程序分解成小步骤，一点一点地创建。学习测试技术、版本控制技术，甚至如何为一个雄心勃勃的项目（如编写编译器）做准备。</p><p>本书的目标读者是普通的 C 程序员。您不需要是一个非常了解 C 语言规范的超级 C 程序员。了解指针和数组就足够了，并且至少可以花一些时间阅读别人编写的小型 C 程序。</p><p>在写这本书时，我不仅试图解释语言规范和 CPU 规范，而且还尽可能多地解释为什么选择这样的设计。我们还穿插了有关编译器、CPU、计算机行业及其历史的专栏，这些专栏会引起读者的兴趣，使其读起来令人愉快。</p><h2 id="本书假设的开发环境"><a href="#本书假设的开发环境" class="headerlink" title="本书假设的开发环境"></a><a href="#%E6%9C%AC%E6%9B%B8%E3%81%AE%E6%83%B3%E5%AE%9A%E3%81%99%E3%82%8B%E9%96%8B%E7%99%BA%E7%92%B0%E5%A2%83">本书假设的开发环境</a></h2><p>本书假设 64 位 Linux 环境运行在所谓的普通 PC（例如 Intel 或 AMD）上。请根据您使用的发行版提前安装 gcc 等开发工具并 make。如果您使用的是 Ubuntu，则可以通过运行以下命令来安装本书中使用的命令。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt update</span><br><span class="line">$ sudo apt install -y gcc make git binutils libc6-dev</span><br></pre></td></tr></table></figure><p>尽管 macOS 在程序集源代码级别与 Linux 相当兼容，但它并不完全兼容（具体来说，不支持称为 “ 静态链接 “ 的功能）。尽管可以使用本书中的信息为 macOS 创建 C 编译器，但如果您尝试这样做，您可能会遇到一些小的不兼容问题。不建议同时学习创建 C 编译器的技术以及 macOS 和 Linux 之间的差异。当某件事不起作用时，很难知道哪种理解是错误的。</p><p>因此，本书不涉及 macOS。在 macOS 上，请使用某种虚拟环境来准备 Linux 环境。如果您是第一次准备 Linux 虚拟环境，请参阅附录，其中总结了如何使用 Docker 创建开发环境。</p><p>Windows 在汇编源代码级别与 Linux 不兼容。然而，在 Windows 10 中，可以像一个应​​用程序一样在 Windows 上运行 Linux，并且通过使用它，您可以在 Windows 上继续开发。名为 Windows Subsystem for Linux (WSL) 的应用程序就是 Linux 兼容环境。在 Windows 上实现本书内容时，请安装 WSL 并在其中进行开发。</p><p>コラム:  专栏：在线编译器</p><p>查看 C 代码及其编译结果是学习汇编语言的好方法，但是一遍又一遍地编辑和编译源代码，然后检查汇编输出可能会令人惊讶地乏味。有一个非常好的网站可以为您省去麻烦。那就是 Compiler Explorer（俗称 godbolt）。当您在 Compiler Explorer 屏幕左半边的文本框中输入代码时，相应的汇编输出会实时显示在屏幕的右半边。当您想要检查 C 代码被转换成何种类型的汇编时，该网站是一个不错的选择。</p><hr><h1 id="创建计算器级语言"><a href="#创建计算器级语言" class="headerlink" title="创建计算器级语言"></a><a href="#%E9%9B%BB%E5%8D%93%E3%83%AC%E3%83%99%E3%83%AB%E3%81%AE%E8%A8%80%E8%AA%9E%E3%81%AE%E4%BD%9C%E6%88%90">创建计算器级语言</a></h1><p>在本章中，编写 C 编译器的第一步是支持算术运算和其他算术运算符，以便您可以编译如下表达式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">30 + (4 - 2) * -5</span><br></pre></td></tr></table></figure><p>这看似一个简单的目标，但实际上相当困难。数学公式的结构是括号内的表达式优先，或者乘法优先于加法，除非您以某种方式理解这一点，否则您将无法正确执行计算。但是，作为输入给出的公式只是一个平面字符串，而不是结构化数据。为了正确评估表达式，有必要分析字符序列并成功导出隐藏结构。</p><p>本章介绍最常见的解析算法之一，递归下降解析。您日常使用的 C&#x2F;C++ 编译器，例如 GCC 和 Clang，也使用递归下降解析。</p><p>编程时经常需要读取具有某种结构的文本，而不仅仅是编译器。您在本章中学到的技术可以直接用于解决此类问题。可以毫不夸张地说，您将在本章中学到的语法分析技术是受用一生的技术。阅读本章以了解算法并将解析技能添加到程序员的工具箱中。</p><h2 id="第-1-步：创建一种编译整数的语言"><a href="#第-1-步：创建一种编译整数的语言" class="headerlink" title="第 1 步：创建一种编译整数的语言"></a><a href="#%E3%82%B9%E3%83%86%E3%83%83%E3%83%971%E6%95%B4%E6%95%B01%E5%80%8B%E3%82%92%E3%82%B3%E3%83%B3%E3%83%91%E3%82%A4%E3%83%AB%E3%81%99%E3%82%8B%E8%A8%80%E8%AA%9E%E3%81%AE%E4%BD%9C%E6%88%90">第 1 步：创建一种编译整数的语言</a></h2><p>考虑 C 语言最简单的子集。你想象中的语言是什么样的？ <code>main</code> 它是一种只有函数的语言吗？或者也许是一种仅由一种表达方式组成的语言？最终，我认为可以公平地说，仅由一个整数组成的语言是可以想象的最简单的子集。</p><p>在这一步中，我们首先实现最简单的语言。</p><p>您在此步骤中创建的程序是一个编译器，它从输入中读取数字并输出一个程序集，该程序集以该数字作为程序的退出代码退出。因此，输入只是一个像 <code>42</code> 这样的字符串，当它读取它时，它会创建一个编译器，输出如下所示的程序集：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.intel_syntax noprefix</span><br><span class="line">.globl main</span><br><span class="line"></span><br><span class="line">main:</span><br><span class="line">        mov rax, 42</span><br><span class="line">        ret</span><br></pre></td></tr></table></figure><p><code>.intel_syntax noprefix</code> 是一个汇编命令，它在多种汇编编写方法中选择本书中使用的 Intel 表示法。请务必在您这次创建的编译器的开头包含此行。其他行如前一章所述。</p><p>此时，读者可能会想，” 这个程序不能称为编译器。” 老实说我也这么认为。然而，该程序接受由单个数字组成的语言作为输入并输出与该数字相对应的代码，因此根据定义，它是一个很好的编译器。即使像这样简单的程序如果修改它也会很快变得非常复杂，所以让我们先完成这一步。</p><p>从整个开发流程来看，这一步其实非常重要。这是因为我们将使用这一步中创建的内容作为未来开发的骨架。在这一步中，除了创建编译器本身之外，我们还创建构建文件（Makefile）、自动化测试并设置 git 存储库。让我们逐一查看这些任务。</p><p>コラム:  专栏：Intel 表示法和 AT&amp;T 表示法</p><p>除了本书中使用的 Intel 表示法之外，一种称为 AT&amp;T 表示法的汇编表示法也被广泛使用，主要在 Unix 中。默认情况下，gcc 和 objdump 使用 AT&amp;T 表示法输出程序集。</p><p>在 AT&amp;T 表示法中，结果寄存器是第二个参数。因此，在双参数命令中，参数以相反的顺序写入。使用 <code>%</code> 前缀写入寄存器名称，例如 <code>%rax</code> 。使用 <code>$</code> 前缀写入数字，例如 <code>$42</code> 。</p><p>另外，在引用内存时，请使用 <code>()</code> 而不是 <code>[]</code> 以独特的表示法编写表达式。下面举一些例子来进行比较。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mov rbp, rsp   // Intel</span><br><span class="line">mov %rsp, %rbp // AT&amp;T</span><br><span class="line">mov rax, 8     // Intel</span><br><span class="line">mov $8, %rax   // AT&amp;T</span><br><span class="line">mov [rbp + rcx * 4 - 8], rax // Intel</span><br><span class="line">mov %rax, -8(rbp, rcx, 4)    // AT&amp;T</span><br></pre></td></tr></table></figure><p>在我这次创建的编译器中，为了可读性，我决定使用 Intel 表示法。 Intel 的指令集手册使用 Intel 表示法，其优点是可以将手册的描述直接写成代码。 AT&amp;T 表示法和 Intel 表示法的表达能力是相同的。无论使用哪种表示法，生成的机器语言指令序列都是相同的。</p><h3 id="创建编译器主体"><a href="#创建编译器主体" class="headerlink" title="创建编译器主体"></a><a href="#%E3%82%B3%E3%83%B3%E3%83%91%E3%82%A4%E3%83%A9%E6%9C%AC%E4%BD%93%E3%81%AE%E4%BD%9C%E6%88%90">创建编译器主体</a></h3><p>通常我们将输入作为文件提供给编译器，但由于我们不想打开和读取该文件，因此我们将直接将代码作为命令的第一个参数提供。将第一个参数作为数字读取并将其嵌入到固定短语的汇编中的 C 程序可以轻松编写如下。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;参数数量不正确\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;.intel_syntax noprefix\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;.globl main\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;main:\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;  mov rax, %d\n&quot;</span>, atoi(argv[<span class="number">1</span>]));</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;  ret\n&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建一个名为 <code>9cc</code> 的空目录，并在其中创建一个名为 <code>9cc.c</code> 的文件，其中包含上述内容。然后，如下所示运行 9cc 并检查操作。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cc -o 9cc 9cc.c</span><br><span class="line">$ ./9cc 123 &gt; tmp.s</span><br></pre></td></tr></table></figure><p>第一行编译 <code>9cc.c</code> 并创建一个名为 <code>9cc</code> 的可执行文件。第二行将输入 <code>123</code> 传递给 9cc 以生成程序集并将其写入文件 <code>tmp.s</code> 。我们来检查一下 <code>tmp.s</code> 的内容。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ cat tmp.s</span><br><span class="line">.intel_syntax noprefix</span><br><span class="line">.globl main</span><br><span class="line">main:</span><br><span class="line">  mov rax, 123</span><br><span class="line">  ret</span><br></pre></td></tr></table></figure><p>如您所见，它生成得很好。您可以通过将以此方式创建的汇编文件传递给汇编器来创建可执行文件。</p><p>在 Unix 中， <code>cc</code> （或 <code>gcc</code> ）是许多语言的前端，而不仅仅是 C 和 C++，根据确定启动编译器或汇编器。因此，就像编译 9cc 时一样，可以通过将扩展名为 <code>.s</code> 的汇编器文件传递给 <code>cc</code> 来进行汇编。下面是编译并运行生成的可执行文件的示例。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ cc -o tmp tmp.s</span><br><span class="line">$ ./tmp</span><br><span class="line">$ echo $?</span><br><span class="line">123</span><br></pre></td></tr></table></figure><p>在 shell 中，可以在名为 <code>$?</code> 的变量中访问上一个命令的退出代码。在上面的示例中，显示数字 123，这与 9cc 的参数相同。这意味着它工作正常。尝试给出 0 到 255 范围内 123 以外的数字（Unix 进程退出代码应该是 0 到 255），看看 9cc 是否真的有效。</p><h3 id="创建自动化测试"><a href="#创建自动化测试" class="headerlink" title="创建自动化测试"></a><a href="#%E8%87%AA%E5%8B%95%E3%83%86%E3%82%B9%E3%83%88%E3%81%AE%E4%BD%9C%E6%88%90">创建自动化测试</a></h3><p>许多读者可能从未为爱好编程编写过测试，但在本书中，我们将在每次扩展编译器时编写代码来测试新代码。编写测试一开始可能看起来很乏味，但您很快就会开始欣赏它们。如果不写测试代码，最后每次都得手工运行相同的测试来检查操作，但是手工做就麻烦多了。</p><p>我认为编写测试很乏味的印象很大程度上来自于测试框架被夸大以及测试哲学有时很教条这一事实。例如，像 JUnit 这样的测试框架有多种有用的功能，但安装和学习如何使用它们需要时间。因此，本章不介绍此类测试框架。相反，我将在 shell 脚本中编写一个非常简单的手写 “ 测试框架 “，并用它来编写我的测试。</p><p>下面是用于测试的 shell 脚本 <code>test.sh</code> 。 shell 函数 <code>assert</code> 接收两个参数，输入的值和期望输出的值，并实际组装 9cc 结果并将实际结果与期望值进行比较，我们说的就做。在 shell 脚本中，定义 <code>assert</code> 函数后，我们用它来确保 0 和 42 都能正确编译。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="function"><span class="title">assert</span></span>() &#123;</span><br><span class="line">  expected=<span class="string">&quot;<span class="variable">$1</span>&quot;</span></span><br><span class="line">  input=<span class="string">&quot;<span class="variable">$2</span>&quot;</span></span><br><span class="line"></span><br><span class="line">  ./9cc <span class="string">&quot;<span class="variable">$input</span>&quot;</span> &gt; tmp.s</span><br><span class="line">  cc -o tmp tmp.s</span><br><span class="line">  ./tmp</span><br><span class="line">  actual=<span class="string">&quot;$?&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$actual</span>&quot;</span> = <span class="string">&quot;<span class="variable">$expected</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$input</span> =&gt; <span class="variable">$actual</span>&quot;</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$input</span> =&gt; <span class="variable">$expected</span> expected, but got <span class="variable">$actual</span>&quot;</span></span><br><span class="line">    <span class="built_in">exit</span> 1</span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">assert 0 0</span><br><span class="line">assert 42 42</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> OK</span><br></pre></td></tr></table></figure><p>使用上述内容创建 <code>test.sh</code> 并运行 <code>chmod a+x test.sh</code> 使其可执行。让我们实际运行 <code>test.sh</code> 。如果没有发生错误， <code>test.sh</code> 将显示 <code>OK</code> 并退出，如下所示。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ ./test.sh</span><br><span class="line">0 =&gt; 0</span><br><span class="line">42 =&gt; 42</span><br><span class="line">OK</span><br></pre></td></tr></table></figure><p>如果发生错误， <code>test.sh</code> 将不会显示 <code>OK</code> 。相反， <code>test.sh</code> 显示失败测试的预期值和实际值，如下所示。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ./test.sh</span><br><span class="line">0 =&gt; 0</span><br><span class="line">42 expected, but got 123</span><br></pre></td></tr></table></figure><p>如果要调试测试脚本，请在 bash 中使用 <code>-x</code> 选项运行该脚本。使用 <code>-x</code> 选项，bash 显示执行跟踪，如下所示。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">$ bash -x test.sh</span><br><span class="line">+ assert 0 0</span><br><span class="line">+ expected=0</span><br><span class="line">+ input=0</span><br><span class="line">+ cc -o 9cc 9cc.c</span><br><span class="line">+ ./9cc 0</span><br><span class="line">+ cc -o tmp tmp.s</span><br><span class="line">+ ./tmp</span><br><span class="line">+ actual=0</span><br><span class="line">+ &#x27;[&#x27; 0 &#x27;!=&#x27; 0 &#x27;]&#x27;</span><br><span class="line">+ assert 42 42</span><br><span class="line">+ expected=42</span><br><span class="line">+ input=42</span><br><span class="line">+ cc -o 9cc 9cc.c</span><br><span class="line">+ ./9cc 42</span><br><span class="line">+ cc -o tmp tmp.s</span><br><span class="line">+ ./tmp</span><br><span class="line">+ actual=42</span><br><span class="line">+ &#x27;[&#x27; 42 &#x27;!=&#x27; 42 &#x27;]&#x27;</span><br><span class="line">+ echo OK</span><br><span class="line">OK</span><br></pre></td></tr></table></figure><p>我们在本书中使用的 “ 测试框架 “ 只是一个像上面那样的 shell 脚本。与 JUnit 等成熟的测试框架相比，这个脚本可能看起来太简单了，但是这个 shell 脚本的简单性与 9cc 本身的简单性得到了平衡，所以这是更可取的。自动化测试基本上只是一次性运行您编写的代码并机械地比较结果，因此首先测试它而不是考虑太多非常重要。</p><h3 id="使用-make-构建"><a href="#使用-make-构建" class="headerlink" title="使用 make 构建"></a><a href="#make%E3%81%AB%E3%82%88%E3%82%8B%E3%83%93%E3%83%AB%E3%83%89">使用 make 构建</a></h3><p>在本书中，您将构建 9cc 数百次甚至数千次。创建 9cc 可执行文件然后运行测试脚本的工作每次都是一样的，所以交给工具就方便了。 <code>make</code> 命令通常用于此目的。</p><p>运行时，make 读取当前目录中名为 <code>Makefile</code> 的文件并执行其中写入的命令。 <code>Makefile</code> 由一个以冒号结尾的规则和该规则的一系列命令组成。以下 <code>Makefile</code> 用于自动执行您要在此步骤中运行的命令。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">CFLAGS=-std=c11 -g -static</span><br><span class="line"></span><br><span class="line">9cc: 9cc.c</span><br><span class="line"></span><br><span class="line">test: 9cc</span><br><span class="line">        ./test.sh</span><br><span class="line"></span><br><span class="line">clean:</span><br><span class="line">        rm -f 9cc *.o *~ tmp*</span><br><span class="line"></span><br><span class="line">.PHONY: test clean</span><br></pre></td></tr></table></figure><p>在 <code>9cc.c</code> 所在的同一目录中创建文件名为 <code>Makefile</code> 的上述文件。然后，您可以运行 <code>make</code> 来创建 9cc，并运行 <code>make test</code> 来运行测试。由于 make 可以理解文件依赖关系，因此无需在更改 <code>9cc.c</code> 之后和运行 <code>make test</code> 之前运行 <code>make</code> 。仅当可执行文件 9cc 早于 9cc.c 时，make 才会在运行测试之前构建 9cc。</p><p><code>make clean</code> 是删除临时文件的规则。临时文件可以手动 <code>rm</code> ，但是如果你不小心删除了不想删除的文件，那就很麻烦了，所以你也可以使用 <code>Makefile</code> 中这样的实用程序我正打算写呢。</p><p>注意，编写 <code>Makefile</code> 时， <code>Makefile</code> 的缩进必须是制表符。 4 或 8 个空格将导致错误。这只是糟糕的语法，但 make 是 20 世纪 70 年代开发的旧工具，传统上就是这样。</p><p>请务必将选项 <code>-static</code> 传递给 <code>cc</code> 。该选项在 “ 动态链接 “ 一章中进行了解释。您现在不需要考虑太多这个选项的含义。</p><h3 id="使用-git-进行版本控制"><a href="#使用-git-进行版本控制" class="headerlink" title="使用 git 进行版本控制"></a><a href="#git%E3%81%AB%E3%82%88%E3%82%8B%E3%83%90%E3%83%BC%E3%82%B8%E3%83%A7%E3%83%B3%E7%AE%A1%E7%90%86">使用 git 进行版本控制</a></h3><p>本书使用 git 作为版本控制系统。在本书中，我们将逐步创建一个编译器，并且对于每一步，请创建一个 git 提交并编写提交消息。提交消息可以是日语，因此请确保包含实际更改内容的一行摘要。如果要写多行详细说明，请在第一行后留一个空行，然后再写说明。</p><p>Git 仅对您手动生成的文件执行版本控制。运行 9cc 生成的文件可以通过执行相同的命令再次生成，因此不需要将它们纳入版本控制。事实上，包含此类文件会使每次提交的更改不必要地变长，因此应将它们从版本控制中删除，并且不包含在存储库中。</p><p>在 git 中，您可以在名为 <code>.gitignore</code> 的文件中编写要从版本控制中排除的文件的模式。在与 <code>9cc.c</code> 相同的目录中创建 <code>.gitignore</code> 并添加以下内容，并设置 git 忽略临时文件、编辑器备份文件等。让我们开始吧。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">*~</span><br><span class="line">*.o</span><br><span class="line">tmp*</span><br><span class="line">a.out</span><br><span class="line">9cc</span><br></pre></td></tr></table></figure><p>如果这是您第一次使用 Git，请告诉 Git 您的姓名和电子邮件地址。你在这里告诉 git 的姓名和电子邮件地址将被记录在提交日志中。下面是设置作者姓名和电子邮件地址的示例。读者，请输入您的姓名和电子邮件地址。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.name &quot;Rui Ueyama&quot;</span><br><span class="line">$ git config --global user.email &quot;ruiu@cs.stanford.edu&quot;</span><br></pre></td></tr></table></figure><p>要使用 git 创建提交，首先需要使用 <code>git add</code> 添加已更改的文件。由于这是您的第一次提交，因此首先使用 <code>git init</code> 创建一个 git 存储库，然后使用 <code>git add</code> 添加迄今为止创建的所有文件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git init</span><br><span class="line">Initialized empty Git repository in /home/ruiu/9cc</span><br><span class="line">$ git add 9cc.c test.sh Makefile .gitignore</span><br></pre></td></tr></table></figure><p> 然后使用 <code>git commit</code> 提交。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -m &quot;整数1つをコンパイルするコンパイラを作成&quot;</span><br></pre></td></tr></table></figure><p><code>-m</code> （可选）指定提交消息。如果没有 <code>-m</code> 选项，则 <code>git</code> 启动编辑器。您可以通过运行 <code>git log -p</code> 来确认提交是否成功，如下所示。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ git log -p</span><br><span class="line">commit 0942e68a98a048503eadfee46add3b8b9c7ae8b1 (HEAD -&gt; master)</span><br><span class="line">Author: Rui Ueyama &lt;ruiu@cs.stanford.edu&gt;</span><br><span class="line">Date:   Sat Aug 4 23:12:31 2018 +0000    整数1つをコンパイルするコンパイラを作成diff --git a/9cc.c b/9cc.c</span><br><span class="line">new file mode 100644</span><br><span class="line">index 0000000..e6e4599</span><br><span class="line">--- /dev/null</span><br><span class="line">+++ b/9cc.c</span><br><span class="line">@@ -0,0 +1,16 @@</span><br><span class="line">+#include &lt;stdio.h&gt;</span><br><span class="line">+#include &lt;stdlib.h&gt;</span><br><span class="line">+</span><br><span class="line">+int main(int argc, char **argv) &#123;</span><br><span class="line">+  if (argc != 2) &#123;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>最后，让我们将目前创建的 git 存储库上传到 GitHub。没有特别的理由上传到 GitHub，但也没有理由不上传，并且 GitHub 作为代码的备份非常有用。要上传到 GitHub，请创建一个新存储库（在本示例中，我们使用用户 <code>rui314</code> 创建了一个名为 <code>9cc</code> 的存储库），然后使用以下命令创建新存储库。添加存储库作为远程存储库。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git remote add origin git@github.com:rui314/9cc.git</span><br></pre></td></tr></table></figure><p>然后，运行 <code>git push</code> 会将存储库的内容推送到 GitHub。运行 <code>git push</code> 后，尝试在浏览器中打开 GitHub 并验证您的源代码是否已上传。</p><p>这样就完成了创建编译器的第一步。这一步中的编译器太简单了，不能称为编译器，但它是一个很好的程序，包含了编译器所需的所有元素。从现在开始，我们将继续增强这个编译器的功能，尽管可能令人难以置信，但我们将把它开发成一个优秀的 C 编译器。享受第一步的完成。</p><p> 参考实现</p><ul><li><a href="https://github.com/rui314/chibicc/commit/f722daaaae0606115df4ace5a852da23c1a5b0f3">f722daaaae060611</a></li></ul><h2 id="第2步：创建一个可以加减法的编译器"><a href="#第2步：创建一个可以加减法的编译器" class="headerlink" title="第2步：创建一个可以加减法的编译器"></a><a href="#%E3%82%B9%E3%83%86%E3%83%83%E3%83%972%E5%8A%A0%E6%B8%9B%E7%AE%97%E3%81%AE%E3%81%A7%E3%81%8D%E3%82%8B%E3%82%B3%E3%83%B3%E3%83%91%E3%82%A4%E3%83%A9%E3%81%AE%E4%BD%9C%E6%88%90">第2步：创建一个可以加减法的编译器</a></h2><p>在这一步中，我们扩展了上一步中创建的编译器，使其不仅包含 <code>42</code> 等值，还包含 <code>2+11</code> 和 <code>5+20-4</code> 等加法和减法&gt; 允许您接收表情。</p><p>像 <code>5+20-4</code> 这样的表达式可以在编译时计算，并且结果数字（在本例中为 <code>21</code> ）可以嵌入到程序集中，但这会导致编译器就像解释器一样，因此您需要输出在运行时执行加法和减法的程序集。加法和减法的汇编指令是 <code>add</code> 和 <code>sub</code> 。 <code>add</code> 采用两个寄存器，将它们的内容相加，然后将结果写入其第一个参数的寄存器。 <code>sub</code> 与 <code>add</code> 相同，但有减法。使用这些指令， <code>5+20-4</code> 可以编译如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.intel_syntax noprefix</span><br><span class="line">.globl main</span><br><span class="line"></span><br><span class="line">main:</span><br><span class="line">        mov rax, 5</span><br><span class="line">        add rax, 20</span><br><span class="line">        sub rax, 4</span><br><span class="line">        ret</span><br></pre></td></tr></table></figure><p>在上面的程序集中， <code>mov</code> 将 RAX 设置为 5，然后将 20 添加到 RAX 并减去 4。执行 <code>ret</code> 时 RAX 的值应该是 <code>5+20-4</code> 或 21。让我们运行一下并检查一下。将上面的文件保存在 <code>tmp.s</code> 中，组装它，然后尝试运行它。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ cc -o tmp tmp.s</span><br><span class="line">$ ./tmp</span><br><span class="line">$ echo $?</span><br><span class="line">21</span><br></pre></td></tr></table></figure><p> 21 已正确显示，如上所示。</p><p>现在，我应该如何创建这个程序集文件？如果我们将这种涉及加法和减法的表达式视为一种 “ 语言 “，那么这种语言可以定义如下。</p><ul><li>开头有一个数字</li><li>后面跟着零个或多个 “ 术语 “</li><li>术语可以是 <code>+</code> 后跟一个数字，也可以是 <code>-</code> 后跟一个数字。</li></ul><p>如果将此定义翻译成 C 代码，您将得到如下所示的程序：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;参数数量不正确\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">char</span> *p = argv[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;.intel_syntax noprefix\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;.globl main\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;main:\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;  mov rax, %ld\n&quot;</span>, strtol(p, &amp;p, <span class="number">10</span>));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (*p) &#123;</span><br><span class="line">    <span class="keyword">if</span> (*p == <span class="string">&#x27;+&#x27;</span>) &#123;</span><br><span class="line">      p++;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;  add rax, %ld\n&quot;</span>, strtol(p, &amp;p, <span class="number">10</span>));</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (*p == <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">      p++;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;  sub rax, %ld\n&quot;</span>, strtol(p, &amp;p, <span class="number">10</span>));</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;意外的字符: &#x27;%c&#x27;\n&quot;</span>, *p);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;  ret\n&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序有点长，但前半部分和 <code>ret</code> 行与以前相同。中间添加了阅读术语的代码。这次，程序不仅仅是读取单个数字，所以读取一个数字后，我们需要知道它读了多远。由于 <code>atoi</code> 不返回读取的字符数，因此 <code>atoi</code> 不知道从哪里开始阅读下一部分。因此，我们使用了 C 标准库中的 <code>strtol</code> 函数。</p><p><code>strtol</code> 读取数字后，它会更新第二个参数中的指针，以指向读取的最后一个字符之后的字符。因此，读取一个数字后，如果下一个字符是 <code>+</code> 或 <code>-</code> ，则 <code>p</code> 应指向该字符。上面的程序利用了这一事实，在 <code>while</code> 循环中逐个读取术语，并在每次读取一个术语时输出一行汇编。</p><p>现在，让我们运行这个编译器的修改版本。更新 <code>9cc.c</code> 文件后，您只需运行 <code>make</code> 即可创建新的 9cc 文件。执行示例如下所示。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ make</span><br><span class="line">$ ./9cc &#x27;5+20-4&#x27;</span><br><span class="line">.intel_syntax noprefix</span><br><span class="line">.globl main</span><br><span class="line">main:</span><br><span class="line">  mov rax, 5</span><br><span class="line">  add rax, 20</span><br><span class="line">  sub rax, 4</span><br><span class="line">  ret</span><br></pre></td></tr></table></figure><p>看起来程序集已成功输出。为了测试这个新功能，我们向 <code>test.sh</code> 添加一条测试行，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">assert 21 &quot;5+20-4&quot;</span><br></pre></td></tr></table></figure><p>完成此操作后，将更改提交到 git。为此，请运行以下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git add test.sh 9cc.c</span><br><span class="line">$ git commit</span><br></pre></td></tr></table></figure><p>当您运行 <code>git commit</code> 时，编辑器将启动，因此编写 “ 添加加法和减法 “，保存并退出编辑器。尝试使用 <code>git log -p</code> 命令来验证提交是否按预期工作。最后，运行 <code>git push</code> 将提交推送到 GitHub，这一步就完成了！</p><p> 参考实现</p><ul><li><a href="https://github.com/rui314/chibicc/commit/afc9e8f05faddf051aa3a578520d6484ab451282">afc9e8f05faddf05</a></li></ul><h2 id="第-3-步：引入分词器"><a href="#第-3-步：引入分词器" class="headerlink" title="第 3 步：引入分词器"></a><a href="#%E3%82%B9%E3%83%86%E3%83%83%E3%83%973%E3%83%88%E3%83%BC%E3%82%AF%E3%83%8A%E3%82%A4%E3%82%B6%E3%82%92%E5%B0%8E%E5%85%A5">第 3 步：引入分词器</a></h2><p>上一步中创建的编译器有一个缺点。如果输入包含空白字符，则会出现错误。例如，如果如下所示给字符串 <code>5 - 3</code> 加上空格，则在尝试读取 <code>+</code> 或 <code>-</code> 时会发现空格字符。这将导致编译失败。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ./9cc &#x27;5 - 3&#x27; &gt; tmp.s</span><br><span class="line">予期しない文字です: &#x27; &#x27;</span><br></pre></td></tr></table></figure><p>有多种方法可以解决此问题。一种明显的方法是在尝试读取 <code>+</code> 或 <code>-</code> 之前跳过空格。这种方法没有什么特别的错误，但在这一步中我们将采用不同的方法来解决问题。方法是在读取表达式之前将输入拆分为单词。</p><p>就像日语和英语一样，数学公式和编程语言可以被认为是由单词序列组成的。例如， <code>5+20-4</code> 变为 <code>5</code> 、 <code>+</code> 、 <code>20</code> 、 <code>-</code> 、 <code>4</code> 5 您可以将其视为由两个单词组成。这个 “ 词 “ 被称为 “ 令牌 “。标记之间的空白仅用于分隔标记，而不是单词的一部分。因此，在将字符串拆分为标记序列时，删除空格字符是很自然的。将字符串划分为标记字符串称为 “ 标记化 “。</p><p>将字符串分成标记序列还有其他好处。当表达式被划分为标记时，可以对标记进行分类并指定类型。例如， <code>+</code> 和 <code>-</code> 是如您所见的 <code>+</code> 和 <code>-</code> 等符号，而 <code>123</code> 这个字符串表示数字 123。在进行词法分析时，不仅要将输入拆分为简单的字符串，还需要解释每个单独的令牌，在消耗令牌序列时需要考虑更少的事情。</p><p>在当前允许加法和减法的表达式语法中，存在三种类型的标记： <code>+</code> 、 <code>-</code> 和数字。此外，出于编译器实现的原因，最好定义一种特殊类型来表示标记字符串的结尾（相当于以 <code>&#39;\0&#39;</code> 结尾的字符串）。让我们将标记做成一个由指针连接的链表，以便我们可以处理任意长度的输入。</p><p>虽然有点长，但我将在下面发布引入分词器的编译器的改进版本。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 令牌的类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">  TK_RESERVED, <span class="comment">// 符号</span></span><br><span class="line">  TK_NUM,      <span class="comment">// 整数令牌</span></span><br><span class="line">  TK_EOF,      <span class="comment">// 表示输入结束的令牌</span></span><br><span class="line">&#125; TokenKind;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Token</span> <span class="title">Token</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 令牌结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Token</span> &#123;</span></span><br><span class="line">  TokenKind kind; <span class="comment">// 令牌类型</span></span><br><span class="line">  Token *next;    <span class="comment">// 下一个输入令牌</span></span><br><span class="line">  <span class="type">int</span> val;        <span class="comment">// 如果kind为TK_NUM，则为其数值</span></span><br><span class="line">  <span class="type">char</span> *str;      <span class="comment">// 令牌字符串</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前关注的令牌</span></span><br><span class="line">Token *token;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于报告错误的函数</span></span><br><span class="line"><span class="comment">// 与printf相同的参数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">error</span><span class="params">(<span class="type">char</span> *fmt, …)</span> &#123;</span><br><span class="line">  va_list ap;</span><br><span class="line">  va_start(ap, fmt);</span><br><span class="line">  <span class="built_in">vfprintf</span>(<span class="built_in">stderr</span>, fmt, ap);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果下一个令牌是期望的符号，则读取并返回true。</span></span><br><span class="line"><span class="comment">// 否则返回false。</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">consume</span><span class="params">(<span class="type">char</span> op)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (token-&gt;kind != TK_RESERVED || token-&gt;str[<span class="number">0</span>] != op)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  token = token-&gt;next;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果下一个令牌是期望的符号，则读取它。</span></span><br><span class="line"><span class="comment">// 否则报告错误。</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">expect</span><span class="params">(<span class="type">char</span> op)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (token-&gt;kind != TK_RESERVED || token-&gt;str[<span class="number">0</span>] != op)</span><br><span class="line">    error(<span class="string">&quot;&#x27;%c&#x27;不是预期的符号&quot;</span>, op);</span><br><span class="line">  token = token-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果下一个令牌是数字，则读取令牌并返回其数值。</span></span><br><span class="line"><span class="comment">// 否则报告错误。</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">expect_number</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (token-&gt;kind != TK_NUM)</span><br><span class="line">    error(<span class="string">&quot;不是数字&quot;</span>);</span><br><span class="line">  <span class="type">int</span> val = token-&gt;val;</span><br><span class="line">  token = token-&gt;next;</span><br><span class="line">  <span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">at_eof</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> token-&gt;kind == TK_EOF;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建新的令牌并连接到cur</span></span><br><span class="line">Token *<span class="title function_">new_token</span><span class="params">(TokenKind kind, Token *cur, <span class="type">char</span> *str)</span> &#123;</span><br><span class="line">  Token *tok = <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="keyword">sizeof</span>(Token));</span><br><span class="line">  tok-&gt;kind = kind;</span><br><span class="line">  tok-&gt;str = str;</span><br><span class="line">  cur-&gt;next = tok;</span><br><span class="line">  <span class="keyword">return</span> tok;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对输入字符串p进行令牌化并返回其令牌</span></span><br><span class="line">Token *<span class="title function_">tokenize</span><span class="params">(<span class="type">char</span> *p)</span> &#123;</span><br><span class="line">  Token head;</span><br><span class="line">  head.next = <span class="literal">NULL</span>;</span><br><span class="line">  Token *cur = &amp;head;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (*p) &#123;</span><br><span class="line">    <span class="comment">// 跳过空白字符</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isspace</span>(*p)) &#123;</span><br><span class="line">      p++;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (*p == <span class="string">&#x27;+&#x27;</span> || *p == <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">      cur = new_token(TK_RESERVED, cur, p++);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isdigit</span>(*p)) &#123;</span><br><span class="line">      cur = new_token(TK_NUM, cur, p);</span><br><span class="line">      cur-&gt;val = strtol(p, &amp;p, <span class="number">10</span>);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    error(<span class="string">&quot;无法进行令牌化&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  new_token(TK_EOF, cur, p);</span><br><span class="line">  <span class="keyword">return</span> head.next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">    error(<span class="string">&quot;参数数量不正确&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 进行令牌化</span></span><br><span class="line">  token = tokenize(argv[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 输出汇编的前半部分</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;.intel_syntax noprefix\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;.globl main\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;main:\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 表达式的开头必须是一个数字，检查它并输出第一条mov指令</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;  mov rax, %d\n&quot;</span>, expect_number());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 消耗`+ &lt;数&gt;`或`- &lt;数&gt;`的令牌序列并输出汇编</span></span><br><span class="line">  <span class="keyword">while</span> (!at_eof()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (consume(<span class="string">&#x27;+&#x27;</span>)) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;  add rax, %d\n&quot;</span>, expect_number());</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    expect(<span class="string">&#x27;-&#x27;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;  sub rax, %d\n&quot;</span>, expect_number());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;  ret\n&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码不是很短，大约 150 行，但它没有做任何太棘手的事情，所以你应该能够通过从顶部阅读来阅读它。</p><p>让我解释一下上面代码中使用的一些编程技术。</p><ul><li>我决定使用全局变量 <code>token</code> 来表示解析器读取的标记序列。解析器通过 <code>token</code> 的链接列表读取输入。这种使用全局变量的编程风格可能看起来不太干净。然而，在实践中，通过将输入标记序列视为像标准输入一样的流，通常更容易读取解析器代码，就像我们在这里所做的那样。因此，我们这里采用了这样的风格。</li><li>直接接触 <code>token</code> 的代码应该分成 <code>consume</code> 和 <code>expect</code> 等函数，其他函数不应该直接接触 <code>token</code> 。做好了。</li><li><code>tokenize</code> 函数正在构建一个链表。构建链表时，您可以通过创建一个虚拟 <code>head</code> 元素、将新元素连接到它并在末尾返回 <code>head-&gt;next</code> 来简化代码。这种方法浪费了分配给 <code>head</code> 元素的大部分内存，但分配局部变量的成本几乎为零，因此您无需担心。</li><li><code>calloc</code> 是一个分配内存的函数，就像 <code>malloc</code> 一样。与 <code>malloc</code> 不同， <code>calloc</code> 将分配的内存清零。我决定在这里使用 <code>calloc</code> 来节省将元素归零的工作。</li></ul><p>这个改进的版本现在应该能够跳过空格，所以让我们将以下测试添加到单行 <code>test.sh</code> 中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">assert 41 &quot; 12 + 34 - 5 &quot;</span><br></pre></td></tr></table></figure><p>Unix 进程的退出代码是 0 到 255 之间的数字，因此在编写测试时，请确保整个表达式的结果落在 0 到 255 的范围内。</p><p>将测试文件添加到 git 存储库即可完成此步骤。</p><p> 参考实现</p><ul><li><a href="https://github.com/rui314/chibicc/commit/ef6d1791eb2a5ef3af913945ca577ea76d4ff97e">ef6d1791eb2a5ef3</a></li></ul><h2 id="第-4-步：改进错误消息"><a href="#第-4-步：改进错误消息" class="headerlink" title="第 4 步：改进错误消息"></a><a href="#%E3%82%B9%E3%83%86%E3%83%83%E3%83%974%E3%82%A8%E3%83%A9%E3%83%BC%E3%83%A1%E3%83%83%E3%82%BB%E3%83%BC%E3%82%B8%E3%82%92%E6%94%B9%E8%89%AF">第 4 步：改进错误消息</a></h2><p>使用到目前为止我们创建的编译器，如果输入在语法上不正确，我们唯一可以判断的是某个地方有错误。让我们尝试在这一步中改进这个问题。具体来说，我们将能够显示如下所示的直观错误消息。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ ./9cc &quot;1+3++&quot; &gt; tmp.s</span><br><span class="line">1+3++</span><br><span class="line">    ^ 不是数字</span><br><span class="line">$ ./9cc &quot;1 + foo + 5&quot; &gt; tmp.s</span><br><span class="line">1 + foo + 5</span><br><span class="line">    ^ 无法进行令牌化</span><br></pre></td></tr></table></figure><p>为了显示这样的错误消息，我们需要能够知道错误发生在输入的哪个字节。为此，我们将整个程序字符串保存在名为 <code>user_input</code> 的变量中，并定义一个新的错误显示函数，该函数接收指向字符串中间的指针。代码如下所示。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用户输入程序</span></span><br><span class="line"><span class="type">char</span> *user_input;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报告错误位置</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">error_at</span><span class="params">(<span class="type">char</span> *loc, <span class="type">char</span> *fmt, …)</span> &#123;</span><br><span class="line">  va_list ap;</span><br><span class="line">  va_start(ap, fmt);</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> pos = loc - user_input;</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;%s\n&quot;</span>, user_input);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;%*s&quot;</span>, pos, <span class="string">&quot; &quot;</span>); <span class="comment">// 输出pos个空格</span></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;^ &quot;</span>);</span><br><span class="line">  <span class="built_in">vfprintf</span>(<span class="built_in">stderr</span>, fmt, ap);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>error_at</code> 接收的指针是指向代表整个输入的字符串中间的指针。通过获取该指针和指向输入开头的指针之间的差异，您可以知道错误位于输入的哪个字节，因此可以使用 <code>^</code> 显着地标记该位置。</p><p>通过将 <code>argv[1]</code> 保存到 <code>user_input</code> 并将 <code>error(&quot;数ではありません&quot;)</code> 等代码更新为 <code>error_at(token-&gt;str, &quot;数ではありません&quot;)</code> 等代码来完成此步骤。</p><p>实用级别的编译器也应该为输入有错误时的行为编写测试，但目前错误消息只是输出以帮助调试，在这个阶段没有必要编写测试。你没有。</p><p> 参考实现</p><ul><li><a href="https://github.com/rui314/chibicc/commit/c6ff1d98a1419e69c31902447e2caa85af4e9844">c6ff1d98a1419e69</a></li></ul><h2 id="语法描述方法与递归下降解析"><a href="#语法描述方法与递归下降解析" class="headerlink" title="语法描述方法与递归下降解析"></a><a href="#%E6%96%87%E6%B3%95%E3%81%AE%E8%A8%98%E8%BF%B0%E6%96%B9%E6%B3%95%E3%81%A8%E5%86%8D%E5%B8%B0%E4%B8%8B%E9%99%8D%E6%A7%8B%E6%96%87%E8%A7%A3%E6%9E%90">语法描述方法与递归下降解析</a></h2><p>现在，接下来我想在语言中添加用于乘法、除法和优先级的括号，即 <code>*</code> 、 <code>/</code> 、 <code>()</code> 。这是一个重大的技术挑战。这是因为有一个规则，在表达式中必须先计算乘法和除法。例如，表达式 <code>1+2*3</code> 必须解释为 <code>1+(2*3)</code> ，而不是 <code>(1+2)*3</code> 。运算符首先 “ 粘在一起 “ 的规则称为 “ 运算符优先级 “。</p><p>我们应该如何处理运算符优先级？到目前为止，我们创建的编译器只是从头开始读取标记序列并输出程序集，因此如果您只是扩展它并添加 <code>*</code> 和 <code>/</code> 、 <code>1+2*3</code> 将被编译为 <code>(1+2)*3</code> 。</p><p>现有的编译器自然擅长处理运算符优先级。编译器的解析非常强大，只要遵循语法就可以正确解释任何复杂的代码。这个编译器的行为可能给人的印象是它具有超越人类的智力，但实际上，计算机不具备像人类一样阅读文本的能力，因此解析只是通过某种机械机制来执行 。它到底是如何运作的？</p><p>在本章中，让我们暂时放下编码，学习一些解析技术。本章按以下顺序描述解析技术：</p><ol><li><p>首先通过了解解析器输出的数据结构来了解最终目标。</p></li><li><p> 了解定义语法规则的规则</p></li><li><p>学习根据定义语法规则的规则编写解析器的技术</p></li></ol><h3 id="递归降序解析"><a href="#递归降序解析" class="headerlink" title="递归降序解析"></a><a href="#%E5%86%8D%E5%B8%B0%E4%B8%8B%E9%99%8D%E6%A7%8B%E6%96%87%E8%A7%A3%E6%9E%90">递归降序解析</a></h3><p>如果给定 C 语言的产生式规则，通过将它们逐一展开，就可以机械地生成任何从产生式规则来看是正确的 C 程序。但我们想要用 9cc 做的事情实际上是相反的。我从外部源获得一个作为字符串的 C 程序，我想知道展开时产生输入字符串的展开过程，或者产生与以下字符串相同的语法树的结构输入。</p><p>事实上，对于某些类型的产生式规则，如果给定一个规则，就可以机械地编写代码来找到与该规则生成的句子相匹配的语法树。这里描述的 “ 递归下降解析方法 “ 就是这样一种技术。</p><p>作为示例，让我们考虑四种算术运算的语法。我将重新发布四种算术运算的语法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">expr    = mul (&quot;+&quot; mul | &quot;-&quot; mul)*</span><br><span class="line">mul     = primary (&quot;*&quot; primary | &quot;/&quot; primary)*</span><br><span class="line">primary = num | &quot;(&quot; expr &quot;)&quot;</span><br></pre></td></tr></table></figure><p>使用递归下降解析编写解析器时的基本策略是将每个非终结符直接映射到每个函数。因此解析器将具有三个函数： <code>expr</code> 、 <code>mul</code> 和 <code>primary</code> 。正如其名称所示，每个函数都会解析一系列标记。</p><p>让我们具体地考虑一下。传递给解析器的输入是一系列标记。由于我们想要从解析器创建并返回一个抽象语法树，因此让我们定义抽象语法树中的节点类型。节点类型如下所示。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象语法树的节点类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">  ND_ADD, <span class="comment">// +</span></span><br><span class="line">  ND_SUB, <span class="comment">// -</span></span><br><span class="line">  ND_MUL, <span class="comment">// *</span></span><br><span class="line">  ND_DIV, <span class="comment">// /</span></span><br><span class="line">  ND_NUM, <span class="comment">// 整数</span></span><br><span class="line">&#125; NodeKind;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> <span class="title">Node</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象语法树的节点类型</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">  NodeKind kind; <span class="comment">// 节点类型</span></span><br><span class="line">  Node *lhs;     <span class="comment">// 左侧</span></span><br><span class="line">  Node *rhs;     <span class="comment">// 右侧</span></span><br><span class="line">  <span class="type">int</span> val;       <span class="comment">// 仅在kind为ND_NUM时使用</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>lhs</code> 和 <code>rhs</code> 分别表示左侧和右侧。</p><p>我们还定义一个函数来创建新节点。该语法中有两种类型的算术运算：接受左侧和右侧的二元运算符以及数字，因此我们将为这两种类型分别准备两个函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Node *<span class="title function_">new_node</span><span class="params">(NodeKind kind, Node *lhs, Node *rhs)</span> &#123;</span><br><span class="line">  Node *node = <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="keyword">sizeof</span>(Node));</span><br><span class="line">  node-&gt;kind = kind;</span><br><span class="line">  node-&gt;lhs = lhs;</span><br><span class="line">  node-&gt;rhs = rhs;</span><br><span class="line">  <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Node *<span class="title function_">new_node_num</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">  Node *node = <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="keyword">sizeof</span>(Node));</span><br><span class="line">  node-&gt;kind = ND_NUM;</span><br><span class="line">  node-&gt;val = val;</span><br><span class="line">  <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，让我们使用这些函数和数据类型编写一个解析器。 <code>+</code> 和 <code>-</code> 是左结合运算符。解析左结合运算符的函数被编写为如下模式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Node *<span class="title function_">expr</span><span class="params">()</span> &#123;</span><br><span class="line">  Node *node = mul();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    <span class="keyword">if</span> (consume(<span class="string">&#x27;+&#x27;</span>))</span><br><span class="line">      node = new_node(ND_ADD, node, mul());</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (consume(<span class="string">&#x27;-&#x27;</span>))</span><br><span class="line">      node = new_node(ND_SUB, node, mul());</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="keyword">return</span> node;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>consume</code> 是上一步中定义的函数，它向前读取输入中的一个标记，如果输入流中的下一个标记与参数匹配，则返回 true。</p><p><code>expr</code> 请仔细阅读该函数。您可以看到产生式 <code>expr = mul (&quot;+&quot; mul | &quot;-&quot; mul)*</code> 直接映射到函数调用和循环。在上面 <code>expr</code> 函数返回的抽象语法树中，运算符是左关联的，这意味着返回节点左侧的分支更深。</p><p>我们还定义 <code>expr</code> 函数使用的 <code>mul</code> 函数。 <code>*</code> 和 <code>/</code> 也是左结合运算符，因此可以使用相同的模式编写它们。该函数如下所示。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Node *<span class="title function_">mul</span><span class="params">()</span> &#123;</span><br><span class="line">  Node *node = primary();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    <span class="keyword">if</span> (consume(<span class="string">&#x27;*&#x27;</span>))</span><br><span class="line">      node = new_node(ND_MUL, node, primary());</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (consume(<span class="string">&#x27;/&#x27;</span>))</span><br><span class="line">      node = new_node(ND_DIV, node, primary());</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="keyword">return</span> node;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中的函数调用关系直接对应于 <code>mul = primary (&quot;*&quot; primary | &quot;/&quot; primary)*</code> 产生式规则。</p><p>最后，让我们定义 <code>primary</code> 函数。 <code>primary</code> 不会读取左结合运算符，因此上面的代码并不遵循上面的模式，但是可以按原样使用产生式规则 <code>primary = &quot;(&quot; expr &quot;)&quot; | num</code> 来对应于函数调用。, <code>primary</code> 函数可以写成如下。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Node *<span class="title function_">primary</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="comment">// 如果下一个令牌是&quot;(&quot;，那么应该是&quot;(&quot; expr &quot;)&quot;的结构</span></span><br><span class="line">  <span class="keyword">if</span> (consume(<span class="string">&#x27;(&#x27;</span>)) &#123;</span><br><span class="line">    Node *node = expr();</span><br><span class="line">    expect(<span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 否则应该是一个数字</span></span><br><span class="line">  <span class="keyword">return</span> new_node_num(expect_number());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们已经有了所有的功能，我们真的可以解析令牌字符串吗？尽管乍一看可能并不明显，但您可以使用这组函数来正确解析令牌序列。例如，考虑表达式 <code>1+2*3</code> 。</p><p>第一个调用的是 <code>expr</code> 。它开始读取输入，假设整个表达式为 <code>expr</code> （在本例中确实如此）。然后，函数调用如下： <code>expr</code> → <code>mul</code> → <code>primary</code> ，读取令牌 <code>1</code> ，并读取令牌&lt; b6 &gt; 返回一个语法树，表示 1 作为返回值。</p><p>接下来， <code>expr</code> 中的表达式 <code>consume(&#39;+&#39;)</code> 变为 true，因此令牌 <code>+</code> 被消耗并返回 <code>mul</code> 将被调用。此阶段剩余的输入是 <code>2*3</code> 。</p><p>从 <code>mul</code> 开始，和之前一样调用了 <code>primary</code> ，并且读取了令牌 <code>2</code> ，但是这次 <code>mul</code> 是不会立即返回的。 <code>mul</code> 中的表达式 <code>consume(&#39;*&#39;)</code> 变为 true，因此 <code>mul</code> 再次调用 <code>primary</code> 并 <code>3</code> 将返回表示 <code>2*3</code> 的语法树。</p><p>在返回的目的地 <code>expr</code> 处，将表示 1 的语法树和表示 <code>2*3</code> 的语法树组合起来，构造表示 <code>1+2*3</code> 的语法树，即为返回 <code>expr</code> 的值。换句话说， <code>1+2*3</code> 被正确解析。</p><p>下图展示了函数调用关系以及每个函数读取的 token。下图中，整个 <code>1+2*3</code> 有一层 <code>expr</code> ，它代表对读取整个输入的 <code>expr</code> 的调用。 <code>expr</code> 上方有两个 <code>mul</code> ，但它们还有另一个 <code>mul</code> &gt; 表示调用。</p><p><img src="/../../img/blog/ed3375792da2e2a04ad0dd81b3bb1500_MD5.svg"></p><p>解析 <code>1+2*3</code> 时的函数调用关系</p><p>下面显示了一个稍微复杂的示例。下图展示了解析 <code>1*2+(3+4)</code> 时的函数调用关系。</p><p><img src="/../../img/blog/3c90870f3dae5e03d8aa63ce050caba4_MD5.svg"></p><p>解析 <code>1*2+(3+4)</code> 时的函数调用关系</p><p>对于不熟悉递归的程序员来说，像上面这样的递归函数可能会让人感到困惑。老实说，即使对于我这个应该非常熟悉递归的人来说，这种代码的工作也感觉像是一种魔法。即使您知道递归代码是如何工作的，它还是有一些奇怪的地方，而这可能就是它的本质。尝试一遍又一遍地在脑海中跟踪代码，以确保其正常工作。</p><p>如上所述将一个产生式规则映射到一个函数的解析方法称为 “ 递归降序解析 “。在上面的解析器中，只预读一个标记来决定调用或返回哪个函数。 (1) 称为解析器。另外，可以由 LL(1) 解析器编写的语法称为 LL(1) 语法。</p><h2 id="堆叠机"><a href="#堆叠机" class="headerlink" title="堆叠机"></a><a href="#%E3%82%B9%E3%82%BF%E3%83%83%E3%82%AF%E3%83%9E%E3%82%B7%E3%83%B3">堆叠机</a></h2><p>在上一章中，我们解释了将标记序列转换为抽象语法树的算法。通过选择考虑运算符优先级的语法， <code>*</code> 和 <code>/</code> 比 <code>+</code> 和 <code>-</code> 更好。现在我们可以创建一个抽象语法树的分支总是在树的顶部，但是我们如何将这棵树转换为汇编呢？本章解释了如何进行。</p><p>首先我们考虑一下为什么不能像加减法一样转换为汇编。可以执行加法和减法的编译器使用 RAX 作为结果寄存器并在那里执行加法和减法。也就是说，编译后的程序只保留了一个中间计算结果。</p><p>但涉及乘法和除法时，不保证中间计算结果只有一个。以 2_3+4_5 为例。为了进行加法，两边都必须计算，所以 2_3 和 4_5 必须在加法之前计算。换句话说，在这种情况下，除非能够存储两个中间计算结果，否则无法执行整个计算。</p><p>称为 “ 堆栈机 “ 的计算机可以轻松地执行这样的计算。让我们远离解析器创建的抽象语法树并了解堆栈机。</p><h3 id="编译到堆栈机"><a href="#编译到堆栈机" class="headerlink" title="编译到堆栈机"></a><a href="#%E3%82%B9%E3%82%BF%E3%83%83%E3%82%AF%E3%83%9E%E3%82%B7%E3%83%B3%E3%81%B8%E3%81%AE%E3%82%B3%E3%83%B3%E3%83%91%E3%82%A4%E3%83%AB">编译到堆栈机</a></h3><p>本节介绍如何将抽象语法树转换为堆栈机器码。如果你能做到这一点，你将能够解析由四个算术运算组成的表达式，组装抽象语法树，使用 x86-64 指令将其编译成堆栈机，并执行它。换句话说，将有可能编写一个可执行四种算术运算的编译器。</p><p>在堆栈机中，当计算子表达式时，结果的一个值（无论它是什么）都保留在堆栈顶部。例如，考虑下面的树。</p><p><img src="/../../img/blog/b5a50cee05b8bcf8a30d76f472634ed2_MD5.svg"></p><p> 表示加法的抽象语法树</p><p><code>A</code> 和 <code>B</code> 是子树的抽象表示，实际上表示某种类型的节点。然而，在编译整个树时，树的具体类型或形状并不重要。要编译此树，请执行以下操作：</p><ol><li><p> 编译左子树</p></li><li><p> 编译右子树</p></li><li><p>输出将堆栈上的两个值替换为将它们相加的结果的代码</p></li></ol><p>执行完#1 中的代码后，无论具体代码是什么，栈顶都应该有一个值代表左子树的结果。类似地，运行 2 中的代码后，堆栈顶部应该有一个代表右子树结果的值。因此，为了计算整棵树的值，我们只需要将这两个值替换为它们的总值即可。</p><p>这样，当将抽象语法树编译到堆栈机时，我们会递归地思考并在树下降时输出程序集。尽管对于不熟悉递归概念的读者来说，这似乎有点困难，但它是处理树等自相似数据结构时的标准技术。</p><p> 让我们考虑下面的例子。</p><p><img src="/../../img/blog/c6820209048de0d36fab3c94c1acd096_MD5.svg"></p><p> 表示加法和乘法的抽象语法树</p><p>执行代码生成的函数接收树的根节点。</p><p>按照上述步骤，该函数所做的第一件事是编译左子树。换句话说，我们将编译数字 2。 2 的计算结果是 2，所以该子树的编译结果是 <code>PUSH 2</code> 。</p><p>然后代码生成函数尝试编译右子树。这将递归地编译子树的左侧，从而输出 <code>PUSH 3</code> 。接下来我们将编译子树的右侧，它将输出 <code>PUSH 4</code> 。</p><p>然后代码生成函数返回到递归调用并输出与子树运算符的类型匹配的代码。第一个输出是将堆栈顶部的两个元素替换为它们的乘积的代码。接下来，输出用它们的和替换栈顶两个元素的代码。结果将是下面的组件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PUSH 2</span><br><span class="line">PUSH 3</span><br><span class="line">PUSH 4</span><br><span class="line">MUL</span><br><span class="line">ADD</span><br></pre></td></tr></table></figure><p>使用这种方法，抽象语法树可以机械地简化为汇编。</p><h3 id="如何在-x86-64-上创建堆栈机器"><a href="#如何在-x86-64-上创建堆栈机器" class="headerlink" title="如何在 x86-64 上创建堆栈机器"></a><a href="#x86-64%E3%81%AB%E3%81%8A%E3%81%91%E3%82%8B%E3%82%B9%E3%82%BF%E3%83%83%E3%82%AF%E3%83%9E%E3%82%B7%E3%83%B3%E3%81%AE%E5%AE%9F%E7%8F%BE%E6%96%B9%E6%B3%95">如何在 x86-64 上创建堆栈机器</a></h3><p>到目前为止，我们一直在讨论虚拟堆栈机。实际的 x86-64 是寄存器机，而不是堆栈机。 x86-64 操作通常被定义为在两个寄存器之间操作，而不是在堆栈顶部的两个值之间操作。因此，为了在 x86-64 上使用堆栈机技术，您需要使用寄存器机在某种意义上模拟堆栈机。</p><p>用寄存器机模拟堆栈机相对容易。堆栈机上的一条指令可以使用多条指令来实现。</p><p> 让我们解释一下具体的方法。</p><p>首先，准备一个指向堆栈顶部元素的寄存器。该寄存器称为堆栈指针。如果要弹出堆栈顶部的两个值，请取出堆栈指针指向的两个元素，并将它们更改为您从中删除堆栈指针的元素的数量。同样，压入时，您所要做的就是更改堆栈指针的值并写入它指向的内存区域。</p><p>x86-64 RSP 寄存器设计用作堆栈指针。 x86-64 上的 <code>push</code> 和 <code>pop</code> 等指令隐式使用 RSP 作为堆栈指针，修改其值，并访问 RSP 指向的内存，这是一个命令要做的事情。因此，当像堆栈机一样使用 x86-64 指令集时，可以直接使用 RSP 作为堆栈指针。现在，让我们使用 x86-64 作为堆栈机来编译表达式 <code>1+2</code> 。下面是 x86-64 程序集。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 将左操作数和右操作数推入栈中</span><br><span class="line">push 1</span><br><span class="line">push 2// 弹出左操作数和右操作数到RAX和RDI中，然后执行加法</span><br><span class="line">pop rdi</span><br><span class="line">pop rax</span><br><span class="line">add rax, rdi// 将相加的结果推入栈中</span><br><span class="line">push rax</span><br></pre></td></tr></table></figure><p>由于 x86-64 没有指令 “ 将 RSP 指向的两个元素相加 “，因此您需要将它们加载到寄存器中，执行加法，然后将结果推回堆栈。这就是上面的 <code>add</code> 命令的作用。</p><p>同样，在 x86-64 上实现 <code>2*3+4*5</code> 时，它看起来像这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 计算2*3并将结果推入栈中</span><br><span class="line">push 2</span><br><span class="line">push 3</span><br><span class="line">pop rdi</span><br><span class="line">pop rax</span><br><span class="line">mul rax, rdi</span><br><span class="line">push rax// 计算4*5并将结果推入栈中</span><br><span class="line">push 4</span><br><span class="line">push 5</span><br><span class="line">pop rdi</span><br><span class="line">pop rax</span><br><span class="line">mul rax, rdi</span><br><span class="line">push rax// 对栈顶的两个值进行相加</span><br><span class="line">// 即计算2*3+4*5</span><br><span class="line">pop rdi</span><br><span class="line">pop rax</span><br><span class="line">add rax, rdi</span><br><span class="line">push rax</span><br></pre></td></tr></table></figure><p>这样，通过使用 x86-64 堆栈操作指令，即使在 x86-64 上也可以运行与堆栈机非常相似的代码。</p><p>以下 <code>gen</code> 函数将此技术实现为 C 函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">gen</span><span class="params">(Node *node)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (node-&gt;kind == ND_NUM) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;  push %d\n&quot;</span>, node-&gt;val);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  gen(node-&gt;lhs);</span><br><span class="line">  gen(node-&gt;rhs);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;  pop rdi\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;  pop rax\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span> (node-&gt;kind) &#123;</span><br><span class="line">  <span class="keyword">case</span> ND_ADD:</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;  add rax, rdi\n&quot;</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> ND_SUB:</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;  sub rax, rdi\n&quot;</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> ND_MUL:</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;  imul rax, rdi\n&quot;</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> ND_DIV:</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;  cqo\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;  idiv rdi\n&quot;</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;  push rax\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然它在解析或代码生成中并不是特别重要，但上面的代码使用了 <code>idiv</code> 指令，该指令的规范很棘手，所以让我们解释一下。</p><p><code>idiv</code> 是执行有符号除法的指令。如果 x86-64 的 <code>idiv</code> 有一个简单的规范，上面的代码就会写成 <code>idiv rax, rdi</code> ，但是如果两个这样的寄存器是 则所采用的除法指令在 x86-64 上不存在。相反， <code>idiv</code> 隐式采用 RDX 和 RAX，将它们一起视为 128 位整数，将其除以参数寄存器的 64 位值，然后返回设置在 RAX 中，余数设置在黑索金。使用 <code>cqo</code> 指令，可以将 RAX 中的 64 位值扩展为 128 位，并在 RDX 和 RAX 中设置，因此在上面的代码中， <code>idiv</code> 在调用 <code>cqo</code> 。</p><p>好了，关于堆栈机的解释就到此结束了。到目前为止，您应该能够执行复杂的解析并将生成的抽象语法树转换为机器代码。让我们回去编写一个编译器来运用这些知识！</p><h2 id="第-5-步：创建一种可以执行四种算术运算的语言"><a href="#第-5-步：创建一种可以执行四种算术运算的语言" class="headerlink" title="第 5 步：创建一种可以执行四种算术运算的语言"></a><a href="#%E3%82%B9%E3%83%86%E3%83%83%E3%83%975%E5%9B%9B%E5%89%87%E6%BC%94%E7%AE%97%E3%81%AE%E3%81%A7%E3%81%8D%E3%82%8B%E8%A8%80%E8%AA%9E%E3%81%AE%E4%BD%9C%E6%88%90">第 5 步：创建一种可以执行四种算术运算的语言</a></h2><p>在本章中，我们将修改前面章节中创建的编译器并对其进行扩展，以便它可以处理包含优先括号的四种算术运算的表达式。所有必要的部分都已包含在内，因此只需编写少量新代码。尝试更改编译器的 <code>main</code> 函数以使用新创建的解析器和代码生成器。该代码应如下所示。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">    error(<span class="string">&quot;参数数量不正确&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 对输入进行词法分析和语法分析</span></span><br><span class="line">  user_input = argv[<span class="number">1</span>];</span><br><span class="line">  token = tokenize(user_input);</span><br><span class="line">  Node *node = expr();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 输出汇编的前半部分</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;.intel_syntax noprefix\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;.globl main\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;main:\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 遍历抽象语法树并生成代码</span></span><br><span class="line">  gen(node);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 栈顶应该保留整个表达式的值</span></span><br><span class="line">  <span class="comment">// 将其加载到RAX中并作为函数的返回值</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;  pop rax\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;  ret\n&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时，由加法、减法、乘法和优先级括号组成的表达式应该可以正确编译。让我们添加一些测试。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">assert 47 &#x27;5+6*7&#x27;</span><br><span class="line">assert 15 &#x27;5*(9-6)&#x27;</span><br><span class="line">assert 4 &#x27;(3+5)/2&#x27;</span><br></pre></td></tr></table></figure><p>请注意，为了便于解释，到目前为止的故事流程就好像 <code>*</code> 、 <code>/</code> 和 <code>()</code> 一次性全部实现。事实上，最好避免一次全部实施。由于最初有一个可以执行加法和减法的函数，因此首先尝试引入一个抽象语法树和一个使用它的代码生成器，而不破坏该函数。由于我们当时没有添加新功能，因此不需要新的测试。之后，请实施 <code>*</code> 、 <code>/</code> 和 <code>()</code> ，包括测试。</p><p> 参考实现</p><ul><li><a href="https://github.com/rui314/chibicc/commit/3c1e3831009edff2ea237d3e59680ba9d4bb2e14">3c1e3831009edff2</a></li></ul><p>コラム:  专栏：9cc 中的内存管理</p><p>如果您已经读完本书，您可能想知道内存管理在这个编译器中是如何工作的。到目前为止我们看到的代码使用了 calloc（malloc 的一个变体），但它没有调用 free。换句话说，分配的内存不会被释放。这不是有点疏忽吗？</p><p>事实上，这种 “ 不进行内存管理作为内存管理策略 “ 的设计是作者在考虑了各种权衡后有意选择的。</p><p>这种设计的优点是，通过不释放内存，您可以像编写具有垃圾收集器的语言一样编写代码。这不仅消除了编写内存管理代码的需要，还消除了与手动内存管理相关的神秘错误。</p><p>另一方面，考虑到它像普通 PC 一样在计算机上运行，​​实际上不存在因不释放而引起的问题。编译器是一个短暂的程序，它只读取单个 C 文件并输出汇编代码。当程序结束时，操作系统会自动释放所有分配的内存。因此，唯一的问题是总共分配多少内存，但根据我的实际测量，即使编译相当大的 C 文件，内存占用也只有 100 MiB 左右。</p><p>因此，不释放是一个现实有效的策略。例如，D 语言编译器 DMD 基于同样的思想，采用只分配不释放的策略。 </p><h2 id="步骤-6：一元加和一元减"><a href="#步骤-6：一元加和一元减" class="headerlink" title="步骤 6：一元加和一元减"></a><a href="#%E3%82%B9%E3%83%86%E3%83%83%E3%83%976%E5%8D%98%E9%A0%85%E3%83%97%E3%83%A9%E3%82%B9%E3%81%A8%E5%8D%98%E9%A0%85%E3%83%9E%E3%82%A4%E3%83%8A%E3%82%B9">步骤 6：一元加和一元减</a></h2><p>执行减法的 <code>-</code> 运算符不仅可以在两个术语之间使用，例如 <code>5-3</code> ，也可以在单个术语之间使用，例如 <code>-3</code> 您可以写在前面。类似地， <code>+</code> 运算符可以通过省略左侧而写为 <code>+3</code> 。像这样只使用一项的运算符称为 “ 一元运算符 “。另一方面，采用两项的运算符称为二元运算符。</p><p>除了 <code>+</code> 和 <code>-</code> 之外，C 还具有一元运算符，例如用于获取指针的 <code>&amp;</code> 和用于取消引用指针的 <code>*</code> 。 ，但在这一步中我们将只实现 <code>+</code> 和 <code>-</code> 。</p><p>一元 <code>+</code> 和一元 <code>-</code> 与二元 <code>+</code> 和 <code>-</code> 是相同的符号，但它们的定义不同。二进制 <code>-</code> 被定义为从左侧减去右侧的运算，但由于一元 <code>-</code> 本来就没有左侧，因此二进制 <code>-</code> 该定义本身没有任何意义。在 C 语言中，一元 <code>-</code> 被定义为反转右侧符号的运算。一元 <code>+</code> 是一个运算符，它返回右侧不变。这是一个并不真正需要使用的运算符，但它除了一元 <code>-</code> 之外还存在。</p><p>可以适当地将 <code>+</code> 和 <code>-</code> 视为具有相同名称、具有相似但不同定义的多个运算符：一元和二元。它是一元还是二元取决于上下文。包含一元 <code>+</code> &#x2F; <code>-</code> 的新语法如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">expr    = mul (&quot;+&quot; mul | &quot;-&quot; mul)*</span><br><span class="line">mul     = unary (&quot;*&quot; unary | &quot;/&quot; unary)*</span><br><span class="line">unary   = (&quot;+&quot; | &quot;-&quot;)? primary</span><br><span class="line">primary = num | &quot;(&quot; expr &quot;)&quot;</span><br></pre></td></tr></table></figure><p>上面的新语法添加了一个新的非终结符号 <code>unary</code> ，并且 <code>mul</code> 现在使用 <code>unary</code> 而不是 <code>primary</code> 。我是。 <code>X?</code> 是可选元素的 EBNF 语法，即 <code>X</code> 出现零次或一次。根据规则 <code>unary = (&quot;+&quot; | &quot;-&quot;)? primary</code> ，非终结符号 <code>unary</code> 可能有一个 <code>+</code> 或 <code>-</code> ，或者没有。它后面是 <code>primary</code> 。</p><p>检查 <code>-3</code> 、 <code>-(3+5)</code> 和 <code>-3*+5</code> 等表达式是否与此新语法匹配。 <code>-3*+5</code> 的语法树如下所示。</p><p><img src="/../../img/blog/6f66164ff96d5c4c63b6023b64e7b911_MD5.svg"></p><p>让我们更改解析器以遵循这个新语法。像往常一样，解析器的更改应该通过将语法直接映射到函数调用来完成。解析 <code>unary</code> 的函数如下所示。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Node *<span class="title function_">unary</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (consume(<span class="string">&#x27;+&#x27;</span>))</span><br><span class="line">    <span class="keyword">return</span> primary();</span><br><span class="line">  <span class="keyword">if</span> (consume(<span class="string">&#x27;-&#x27;</span>))</span><br><span class="line">    <span class="keyword">return</span> new_node(ND_SUB, new_node_num(<span class="number">0</span>), primary());</span><br><span class="line">  <span class="keyword">return</span> primary();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里，我决定在解析阶段将 <code>+x</code> 替换为 <code>x</code> ，将 <code>-x</code> 替换为 <code>0-x</code> 。因此，此步骤不需要更改代码生成器。</p><p>您可以通过编写一些测试并将它们与添加一元 <code>+</code> &#x2F; <code>-</code> 的代码一起签入来完成此步骤。编写测试时，尽量将测试结果保持在 0-255 范围内。像 <code>-10+20</code> 这样的表达式使用一元 <code>-</code> 但整体值为正数，因此使用此测试。</p><p> 参考实现</p><ul><li><a href="https://github.com/rui314/chibicc/commit/bb5fe99dbad62c9516ec6a4bc64e444d09115e6d">bb5fe99dbad62c95</a></li></ul><h2 id="第-7-步：比较运算符"><a href="#第-7-步：比较运算符" class="headerlink" title="第 7 步：比较运算符"></a><a href="#%E3%82%B9%E3%83%86%E3%83%83%E3%83%977-%E6%AF%94%E8%BC%83%E6%BC%94%E7%AE%97%E5%AD%90">第 7 步：比较运算符</a></h2><p>在本节中： <code>&lt;</code> 、 <code>&lt;=</code> 、 <code>&gt;</code> 、 <code>&gt;=</code> 、 <code>==</code> 、 <code>!=</code> 实施。虽然这些比较运算符看起来有特殊含义，但它们实际上是将两个整数合并为一个，就像 <code>+</code> 和 <code>-</code> 一样，它是一个返回两个整数的普通二元运算符。就像 <code>+</code> 返回两边相加的结果一样，例如 <code>==</code> 如果两边相同则返回 1，如果不同则返回 0。</p><h3 id="分词器更改"><a href="#分词器更改" class="headerlink" title="分词器更改"></a><a href="#%E3%83%88%E3%83%BC%E3%82%AF%E3%83%8A%E3%82%A4%E3%82%B6%E3%81%AE%E5%A4%89%E6%9B%B4">分词器更改</a></h3><p>到目前为止我们处理的符号标记的长度都是一个字符，我们在代码中也假设了这一点，但是为了处理诸如 <code>==</code> 这样的比较运算符，我们对代码进行了泛化，需要这样做。让我们在 <code>Token</code> 结构中存储一个名为 <code>len</code> 的成员，以便我们可以将字符串的长度存储在令牌中。新的结构类型如下所示。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Token</span> &#123;</span></span><br><span class="line">  TokenKind kind; <span class="comment">// 令牌的类型</span></span><br><span class="line">  Token *next;    <span class="comment">// 下一个输入令牌</span></span><br><span class="line">  <span class="type">int</span> val;        <span class="comment">// 仅当kind为TK_NUM时使用，表示数值</span></span><br><span class="line">  <span class="type">char</span> *str;      <span class="comment">// 令牌字符串</span></span><br><span class="line">  <span class="type">int</span> len;        <span class="comment">// 令牌的长度</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>此更改还需要更改 <code>consume</code> 和 <code>expect</code> 等函数来改进它们，以便它们接受字符串而不是字符。这是一个进行了一些更改的示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">consume</span><span class="params">(<span class="type">char</span> *op)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (token-&gt;kind != TK_RESERVED ||</span><br><span class="line">      <span class="built_in">strlen</span>(op) != token-&gt;len ||</span><br><span class="line">      <span class="built_in">memcmp</span>(token-&gt;str, op, token-&gt;len))</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  token = token-&gt;next;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当对由多个字符组成的符号进行标记时，必须首先对较长的标记进行标记。例如，如果字符串的其余部分以 <code>&gt;</code> 开头，则可以使用 &lt; b3 如果您检查它以 &gt; 开头的可能性， <code>&gt;=</code> 将被错误地标记为两个标记， <code>&gt;</code> 和 <code>=</code> 。完毕。</p><h3 id="新语法"><a href="#新语法" class="headerlink" title="新语法"></a><a href="#%E6%96%B0%E3%81%97%E3%81%84%E6%96%87%E6%B3%95">新语法</a></h3><p>要向解析器添加对比较运算符的支持，请考虑添加比较运算符后语法会是什么样子。如果按照优先级从低到高的顺序编写到目前为止出现的运算符，它将如下所示：</p><ol><li><p><code>==</code> <code>!=</code></p></li><li><p><code>&lt;</code> <code>&lt;=</code> <code>&gt;</code> <code>&gt;=</code></p></li><li><p><code>+</code> <code>-</code></p></li><li><p><code>*</code> <code>/</code></p></li><li><p>一元 <code>+</code> 一元 <code>-</code></p></li><li><p><code>()</code></p></li></ol><p>优先级可以用生成语法来表达，其中具有不同优先级的运算符映射到不同的非终结符。如果我们以与 <code>expr</code> 和 <code>mul</code> 相同的方式考虑语法，则添加比较运算符的新语法如下。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">expr       = equality</span><br><span class="line">equality   = relational (&quot;==&quot; relational | &quot;!=&quot; relational)*</span><br><span class="line">relational = add (&quot;&lt;&quot; add | &quot;&lt;=&quot; add | &quot;&gt;&quot; add | &quot;&gt;=&quot; add)*</span><br><span class="line">add        = mul (&quot;+&quot; mul | &quot;-&quot; mul)*</span><br><span class="line">mul        = unary (&quot;*&quot; unary | &quot;/&quot; unary)*</span><br><span class="line">unary      = (&quot;+&quot; | &quot;-&quot;)? primary</span><br><span class="line">primary    = num | &quot;(&quot; expr &quot;)&quot;</span><br></pre></td></tr></table></figure><p><code>equality</code> 有 <code>==</code> 和 <code>!=</code> ， <code>relational</code> 有 <code>&lt;</code> ， <code>&lt;=</code> ， &lt; 它代表 b6&gt;和 <code>&gt;=</code> 。这些非终结符可以使用解析左关联运算符的模式直接映射到函数。</p><p>注意，在上面的语法中， <code>expr</code> 和 <code>equality</code> 被分开，表示整个表达式是 <code>equality</code> 。我本来可以将 <code>equality</code> 的右侧直接写在 <code>expr</code> 的右侧，但我认为上面的语法可能更容易阅读。</p><p>コラム: 专栏：简单而冗长的代码与高级而简洁的代码</p><p>在递归降序解析中，您编写的代码几乎完全对应于产生式规则，因此解析相似规则的函数看起来是相同的。您到目前为止编写的 <code>relational</code> 、 <code>equality</code> 、 <code>add</code> 和 <code>mul</code> 也应该具有类似的功能。</p><p>人们很自然地会想到如何使用元编程技术（例如 C 宏、C++ 模板、高阶函数和代码生成）更好地抽象这些函数的常见模式。事实上，这样的事情是可以做的。然而，本书并不是有意这样做的。理由如下。</p><p>简单的代码很容易理解，即使有些冗长。如果您稍后最终对类似的功能进行类似的更改，那么实际上没什么大不了的。另一方面，高度抽象的代码可能很难理解，因为您首先需要了解抽象机制，然后再了解如何使用它。例如，如果我在本书开始时编写了一个使用元编程生成递归下降解析函数的函数，那么这本书就会困难得多。</p><p>您不必总是以编写优雅而简洁的代码为目标。当你的目标是这样的时候，你往往会让代码变得更难，以至于不能再难了。</p><p>编写代码的人成为该代码的专家，因此他们倾向于认为从专家的角度来看简洁、精益的代码就是好代码，但大多数代码读者与作者有相同的感觉。没有必要这样。首先要精通它，所以你需要在某种程度上质疑自己作为代码编写者的感觉。创建易于理解和维护的程序的一项重要技术是有意编写简单的代码，必要时可以写得更好。</p><h3 id="汇编代码生成"><a href="#汇编代码生成" class="headerlink" title="汇编代码生成"></a><a href="#%E3%82%A2%E3%82%BB%E3%83%B3%E3%83%96%E3%83%AA%E3%82%B3%E3%83%BC%E3%83%89%E3%81%AE%E7%94%9F%E6%88%90">汇编代码生成</a></h3><p>在 x86-64 上，使用 cmp 指令进行比较。从堆栈中弹出两个整数，执行比较，如果它们相同则将 RAX 设置为 1，否则设置为 0，代码如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pop rdi</span><br><span class="line">pop rax</span><br><span class="line">cmp rax, rdi</span><br><span class="line">sete al</span><br><span class="line">movzb rax, al</span><br></pre></td></tr></table></figure><p>对于一个简短的程序集来说，代码有点冗长，所以让我们一步一步地完成它。</p><p>前两行将值从堆栈中弹出。第三行比较弹出的值。比较结果去哪儿了？在 x86-64 上，比较指令的结果设置在特殊的 “ 标志寄存器 “ 中。标志寄存器是每次执行整数运算或比较运算指令时更新的寄存器，包含指示结果是否为 0 的位、指示是否发生溢出的位、指示结果是否小于的位 0 等都有。</p><p>标志寄存器不是普通的整数寄存器，因此如果要将比较结果设置到 RAX 中，则需要将标志寄存器的特定位复制到 RAX 中。 <code>sete</code> 指令执行此操作。如果前一个 <code>cmp</code> 指令检查的两个寄存器中的值相同，则 <code>sete</code> 指令将指定寄存器（此处为 AL）设置为 1。否则设置为 0。</p><p>AL 是本书中尚未出现的新寄存器名称，但 AL 实际上只是另一个指向 RAX 低 8 位的寄存器。因此，当 <code>sete</code> 将值设置为 AL 时，RAX 也会自动更新。然而，当通过 AL 更新 RAX 时，高 56 位保持其原始值，因此如果要将整个 RAX 设置为 0 或 1，则必须将高 56 位清零。 <code>movzb</code> 指令执行此操作。如果 <code>sete</code> 指令可以直接写入 RAX 就好了，但是 <code>sete</code> 被设计为只接受 8 位寄存器作为参数，所以比较指令可以这样写我们将使用两条指令来设置 RAX 中的值。</p><p><img src="/../../img/blog/06de9cc7e6089d326d9aa40e45c6a426_MD5.svg"></p><p>其他比较运算符可以使用其他指令代替 <code>sete</code> 来实现。使用 <code>setl</code> 表示 <code>&lt;</code> ，使用 <code>setle</code> 表示 <code>&lt;=</code> ，使用 <code>setne</code> 表示 <code>!=</code> 。请。</p><p><code>&gt;</code> 和 <code>&gt;=</code> 不需要代码生成器支持。请在解析器中切换两边并将其读取为 <code>&lt;</code> 或 <code>&lt;=</code> 。</p><p> 参考实现</p><ul><li><a href="https://github.com/rui314/chibicc/commit/6ddba4be5f63388607fc77fd786267b9ddcb14c9">6ddba4be5f633886</a></li></ul><hr><h1 id="单独编译和链接"><a href="#单独编译和链接" class="headerlink" title="单独编译和链接"></a><a href="#%E5%88%86%E5%89%B2%E3%82%B3%E3%83%B3%E3%83%91%E3%82%A4%E3%83%AB%E3%81%A8%E3%83%AA%E3%83%B3%E3%82%AF">单独编译和链接</a></h1><p>在此阶段之前，开发一直采用仅由一个 C 文件和一个测试 shell 脚本组成的文件结构。这个结构并没有什么问题，但是由于源代码越来越长，我决定将其拆分为多个 C 文件，以便于阅读。在这一步中，我们将把一个文件 9cc.c 拆分为以下五个文件。</p><ul><li><code>9cc.h</code> ：头文件</li><li><code>main.c</code> : <code>main</code> 功能</li><li><code>parse.c</code> ：解析器</li><li><code>codegen.c</code> ：代码生成器</li></ul><p>由于 <code>main</code> 函数很小，我可以将它放在另一个 C 文件中，但从语义上讲，它不属于 <code>parse.c</code> 或 <code>codegen.c</code> ，所以我会将其分成一个单独的文件。</p><h2 id="步骤8：分割文件并更改Makefile"><a href="#步骤8：分割文件并更改Makefile" class="headerlink" title="步骤8：分割文件并更改Makefile"></a><a href="#%E3%82%B9%E3%83%86%E3%83%83%E3%83%978-%E3%83%95%E3%82%A1%E3%82%A4%E3%83%AB%E5%88%86%E5%89%B2%E3%81%A8makefile%E3%81%AE%E5%A4%89%E6%9B%B4">步骤8：分割文件并更改Makefile</a></h2><h3 id="分割文件"><a href="#分割文件" class="headerlink" title="分割文件"></a><a href="#%E3%83%95%E3%82%A1%E3%82%A4%E3%83%AB%E3%81%AE%E5%88%86%E5%89%B2">分割文件</a></h3><p>尝试使用本章开头所示的配置来拆分文件。 <code>9cc.h</code> 是一个头文件。根据程序的结构，每个 <code>.c</code> 文件可能有一个 <code>.h</code> 文件，但额外的声明不会造成任何特定的危害。，没有必要管理这样的详细的依赖关系在这里。准备一个名为 <code>9cc.h</code> 的文件，并将其作为 <code>#include &quot;9cc.h&quot;</code> 包含在所有 C 文件中。</p><h3 id="生成文件更改"><a href="#生成文件更改" class="headerlink" title="生成文件更改"></a><a href="#makefile%E3%81%AE%E5%A4%89%E6%9B%B4">生成文件更改</a></h3><p>现在我们已经将程序更改为多个文件，让我们也更新 <code>Makefile</code> 。下面的 <code>Makefile</code> 编译并链接当前目录中的所有 .c 文件，以创建一个名为 9cc 的可执行文件。假设只有一个文件 9cc.h 作为项目头文件，并且所有 .c 文件都包含该头文件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">CFLAGS=-std=c11 -g -static</span><br><span class="line">SRCS=$(wildcard *.c)</span><br><span class="line">OBJS=$(SRCS:.c=.o)</span><br><span class="line"></span><br><span class="line">9cc: $(OBJS)</span><br><span class="line">        $(CC) -o 9cc $(OBJS) $(LDFLAGS)</span><br><span class="line"></span><br><span class="line">$(OBJS): 9cc.h</span><br><span class="line"></span><br><span class="line">test: 9cc</span><br><span class="line">        ./test.sh</span><br><span class="line"></span><br><span class="line">clean:</span><br><span class="line">        rm -f 9cc *.o *~ tmp*</span><br><span class="line"></span><br><span class="line">.PHONY: test clean</span><br></pre></td></tr></table></figure><p>注意 <code>Makefile</code> 的缩进必须是制表符。</p><p>在 <code>Makefile</code> 中，由冒号分隔的行和由制表符缩进的零个或多个命令行构成了一条规则。冒号之前的名称称为 “ 目标 “。冒号后的零个或多个文件名称为从属文件。</p><p>当您运行 <code>make foo</code> 时， <code>make</code> 尝试创建一个名为 <code>foo</code> 的文件。如果指定的目标文件已存在，则仅当目标文件早于依赖文件时， <code>make</code> 才会重新运行目标规则。这使得仅当源代码更改时才可以重新生成二进制文件等行为。</p><p><code>.PHONY</code> 是一个特殊名称，用于表示虚拟目标。 <code>make test</code> 和 <code>make clean</code> 不会执行来创建 <code>test</code> 和 <code>clean</code> 等文件，但通常 <code>make</code> 不会执行不知道这一点，所以如果碰巧存在名为 <code>test</code> 或 <code>clean</code> 的文件，它将使用 <code>make test</code> 或 <code>make clean</code> 不再做任何事。通过用 <code>.PHONY</code> 指定这样一个虚拟目标，你并不真的想创建一个具有该名称的文件，但是无论指定的目标文件是否存在，规则都会被执行。你可以告诉 <code>make</code> 应该执行命令。</p><p><code>CFLAGS</code> 、 <code>SRCS</code> 和 <code>OBJS</code> 是变量。</p><p><code>CFLAGS</code> 是 make 的内置规则识别的变量，包含要传递给 C 编译器的命令行选项。在这里我们传递以下标志：</p><ul><li><code>-std=c11</code> ：告诉源代码是用最新的 C 标准 C11 编写的。</li><li><code>-g</code> ：输出调试信息</li><li><code>-static</code> ：静态链接</li></ul><p><code>SRCS</code> 右侧使用的 <code>wildcard</code> 是 make 提供的函数，扩展为与函数参数匹配的文件名。 <code>$(wildcard *.c)</code> 目前扩展为 <code>main.c parse.c codegen.c</code> 。</p><p><code>OBJS</code> 右侧使用变量替换规则生成一个值，将 SRC 中的.c 替换为.o。 <code>SRCS</code> 变为 <code>main.c parse.c codegen.c</code> ，因此 <code>OBJS</code> 变为 <code>main.o parse.o codegen.o</code> 。</p><p>考虑到这些事情，让我们跟踪一下执行 <code>make 9cc</code> 时发生的情况。该命令的最终目标是创建 <code>9cc</code> 文件，因为 make 尝试生成指定为参数的目标（如果没有参数，则选择第一个规则，因此在本例中，9cc 执行无需指定）。 make 通过遍历依赖项并尝试构建丢失或过时的文件来实现此目的。</p><p><code>9cc</code> 的依赖文件是当前目录中与 <code>.c</code> 文件对应的 <code>.o</code> 文件。如果 <code>.o</code> 文件在上次运行 make 时保留下来，并且它的时间戳比相应的 <code>.c</code> 文件更新，那么 make 会费心重新运行相同的命令。我不这样做那。仅当 <code>.o</code> 文件不存在或 <code>.c</code> 文件较新时才运行编译器生成 <code>.o</code> 文件。</p><p>规则 <code>$(OBJS): 9cc.h</code> 表示所有 <code>.o</code> 文件依赖于 <code>9cc.h</code> 。因此，如果更改 <code>9cc.h</code> ，所有 <code>.o</code> 文件都将重新编译。</p><p>コラム:  专栏：static 关键字的各种含义</p><p>C 中的 <code>static</code> 关键字有两个主要用途：</p><ol><li><p>将 <code>static</code> 添加到局部变量，以便即使退出函数后它们的值也能保存</p></li><li><p>在全局变量和函数中添加 <code>static</code> ，使变量和函数的作用域成为文件作用域。</p></li></ol><p>虽然这两种用法没有什么共同点，但是它们使用了相同的关键字，这是学习 C 时的困惑点之一。理想情况下，他们应该使用不同的关键字，例如用于用法 1 的 <code>persistent</code> 和用于用法 2 的 <code>private</code> 。更理想的情况是，对于用法 2，最好使用 <code>private</code> 作为默认值并将 <code>public</code> 附加到全局范围内的变量和函数。</p><p>C 重用关键字的原因是为了与过去编写的代码资产兼容。如果向语言添加新关键字（例如 <code>private</code> ），则使用该关键字作为变量或函数名称的现有程序将不再编译。 C 不喜欢这样，因此他决定在不同的上下文中重用现有的关键字，而不是添加更多关键字。</p><p>如果我在 20 世纪 70 年代的某个时候决定添加新关键字而不是重复使用 <code>static</code> 关键字，我可能可以节省大量的代码更改。如果您考虑到那时该怎么做，那就是相当困难的问题。</p><hr><h1 id="函数和局部变量"><a href="#函数和局部变量" class="headerlink" title="函数和局部变量"></a><a href="#%E9%96%A2%E6%95%B0%E3%81%A8%E3%83%AD%E3%83%BC%E3%82%AB%E3%83%AB%E5%A4%89%E6%95%B0">函数和局部变量</a></h1><p>在本章中，我们将实现函数和局部变量。我们还实现了一个简单的控制结构。完成本章后，您将能够编译如下代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// mからnまでを足す</span><br><span class="line">sum(m, n) &#123;</span><br><span class="line">  acc = 0;</span><br><span class="line">  for (i = m; i &lt;= n; i = i + 1)</span><br><span class="line">    acc = acc + i;</span><br><span class="line">  return acc;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main() &#123;</span><br><span class="line">  return sum(1, 10); // 55を返す</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然上面的代码和 C 还有差距，但我想可以说已经相当接近 C 了。</p><h2 id="第9步：单字符局部变量"><a href="#第9步：单字符局部变量" class="headerlink" title="第9步：单字符局部变量"></a><a href="#%E3%82%B9%E3%83%86%E3%83%83%E3%83%9791%E6%96%87%E5%AD%97%E3%81%AE%E3%83%AD%E3%83%BC%E3%82%AB%E3%83%AB%E5%A4%89%E6%95%B0">第9步：单字符局部变量</a></h2><p>到上一章为止，我们已经能够为可以执行四种算术运算的语言创建编译器。在本节中，我们将向该语言添加功能以允许使用变量。具体来说，目标是能够编译包含变量的多个语句，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = 3;</span><br><span class="line">b = 5 * 6 - 8;</span><br><span class="line">a + b / 2;</span><br></pre></td></tr></table></figure><p>我们用最后一个表达式的结果作为整个程序的计算结果。我认为你可以说这种语言比只使用四个算术运算的语言具有更 “ 真实的语言 “ 感觉。</p><p>在本章中，我们将首先解释如何实现变量，然后我们将逐步实现变量。</p><h3 id="分词器更改-1"><a href="#分词器更改-1" class="headerlink" title="分词器更改"></a><a href="#%E3%83%88%E3%83%BC%E3%82%AF%E3%83%8A%E3%82%A4%E3%82%B6%E3%81%AE%E5%A4%89%E6%9B%B4-1">分词器更改</a></h3><p>现在您已经知道如何实现变量了，让我们开始实现它们吧。然而，支持任意数量的变量很快就变得太困难了，所以我们决定在这一步中将变量限制为单个小写字母，因此变量 <code>a</code> 是 RBP-8，变量 <code>b</code> 是 RBP-16，变量 <code>c</code> 是 RBP-24，依此类推。由于字母表中有 26 个字符，如果我们决定将 RSP 下推 26 x 8，即 208 个字节，那么在调用该函数时，我们将能够为所有单字符变量保留空间。</p><p>我们现在就来实现它。首先，让我们修改分词器，使其除了前面的语法元素之外还可以对单字符变量进行分词。为此，我们需要添加新的令牌类型。由于可以从 <code>str</code> 成员中读取变量名，因此无需向 <code>Token</code> 类型添加新成员。因此，令牌类型为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">  TK_RESERVED, <span class="comment">// 符号</span></span><br><span class="line">  TK_IDENT,    <span class="comment">// 标识符</span></span><br><span class="line">  TK_NUM,      <span class="comment">// 整数令牌</span></span><br><span class="line">  TK_EOF,      <span class="comment">// 表示输入结束的令牌</span></span><br><span class="line">&#125; TokenKind;</span><br></pre></td></tr></table></figure><p>修改标记生成器，为字母表中的小写字母创建 <code>TK_IDENT</code> 类型的标记。您应该将以下 <code>if</code> 语句添加到标记生成器中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="string">&#x27;a&#x27;</span> &lt;= *p &amp;&amp; *p &lt;= <span class="string">&#x27;z&#x27;</span>) &#123;</span><br><span class="line">  cur = new_token(TK_IDENT, cur, p++);</span><br><span class="line">  cur-&gt;len = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="解析器的变化"><a href="#解析器的变化" class="headerlink" title="解析器的变化"></a><a href="#%E3%83%91%E3%83%BC%E3%82%B5%E3%81%AE%E5%A4%89%E6%9B%B4">解析器的变化</a></h3><p>通过递归下降解析，如果您知道语法，则可以将其机械地映射到函数调用。因此，为了考虑应该对解析器进行更改，有必要考虑添加变量名（标识符）时新语法将是什么样子。</p><p>我们将标识符称为 <code>ident</code> 。这是一个终结符，就像 <code>num</code> 一样。任何可以使用数字的地方都可以使用变量，因此将 <code>num</code> 替换为 <code>num | ident</code> 创建的语法允许在与数字相同的位置使用变量。</p><p>除此之外，我们还需要在语法中添加一个赋值表达式。由于无法分配变量，我们希望创建一种允许 <code>a=1</code> 等表达式的语法。在这里，我们使用可以写成 <code>a=b=1</code> 的语法来匹配 C。</p><p>此外，我希望能够编写用分号分隔的多个语句，因此生成的新语法如下。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">program    = stmt*</span><br><span class="line">stmt       = expr &quot;;&quot;</span><br><span class="line">expr       = assign</span><br><span class="line">assign     = equality (&quot;=&quot; assign)?</span><br><span class="line">equality   = relational (&quot;==&quot; relational | &quot;!=&quot; relational)*</span><br><span class="line">relational = add (&quot;&lt;&quot; add | &quot;&lt;=&quot; add | &quot;&gt;&quot; add | &quot;&gt;=&quot; add)*</span><br><span class="line">add        = mul (&quot;+&quot; mul | &quot;-&quot; mul)*</span><br><span class="line">mul        = unary (&quot;*&quot; unary | &quot;/&quot; unary)*</span><br><span class="line">unary      = (&quot;+&quot; | &quot;-&quot;)? primary</span><br><span class="line">primary    = num | ident | &quot;(&quot; expr &quot;)&quot;</span><br></pre></td></tr></table></figure><p>首先，检查 <code>42;</code> 和 <code>a=b=2; a+b;</code> 等程序是否符合此语法。之后，修改您到目前为止创建的解析器，以便它可以解析上述语法。在这个阶段，像 <code>a+1=5</code> 这样的表达式也可以被解析，这是正确的。消除此类语义上无效的表达式将在下一步中完成。修改解析器没有什么特别棘手的，您应该能够像以前一样通过将语法元素映射到函数调用来完成此操作。</p><p>由于我们通过用分号分隔来乘以多个表达式，因此我们需要将多个节点作为解析结果保存在某处。现在，请准备以下全局数组并按顺序存储解析结果节点。如果用 NULL 填充最后一个节点，您将能够看到它的结束位置。下面显示了一些要添加的新代码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Node *code[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line">Node *<span class="title function_">assign</span><span class="params">()</span> &#123;</span><br><span class="line">  Node *node = equality();</span><br><span class="line">  <span class="keyword">if</span> (consume(<span class="string">&quot;=&quot;</span>))</span><br><span class="line">    node = new_node(ND_ASSIGN, node, assign());</span><br><span class="line">  <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Node *<span class="title function_">expr</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> assign();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Node *<span class="title function_">stmt</span><span class="params">()</span> &#123;</span><br><span class="line">  Node *node = expr();</span><br><span class="line">  expect(<span class="string">&quot;;&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">program</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (!at_eof())</span><br><span class="line">    code[i++] = stmt();</span><br><span class="line">  code[i] = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>抽象语法树需要能够表达一个新的 “ 代表局部变量的节点 “。为此，我们为局部变量添加一个新类型，为节点添加一个新成员。例如，它应该如下所示：此数据结构使解析器为标识符标记创建并返回类型为 <code>ND_LVAR</code> 的节点。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">  ND_ADD,    <span class="comment">// +</span></span><br><span class="line">  ND_SUB,    <span class="comment">// -</span></span><br><span class="line">  ND_MUL,    <span class="comment">// *</span></span><br><span class="line">  ND_DIV,    <span class="comment">// /</span></span><br><span class="line">  ND_ASSIGN, <span class="comment">// =</span></span><br><span class="line">  ND_LVAR,   <span class="comment">// 局部变量</span></span><br><span class="line">  ND_NUM,    <span class="comment">// 整数</span></span><br><span class="line">&#125; NodeKind;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> <span class="title">Node</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象语法树节点</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">  NodeKind kind; <span class="comment">// 节点类型</span></span><br><span class="line">  Node *lhs;     <span class="comment">// 左操作数</span></span><br><span class="line">  Node *rhs;     <span class="comment">// 右操作数</span></span><br><span class="line">  <span class="type">int</span> val;       <span class="comment">// 仅在kind为ND_NUM时使用</span></span><br><span class="line">  <span class="type">int</span> offset;    <span class="comment">// 仅在kind为ND_LVAR时使用</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>offset</code> 是一个成员，表示距局部变量基指针的偏移量。目前，局部变量处于由名称决定的固定位置，例如 RBP-8 中的变量 <code>a</code> 、RBP-16 中的 <code>b</code> 等，因此偏移量为语法这样可以在分析阶段确定。下面的代码读取标识符并返回 <code>ND_LVAR</code> 类型的节点。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Node *<span class="title function_">primary</span><span class="params">()</span> &#123;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  Token *tok = consume_ident();</span><br><span class="line">  <span class="keyword">if</span> (tok) &#123;</span><br><span class="line">    Node *node = <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="keyword">sizeof</span>(Node));</span><br><span class="line">    node-&gt;kind = ND_LVAR;</span><br><span class="line">    node-&gt;offset = (tok-&gt;str[<span class="number">0</span>] - <span class="string">&#x27;a&#x27;</span> + <span class="number">1</span>) * <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ...</span><br></pre></td></tr></table></figure><h3 id="代码生成器更改"><a href="#代码生成器更改" class="headerlink" title="代码生成器更改"></a><a href="#%E3%82%B3%E3%83%BC%E3%83%89%E3%82%B8%E3%82%A7%E3%83%8D%E3%83%AC%E3%83%BC%E3%82%BF%E3%81%AE%E5%A4%89%E6%9B%B4">代码生成器更改</a></h3><p>使用我们到目前为止所学到的知识，让我们修改代码生成器以处理包含变量的表达式。此更改添加了一个将表达式计算为左值的函数。下面代码中的函数 <code>gen_lval</code> 就是这样做的。 <code>gen_lval</code> 当给定节点指向变量时计算变量的地址并将其推入堆栈。否则显示错误。这将消除像 <code>(a+1)=2</code> 这样的表达式。</p><p>当使用变量作为右值时，首先将其计算为左值，然后将堆栈顶部的计算结果视为地址，并从该地址加载值。代码如下所示。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">gen_lval</span><span class="params">(Node *node)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (node-&gt;kind != ND_LVAR)</span><br><span class="line">    error(<span class="string">&quot;赋值操作左值不是变量&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;  mov rax, rbp\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;  sub rax, %d\n&quot;</span>, node-&gt;offset);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;  push rax\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">gen</span><span class="params">(Node *node)</span> &#123;</span><br><span class="line">  <span class="keyword">switch</span> (node-&gt;kind) &#123;</span><br><span class="line">  <span class="keyword">case</span> ND_NUM:</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;  push %d\n&quot;</span>, node-&gt;val);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">case</span> ND_LVAR:</span><br><span class="line">    gen_lval(node);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;  pop rax\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;  mov rax, [rax]\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;  push rax\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">case</span> ND_ASSIGN:</span><br><span class="line">    gen_lval(node-&gt;lhs);</span><br><span class="line">    gen(node-&gt;rhs);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;  pop rdi\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;  pop rax\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;  mov [rax], rdi\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;  push rdi\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  gen(node-&gt;lhs);</span><br><span class="line">  gen(node-&gt;rhs);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;  pop rdi\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;  pop rax\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span> (node-&gt;kind) &#123;</span><br><span class="line">  <span class="keyword">case</span> ND_ADD:</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;  add rax, rdi\n&quot;</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> ND_SUB:</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;  sub rax, rdi\n&quot;</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> ND_MUL:</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;  imul rax, rdi\n&quot;</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> ND_DIV:</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;  cqo\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;  idiv rdi\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;  push rax\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="主要功能变化"><a href="#主要功能变化" class="headerlink" title="主要功能变化"></a><a href="#%E3%83%A1%E3%82%A4%E3%83%B3%E9%96%A2%E6%95%B0%E3%81%AE%E5%A4%89%E6%9B%B4">主要功能变化</a></h3><p>现在我们已经拥有了所有部分，让我们更改 <code>main</code> 函数并实际运行编译器。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">    error(<span class="string">&quot;参数数量不正确&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 对输入进行词法分析和语法分析</span></span><br><span class="line">  <span class="comment">// 结果存储在code中</span></span><br><span class="line">  user_input = argv[<span class="number">1</span>];</span><br><span class="line">  tokenize();</span><br><span class="line">  program();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 输出汇编的前半部分</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;.intel_syntax noprefix\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;.globl main\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;main:\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 函数开头</span></span><br><span class="line">  <span class="comment">// 分配26个变量的内存空间</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;  push rbp\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;  mov rbp, rsp\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;  sub rsp, 208\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 顺序生成代码从第一个表达式开始</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; code[i]; i++) &#123;</span><br><span class="line">    gen(code[i]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 表达式的计算结果应该留在栈中</span></span><br><span class="line">    <span class="comment">// 因此为了避免栈溢出，我们在这里弹出计算结果</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;  pop rax\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 函数结尾</span></span><br><span class="line">  <span class="comment">// 最后一个表达式的结果保存在RAX中，作为返回值</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;  mov rsp, rbp\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;  pop rbp\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;  ret\n&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第10步：多字符局部变量"><a href="#第10步：多字符局部变量" class="headerlink" title="第10步：多字符局部变量"></a><a href="#%E3%82%B9%E3%83%86%E3%83%83%E3%83%9710%E8%A4%87%E6%95%B0%E6%96%87%E5%AD%97%E3%81%AE%E3%83%AD%E3%83%BC%E3%82%AB%E3%83%AB%E5%A4%89%E6%95%B0">第10步：多字符局部变量</a></h2><p>在上一章中，我们将变量名固定为一个字母，并将其视为从 a 到 z 的 26 个局部变量始终存在。本节提供对名称长于一个字符的标识符的支持，允许编译如下代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">foo = 1;</span><br><span class="line">bar = 2 + 3;</span><br><span class="line">return foo + bar; </span><br></pre></td></tr></table></figure><p>变量无需定义即可使用。因此，解析器必须确定每个标识符以前是否见过，如果是新的，则自动在堆栈区域中分配一个变量。</p><p>首先，更改标记生成器以将多字符标识符读取为 <code>TK_IDENT</code> 类型标记。</p><p>我们将把变量表示为链表。让我们使用名为 <code>LVar</code> 的结构来表示一个变量，并将第一个元素保存为名为 <code>locals</code> 的指针。用代码表达的话，看起来像这样：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LVar</span> <span class="title">LVar</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 局部变量的类型</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LVar</span> &#123;</span></span><br><span class="line">  LVar *next; <span class="comment">// 下一个变量或NULL</span></span><br><span class="line">  <span class="type">char</span> *name; <span class="comment">// 变量的名称</span></span><br><span class="line">  <span class="type">int</span> len;    <span class="comment">// 名称的长度</span></span><br><span class="line">  <span class="type">int</span> offset; <span class="comment">// 从RBP的偏移量</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 局部变量链表</span></span><br><span class="line">LVar *locals;</span><br></pre></td></tr></table></figure><p>在解析器中，当出现 <code>TK_IDENT</code> 类型的标记时，它会检查该标识符是否曾经出现过。您可以通过跟随 <code>locals</code> 并查看变量名称来判断变量是否已存在。如果该变量之前出现过，则按原样使用该变量的 <code>offset</code> 。对于新变量，创建新的 <code>LVar</code> ，设置新的偏移量，然后使用该偏移量。</p><p> 下面是一个按名称搜索变量的函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过名称搜索变量。如果找不到，则返回NULL。</span></span><br><span class="line">LVar *<span class="title function_">find_lvar</span><span class="params">(Token *tok)</span> &#123;</span><br><span class="line">  <span class="keyword">for</span> (LVar *var = locals; var; var = var-&gt;next)</span><br><span class="line">    <span class="keyword">if</span> (var-&gt;len == tok-&gt;len &amp;&amp; !<span class="built_in">memcmp</span>(tok-&gt;str, var-&gt;name, var-&gt;len))</span><br><span class="line">      <span class="keyword">return</span> var;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在你的解析器中，你应该只添加如下代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Token *tok = consume_ident();</span><br><span class="line"><span class="keyword">if</span> (tok) &#123;</span><br><span class="line">  Node *node = <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="keyword">sizeof</span>(Node));</span><br><span class="line">  node-&gt;kind = ND_LVAR;</span><br><span class="line"></span><br><span class="line">  LVar *lvar = find_lvar(tok);</span><br><span class="line">  <span class="keyword">if</span> (lvar) &#123;</span><br><span class="line">    node-&gt;offset = lvar-&gt;offset;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    lvar = <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="keyword">sizeof</span>(LVar));</span><br><span class="line">    lvar-&gt;next = locals;</span><br><span class="line">    lvar-&gt;name = tok-&gt;str;</span><br><span class="line">    lvar-&gt;len = tok-&gt;len;</span><br><span class="line">    lvar-&gt;offset = locals-&gt;offset + <span class="number">8</span>;</span><br><span class="line">    node-&gt;offset = lvar-&gt;offset;</span><br><span class="line">    locals = lvar;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第11步：返回语句"><a href="#第11步：返回语句" class="headerlink" title="第11步：返回语句"></a><a href="#%E3%82%B9%E3%83%86%E3%83%83%E3%83%9711return%E6%96%87">第11步：返回语句</a></h2><p>在本章中，我们将添加 <code>return</code> 语句，以便我们可以编译如下代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = 3;</span><br><span class="line">b = 5 * 6 - 8;</span><br><span class="line">return a + b / 2;</span><br></pre></td></tr></table></figure><p>假设 <code>return</code> 语句可以写在程序中间。与普通 C 一样，程序执行将在第一个 <code>return</code> 处中止，并且函数将返回。例如，下面的程序返回第一个 <code>return</code> 的值，即 5。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">return 5;</span><br><span class="line">return 8;</span><br></pre></td></tr></table></figure><p>为了实现这个功能，我们首先考虑一下添加了 <code>return</code> 的语法会发生什么。到目前为止，语句只是一个表达式，但新语法允许 <code>return &lt;式&gt;;</code> 。所以新的语法是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">program = stmt*</span><br><span class="line">stmt    = expr &quot;;&quot;</span><br><span class="line">        | &quot;return&quot; expr &quot;;&quot;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>为了实现这一点，分词器、解析器和代码生成器都需要进行一些调整。</p><p>首先，让标记生成器识别 <code>return</code> 标记并用 <code>TK_RETURN</code> 类型标记表示它。只有有限数量的标记（称为关键字）在语法中具有特殊含义，例如 <code>return</code> 、 <code>while</code> 和 <code>int</code> 。让每个令牌都有不同的类型，就像这样。</p><p>要确定下一个标记是否是 <code>return</code> ，似乎您所要做的就是检查标记器的剩余输入字符串是否以 <code>return</code> 开头，但在这种情况下，<code>returnx</code> 这样的标记会被错误地标记为 <code>return</code> 和 <code>x</code> 。所以这里我们需要确保输入以 <code>return</code> 开头，并且下一个字符不是令牌字符。</p><p>下面是一个函数，用于确定给定字符是否是标记字符，即字母数字字符或下划线。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">is_alnum</span><span class="params">(<span class="type">char</span> c)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (<span class="string">&#x27;a&#x27;</span> &lt;= c &amp;&amp; c &lt;= <span class="string">&#x27;z&#x27;</span>) ||</span><br><span class="line">         (<span class="string">&#x27;A&#x27;</span> &lt;= c &amp;&amp; c &lt;= <span class="string">&#x27;Z&#x27;</span>) ||</span><br><span class="line">         (<span class="string">&#x27;0&#x27;</span> &lt;= c &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>) ||</span><br><span class="line">         (c == <span class="string">&#x27;_&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用此函数，您可以将以下代码添加到 <code>tokenize</code> 将 <code>return</code> 标记为 <code>TK_RETURN</code> 。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">strncmp</span>(p, <span class="string">&quot;return&quot;</span>, <span class="number">6</span>) == <span class="number">0</span> &amp;&amp; !is_alnum(p[<span class="number">6</span>])) &#123;</span><br><span class="line">  tokens[i].ty = TK_RETURN;</span><br><span class="line">  tokens[i].str = p;</span><br><span class="line">  i++;</span><br><span class="line">  p += <span class="number">6</span>;</span><br><span class="line">  <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来，让我们修改解析器，以便它可以解析包含 TK_RETURN 的标记序列。为此，首先添加节点类型 <code>ND_RETURN</code> 来表示 <code>return</code> 语句。接下来，修改读取语句的函数，使其能够解析 <code>return</code> 语句。像往常一样，您可以通过将语法直接映射到函数调用来解析语法。新的 <code>stmt</code> 函数如下所示。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Node *<span class="title function_">stmt</span><span class="params">()</span> &#123;</span><br><span class="line">  Node *node;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (consume(TK_RETURN)) &#123;</span><br><span class="line">    node = <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="keyword">sizeof</span>(Node));</span><br><span class="line">    node-&gt;kind = ND_RETURN;</span><br><span class="line">    node-&gt;lhs = expr();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    node = expr();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!consume(<span class="string">&#x27;;&#x27;</span>))</span><br><span class="line">    error_at(tokens[pos].str, <span class="string">&quot;&#x27;;&#x27;不是令牌&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ND_RETURN</code> 类型节点仅在此处生成，因此我决定使用 <code>malloc</code> 来当场设置值，而不是创建新函数。</p><p>最后，修改代码生成器，使其为 <code>ND_RETURN</code> 类型的节点输出适当的汇编代码。新 <code>gen</code> 函数的一部分如下所示。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">gen</span><span class="params">(Node *node)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (node-&gt;kind == ND_RETURN) &#123;</span><br><span class="line">    gen(node-&gt;lhs);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;  pop rax\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;  mov rsp, rbp\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;  pop rbp\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;  ret\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure><p>在上面的代码中，函数调用 <code>gen(node-&gt;lhs)</code> 输出的表达式的代码是 <code>return</code> 的返回值。该代码应在堆栈顶部留下一个值。 <code>gen(node-&gt;lhs)</code> 之后的程序集从堆栈中弹出值，将其设置到 RAX 中，然后从函数返回。</p><p>上一章之前实现的函数始终在函数末尾输出一条 <code>ret</code> 指令。按照本章所述实现 <code>return</code> 语句将导致为每个 <code>return</code> 语句输出额外的 <code>ret</code> 指令。这些指令可以组合在一起，但为了简单起见，我们决定允许输出多个 <code>ret</code> 指令。此时无需担心这些细节，因此优先考虑实现简单性非常重要。能够编写困难的代码是一项有用的技能，但有时更有用的技能并不是一开始就让代码变得太难。</p><p>コラム:  专栏：语法层次结构</p><p>“ 正则表达式 “ 通常用于判断输入是否匹配某种规则，但更复杂的语法无法使用正则表达式来表达。例如，原则上不可能编写一个正则表达式来确定字符串中括号是否平衡。</p><p>上下文无关语法（可以用 BNF 表示的语法）比正则表达式更强大；例如，它们只能表示带有平衡括号的字符串（BNF 中的 <code>S → SS | &quot;(&quot; S &quot;)&quot; | ε</code> ）。然而，与正则表达式一样，上下文无关语法也有其局限性，上下文无关语法无法表达普通编程语言中出现的复杂规则。例如，规则 “ 变量必须在使用之前声明 “ 是 C 语法的一部分，但这样的规则不能使用上下文无关语法来表达。</p><p>如果你编写一个 C 语言编译器，你可以说编译器接受的输入是有效的 C 程序，而它不接受的输入是无效的 C 程序，除非编译器有 bug。也就是说，如果你有普通计算机的能力，就可以判断问题是否符合 C 语法，而编译器整体上可以说是比上下文无关语法更强大的语法判断器。这样，总能用 YES&#x2F;NO 判断是否与该文法匹配的文法称为 Decidable。</p><p>您还可以考虑不可判定的语法。例如，问题 “ 当给定一个计算机程序作为输入并执行时，该程序最终执行 <code>exit</code> 函数并退出，还是继续无限期地运行？” 已被证明一般是不可能的在不实际运行程序的情况下确定是&#x2F;否（假设您在具有无限内存的虚拟计算机上运行它）。换句话说，对于程序是否会停止的问题，如果程序停止，你可以回答 “ 是 “，但不能回答 “ 否 “，因为如果程序不停止，它就会无限期地继续运行。</p><p>这样，决策机不仅有可能返回 YES&#x2F;NO，而且决策机没有完成执行的一类文法称为图灵可识别的。</p><p>换句话说，存在语法层次结构：正则表达式 &lt; 上下文无关语法 &lt; 可判定 &lt; 图灵可识别。这些语法层次结构作为计算机科学的一部分得到了广泛的研究。著名的未解决问题 P≟NP 也是一个与语法层次结构相关的问题。</p><h2 id="1973年C编译器"><a href="#1973年C编译器" class="headerlink" title="1973年C编译器"></a><a href="#%E5%B9%B4%E3%81%AEc%E3%82%B3%E3%83%B3%E3%83%91%E3%82%A4%E3%83%A9">1973年C编译器</a></h2><p>到目前为止，我们一直在逐步构建编译器。从某种意义上来说，这个发展过程可以说是追随了 C 的历史。</p><p>如果你看看当前版本的 C，你会发现有些部分没有多大意义或者不必要地复杂，但如果不回顾历史就无法理解这些东西。当您阅读早期的 C 代码并查看 C 的早期形式以及该语言和编译器的后续发展时，当前 C 的许多令人困惑的方面开始变得有意义。</p><p>C 于 1972 年作为 Unix 语言开发。 1972 年或 1973 年（C 历史上非常早期的时期）的源代码保留在磁带上，从中读取的文件发布在 Internet 上。我们看一下当时 C 编译器的代码。下面是一个函数，它接收 <code>printf</code> 格式的消息并将其打印为编译错误消息。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">error(s, p1, p2) &#123;</span><br><span class="line">  <span class="keyword">extern</span> <span class="built_in">printf</span>, line, fout, flush, <span class="built_in">putchar</span>, nerror;</span><br><span class="line">  <span class="type">int</span> f;</span><br><span class="line"></span><br><span class="line">  nerror++;</span><br><span class="line">  flush();</span><br><span class="line">  f = fout;</span><br><span class="line">  fout = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d: &quot;</span>, line);</span><br><span class="line">  <span class="built_in">printf</span>(s, p1, p2);</span><br><span class="line">  <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">  fout = f;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它看起来有点奇怪，类似 C，非 C 语言。那时的 C 就是这样一种语言。当你阅读这段代码时，你首先注意到的是，就像我们创建的编译器的早期版本一样，函数返回值或参数没有类型。这里，s 是一个指向字符串的指针， <code>p1</code> 和 <code>p2</code> 应该是整数，但在当时的机器上它们的大小都是相同的，所以像这样的变量是没有类型。</p><p>第二行包含 <code>error</code> 引用的全局变量和函数的声明。当时，C 编译器没有头文件或 C 预处理器，因此程序员必须通过这种方式告诉编译器变量和函数的存在。</p><p>与我们当前的编译器一样，函数仅检查名称是否存在，而不检查参数的类型或数量是否匹配。将预期数量的参数放入堆栈后，他们可以跳转到函数体，函数调用就会成功，所以他们可能认为这样就可以了。</p><p><code>fout</code> 是一个全局变量，保存输出文件描述符的编号。此时， <code>fprintf</code> 还不存在，为了将字符串写入标准错误而不是标准输出，需要通过全局变量切换输出目的地。</p><p>在 <code>error</code> 内部， <code>printf</code> 被调用两次。第二个 printf 除了格式字符串之外还传递两个值。那么，当显示仅包含一个值的错误消息时，您该怎么办？</p><p>事实上，即使您只是强制它使用更少的参数，这个 <code>error</code> 函数也可以正常工作。回想一下，此时函数参数检查还不存在。像 <code>s</code> 、 <code>p1</code> 、 <code>p2</code> 这样的参数只是指向堆栈指针中的第 1 个、第 2 个和第 3 个字，但实际上 <code>p2</code> 的值。 <code>printf</code> 访问的额外参数等于第一个参数字符串中包含的 <code>%d</code> 和 <code>%s</code> 的数量，因此 <code>%d</code> 永远不会被访问。因此，即使参数数量不匹配也没有问题。</p><p>这样看来，早期的 C 编译器与现在的 9cc 有很多相似之处。</p><p>让我们看另一个代码示例。下面的代码是一个函数，它将传递的字符串复制到静态分配的区域中，并返回指向该区域开头的指针。换句话说，这是一个像 <code>strdup</code> 这样使用静态空间的函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">copy(s)</span><br><span class="line"><span class="type">char</span> s[]; &#123;</span><br><span class="line">  <span class="keyword">extern</span> tsp;</span><br><span class="line">  <span class="type">char</span> tsp[], otsp[];</span><br><span class="line"></span><br><span class="line">  otsp = tsp;</span><br><span class="line">  <span class="keyword">while</span>(*tsp++ = *s++);</span><br><span class="line">  <span class="keyword">return</span>(otsp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当时，还没有设计出 <code>int *p</code> 形式的声明语法。相反，指针类型被声明为 <code>int p[]</code> 。函数参数列表和函数体之间有类似变量定义的东西，但这是将 <code>s</code> 声明为指针类型。</p><p>关于这个早期的 C 编译器，还有一些值得一提的事情。</p><ul><li>此时该结构还不存在。</li><li><code>&amp;&amp;</code> 和 <code>||</code> 等运算符尚不可用。此时， <code>&amp;</code> 和 <code>|</code> 是上下文相关的，因为它们仅在 <code>if</code> 等条件表达式中才成为逻辑运算符。</li><li><code>+=</code> 等运算符被写为 <code>=+</code> 。在此语法中，如果您打算将 -1 分配给 <code>i</code> 并写入不带空格的 <code>i=-1</code> ，它将被解释为 <code>i =- 1</code> 。存在一个问题： <code>i</code> 将会递减，这是一种意外行为。</li><li>唯一的整数类型是 char 和 int；short 和 long 不存在。没有用于声明类型（例如 “ 函数指针数组 “）的语法，并且不可能编写复杂类型。</li></ul><p>除了上述之外，20 世纪 70 年代初期的 C 还缺乏各种特性。然而，这个 C 编译器是用 C 编写的，从上面的源代码可以看出。在结构出现之前，C 就已经是自托管的了。</p><p>通过查看旧的源代码，您还可以推断出为什么 C 的某些令人困惑的语法最终会变成当前的形式。如果变量名称始终位于 <code>extern</code> 或 <code>auto</code> 或 <code>int</code> 或 <code>char</code> 之后，则解析变量定义很容易。 <code>[]</code> 代表一个指针，如果它简单地跟在变量名后面，也很容易解析。然而，很明显，如果这种语法沿着早期编译器中看到的路线发展，它最终会以目前不必要的复杂形式出现。</p><p>嗯，Unix 和 C 的共同发明者 Dennis Ritchie 在 1973 年左右所做的事情是真正的增量开发。他一边开发 C 语言本身，一边使用 C 语言编写编译器。当前版本的 C 并不是某种随着语言不断添加功能而达到特殊点的成品，而只是在丹尼斯·里奇 (Dennis Ritchie) 认为该语言具有足够功能时作为一种语言完成的。这就是发生的事情。</p><p>即使有了我们的编译器，我们也从一开始就没有追求完整的版本。 C 的完整形式没有任何特殊含义，因此可能没有必要专门追求它。在任何时间点继续开发一种具有合理特性集的语言，并最终将其转换为 C，是原始 C 编译器使用的历史悠久的开发方法。让我们满怀信心、继续发展！</p><p>コラム: 专栏：Rob Pike 的 5 条编程规则</p><p>9cc 受到 Rob Pike 编程哲学的影响。 Rob Pike 是 Dennis Ritchie 的前同事，Dennis Ritchie 是 C 语言的创建者、Go 语言的创建者，并且与 Unix 的创建者 Ken Thompson 共同创建了 Unicode 的 UTF-8。</p><p>我引用 Rob Pike 的 5 条编程规则。</p><ol><li><p>无法预测程序的哪些部分将占用时间。瓶颈出现在令人惊讶的地方，因此在知道它们在哪里之前，不要试图猜测它们在哪里并添加性能技巧。</p></li><li><p>测量一下。在测量之前不要尝试优化。另外，即使您测量了它，也不要尝试优化代码中速度极慢的部分以外的任何内容。</p></li><li><p>当 n 很小时，花哨的算法会很慢，而且 n 通常也很小。复杂的算法有大量的常数部分。除非您知道 n 通常很大，否则不要变得复杂。 （即使 n 很大，也先应用规则 2。）</p></li><li><p>复杂的算法比简单的算法更容易出现错误并且更难实现。应使用简单的算法和数据结构。</p></li><li><p>数据才是最重要的。如果您选择正确的数据结构并很好地表示您的数据，您的算法几乎总是微不足道的。编程的核心是数据结构，而不是算法。</p></li></ol><h2 id="第-12-步：添加控制结构"><a href="#第-12-步：添加控制结构" class="headerlink" title="第 12 步：添加控制结构"></a><a href="#%E3%82%B9%E3%83%86%E3%83%83%E3%83%9712-%E5%88%B6%E5%BE%A1%E6%A7%8B%E6%96%87%E3%82%92%E8%B6%B3%E3%81%99">第 12 步：添加控制结构</a></h2><p>在本节中，我们将向语言添加以下控制结构： <code>if</code> 、 <code>if … else</code> 、 <code>while</code> 和 <code>for</code> 。尽管这些控制结构乍一看似乎很复杂，但当直接编译成汇编时，它们相对容易实现。</p><p>由于汇编中没有与 C 控制结构相对应的内容，因此 C 控制结构在汇编中由分支指令和标签表示。从某种意义上来说，这与使用 <code>goto</code> 重写控制结构是一样的。正如人类可以手动将控制结构重写为 <code>goto</code> 语句一样，只需根据模式生成代码即可轻松实现控制结构。</p><p>还有各种其他控制语法，例如 <code>do … while</code> 、 <code>goto</code> 、 <code>continue</code> 和 <code>break</code> ，但它们不需要实现现在还没有。</p><p>添加了 <code>if</code> 、 <code>while</code> 和 <code>for</code> 的新语法如下所示。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">program = stmt*</span><br><span class="line">stmt    = expr &quot;;&quot;</span><br><span class="line">        | &quot;if&quot; &quot;(&quot; expr &quot;)&quot; stmt (&quot;else&quot; stmt)?</span><br><span class="line">        | &quot;while&quot; &quot;(&quot; expr &quot;)&quot; stmt</span><br><span class="line">        | &quot;for&quot; &quot;(&quot; expr? &quot;;&quot; expr? &quot;;&quot; expr? &quot;)&quot; stmt</span><br><span class="line">        | ...</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>在读取 <code>expr? &quot;;&quot;</code> 时，我们向前看一个 token，并假设如果下一个 token 是 <code>;</code> 则 <code>expr</code> 不存在，否则 &lt; 可以读取 b3&gt;&lt; &#x2F;b3&gt; 等等。</p><p><code>if (A) B</code> 编译成如下所示的程序集：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  A编译后的代码 // スタックトップに結果が入っているはず</span><br><span class="line">  pop rax</span><br><span class="line">  cmp rax, 0</span><br><span class="line">  je  .LendXXX</span><br><span class="line">  B编译后的代码</span><br><span class="line">.LendXXX:</span><br></pre></td></tr></table></figure><p> 所以 <code>if (A) B</code> 是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  if (A == 0)</span><br><span class="line">    goto end;</span><br><span class="line">  B;</span><br><span class="line">end:</span><br></pre></td></tr></table></figure><p>将以同样的方式进行扩展。确保 <code>XXX</code> 是序列号或类似的内容，以便所有标签都是唯一的。</p><p><code>if (A) B else C</code> 编译成如下所示的程序集：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">  A编译后的代码 // スタックトップに結果が入っているはず</span><br><span class="line">  pop rax</span><br><span class="line">  cmp rax, 0</span><br><span class="line">  je  .LelseXXX</span><br><span class="line">  B编译后的代码</span><br><span class="line">  jmp .LendXXX</span><br><span class="line">.LelseXXX</span><br><span class="line">  C编译后的代码</span><br><span class="line">.LendXXX</span><br></pre></td></tr></table></figure><p>即， <code>if (A) B else C</code> 展开如下。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  if (A == 0)</span><br><span class="line">    goto els;</span><br><span class="line">  B;</span><br><span class="line">  goto end;</span><br><span class="line">els:</span><br><span class="line">  C;</span><br><span class="line">end:</span><br></pre></td></tr></table></figure><p>读取 <code>if</code> 语句时，先读一个标记并检查 <code>else</code> 是否存在，如果存在 <code>else</code> ，则检查 <code>if … else</code> ，否则编译为 <code>if</code> ，不带 <code>else</code> 。</p><p>像这样编译 <code>while (A) B</code> ：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.LbeginXXX:</span><br><span class="line">  A编译后的代码</span><br><span class="line">  pop rax</span><br><span class="line">  cmp rax, 0</span><br><span class="line">  je  .LendXXX</span><br><span class="line">  B编译后的代码</span><br><span class="line">  jmp .LbeginXXX</span><br><span class="line">.LendXXX:</span><br></pre></td></tr></table></figure><p>换句话说， <code>while (A) B</code> 被扩展为如下代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">begin:</span><br><span class="line">  if (A == 0)</span><br><span class="line">    goto end;</span><br><span class="line">  B;</span><br><span class="line">  goto begin;</span><br><span class="line">end:</span><br></pre></td></tr></table></figure><p>像这样编译 <code>for (A; B; C) D</code> ：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">  A编译后的代码</span><br><span class="line">.LbeginXXX:</span><br><span class="line">  B编译后的代码</span><br><span class="line">  pop rax</span><br><span class="line">  cmp rax, 0</span><br><span class="line">  je  .LendXXX</span><br><span class="line">  D编译后的代码</span><br><span class="line">  C编译后的代码</span><br><span class="line">  jmp .LbeginXXX</span><br><span class="line">.LendXXX:</span><br></pre></td></tr></table></figure><p><code>for (A; B; C) D</code> 对应的 C 代码如下所示。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  A;</span><br><span class="line">begin:</span><br><span class="line">  if (B == 0)</span><br><span class="line">    goto end;</span><br><span class="line">  D;</span><br><span class="line">  C;</span><br><span class="line">  goto begin;</span><br><span class="line">end:</span><br></pre></td></tr></table></figure><p>请注意，以 <code>.L</code> 开头的标签会被汇编器特别识别，并自动成为文件范围。文件范围标签可以从同一文件内引用，但不能从其他文件引用。因此，如果使 <code>if</code> 和 <code>for</code> 的编译器生成的标签从 <code>.L</code> 开始，则其他文件中包含的标签就无需担心冲突。</p><p>使用 cc 编译一个小循环并使用程序集作为参考。</p><p>コラム:  专栏：编译器检测运行时错误</p><p>当用 C 语言编写程序时，通常会在数组末尾写入数据，或者由于指针错误而损坏不相关的数据结构。这些错误也可能成为安全漏洞，因此我们的想法是在编译器的帮助下在运行时主动检测错误。</p><p>例如，如果将 <code>-fstack-protector</code> 选项传递给 GCC，则编译后的函数将向序言中的函数框架输出一个称为 “ 金丝雀 “ 的随机指针大小的整数，并且金丝雀将打印在尾声。这将确认该值没有改变。这样，如果堆栈的内容由于数组缓冲区溢出而在不知不觉中被覆盖，则金丝雀值几乎肯定会发生变化，因此可以在函数返回时检测到错误。如果检测到错误，程序通常会立即终止。</p><p>LLVM 有一个叫做 TSan (ThreadSanitizer) 的东西，它可以输出代码，在运行时检测多个线程在没有正确保护锁的情况下访问共享数据结构。此外，LLVM 的 UBSan (UndefinedBehaviorSanitizer) 可以输出代码，在运行时检测您是否无意中踩到了 C 中的未定义行为。例如，有符号整数溢出在 C 中是未定义的行为，因此如果发生有符号整数溢出，UBSan 将报告错误。</p><p>由于 TSan 等会使程序速度变慢数倍，因此将其添加到经常使用的程序的编译选项中是不合理的，但诸如堆栈金丝雀之类的运行成本相对较低的功能可以根据环境使用。默认情况下它可能处于打开状态。</p><p>近年来，借助此类编译器的动态错误检测得到了积极的研究，并且为使用 C 和 C++ 等非内存安全语言编写相当安全的程序做出了巨大贡献。</p><h2 id="第13步：块"><a href="#第13步：块" class="headerlink" title="第13步：块"></a><a href="#%E3%82%B9%E3%83%86%E3%83%83%E3%83%9713-%E3%83%96%E3%83%AD%E3%83%83%E3%82%AF">第13步：块</a></h2><p>此步骤支持 “ 块 “，允许您在 <code>&#123; … &#125;</code> 之间编写多个语句。块的正式名称是复合语句，但由于它的单词很长，所以通常简称为块。</p><p>块具有将多个语句组合成单个语句的作用。上面步骤中实现的 <code>if</code> 和 <code>while</code> 只允许在条件表达式为 true 时执行一条语句，但是在这一步中你可以通过实现它，你将能够像在 C 语言中一样，编写用 <code>&#123;&#125;</code> 括起来的多个语句。</p><p>函数体实际上也是一个块。语法上要求函数体必须是一个块。函数定义中的 <code>&#123; … &#125;</code> 实际上在语法上与 <code>if</code> 或 <code>while</code> 之后编写的 <code>&#123; … &#125;</code> 相同。</p><p> 添加块的语法如下所示。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">program = stmt*</span><br><span class="line">stmt    = expr &quot;;&quot;</span><br><span class="line">        | &quot;&#123;&quot; stmt* &quot;&#125;&quot;</span><br><span class="line">        | ...</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>在此语法中，如果 <code>stmt</code> 以 <code>&quot;&#123;&quot;</code> 开头，则将出现零个或多个 <code>stmt</code> ，直到 <code>&quot;&#125;&quot;</code> 出现。这是一件好事。要解析 <code>stmt* &quot;&#125;&quot;</code> ，请在 <code>while</code> 语句中重复调用 <code>stmt</code> ，直到出现 <code>&quot;&#125;&quot;</code> ，并将结果存储在向量中。请返回它作为</p><p>要实现块，请添加代表该块的节点类型 <code>ND_BLOCK</code> 。表示节点的结构 <code>Node</code> 必须使用包含块中包含的表达式的向量进行填充。如果节点的类型为 <code>ND_BLOCK</code> ，则代码生成器应按顺序为节点中包含的语句生成代码。请注意，每个语句都会在堆栈上留下一个值，因此不要忘记每次都将其弹出。</p><h2 id="第14步：响应函数调用"><a href="#第14步：响应函数调用" class="headerlink" title="第14步：响应函数调用"></a><a href="#%E3%82%B9%E3%83%86%E3%83%83%E3%83%9714-%E9%96%A2%E6%95%B0%E3%81%AE%E5%91%BC%E3%81%B3%E5%87%BA%E3%81%97%E3%81%AB%E5%AF%BE%E5%BF%9C%E3%81%99%E3%82%8B">第14步：响应函数调用</a></h2><p>此步骤的目标是能够识别没有参数的函数调用，例如 <code>foo()</code> 并将其编译为 <code>call foo</code> 。</p><p> 函数调用的新语法如下所示。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">primary = num</span><br><span class="line">        | ident (&quot;(&quot; &quot;)&quot;)?</span><br><span class="line">        | &quot;(&quot; expr &quot;)&quot;</span><br></pre></td></tr></table></figure><p>读取 <code>ident</code> 后向前看一个标记，您可以判断 <code>ident</code> 是变量名还是函数名。</p><p>为了进行测试，请准备一个包含 <code>int foo() &#123; printf(&quot;OK\n&quot;); &#125;</code> 等内容的 C 文件，将其编译为包含 <code>cc -c</code> 的目标文件，并将其与编译器的输出链接。通过这样做，您应该能够在整体上正确链接，并且您应该能够确认您要调用的函数被正确调用。</p><p>一旦成功，下一步就是能够编写像 <code>foo(3, 4)</code> 这样的函数调用。无需检查参数的数量或类型。通过简单地按顺序评估参数，将在堆栈上创建要传递给函数的参数，因此我们可以按照 x86-64 ABI 指定的顺序将它们复制到寄存器并调用该函数。不需要支持超过 6 个参数。</p><p>为了进行测试，就像上面一样，您应该能够准备一个像 <code>int foo(int x, int y) &#123; printf(&quot;%d\n&quot;, x + y); &#125;</code> 这样的函数，并通过链接它来检查它的操作。</p><p>x86-64 函数调用 ABI 很简单（只要遵循上面的方法），但有一个警告。在调用函数之前，RSP 必须是 16 的倍数。由于 <code>push</code> 和 <code>pop</code> 以 8 字节为单位改变 RSP，因此在发出 <code>call</code> 指令时 RSP 不一定必须是 16 的倍数。限制。如果不遵守这一承诺，假设 RSP 为 16 的倍数的函数将遭受一种神秘现象，即它们只有一半的时间会失败。确保在调用该函数之前调整 RSP，使其成为 16 的倍数。</p><h2 id="第-15-步：解决函数定义问题"><a href="#第-15-步：解决函数定义问题" class="headerlink" title="第 15 步：解决函数定义问题"></a><a href="#%E3%82%B9%E3%83%86%E3%83%83%E3%83%9715-%E9%96%A2%E6%95%B0%E3%81%AE%E5%AE%9A%E7%BE%A9%E3%81%AB%E5%AF%BE%E5%BF%9C%E3%81%99%E3%82%8B">第 15 步：解决函数定义问题</a></h2><p>完成此操作后，我们现在可以定义该函数。然而，C 函数定义很难解析，所以我不会一次全部实现它们。目前，我们的语言只有 int 类型，因此我们实现了 <code>foo(x, y) &#123; … &#125;</code> 语法，而不是 <code>int foo(int x, int y) &#123; … &#125;</code> 语法，该语法省略了类型名称。</p><p>被调用方需要能够使用 <code>x</code> 和 <code>y</code> 等名称来访问参数，但目前还无法通过名称直接访问寄存器中传递的值。 。要做的就是像 <code>x</code> 和 <code>y</code> 这样的局部变量存在一样进行编译，并在函数的序言中设置该局部变量的寄存器值。将其写入堆栈上的区域。之后，您应该能够毫无区别地处理参数和局部变量。</p><p>到目前为止，行为与用 <code>main() &#123; … &#125;</code> 隐式包围整个事物相同，但这种情况将被废除，所有代码都将编写在某个函数内。然后，在解析顶层时，当您首先读取标记时，它始终是函数名称，然后是参数列表，然后是函数体。易于阅读。</p><p>完成此步骤后，您将能够使用递归计算并显示斐波那契数列，这应该会使其变得更有趣。</p><h2 id="二进制级接口"><a href="#二进制级接口" class="headerlink" title="二进制级接口"></a><a href="#%E3%83%90%E3%82%A4%E3%83%8A%E3%83%AA%E3%83%AC%E3%83%99%E3%83%AB%E3%81%AE%E3%82%A4%E3%83%B3%E3%82%BF%E3%83%BC%E3%83%95%E3%82%A7%E3%82%A4%E3%82%B9">二进制级接口</a></h2><p>C 语言规范定义了源代码级别的规范。例如，语言规范指定如何定义函数，以及应包含哪些文件来声明哪些函数。另一方面，语言规范并没有规定为符合标准而编写的源代码将被转换成哪种机器语言。这是有道理的，因为 C 语言标准并不是根据任何特定的指令集来确定的。</p><p>因此，乍一看似乎没有必要明确确定机器语言级别的规范，但实际上，每个平台在某种程度上都确定了规范。该规范称为 ABI（应用程序二进制接口）。</p><p>到目前为止，本书中调用函数的方式意味着参数以特定顺序放置在寄存器中。此外，返回值承诺设置为 RAX。这些如何调用函数的规则称为 “ 函数调用约定 “。函数调用约定是 ABI 的一部分。</p><p>除了如何传递参数和返回值之外，C 语言 ABI 还包括以下内容：</p><ul><li>被函数调用改变的寄存器和没有改变的寄存器（RBP 等在返回前都恢复到原来的值，但有些寄存器不需要恢复到原来的值）</li><li><code>int</code> 和 <code>long</code> 等类型的大小</li><li>结构布局规则（结构成员在内存中实际排列的规则）</li><li>位域布局规则（例如，位域应该从最低有效位开始排列还是从最高有效位开始排列？）</li></ul><p>ABI 只是软件层面的约定，所以有可能想到与本书中解释的不同的东西，但是不兼容 ABI 的代码不能互相调用和使用，所以基本上，CPU 供应商和 OS 供应商定义平台标准 ABI。有两种广泛使用的 x86-64 系统：System V ABI（用于 Unix 和 macOS）和 Microsoft ABI（用于 Windows）。请注意，这两个调用约定并不是必然分开的，而只是不同的人创建了单独的约定。</p><p>到目前为止，在本书中，我们已经使用自己的编译器来调用用另一个编译器编译的函数。这是可能的，因为我们的 C 编译器和另一个编译器具有相同的 ABI。</p><hr><h1 id="指针和字符串文字"><a href="#指针和字符串文字" class="headerlink" title="指针和字符串文字"></a><a href="#%E3%83%9D%E3%82%A4%E3%83%B3%E3%82%BF%E3%81%A8%E6%96%87%E5%AD%97%E5%88%97%E3%83%AA%E3%83%86%E3%83%A9%E3%83%AB">指针和字符串文字</a></h1><p>在前面的章节中，我们开发了一种可以执行有意义的计算的语言，但是我们的语言仍然无法显示 <code>Hello world</code> 。是时候添加一些字符串以便程序可以输出有意义的消息了。</p><p>C 字符串文字与 <code>char</code> 类型、全局变量和数组密切相关。以以下函数为例。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Hello, world!\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码将以与下面的代码相同的方式编译。但是， <code>msg</code> 是一个唯一标识符，不会与其他标识符重叠。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> msg[<span class="number">15</span>] = <span class="string">&quot;Hello, world!\n&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> &#123;</span><br><span class="line">  <span class="built_in">printf</span>(msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们的编译器仍然缺乏一些支持字符串文字的功能。在本章中，我们将按顺序实现以下函数，以便我们可以支持字符串文字并使用 <code>printf</code> 等显示消息。</p><ol><li><p>一元 <code>&amp;</code> 和一元 <code>*</code></p></li><li><p> 指针</p></li><li><p> 大批</p></li><li><p> 全局变量</p></li><li><p> 字符类型</p></li><li><p> 字符串字面量</p></li></ol><p>我们还将在本章中添加测试上述功能所需的功能。</p><h2 id="步骤-16：一元-amp-和一元"><a href="#步骤-16：一元-amp-和一元" class="headerlink" title="步骤 16：一元 &amp; 和一元 *"></a><a href="#%E3%82%B9%E3%83%86%E3%83%83%E3%83%9716-%E5%8D%98%E9%A0%85%E3%81%A8%E5%8D%98%E9%A0%85">步骤 16：一元 &amp; 和一元 *</a></h2><p>在此步骤中，实现指针的第一步是实现返回地址的一元 <code>&amp;</code> 和引用地址的一元 <code>*</code> 。</p><p>这些运算符最初是返回或获取指针类型值的运算符，但由于我们的编译器还没有除整数之外的任何类型，因此我们用整数类型替换指针类型。我会决定。也就是说， <code>&amp;x</code> 将变量 <code>x</code> 的地址仅作为整数返回。另外， <code>*x</code> 是将 <code>x</code> 的值视为地址并从该地址读取值的操作。</p><p>实现这样的运算符允许如下代码工作：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x = 3;</span><br><span class="line">y = &amp;x;</span><br><span class="line">return *y; // 3を返す</span><br></pre></td></tr></table></figure><p>此外，利用局部变量在内存中连续分配的事实，还可以通过指针间接强制访问堆栈上的变量。下面的代码假设变量 <code>x</code> 位于堆栈上变量 <code>y</code> 上方 8 个字节。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x = 3;</span><br><span class="line">y = 5;</span><br><span class="line">z = &amp;y + 8;</span><br><span class="line">return *z; // 3を返す</span><br></pre></td></tr></table></figure><p>在这种不区分指针类型和整数类型的实现中，例如，表达式 <code>*4</code> 将是从地址 4 读取值的表达式，但我们假设现在这样就可以了。</p><p>实施相对容易。添加一元 <code>&amp;</code> 和一元 <code>*</code> 的语法如下所示。根据此语法修改解析器，将一元 <code>&amp;</code> 和一元 <code>*</code> 分别读取为 <code>ND_ADDR</code> 和 <code>ND_DEREF</code> 类型的节点。请如此。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">unary = &quot;+&quot;? primary</span><br><span class="line">      | &quot;-&quot;? primary</span><br><span class="line">      | &quot;*&quot; unary</span><br><span class="line">      | &quot;&amp;&quot; unary</span><br></pre></td></tr></table></figure><p>代码生成器的更改很少。下面列出了这些更改。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> ND_ADDR:</span><br><span class="line">  gen_lval(node-&gt;lhs);</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">case</span> ND_DEREF:</span><br><span class="line">  gen(node-&gt;lhs);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;  pop rax\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;  mov rax, [rax]\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;  push rax\n&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span>;</span><br></pre></td></tr></table></figure><h2 id="第17步：消除隐式变量定义并引入-int-关键字"><a href="#第17步：消除隐式变量定义并引入-int-关键字" class="headerlink" title="第17步：消除隐式变量定义并引入 int 关键字"></a><a href="#%E3%82%B9%E3%83%86%E3%83%83%E3%83%9717-%E6%9A%97%E9%BB%99%E3%81%AE%E5%A4%89%E6%95%B0%E5%AE%9A%E7%BE%A9%E3%82%92%E5%BB%83%E6%AD%A2%E3%81%97%E3%81%A6int%E3%81%A8%E3%81%84%E3%81%86%E3%82%AD%E3%83%BC%E3%83%AF%E3%83%BC%E3%83%89%E3%82%92%E5%B0%8E%E5%85%A5%E3%81%99%E3%82%8B">第17步：消除隐式变量定义并引入 int 关键字</a></h2><p>到目前为止，所有变量和函数返回值都隐式设置为 int。因此，我们没有麻烦地用类型名称来定义变量，例如 <code>int x;</code> ，并假设所有新标识符都是新的变量名称。你不能再做出这样的假设。那么，我们首先修改这一点。请实现以下功能。</p><ul><li>不要将新标识符视为变量名，并将未定义的变量标记为错误。</li><li>请务必以 <code>int x;</code> 格式定义变量。无需支持 <code>int x = 3;</code> 等初始化表达式。同样，我们不需要像 <code>int x, y;</code> 这样的东西。只实施最简单的事情。</li><li>到目前为止，函数都是以 <code>foo(x, y)</code> 的形式编写的，但我们将它们修改为 <code>int foo(int x, int y)</code> 的形式。目前，顶层应该只有函数定义，因此解析器首先读取 <code>int</code> ，然后按应有的方式读取函数名称，然后读取列 <code>int &lt;引数の名前&gt;</code> 。意味着阅读。不需要支持任何更困难的语法，也不需要做任何事情只是为了 “ 为未来的扩展做准备 “。只需编写足够的代码来读取 “int &lt;函数名称&gt;(&lt;由重复 int &lt;变量名称组成的参数列表&gt;&gt;)”。</li></ul><h2 id="第18步：引入指针类型"><a href="#第18步：引入指针类型" class="headerlink" title="第18步：引入指针类型"></a><a href="#%E3%82%B9%E3%83%86%E3%83%83%E3%83%9718-%E3%83%9D%E3%82%A4%E3%83%B3%E3%82%BF%E5%9E%8B%E3%82%92%E5%B0%8E%E5%85%A5%E3%81%99%E3%82%8B">第18步：引入指针类型</a></h2><h3 id="定义一个表示指针的类型"><a href="#定义一个表示指针的类型" class="headerlink" title="定义一个表示指针的类型"></a><a href="#%E3%83%9D%E3%82%A4%E3%83%B3%E3%82%BF%E3%82%92%E8%A1%A8%E3%81%99%E5%9E%8B%E3%82%92%E5%AE%9A%E7%BE%A9%E3%81%99%E3%82%8B">定义一个表示指针的类型</a></h3><p>在此步骤中，以前仅允许在类型名称中使用 <code>int</code> ，但现在允许在 <code>int</code> 后跟零个或多个 <code>*</code> 作为类型名称。也就是说，它允许解析诸如 <code>int *x</code> 和 <code>int ***x</code> 之类的定义。</p><p>当然，诸如 “ 指向 int 的指针 “ 之类的类型必须由编译器处理。例如，如果变量 <code>x</code> 是指向 int 的指针，则编译器必须知道表达式 <code>*x</code> 的类型为 int。由于类型可以像您想要的那样复杂，例如 “ 指向 int 的指针的指针 “，因此不能仅用固定大小的类型来表达。</p><p>所以我们要做的就是使用指针。到目前为止，通过映射与变量关联的唯一信息是距堆栈上基指针 (RBP) 的偏移量。更改此设置以便您可以拥有变量类型。粗略地说，变量类型应该是如下结构。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Type</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">enum</span> &#123;</span> INT, PTR &#125; ty;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Type</span> *<span class="title">ptr_to</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里 <code>ty</code> 可以有两个值之一：int 类型或 “ 指向 “ 类型的指针。仅当 <code>ty</code> 的类型为 “ 指向 “ 的指针时， <code>ptr_to</code> 才是有意义的成员，在这种情况下，它包含指向 “ Put 所指向的 Type 对象的指针 “。例如，对于 “ 指向 int 的指针 “，表示该类型的数据结构内部如下。</p><p><img src="/../../img/blog/a646a0bc04bdbaea4703ac333d649f82_MD5.svg"></p><p> 表示指向 int 的指针的数据结构</p><p>如果它是一个 “ 指向 int 指针的指针 “，它将如下所示：</p><p><img src="/../../img/blog/ab8b4213a762b079860fb603db4db2b0_MD5.svg"></p><p> 表示指向 int 的指针的数据结构</p><p>通过这种方式，可以在编译器内表达任意数量的困难类型。</p><h3 id="赋值给指针所指向的值"><a href="#赋值给指针所指向的值" class="headerlink" title="赋值给指针所指向的值"></a><a href="#%E3%83%9D%E3%82%A4%E3%83%B3%E3%82%BF%E3%81%8C%E6%8C%87%E3%81%97%E3%81%A6%E3%81%84%E3%82%8B%E5%80%A4%E3%81%AB%E4%BB%A3%E5%85%A5%E3%81%99%E3%82%8B">赋值给指针所指向的值</a></h3><p>如何编译赋值表达式左侧不是简单变量名（例如 <code>*p=3</code> ）的表达式？这些表达式的基本概念与左侧为简单变量时相同。在这种情况下，您可以将 <code>*p</code> 编译为左值，以便生成 <code>p</code> 的地址。</p><p>当编译表示 <code>*p=3</code> 的语法树时，代码会沿着树递归生成，但首先调用的是 <code>*p</code> 作为左值。用于编译的代码生成器。</p><p>代码生成器将根据给定语法树的类型进行分支。对于一个简单的变量，如上所述，我们将输出输出该变量地址的代码，但这里我们给出了一个解引用运算符，所以我们需要做一些不同的事情。如果给出了解引用运算符，则将其中的语法树编译为 “ 右值 “。然后它应该编译成计算某个地址的代码（否则您无法取消引用该结果）。然后你可以将该地址留在堆栈上。</p><p>完成此步骤后，您应该能够编译如下语句：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x;</span><br><span class="line"><span class="type">int</span> *y;</span><br><span class="line">y = &amp;x;</span><br><span class="line">*y = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">return</span> x; <span class="comment">// → 3</span></span><br></pre></td></tr></table></figure><h2 id="第19步：实现指针加法和减法"><a href="#第19步：实现指针加法和减法" class="headerlink" title="第19步：实现指针加法和减法"></a><a href="#%E3%82%B9%E3%83%86%E3%83%83%E3%83%9719-%E3%83%9D%E3%82%A4%E3%83%B3%E3%82%BF%E3%81%AE%E5%8A%A0%E7%AE%97%E3%81%A8%E6%B8%9B%E7%AE%97%E3%82%92%E5%AE%9F%E8%A3%85%E3%81%99%E3%82%8B">第19步：实现指针加法和减法</a></h2><p>在此步骤中，我们将能够为指针值 <code>p</code> 编写诸如 <code>p+1</code> 和 <code>p-5</code> 之类的表达式。虽然这看起来像是简单的整数加法，但实际上是完全不同的运算。 <code>p+1</code> 并不意味着将 <code>p</code> 所保存的地址加 1，而是使其成为指向 <code>p</code> 的下一个元素的指针。这意味着必须将指针指向的数据类型添加到 <code>p</code> 中。例如，如果 <code>p</code> 指向 int，根据我们的 ABI， <code>p+1</code> 将添加 4 作为地址中的字节数。另一方面，如果 <code>p</code> 是指向 int 的指针，则 <code>p+1</code> 将加 8。</p><p>因此，在添加或减去指针时，您需要一种方法来知道类型的大小，但目前 int 为 4，指针为 8，所以请这样编写代码。</p><p>由于现阶段我们还没有办法分配连续内存（我们的编译器还没有数组），因此编写测试有点困难。您可以简单地寻求外部编译器的帮助，在那里进行 malloc，并使用编译器输出中的帮助器函数编写测试。例如，您可以像这样测试它。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int *p;</span><br><span class="line">alloc4(&amp;p, 1, 2, 4, 8);</span><br><span class="line">int *q;</span><br><span class="line">q = p + 2;</span><br><span class="line">*q;  // → 4</span><br><span class="line">q = p + 3;</span><br><span class="line">return *q;  // → 8</span><br></pre></td></tr></table></figure><p>コラム:  列：int 或 long 的大小</p><p>像 x86-64 System V ABI 这样的数据模型（其中 int 为 32 位、long 和指针为 64 位）称为 LP64。这意味着长整型和指针都是 64 位。即使在 x86-64 上具有相同的 ABI，Windows 也使用 LLP64，这是一种数据模型，其中 int 和 long 为 32 位，long long 和指针为 64 位。</p><p>LP64 和 LLP64 不兼容 ABI，因为它们的长度不同。例如，如果您创建一个包含长成员的结构体，将整个结构体按原样写入文件，然后通过将文件中的数据直接转换为该结构体来读取它，则可以在 Unix 和 Windows 中写入该文件。不能互相传递阅读。</p><p>C 规范规定 int 是 “ 普通 “int 对象，具有执行环境体系结构建议的自然大小。当你这么说的时候，感觉就像你必须在 64 位机器上将 int 变成 64 位，但什么是自然的是一个主观问题，而且即使是 64 位机器通常也可以自然地处理 32 位操作，它不是即使在 64 位机器上，将 int 设为 32 位也必然是错误的。</p><p>如果你现实地考虑一下，将 int 设为 64 位会导致以下问题：</p><ul><li>在极少数情况下，int 需要大到 64 位，因此将 int 设为 64 位只会浪费内存。</li><li>如果 short 是 16 位，int 和 long 是 64 位，那么就没有代表 32 位整数的类型。</li></ul><p>由于上述原因，int 在大多数现有 64 位机器上都是 32 位。然而，具有 64 位 int 的 ILP64 也存在。例如，旧的 Cray 超级计算机是 ILP64。</p><h2 id="第20步：sizeof运算符"><a href="#第20步：sizeof运算符" class="headerlink" title="第20步：sizeof运算符"></a><a href="#%E3%82%B9%E3%83%86%E3%83%83%E3%83%9720-sizeof%E6%BC%94%E7%AE%97%E5%AD%90">第20步：sizeof运算符</a></h2><p><code>sizeof</code> 看起来像一个函数，但从语法上讲它是一个一元运算符。在 C 中，大多数运算符都是符号，但从语法上讲，没有特殊原因说明运算符必须是符号，事实上 <code>sizeof</code> 是一个例外。</p><p>让我们回顾一下 <code>sizeof</code> 运算符的行为。 <code>sizeof</code> 是一个运算符，返回参数表达式类型在内存中的字节数。例如，在我们的 ABI 中，如果 <code>x</code> 是 <code>int</code> ，则 <code>sizeof(x)</code> 返回 4；如果 <code>x</code> 是指针，则返回 8。 <code>sizeof</code> 的参数中可以写任何表达式，例如，如果表达式 <code>x+3</code> 的类型整体为 int，则 <code>sizeof(x+3)</code> 为 4，如果是一个指针，它将返回 8。</p><p>我们的编译器还没有数组，但如果 <code>x</code> 是数组， <code>sizeof(x)</code> 将返回 <code>x</code> 的整个大小（以字节为单位）。例如，如果 <code>x</code> 定义为 <code>int x[10]</code> ，则 <code>sizeof(x)</code> 将返回 40。如果 <code>x</code> 定义为 <code>int x[5][10]</code> ，则 <code>sizeof(x)</code> 为 200， <code>sizeof(x[0])</code> 为 40， <code>sizeof(x[0][0])</code> 变为 4。</p><p><code>sizeof</code> 运算符的参数只是为了告诉您类型而编写的；它们并不是要执行的实际表达式。例如，即使您编写表达式 <code>sizeof(x[3])</code> ，实际上也不会发生对 <code>x[3]</code> 的访问。表达式 <code>x[3]</code> 的总体类型在编译时已知，因此表达式 <code>sizeof(x[3])</code> 在编译时被替换为该类型的大小。因此，赋予 <code>sizeof</code> 的具体表达式例如 <code>x[3]</code> 在运行时不再存在。</p><p>  <code>sizeof</code> 的行为如下所示。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">int x;</span><br><span class="line">int *y;</span><br><span class="line"></span><br><span class="line">sizeof(x); // 4</span><br><span class="line">sizeof(y); // 8</span><br><span class="line"></span><br><span class="line">sizeof(x + 3); // 4</span><br><span class="line">sizeof(y + 3); // 8</span><br><span class="line">sizeof(*y);    // 4</span><br><span class="line"></span><br><span class="line">// sizeofに渡す式は何でもよい</span><br><span class="line">sizeof(1); // 4</span><br><span class="line"></span><br><span class="line">// sizeofの結果は現在int型なのでsizeof(int)と同じ</span><br><span class="line">sizeof(sizeof(1)); // 4</span><br></pre></td></tr></table></figure><p>现在，让我们实现这个 <code>sizeof</code> 运算符。实现 <code>sizeof</code> 运算符涉及修改分词器和解析器。</p><p>首先，修改标记生成器以将关键字 <code>sizeof</code> 识别为 <code>TK_SIZEOF</code> 类型的标记。</p><p>接下来，我们修改解析器以将 <code>sizeof</code> 替换为 <code>int</code> 类型的常量。添加了 <code>sizeof</code> 运算符的语法如下所示。在下面的语法中， <code>sizeof</code> 被定义为一元运算符，其优先级与一元加和一元减相同。这与 C 的语法相同。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">unary = &quot;sizeof&quot; unary</span><br><span class="line">      | (&quot;+&quot; | &quot;-&quot;)? primary</span><br></pre></td></tr></table></figure><p>在这个语法中，不仅允许 <code>sizeof(x)</code> ，也允许 <code>sizeof x</code> ，在实际的 C 中也是如此。</p><p>在解析器中，当 <code>sizeof</code> 运算符出现时，作为其参数的表达式会像往常一样被解析，与结果语法树关联的类型为 <code>int</code> 如果是，则将其替换为数字 4，如果是指针，则替换为数字 8。由于解析器将其替换为常量，因此无需对代码生成树进行任何更改。</p><h2 id="第21步：实现数组"><a href="#第21步：实现数组" class="headerlink" title="第21步：实现数组"></a><a href="#%E3%82%B9%E3%83%86%E3%83%83%E3%83%9721-%E9%85%8D%E5%88%97%E3%82%92%E5%AE%9F%E8%A3%85%E3%81%99%E3%82%8B">第21步：实现数组</a></h2><h3 id="定义数组类型"><a href="#定义数组类型" class="headerlink" title="定义数组类型"></a><a href="#%E9%85%8D%E5%88%97%E5%9E%8B%E3%82%92%E5%AE%9A%E7%BE%A9%E3%81%99%E3%82%8B">定义数组类型</a></h3><p>在这一步中我们将实现数组。到目前为止，我们只处理了足以容纳寄存器的数据，但这是我们第一次处理比这个大的数据。</p><p>然而，当涉及到数组时，C 的语法是有限制的。您不能将数组作为函数参数传递或将数组作为函数返回值返回。如果您出于此目的编写代码，则数组本身不会按值传递，但会自动创建并传递指向该数组的指针。也不支持直接对数组进行赋值和复制（必须使用 memcpy）。</p><p>因此，无需在函数和变量之间传递不适合寄存器的数据。能够在堆栈上分配大于一个字的内存区域就足够了。</p><p>请允许读取如下变量定义。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int a[10];</span><br></pre></td></tr></table></figure><p>上面 a 的类型是一个数组，数组长度为 10，元素类型为 int。与指针类型一样，数组类型可以像您想要的那样复杂，因此就像步骤 7 中一样，使用 ptr_to 指向数组元素的类型。表示类型的结构应如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Type</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">enum</span> &#123;</span> INT, PTR, ARRAY &#125; ty;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Type</span> *<span class="title">ptr_to</span>;</span></span><br><span class="line">  <span class="type">size_t</span> array_size;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里， <code>array_size</code> 是一个仅对数组类型有意义的字段，是一个保存数组中元素数量的变量。</p><p>完成此操作后，您应该能够轻松地为堆栈上的数组分配空间。要查找数组的大小（以字节为单位），只需将数组元素的大小（以字节为单位）乘以数组中元素的数量即可。到目前为止，堆栈区域应该为所有变量保留为一个字，但请更改这一点并确保数组具有所需的大小。</p><h3 id="实现从数组到指针的隐式类型转换"><a href="#实现从数组到指针的隐式类型转换" class="headerlink" title="实现从数组到指针的隐式类型转换"></a><a href="#%E9%85%8D%E5%88%97%E3%81%8B%E3%82%89%E3%83%9D%E3%82%A4%E3%83%B3%E3%82%BF%E3%81%B8%E3%81%AE%E6%9A%97%E9%BB%99%E3%81%AE%E5%9E%8B%E5%A4%89%E6%8F%9B%E3%82%92%E5%AE%9F%E8%A3%85%E3%81%99%E3%82%8B">实现从数组到指针的隐式类型转换</a></h3><p>数组和指针经常结合使用，所以 C 的语法允许它在不区分指针和数组的情况下工作，但是这适得其反，让我们很难理解数组和指针之间的关系，似乎变得越来越困难让程序员能够理解。因此，这里我们来解释一下数组和指针的关系。</p><p>首先，在 C 中，数组和指针是完全不同的类型。</p><p>指针（在 x86-64 上）是 8 字节值类型。正如 + 和 - 等运算符是为整数定义的一样，+ 和 - 也为指针定义（形式略有不同）。此外，指针还定义了一元 <code>*</code> 运算符，它允许您引用指针所指向的内容。除了一元 <code>*</code> 之外，指针没有什么特别的。换句话说，指针是像 int 一样的普通类型。</p><p>另一方面，数组是一种可以是任意字节数的类型。与指针不同，为数组定义的运算符很少。唯一定义的运算符是 <code>sizeof</code> 运算符（它返回数组的大小）和 &amp; 运算符（它返回指向数组第一个元素的指针）。没有其他运算符可以应用于数组。</p><p>那么为什么像 <code>a[3]</code> 这样的表达式可以编译呢？在 C 中， <code>a[3]</code> 被定义为等同于 <code>*(a+3)</code> 。数组中不是没有定义 + 运算符吗？</p><p>这就是将数组隐式转换为指针的语法发挥作用的地方。数组会隐式转换为指向数组第一个元素的指针，除非用作 <code>sizeof</code> 或一元 <code>&amp;</code> 的操作数。因此， <code>*(a+3)</code> 是一个将数组 a 第一个元素的指针解引用加 3 的表达式，相当于访问数组的第三个元素，意义相同。</p><p>在 C 中，没有用于数组访问的 <code>[]</code> 运算符。 C 中的 <code>[]</code> 只是通过指针访问数组元素的简写符号。</p><p>类似地，如果将数组作为函数参数传递，它就会成为指向数组第一个元素的指针，或者您可以像直接将数组分配给指针一样编写它，但这也是可能的，如上所示。这取决于原因。</p><p>因此，编译器在实现大多数运算符时必须将数组转换为指针。这应该不会太难实施。除非您正在实现 <code>sizeof</code> 和一元 <code>&amp;</code> ，否则当您解析运算符的操作数时，如果它是 T 类型的数组，它将被解释为指向 T 的指针。 ，应该足够了。对于数组类型值，代码生成器应生成将值的地址压入堆栈的代码。</p><p>完成此操作后，您应该能够运行如下代码。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int a[2];</span><br><span class="line">*a = 1;</span><br><span class="line">*(a + 1) = 2;</span><br><span class="line">int *p;</span><br><span class="line">p = a;</span><br><span class="line">return *p + *(p + 1)  // → 3</span><br></pre></td></tr></table></figure><p>本书有意避免深入研究 C 语言规范的细节，直到编译器更加成熟。这是有原因的。在实现有规范的编程语言时，在某种程度上成为语言律师是必要的，但从一开始就过多关注细节并不是一种可取的开发方式。就像当你画一幅画时，你首先完成整个事物的粗略草图，而不是只详细地绘制一个部分，当你在实现一种编程语言时，尝试平衡它，这样你就不会变得太多首先是语言律师，我们需要维护和发展它。</p><h2 id="第22步：实现数组下标"><a href="#第22步：实现数组下标" class="headerlink" title="第22步：实现数组下标"></a><a href="#%E3%82%B9%E3%83%86%E3%83%83%E3%83%9722-%E9%85%8D%E5%88%97%E3%81%AE%E6%B7%BB%E5%AD%97%E3%82%92%E5%AE%9F%E8%A3%85%E3%81%99%E3%82%8B">第22步：实现数组下标</a></h2><p>在 C 中， <code>x[y]</code> 被定义为等同于 <code>*(x+y)</code> 。因此，实现下标相对简单。只需在解析器中将 <code>x[y]</code> 读取为 <code>*(x+y)</code> 即可。例如， <code>a[3]</code> 变为 <code>*(a+3)</code> 。</p><p>在这个语法中， <code>3[a]</code> 被扩展为 <code>*(3+a)</code> ，所以如果 <code>a[3]</code> 有效， <code>3[a]</code> 也应该有效，但在 C 中所以一个表达式像 <code>3[a]</code> 实际上是合法的。尝试一下。</p><h2 id="第23步：实现全局变量"><a href="#第23步：实现全局变量" class="headerlink" title="第23步：实现全局变量"></a><a href="#%E3%82%B9%E3%83%86%E3%83%83%E3%83%9723-%E3%82%B0%E3%83%AD%E3%83%BC%E3%83%90%E3%83%AB%E5%A4%89%E6%95%B0%E3%82%92%E5%AE%9F%E8%A3%85%E3%81%99%E3%82%8B">第23步：实现全局变量</a></h2><p>我希望很快就能在程序中编写文字字符串。在 C 中，文字字符串是一个字符数组。这很好，因为我们已经实现了数组，但不同的是文字字符串不是存在于堆栈上的值。字符串文字驻留在内存中的固定位置，而不是堆栈上。因此，要实现字符串文字，我们首先添加一个全局变量。</p><p>到目前为止，顶层只允许函数定义。让我们更改该语法，以便我们可以在顶层编写全局变量。</p><p>变量定义解析起来有些棘手，因为它们看起来与函数定义相似。例如，比较以下四个定义。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *foo;</span><br><span class="line"><span class="type">int</span> foo[<span class="number">10</span>];</span><br><span class="line"><span class="type">int</span> *<span class="title function_">foo</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">foo</span><span class="params">()</span> &#123;&#125;</span><br></pre></td></tr></table></figure><p>上面的两个 foo 是变量定义，下面的两个是函数定义，但是直到找到成为函数名或变量名的标识符并读取下一个标记之前，您无法区分它们。因此，您需要首先调用 “ 读取类型名称的前半部分 “ 函数，读取后面应该出现的标识符，然后尝试向前读取一个标记。如果预读标记为 “(“，则表示正在读取函数定义；否则，表示正在读取变量定义。</p><p>将已解析的全局变量的名称放入映射中，以便您可以按名称查找它们。仅当变量名称无法解析为局部变量时，才会尝试将其解析为全局变量。这允许以自然的方式让局部变量隐藏同名的全局变量。</p><p>解析器将局部变量引用和全局变量引用转换为抽象语法树中的单独节点。由于名称可以在解析阶段解析，因此类型也可以在该阶段分离。</p><p>到目前为止，所有变量都应该位于堆栈上，因此变量的读写是相对于 RBP（基指针）的。全局变量不是堆栈上的值，而是内存中的固定位置，因此编译时可以直接访问该地址。请参考实际的 gcc 输出。</p><p>一旦你实现了它，你会惊讶地发现局部变量和全局变量有很大的不同。之所以可以写得没有视觉上的区别，是因为 C 语言抽象得很好。局部变量和全局变量实际上在内部实现完全不同。</p><h2 id="第24步：实现字符类型"><a href="#第24步：实现字符类型" class="headerlink" title="第24步：实现字符类型"></a><a href="#%E3%82%B9%E3%83%86%E3%83%83%E3%83%9724-%E6%96%87%E5%AD%97%E5%9E%8B%E3%82%92%E5%AE%9F%E8%A3%85%E3%81%99%E3%82%8B">第24步：实现字符类型</a></h2><p>数组是一种可以大于一个单词的类型，但字符是一种可以小于一个单词的类型。要完成此步骤，您可能需要编写一个函数，该函数接受表示类型的对象并返回该类型的大小（以字节为单位）。首先，添加一个字符类型，然后修改该函数，使其为该字符类型返回 1。</p><p>在此步骤中无需实现文字字符（用单引号括起来的字符）。避免一次性实施所有事情的冲动，并保持变化尽可能小。</p><p>所以在这一步中，字符实际上只是一个小整数类型。 <code>movsx ecx, BYTE PTR [rax]</code> 可以从 RAX 指向的地址中读取一个字节并将其放入 ECX 中。如果不需要符号扩展，请使用 <code>movzx</code> 指令，如 <code>movzx ecx, BYTE PTR [rax]</code> 。写入时，使用 8 位寄存器作为源寄存器，如 <code>mov [rax], cl</code> 。</p><p>  请参考实际的编译输出。</p><p>实现此步骤后，您应该能够运行如下代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">char x[3];</span><br><span class="line">x[0] = -1;</span><br><span class="line">x[1] = 2;</span><br><span class="line">int y;</span><br><span class="line">y = 4;</span><br><span class="line">return x[0] + y;  // → 3</span><br></pre></td></tr></table></figure><h2 id="第-25-步：实现字符串文字"><a href="#第-25-步：实现字符串文字" class="headerlink" title="第 25 步：实现字符串文字"></a><a href="#%E3%82%B9%E3%83%86%E3%83%83%E3%83%9725-%E6%96%87%E5%AD%97%E5%88%97%E3%83%AA%E3%83%86%E3%83%A9%E3%83%AB%E3%82%92%E5%AE%9F%E8%A3%85%E3%81%99%E3%82%8B">第 25 步：实现字符串文字</a></h2><p>此步骤解析用双引号括起来的字符串，以便可以对其进行编译。现在我们已经有了必要的部分：数组、全局变量和字符类型，我认为实现起来会相对容易。</p><p>首先，修改标记生成器，以便当找到双引号时，读取到下一个双引号以创建字符串标记。这一步不需要实现反斜杠转义等。一步一步来很重要，所以即使看起来很容易实现，也尽量不要这样做。</p><p>在生成要在 CPU 上执行的机器代码时，无法输出表示字符串文字数据的汇编代码。在输出汇编中，全局数据和代码必须不混合地编写。换句话说，在输出代码时，我们希望首先输出代码中出现的所有字符串文字，但是通过语法树来做到这一点是很痛苦的。执行此操作的一个简单方法是拥有一个包含您见过的所有字符串文字的向量，并在每次解析器看到字符串时简单地添加到它。</p><p>  请参考实际的编译输出。</p><p>此时，您应该能够使用 <code>printf</code> 输出字符串。这是一个很好的机会，可以使用自己的编程语言来编写比测试代码等显而易见的东西更复杂的东西。例如，是否可以用您自己的语言编写 8 皇后问题的求解器？人类花了几十年的时间才开发出一种编程语言，使我们能够轻松地编写这个级别的代码。对于人类和你们来说，这都是一个巨大的进步，它可以在几周内实施。</p><p>（当调用带有可变长度参数的函数时，浮点参数的数量存储在 AL 中。我们的编译器还没有浮点数。因此，在调用函数时，（在执行之前始终将 AL 设置为 0 所以。）</p><h2 id="步骤-26：从文件中读取输入"><a href="#步骤-26：从文件中读取输入" class="headerlink" title="步骤 26：从文件中读取输入"></a><a href="#%E3%82%B9%E3%83%86%E3%83%83%E3%83%9726-%E5%85%A5%E5%8A%9B%E3%82%92%E3%83%95%E3%82%A1%E3%82%A4%E3%83%AB%E3%81%8B%E3%82%89%E8%AA%AD%E3%82%80">步骤 26：从文件中读取输入</a></h2><p>到目前为止，我一直将 C 代码直接传递给参数字符串，但由于输入逐渐变长，我认为是时候修改它，以便它像普通 C 编译器一样将文件名作为命令行参数.让我们吧。打开给定文件、读取其内容并返回以 <code>&#39;\0&#39;</code> 结尾的字符串的函数可以简明地编写如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定されたファイルの内容を返す</span></span><br><span class="line"><span class="type">char</span> *<span class="title function_">read_file</span><span class="params">(<span class="type">char</span> *path)</span> &#123;</span><br><span class="line">  <span class="comment">// ファイルを開く</span></span><br><span class="line">  FILE *fp = fopen(path, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (!fp)</span><br><span class="line">    error(<span class="string">&quot;cannot open %s: %s&quot;</span>, path, strerror(errno));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ファイルの長さを調べる</span></span><br><span class="line">  <span class="keyword">if</span> (fseek(fp, <span class="number">0</span>, SEEK_END) == <span class="number">-1</span>)</span><br><span class="line">    error(<span class="string">&quot;%s: fseek: %s&quot;</span>, path, strerror(errno));</span><br><span class="line">  <span class="type">size_t</span> size = ftell(fp);</span><br><span class="line">  <span class="keyword">if</span> (fseek(fp, <span class="number">0</span>, SEEK_SET) == <span class="number">-1</span>)</span><br><span class="line">    error(<span class="string">&quot;%s: fseek: %s&quot;</span>, path, strerror(errno));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ファイル内容を読み込む</span></span><br><span class="line">  <span class="type">char</span> *buf = <span class="built_in">calloc</span>(<span class="number">1</span>, size + <span class="number">2</span>);</span><br><span class="line">  fread(buf, size, <span class="number">1</span>, fp);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ファイルが必ず&quot;\n\0&quot;で終わっているようにする</span></span><br><span class="line">  <span class="keyword">if</span> (size == <span class="number">0</span> || buf[size - <span class="number">1</span>] != <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">    buf[size++] = <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  buf[size] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">  fclose(fp);</span><br><span class="line">  <span class="keyword">return</span> buf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于编译器的实现，每行以换行符结尾的数据比以换行符或 EOF 结尾的数据更容易处理，因此如果文件的最后一个字节不是 <code>\n</code> ，我决定自动添加 <code>\n</code> 。</p><p>严格来说，如果给您一个无法随机访问的特殊文件，此功能将无法正常工作。例如，如果您指定表示标准输入的设备文件 <code>/dev/stdin</code> 或命名管道作为文件名，则您应该会看到显示诸如 <code>/dev/stdin: fseek: Illegal seek</code> 之类的错误消息。不过，实际上这个功能应该没问题。修改您的代码以使用此函数读取文件的内容并将其视为输入。</p><p>由于输入文件通常包含多行，因此您还应该增强显示错误消息的功能。发生错误时，如果您决定显示输入文件名、出错行的行号以及该行的内容，则错误消息将如下所示。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">foo.c:10: x = y + + 5;</span><br><span class="line">                  ^ 式ではありません</span><br></pre></td></tr></table></figure><p>显示此类错误消息的函数如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 入力ファイル名</span></span><br><span class="line"><span class="type">char</span> *filename;</span><br><span class="line"></span><br><span class="line"><span class="comment">// エラーの起きた場所を報告するための関数</span></span><br><span class="line"><span class="comment">// 下のようなフォーマットでエラーメッセージを表示する</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// foo.c:10: x = y + + 5;</span></span><br><span class="line"><span class="comment">//                   ^ 式ではありません</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">error_at</span><span class="params">(<span class="type">char</span> *loc, <span class="type">char</span> *msg)</span> &#123;</span><br><span class="line">  <span class="comment">// locが含まれている行の開始地点と終了地点を取得</span></span><br><span class="line">  <span class="type">char</span> *line = loc;</span><br><span class="line">  <span class="keyword">while</span> (user_input &lt; line &amp;&amp; line[<span class="number">-1</span>] != <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">    line--;</span><br><span class="line"></span><br><span class="line">  <span class="type">char</span> *end = loc;</span><br><span class="line">  <span class="keyword">while</span> (*end != <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">    end++;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 見つかった行が全体の何行目なのかを調べる</span></span><br><span class="line">  <span class="type">int</span> line_num = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">char</span> *p = user_input; p &lt; line; p++)</span><br><span class="line">    <span class="keyword">if</span> (*p == <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">      line_num++;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 見つかった行を、ファイル名と行番号と一緒に表示</span></span><br><span class="line">  <span class="type">int</span> indent = <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;%s:%d: &quot;</span>, filename, line_num);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;%.*s\n&quot;</span>, (<span class="type">int</span>)(end - line), line);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// エラー箇所を&quot;^&quot;で指し示して、エラーメッセージを表示</span></span><br><span class="line">  <span class="type">int</span> pos = loc - line + indent;</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;%*s&quot;</span>, pos, <span class="string">&quot;&quot;</span>); <span class="comment">// pos個の空白を出力</span></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;^ %s\n&quot;</span>, msg);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然这个错误信息输出例程相当简单，但可以说它以相当专业的格式输出错误。</p><p>コラム:  专栏：错误恢复</p><p>如果输入代码在语法上不正确，许多编译器将尝试跳过错误并继续解析其余代码。目标是找到尽可能多的错误，而不仅仅是一个。从解析器错误中恢复并继续解析的能力称为 “ 错误恢复 “。</p><p>错误恢复是旧编译器的一个非常重要的功能。在 20 世纪 60 年代和 1970 年代，程序员在计算机中心使用大型计算机进行分时，要求他们带入要编译的代码并等待，有时甚至是一整夜，然后才能得到编译结果。在这样的环境下，编译器的重要任务之一就是指出尽可能多的可能的错误。在较旧的编译器教科书中，错误恢复是解析的主要主题之一。</p><p>如今，使用编译器进行开发更具交互性，因此错误恢复不再是一个重要的话题。我们开发的编译器只打印第一条错误消息。在现代，这在很多情况下就足够了。</p><h2 id="第-27-步：行注释和块注释"><a href="#第-27-步：行注释和块注释" class="headerlink" title="第 27 步：行注释和块注释"></a><a href="#%E3%82%B9%E3%83%86%E3%83%83%E3%83%9727-%E8%A1%8C%E3%82%B3%E3%83%A1%E3%83%B3%E3%83%88%E3%81%A8%E3%83%96%E3%83%AD%E3%83%83%E3%82%AF%E3%82%B3%E3%83%A1%E3%83%B3%E3%83%88">第 27 步：行注释和块注释</a></h2><p>我们的编译器逐渐发展，编写成熟的代码已经成为可能。在这种情况下，您想要的是注释。本章实现了注释。</p><p>C 中的注释有两种类型。一条注释称为行注释，注释从 <code>//</code> 开始到行尾。另一种类型称为块注释，其中 <code>/*</code> 是开始符号， <code>*/</code> 是结束符号。除了两个字符序列 <code>*/</code> 之外，块注释中的所有字符都会被跳过。</p><p>从语法上讲，注释被视为与单个空格字符相同。因此，分词器很自然地会像空格一样跳过注释。跳过注释的代码如下所示。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">tokenize</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">char</span> *p = user_input;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (*p) &#123;</span><br><span class="line">    <span class="comment">// 空白文字をスキップ</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isspace</span>(*p)) &#123;</span><br><span class="line">      p++;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 行コメントをスキップ</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strncmp</span>(p, <span class="string">&quot;//&quot;</span>, <span class="number">2</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">      p += <span class="number">2</span>;</span><br><span class="line">      <span class="keyword">while</span> (*p != <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">        p++;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ブロックコメントをスキップ</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strncmp</span>(p, <span class="string">&quot;/*&quot;</span>, <span class="number">2</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="type">char</span> *q = <span class="built_in">strstr</span>(p + <span class="number">2</span>, <span class="string">&quot;*/&quot;</span>);</span><br><span class="line">      <span class="keyword">if</span> (!q)</span><br><span class="line">        error_at(p, <span class="string">&quot;コメントが閉じられていません&quot;</span>);</span><br><span class="line">      p = q + <span class="number">2</span>;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>这里我们使用 C 标准库中的 <code>strstr</code> 函数来查找块注释的结尾。 <code>strstr</code> 在字符串中搜索字符串，如果找到则返回指向所传递字符串开头的指针，如果未找到则返回 NULL。</p><p>コラム:  专栏：块注释和嵌套</p><p>块注释不能嵌套。 <code>/*</code> 在注释中没有特殊含义，因此注释掉现有的块注释。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/* /* ... */ */</span><br></pre></td></tr></table></figure><p>第一个 <code>*/</code> 将结束注释，第二个 <code>*/</code> 将导致语法错误。</p><p>如果要注释掉所有可能包含块注释的行，请使用 C 预处理器。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#if 0</span><br><span class="line">...</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><p>一种方法是将其包装在 <code>#if 0</code> 中，如下所示。</p><h2 id="步骤-28：用-C-重写测试"><a href="#步骤-28：用-C-重写测试" class="headerlink" title="步骤 28：用 C 重写测试"></a><a href="#%E3%82%B9%E3%83%86%E3%83%83%E3%83%9728-%E3%83%86%E3%82%B9%E3%83%88%E3%82%92c%E3%81%A7%E6%9B%B8%E3%81%8D%E7%9B%B4%E3%81%99">步骤 28：用 C 重写测试</a></h2><p>在此步骤中，我们将重写测试以使 <code>make test</code> 更快。当您执行此步骤时，您可能已经在 shell 脚本中编写了 100 多个测试。 Shell 脚本测试为每个测试启动多个进程。换句话说，对于每个测试，我都会启动自己的编译器、汇编器、链接器并测试自身。</p><p>即使对于小程序来说，启动进程也不是那么快。因此，如果您执行数百次，总共将花费相当长的时间。您的测试脚本可能需要几秒钟才能运行。</p><p>我首先在 shell 脚本中编写测试的原因是因为否则我无法进行正确的测试。在计算器级语言中，没有 <code>if</code> 或 <code>==</code> ，因此无法验证该语言内计算结果的准确性。但现在可以验证了。现在可以比较结果以查看它们是否正确，如果不正确，则显示错误消息（作为字符串）并退出。</p><p>因此，在这一步中，将用 shell 脚本编写的测试重写为 C 文件。</p><h1 id="C-类型语法"><a href="#C-类型语法" class="headerlink" title="C 类型语法"></a><a href="#type">C 类型语法</a></h1><p>本章介绍如何阅读 C 类型语法。到本章结束时，读者将能够按照逐步的方法解码诸如 <code>void (*x)(int)</code> 和 <code>void (*signal(int, void (*)(int)))(int)</code> 之类的复杂类型。应该是这样。</p><h2 id="代表类型的图表"><a href="#代表类型的图表" class="headerlink" title="代表类型的图表"></a><a href="#%E5%9E%8B%E3%82%92%E8%A1%A8%E3%81%99%E5%9B%B3">代表类型的图表</a></h2><p>C 语言可以表达的类型比较简单。为了将类型语法的复杂性与类型本身的复杂性分开，让我们暂时将语法放在一边，只考虑类型。</p><p>诸如指针和数组之类的复杂类型可以通过用箭头连接简单类型的图表来表示。例如，下图显示了表示 “ 指向 int 的指针 “ 的类型。</p><p><img src="/../../img/blog/4c3a749491fed60036e8c70840e3c681_MD5.svg"></p><p>在日语中，从箭头的终点到起点读作 “int 指针的指针 “。在英语中，发音相反：指向 int 指针的指针，遵循箭头的方向。</p><p>假设变量 <code>x</code> 具有上图所示的类型。对于 “ <code>x</code> 的类型是什么？” 这个问题，最简单的答案是 “ 它是一个指针 “。这是因为第一个箭头指向的类型是指针类型。注意， <code>x</code> 首先是一个指针，而不是 <code>int</code> 这样的类型。 “ 该指针指向什么类型？” 这个问题的答案是 “ 它是一个指针 “。这是因为跟随一个箭头的指针也是一种指针类型。最后，” 该指针指向什么类型？” 这个问题的答案是 “int”。</p><p>下图显示了一个 “int 指针数组 “。数组的长度是 20。在实际的编译器中，数组的长度也表示为代表数组的类型的成员，如下图所示。</p><p><img src="/../../img/blog/28a0d0b33ca1290558c334017d93013f_MD5.svg"></p><p>如果变量 <code>x</code> 具有上图所示的类型，则 <code>x</code> 是长度为 20 的数组类型，并且该数组的元素是指针，该指针指向的变为&lt; b2&gt;。</p><p>函数类型也可以用图形表示。下图显示了带有两个参数（一个 int 和一个指向 int 的指针）并返回一个 void 指针的函数类型。</p><p><img src="/../../img/blog/3ff805c41a8cd70412adac62e7e4088e_MD5.svg"></p><p>最后，让我们看一个更复杂的例子。下图显示了一种称为函数指针的类型，它采用 int 作为参数，并返回一个指向返回 int 的函数的指针。用文字表达很复杂，但用图表表达时，你会发现它很长，结构也很简单。</p><p><img src="/../../img/blog/a31ebf2dc070eaf5a531a5e847963463_MD5.svg"></p><p>如果变量 <code>x</code> 具有上图所示的类型，则 <code>x</code> 是指针类型，该指针指向一个函数，该函数的参数类型为 In <code>int</code> ，返回类型为指针类型，指针指向一个函数，该函数的返回值类型为 <code>int</code> 。</p><p>在内部，编译器使用与上图相同的方法来表示类型。换句话说，涉及指针、数组和函数的复杂类型在编译器内部表示为由指针连接的简单类型结构组成的数据结构，其顺序与上图所示的顺序相同。因此，毫不夸张地说，这张图就是型的真实形态。</p><h2 id="表示类型的符号"><a href="#表示类型的符号" class="headerlink" title="表示类型的符号"></a><a href="#%E5%9E%8B%E3%82%92%E8%A1%A8%E3%81%99%E8%A8%98%E6%B3%95">表示类型的符号</a></h2><p>尽管用如上所示的图表表示类型时更容易理解类型的含义，但每次都画图表来理解类型是很乏味的。在本节中，我们将考虑一种可以写得更紧凑而又不影响图表清晰度的符号。</p><p>除非包含功能类型，否则所有框都将以菊花链形式排列在图中，没有任何分支。因此，如果类型只有指针或数组，您应该能够通过在图中从左到右书写类型的名称来用文本表达图。</p><p>我们来考虑一下具体的记法。代表指针的框将由符号 <code>*</code> 表示。另外，规则是在表示长度为 n 的数组的框中写入 <code>[n]</code> ，并在表示内置类型（例如 int）的框中写入类型名称。那么，下图就可以用字符串 <code>* * int</code> 来表示。</p><p><img src="/../../img/blog/4c3a749491fed60036e8c70840e3c681_MD5.svg"></p><p>从箭头起点开始依次出现 pointer、pointer、int，因此表示法为 <code>* * int</code> 。相反，如果我们给出符号 <code>* * int</code> ，我们也可以画出上面的图。换句话说，这种文本表示是一种符号，允许您以文本形式紧凑地写下与图表相同的信息。</p><p>下图可以用字符串 <code>[20] * int</code> 来表示。</p><p><img src="/../../img/blog/28a0d0b33ca1290558c334017d93013f_MD5.svg"></p><p>对于函数，我们将其写为 “ <code>func(引数の型, …) 返り値の型</code> “。例如下图所示的类型写为 <code>func(int, * int) * void</code> 。鼓励读者检查该符号是否与图表相符。</p><p><img src="/../../img/blog/3ff805c41a8cd70412adac62e7e4088e_MD5.svg"></p><p>最后，如下图所示的类型是 <code>* func(int) * func() int</code> 。</p><p><img src="/../../img/blog/a31ebf2dc070eaf5a531a5e847963463_MD5.svg"></p><p>到目前为止描述的符号可能是类型的最直接和最简单的文本表示。事实上，Go 编程语言中的类型语法与这里描述的表示法完全相同。 Go 是一门由 C 的创建者参与开发的语言，Go 中的类型语法通过吸取 C 的经验教训而得到了巧妙的改进。 </p><h1 id="综上所述"><a href="#综上所述" class="headerlink" title="综上所述"></a><a href="#%E3%81%8A%E3%82%8F%E3%82%8A%E3%81%AB">综上所述</a></h1><p>本书正文以 Markdown 格式编写。我使用 Pandoc 将 Markdown 转换为 HTML，使用 Graphviz 创建语法树图，使用 draw.io 创建其他图表。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机/计算机基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python应用</title>
      <link href="/posts/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python%E5%BA%94%E7%94%A8.html"/>
      <url>/posts/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python%E5%BA%94%E7%94%A8.html</url>
      
        <content type="html"><![CDATA[<h1 id="解方程"><a href="#解方程" class="headerlink" title="解方程"></a>解方程</h1><p><strong>Brent 方法</strong></p><p>Brent 方法是一种数值寻根算法，用于解方程 f(x)&#x3D;0,它结合了二分法（bisection）、弦截法（secant）以及反复同步这两者的过程来实现高效的迭代。</p><p>简要介绍 Brent 方法的思想：</p><ul><li>首先使用二分法确定一个包含根的初始区间 [a,b]。</li><li>在每一次迭代中，通过比较二分法和弦截法的结果来决定采取哪种方法更接近根。</li><li>反复同步二分法和弦截法，并不断缩小区间，直至找到满足精度要求的根。</li><li>相比于其他常见的寻根方法，如 Newton-Raphson 方法和割线法，Brent 方法具有高精度、全局收敛和鲁棒性等优点。在大多数情况下，Brent 方法都比其他算法更快地收敛，尤其是当方程存在多个根或根附近存在奇点时。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> scipy.optimize</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> x**<span class="number">3</span> + np.cos(x) - np.exp(x)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定求解区间 [0, 1]</span></span><br><span class="line">x_values = np.linspace(-<span class="number">1</span>, <span class="number">1</span>, num=<span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 找到所有满足条件的 x 解</span></span><br><span class="line">solutions = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(x_values)-<span class="number">1</span>):</span><br><span class="line">    start, end = x_values[i:i+<span class="number">2</span>]</span><br><span class="line">    <span class="keyword">if</span> func(start) * func(end) &lt; <span class="number">0</span>:</span><br><span class="line">        sol = scipy.optimize.root_scalar(func, bracket=[start, end], method=<span class="string">&#x27;brentq&#x27;</span>, rtol=<span class="number">1e-6</span>)</span><br><span class="line">        solutions.append(sol.root)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印解的个数和具体值</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Found <span class="subst">&#123;<span class="built_in">len</span>(solutions)&#125;</span> solutions: <span class="subst">&#123;solutions&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><p>参考：<a href="https://mp.weixin.qq.com/s/oxe26KwAUihtZHZgbhbb_Q">python之求解非线性方程 (qq.com)</a></p><h1 id="Python-Fire：自动生成命令行接口"><a href="#Python-Fire：自动生成命令行接口" class="headerlink" title="Python Fire：自动生成命令行接口"></a>Python Fire：自动生成命令行接口</h1><p><a href="https://mp.weixin.qq.com/s/Rp7yghuqujeTnzaV4K9xgw">Python Fire：自动生成命令行接口 (qq.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机/编程语言/python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python安装配置</title>
      <link href="/posts/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE.html"/>
      <url>/posts/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE.html</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.python.org/">Welcome to Python.org</a></p><h1 id="pip-下载配置"><a href="#pip-下载配置" class="headerlink" title="pip 下载配置"></a>pip 下载配置</h1><h2 id="临时替换下载源：假设现在我要下载-selenium-这个第三方模块"><a href="#临时替换下载源：假设现在我要下载-selenium-这个第三方模块" class="headerlink" title="临时替换下载源：假设现在我要下载 selenium 这个第三方模块"></a>临时替换下载源：假设现在我要下载 selenium 这个第三方模块</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install -i https://pypi.douban.com/simple/ selenium </span><br></pre></td></tr></table></figure><p>-i 参数表示这一次下载指定某个下载源，下次不再生效</p><h2 id="使用-pip-config-set-永久替换下载源"><a href="#使用-pip-config-set-永久替换下载源" class="headerlink" title="使用 pip config set 永久替换下载源"></a>使用 pip config set 永久替换下载源</h2><ul><li>在命令行中执行以下指令（win10 是 cmd），pip 版本需要&gt;&#x3D;10.0.0</li></ul><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simple</span><br></pre></td></tr></table></figure><h1 id="更改-Python-的-pip-install-默认使用的-pip-库以及默认安装路径"><a href="#更改-Python-的-pip-install-默认使用的-pip-库以及默认安装路径" class="headerlink" title="更改 Python 的 pip install 默认使用的 pip 库以及默认安装路径"></a>更改 Python 的 pip install 默认使用的 pip 库以及默认安装路径</h1><p><a href="https://blog.csdn.net/C_chuxin/article/details/82962797">更改 Python 的 pip install 默认使用的pip库以及默认安装路径_更改pip安装路径-CSDN博客</a></p><h1 id="Anaconda-安装和使用指南"><a href="#Anaconda-安装和使用指南" class="headerlink" title="Anaconda 安装和使用指南"></a>Anaconda 安装和使用指南</h1><p><a href="https://zhuanlan.zhihu.com/p/36398337">Anaconda 安装和使用指南 - 知乎 (zhihu. com)</a></p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机/编程语言/语言环境配置 </tag>
            
            <tag> 计算机/编程语言/python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux故障定位小技巧</title>
      <link href="/posts/%E7%B3%BB%E7%BB%9F/Linux/Linux%E6%95%85%E9%9A%9C%E5%AE%9A%E4%BD%8D%E5%B0%8F%E6%8A%80%E5%B7%A7.html"/>
      <url>/posts/%E7%B3%BB%E7%BB%9F/Linux/Linux%E6%95%85%E9%9A%9C%E5%AE%9A%E4%BD%8D%E5%B0%8F%E6%8A%80%E5%B7%A7.html</url>
      
        <content type="html"><![CDATA[<h1 id="接入层问题故障定位"><a href="#接入层问题故障定位" class="headerlink" title="接入层问题故障定位"></a><a href="https://www.jianshu.com/p/0bbac570fa4c">接入层问题故障定位</a></h1><h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>本篇文章主要介绍各种问题定位的工具以及会结合案例分析问题。</p><h1 id="分析问题的方法论"><a href="#分析问题的方法论" class="headerlink" title="分析问题的方法论"></a>分析问题的方法论</h1><p>套用 5 W 2 H 方法，可以提出性能分析的几个问题</p><ul><li>What- 现象是什么样的</li><li>When- 什么时候发生</li><li>Why- 为什么会发生</li><li>Where- 哪个地方发生的问题</li><li>How much- 耗费了多少资源</li><li>How to do- 怎么解决问题</li></ul><h1 id="Cpu"><a href="#Cpu" class="headerlink" title="Cpu"></a>Cpu</h1><h2 id="说明-1"><a href="#说明-1" class="headerlink" title="说明"></a>说明</h2><p>针对应用程序，我们通常关注的是内核 CPU 调度器功能和性能。</p><p>线程的状态分析主要是分析线程的时间用在什么地方，而线程状态的分类一般分为：</p><p>a. on-CPU：执行中，执行中的时间通常又分为用户态时间 user 和系统态时间 sys。<br>b. off-CPU：等待下一轮上 CPU，或者等待 I&#x2F;O、锁、换页等等，其状态可以细分为可执行、匿名换页、睡眠、锁、空闲等状态。</p><p>如果大量时间花在 CPU 上，对 CPU 的剖析能够迅速解释原因；如果系统时间大量处于 off-cpu 状态，定位问题就会费时很多。但是仍然需要清楚一些概念：</p><ul><li>处理器</li><li>核</li><li>硬件线程</li><li>CPU 内存缓存</li><li>时钟频率</li><li>每指令周期数 CPI 和每周期指令数 IPC</li><li>CPU 指令</li><li>使用率</li><li>用户时间／内核时间</li><li>调度器</li><li>运行队列</li><li>抢占</li><li>多进程</li><li>多线程</li><li>字长</li></ul><h2 id="分析工具"><a href="#分析工具" class="headerlink" title="分析工具"></a>分析工具</h2><table><thead><tr><th>工具</th><th>描述</th></tr></thead><tbody><tr><td>uptime</td><td>平均负载</td></tr><tr><td>vmstat</td><td>包括系统范围的 cpu 平均负载</td></tr><tr><td>mpstat</td><td>查看所有 cpu 核信息</td></tr><tr><td>top</td><td>监控每个进程 cpu 用量</td></tr><tr><td>sar -u</td><td>查看 cpu 信息</td></tr><tr><td>pidstat</td><td>每个进程 cpu 用量分解</td></tr><tr><td>perf</td><td>cpu 剖析和跟踪，性能计数分析</td></tr></tbody></table><p>说明:</p><ul><li>Uptime, vmstat, mpstat, top, pidstat 只能查询到 cpu 及负载的的使用情况。</li><li>Perf 可以跟着到进程内部具体函数耗时情况，并且可以指定内核函数进行统计，指哪打哪。</li></ul><h2 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//查看系统 cpu 使用情况</span><br><span class="line">top</span><br><span class="line"></span><br><span class="line">//查看所有 cpu 核信息</span><br><span class="line">mpstat -P ALL 1</span><br><span class="line"></span><br><span class="line">//查看 cpu 使用情况以及平均负载</span><br><span class="line">vmstat 1</span><br><span class="line"></span><br><span class="line">//进程 cpu 的统计信息</span><br><span class="line">pidstat -u 1 -p pid</span><br><span class="line"></span><br><span class="line">//跟踪进程内部函数级 cpu 使用情况</span><br><span class="line">perf top -p pid -e cpu-clock</span><br></pre></td></tr></table></figure><h1 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h1><h2 id="说明-2"><a href="#说明-2" class="headerlink" title="说明"></a>说明</h2><p>内存是为提高效率而生，实际分析问题的时候，内存出现问题可能不只是影响性能，而是影响服务或者引起其他问题。同样对于内存有些概念需要清楚：</p><ul><li>主存</li><li>虚拟内存</li><li>常驻内存</li><li>地址空间</li><li>OOM</li><li>页缓存</li><li>缺页</li><li>换页</li><li>交换空间</li><li>交换</li><li>用户分配器 libc、glibc、libmalloc 和 mtmalloc</li><li>LINUX 内核级 SLUB 分配器</li></ul><h2 id="分析工具-1"><a href="#分析工具-1" class="headerlink" title="分析工具"></a>分析工具</h2><table><thead><tr><th>工具</th><th>描述</th></tr></thead><tbody><tr><td>free</td><td>缓存容量统计信息</td></tr><tr><td>vmstat</td><td>虚拟内存统计信息</td></tr><tr><td>top</td><td>监视每个进程的内存使用情况</td></tr><tr><td>pidstat</td><td>显示活动进程的内存使用统计</td></tr><tr><td>pmap</td><td>查看进程的内存映像信息</td></tr><tr><td>sar -r</td><td>查看内存</td></tr><tr><td>dtrace</td><td>动态跟踪</td></tr><tr><td>valgrind</td><td>分析程序性能及程序中的内存泄露错误</td></tr></tbody></table><p><strong>说明</strong>：</p><ul><li>Free, vmstat, top, pidstat, pmap 只能统计内存信息以及进程的内存使用情况。</li><li>Valgrind 可以分析内存泄漏问题。</li><li>Dtrace 动态跟踪。需要对内核函数有很深入的了解，通过 D 语言编写脚本完成跟踪。</li></ul><h2 id="使用方式-1"><a href="#使用方式-1" class="headerlink" title="使用方式"></a>使用方式</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//查看系统内存使用情况</span><br><span class="line">free -m</span><br><span class="line"></span><br><span class="line">//虚拟内存统计信息</span><br><span class="line">vmstat 1</span><br><span class="line"></span><br><span class="line">//查看系统内存情况</span><br><span class="line">top</span><br><span class="line"></span><br><span class="line">//1s 采集周期，获取内存的统计信息</span><br><span class="line">pidstat -p pid -r 1</span><br><span class="line"></span><br><span class="line">//查看进程的内存映像信息</span><br><span class="line">pmap -d pid</span><br><span class="line"></span><br><span class="line">//检测程序内存问题</span><br><span class="line">valgrind --tool=memcheck --leak-check=full --log-file=./log.txt ./程序名</span><br></pre></td></tr></table></figure><h1 id="磁盘-IO"><a href="#磁盘-IO" class="headerlink" title="磁盘 IO"></a>磁盘 IO</h1><h2 id="说明-3"><a href="#说明-3" class="headerlink" title="说明"></a>说明</h2><p>磁盘通常是计算机最慢的子系统，也是最容易出现性能瓶颈的地方，因为磁盘离 CPU 距离最远而且 CPU 访问磁盘要涉及到机械操作，比如转轴、寻轨等。访问硬盘和访问内存之间的速度差别是以数量级来计算的，就像 1 天和 1 分钟的差别一样。要监测 IO 性能，有必要了解一下基本原理和 Linux 是如何处理硬盘和内存之间的 IO 的。</p><p>在理解磁盘 IO 之前，同样我们需要理解一些概念，例如：</p><ul><li>文件系统</li><li>VFS</li><li>文件系统缓存</li><li>页缓存 page cache</li><li>缓冲区高速缓存 buffer cache</li><li>目录缓存</li><li>Inode</li><li>Inode 缓存</li><li>Noop 调用策略</li></ul><h2 id="分析工具-2"><a href="#分析工具-2" class="headerlink" title="分析工具"></a>分析工具</h2><table><thead><tr><th>工具</th><th>描述</th></tr></thead><tbody><tr><td>iostat</td><td>磁盘详细统计信息</td></tr><tr><td>iotop</td><td>按进程查看磁盘 IO 的使用情况</td></tr><tr><td>pidstat</td><td>按进程查看磁盘 IO 的使用情况</td></tr><tr><td>perf</td><td>动态跟踪工具</td></tr></tbody></table><h2 id="使用方式-2"><a href="#使用方式-2" class="headerlink" title="使用方式"></a>使用方式</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//查看系统 io 信息</span><br><span class="line">iotop</span><br><span class="line"></span><br><span class="line">//统计 io 详细信息</span><br><span class="line">iostat -d -x -k 1 10</span><br><span class="line"></span><br><span class="line">//查看进程级 io 的信息</span><br><span class="line">pidstat -d 1 -p pid</span><br><span class="line"></span><br><span class="line">//查看系统 IO 的请求，比如可以在发现系统 IO 异常时，可以使用该命令进行调查，就能指定到底是什么原因导致的 IO 异常</span><br><span class="line">perf record -e block:block_rq_issue -ag</span><br><span class="line">^C</span><br><span class="line">perf report</span><br></pre></td></tr></table></figure><h1 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h1><h2 id="说明-4"><a href="#说明-4" class="headerlink" title="说明"></a>说明</h2><p>网络的监测是所有 Linux 子系统里面最复杂的，有太多的因素在里面，比如：延迟、阻塞、冲突、丢包等，更糟的是与 Linux 主机相连的路由器、交换机、无线信号都会影响到整体网络并且很难判断是因为 Linux 网络子系统的问题还是别的设备的问题，增加了监测和判断的复杂度。现在我们使用的所有网卡都称为自适应网卡，意思是说能根据网络上的不同网络设备导致的不同网络速度和工作模式进行自动调整。</p><h2 id="分析工具-3"><a href="#分析工具-3" class="headerlink" title="分析工具"></a>分析工具</h2><table><thead><tr><th>工具</th><th>描述</th></tr></thead><tbody><tr><td>ping</td><td>主要透过 ICMP 封包来进行整个网络的状况报告</td></tr><tr><td>traceroute</td><td>用来检测发出数据包的主机到目标主机之间所经过的网关数量的工具</td></tr><tr><td>netstat</td><td>用于显示与 IP、TCP、UDP 和 ICMP 协议相关的统计数据，一般用于检验本机各端口的网络连接情况</td></tr><tr><td>ss</td><td>可以用来获取 socket 统计信息，而且比 netstat 更快速更高效</td></tr><tr><td>host</td><td>可以用来查出某个主机名的 IP, 跟 nslookup 作用一样</td></tr><tr><td>tcpdump</td><td>是以包为单位进行输出的，阅读起来不是很方便</td></tr><tr><td>tcpflow</td><td>是面向 tcp 流的, 每个 tcp 传输会保存成一个文件, 很方便的查看</td></tr><tr><td>sar -n DEV</td><td>网卡流量情况</td></tr><tr><td>sar -n SOCK</td><td>查询网络以及 tcp，udp 状态信息</td></tr></tbody></table><h2 id="使用方式-3"><a href="#使用方式-3" class="headerlink" title="使用方式"></a>使用方式</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">//显示网络统计信息</span><br><span class="line">netstat -s</span><br><span class="line"></span><br><span class="line">//显示当前 UDP 连接状况</span><br><span class="line">netstat -nu</span><br><span class="line"></span><br><span class="line">//显示 UDP 端口号的使用情况</span><br><span class="line">netstat -apu</span><br><span class="line"></span><br><span class="line">//统计机器中网络连接各个状态个数</span><br><span class="line">netstat -a | awk <span class="string">&#x27;/^tcp/ &#123;++S[$NF]&#125; END &#123;for(a in S) print a, S[a]&#125;&#x27;</span></span><br><span class="line"></span><br><span class="line">//显示 TCP 连接</span><br><span class="line">ss -t -a</span><br><span class="line"></span><br><span class="line">//显示 sockets 摘要信息</span><br><span class="line">ss -s</span><br><span class="line"></span><br><span class="line">//显示所有 udp sockets</span><br><span class="line">ss -u -a</span><br><span class="line"></span><br><span class="line">//tcp,etcp 状态</span><br><span class="line">sar -n TCP,ETCP 1</span><br><span class="line"></span><br><span class="line">//查看网络 IO</span><br><span class="line">sar -n DEV 1</span><br><span class="line"></span><br><span class="line">//抓包以包为单位进行输出</span><br><span class="line">tcpdump -i eth1 host  and port 80</span><br><span class="line"></span><br><span class="line">//抓包以流为单位显示数据内容</span><br><span class="line">tcpflow -<span class="built_in">cp</span> host </span><br></pre></td></tr></table></figure><h1 id="系统负载"><a href="#系统负载" class="headerlink" title="系统负载"></a>系统负载</h1><h2 id="说明-5"><a href="#说明-5" class="headerlink" title="说明"></a>说明</h2><p>Load 就是对计算机干活多少的度量（WikiPedia：the system Load is a measure of the amount of work that a compute system is doing）简单的说是进程队列的长度。Load Average 就是一段时间（1 分钟、5 分钟、15 分钟）内平均 Load。</p><h2 id="分析工具-4"><a href="#分析工具-4" class="headerlink" title="分析工具"></a>分析工具</h2><table><thead><tr><th>工具</th><th>描述</th></tr></thead><tbody><tr><td>top</td><td>查看系统负载情况</td></tr><tr><td>uptime</td><td>查看系统负载情况</td></tr><tr><td>strace</td><td>统计跟踪内核态信息</td></tr><tr><td>vmstat</td><td>查看负载情况</td></tr><tr><td>dmesg</td><td>查看内核日志信息</td></tr></tbody></table><h2 id="使用方式-4"><a href="#使用方式-4" class="headerlink" title="使用方式"></a>使用方式</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//查看负载情况</span><br><span class="line"><span class="built_in">uptime</span></span><br><span class="line"></span><br><span class="line">top</span><br><span class="line"></span><br><span class="line">vmstat</span><br><span class="line"></span><br><span class="line">//统计系统调用耗时情况</span><br><span class="line">strace -c -p pid</span><br><span class="line"></span><br><span class="line">//跟踪指定的系统操作例如 epoll_wait</span><br><span class="line">strace -T -e epoll_wait -p pid</span><br><span class="line"></span><br><span class="line">//查看内核日志信息</span><br><span class="line">dmesg</span><br></pre></td></tr></table></figure><h1 id="火焰图"><a href="#火焰图" class="headerlink" title="火焰图"></a>火焰图</h1><h2 id="说明-6"><a href="#说明-6" class="headerlink" title="说明"></a>说明</h2><p><a href="https://www.brendangregg.com/flamegraphs.html">火焰图（Flame Graph)</a> 是 Bredan Gregg 创建的一种性能分析图表，因为它的样子近似 ?而得名。</p><p>火焰图主要是用来展示 CPU 的调用栈。</p><p>Y 轴表示调用栈，每一层都是一个函数。调用栈越深，火焰就越高，顶部就是正在执行的函数，下方都是它的父函数。</p><p>X 轴表示抽样数，如果一个函数在 x 轴占据的宽度越宽，就表示它被抽到的次数多，即执行的时间长。注意，x 轴不代表时间，而是所有的调用栈合并后，按字母顺序排列的。</p><p>火焰图就是看顶层的哪个函数占据的宽度最大。只要有 “ 平顶 “（plateaus），就表示该函数可能存在性能问题。颜色没有特殊含义，因为火焰图表示的是 CPU 的繁忙程度，所以一般选择暖色调。</p><p>常见的火焰图类型有 <a href="https://www.brendangregg.com/FlameGraphs/cpuflamegraphs.html">On-CPU</a>、<a href="https://www.brendangregg.com/FlameGraphs/offcpuflamegraphs.html">Off-CPU</a>、<a href="https://www.brendangregg.com/FlameGraphs/memoryflamegraphs.html">Memory</a>、<a href="https://www.brendangregg.com/FlameGraphs/hotcoldflamegraphs.html">Hot&#x2F;Cold</a>、<a href="https://www.brendangregg.com/blog/2014-11-09/differential-flame-graphs.html">Differential</a> 等等。</p><h2 id="安装依赖库"><a href="#安装依赖库" class="headerlink" title="安装依赖库"></a>安装依赖库</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//安装 systemtap，默认系统已安装</span><br><span class="line">yum install systemtap systemtap-runtime</span><br><span class="line"></span><br><span class="line">//内核调试库必须跟内核版本对应，例如：uname -r -el5</span><br><span class="line">kernel-debuginfo--elx86_rpm</span><br><span class="line">kernel-devel--elx86_rpm</span><br><span class="line">kernel-debuginfo-common--elx86_rpm</span><br><span class="line"></span><br><span class="line">//安装内核调试库</span><br><span class="line">debuginfo-install --enablerepo=debuginfo search kernel</span><br><span class="line">debuginfo-install --enablerepo=debuginfo search glibc</span><br></pre></td></tr></table></figure><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/lidaohang/quick_location.git</span><br><span class="line">cd quick_location</span><br></pre></td></tr></table></figure><h2 id="CPU-级别火焰图"><a href="#CPU-级别火焰图" class="headerlink" title="CPU 级别火焰图"></a>CPU 级别火焰图</h2><p>Cpu 占用过高，或者使用率提不上来，你能快速定位到代码的哪块有问题吗？<br>一般的做法可能就是通过日志等方式去确定问题。现在我们有了火焰图，能够非常清晰的发现哪个函数占用 cpu 过高，或者过低导致的问题。</p><h3 id="on-CPU"><a href="#on-CPU" class="headerlink" title="on-CPU"></a>on-CPU</h3><p>Cpu 占用过高，执行中的时间通常又分为用户态时间 user 和系统态时间 sys。</p><p><strong>使用方式：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">//on-CPU user</span><br><span class="line">sh ngx_on_cpu_u.sh pid</span><br><span class="line"></span><br><span class="line">//进入结果目录</span><br><span class="line">cd ngx_on_cpu_u</span><br><span class="line"></span><br><span class="line">//on-CPU kernel</span><br><span class="line">sh ngx_on_cpu_k.sh pid</span><br><span class="line"></span><br><span class="line">//进入结果目录</span><br><span class="line">cd ngx_on_cpu_k</span><br><span class="line"></span><br><span class="line">//开一个临时端口 8088</span><br><span class="line">python -m S![](../../../img/blog/0db5ae7b2be5b744645e650605a0bdfd_MD5.webp)*</span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">void foo3()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void foo2()</span><br><span class="line">&#123;</span><br><span class="line">int i;</span><br><span class="line">for(i = 0 ; i &lt; 10; i++)</span><br><span class="line">foo3();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void foo1()</span><br><span class="line">&#123;</span><br><span class="line">int i;</span><br><span class="line">for(i = 0; i&lt; 1000; i++)</span><br><span class="line">foo3();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">int i;</span><br><span class="line">for( i = 0; i&lt; 1000000000; i++) &#123;</span><br><span class="line">foo1();</span><br><span class="line">foo2();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>DEMO 火焰图：</strong></p><p><img src="/../../../img/blog/1847661e7b1ce43a10ced20533589299_MD5.webp">)</p><h3 id="off-CPU"><a href="#off-CPU" class="headerlink" title="off-CPU"></a>off-CPU</h3><p>Cpu 过低，利用率不高。等待下一轮 CPU，或者等待 I&#x2F;O、锁、换页等等，其状态可以细分为可执行、匿名换页、睡眠、锁、空闲等状态。</p><p><strong>使用方式：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// off-CPU user</span><br><span class="line">sh ngx_off_cpu_u.sh pid</span><br><span class="line"></span><br><span class="line">//进入结果目录</span><br><span class="line">cd ngx_off_cpu_u</span><br><span class="line"></span><br><span class="line">//off-CPU kernel</span><br><span class="line">sh ngx_off_cpu_k.sh pid</span><br><span class="line"></span><br><span class="line">//进入结果目录</span><br><span class="line">cd ngx_off_cpu_k</span><br><span class="line"></span><br><span class="line">//开一![](../../../img/blog/61e14eb78118d023a9cf2de50357628b_MD5.webp)id.svg</span><br></pre></td></tr></table></figure><p><strong>官网 DEMO：</strong></p><p><img src="/../../../../img/blog/1847661e7b1ce43a10ced20533589299_MD5.webp"></p><h2 id="内存级别火焰图"><a href="#内存级别火焰图" class="headerlink" title="内存级别火焰图"></a>内存级别火焰图</h2><p>如果线上程序出现了内存泄漏，并且只在特定的场景才会出现。这个时候我们怎么办呢？有什么好的方式和工具能快速的发现代码的问题呢？同样内存级别火焰图帮你快速分析问题的根源。</p><p><strong>使用方式：</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">sh ngx_on_memory.sh pid</span><br><span class="line"></span><br><span class="line">//进入结果目录</span><br><span class="line"><span class="built_in">cd</span> ngx_on_memory</span><br><span class="line"></span><br><span class="line">//开一个临时端口 8088</span><br><span class="line">python -m SimpleHTTPServer 8088</span><br><span class="line"></span><br><span class="line">//打开浏览器输入地址</span><br><span class="line">:8088/pid.svg​</span><br></pre></td></tr></table></figure><p><strong>官网 DEMO：</strong></p><p><img src="/../../../../img/blog/61e14eb78118d023a9cf2de50357628b_MD5.webp"></p><h2 id="性能回退-红蓝差分火焰图"><a href="#性能回退-红蓝差分火焰图" class="headerlink" title="性能回退 - 红蓝差分火焰图"></a>性能回退 - 红蓝差分火焰图</h2><p>你能快速定位 CPU 性能回退的问题么？ 如果你的工作环境非常复杂且变化快速，那么使用现有的工具是来定位这类问题是很具有挑战性的。当你花掉数周时间把根因找到时，代码已经又变更了好几轮，新的性能问题又冒了出来。主要可以用到每次构建中，每次上线做对比看，如果损失严重可以立马解决修复。</p><p>通过抓取了两张普通的火焰图，然后进行对比，并对差异部分进行标色：红色表示上升，蓝色表示下降。差分火焰图是以当前（” 修改后 “）的 profile 文件作为基准，形状和大小都保持不变。因此你通过色彩的差异就能够很直观的找到差异部分，且可以看出为什么会有这样的差异。</p><p><strong>使用方式：</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> quick_location</span><br><span class="line"></span><br><span class="line">//抓取代码修改前的 profile 1 文件</span><br><span class="line">perf record -F 99 -p pid -g -- <span class="built_in">sleep</span> 30</span><br><span class="line">perf script &gt; out.stacks1</span><br><span class="line"></span><br><span class="line">//抓取代码修改后的 profile 2 文件</span><br><span class="line">perf record -F 99 -p pid -g -- <span class="built_in">sleep</span> 30</span><br><span class="line">perf script &gt; out.stacks2</span><br><span class="line"></span><br><span class="line">//生成差分火焰图:</span><br><span class="line">./FlameGraph/stackcollapse-perf.pl ../out.stacks1 &gt; out.folded1</span><br><span class="line">./FlameGraph/stackcollapse-perf.pl ../out.stacks2 &gt; out.folded2</span><br><span class="line">./FlameGraph/difffolded.pl out.folded1 out.folded2 | ./FlameGraph/flamegraph.pl &gt; diffsvg</span><br></pre></td></tr></table></figure><p><strong>DEMO：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//test.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">foo3</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">foo2</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span> ; i &lt; <span class="number">10</span>; i++)</span><br><span class="line"> foo3();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">foo1</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="keyword">for</span>(i =![](../../../img/blog/bf06907f78595c4750246de4e8e3cb8a_MD5.webp)r( i =<span class="number">0</span>; i&lt; <span class="number">1000000000</span>; i++) &#123;</span><br><span class="line">foo1();</span><br><span class="line">foo2();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//testc</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">foo3</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;![](../../../img/blog/ad5f454ed494b6d666e26cf4489af096_MD5.webp)&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">foo1</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i&lt; <span class="number">1000</span>; i++)</span><br><span class="line"> foo3()![](../../../img/blog/<span class="number">5</span>a83253e3d1469a026b9f5b0bc3ee13a_MD5.webp)();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="keyword">for</span>( i =<span class="number">0</span>; i&lt; <span class="number">1000000000</span>; i++) &#123;</span><br><span class="line">foo1();</span><br><span class="line">foo2();</span><br><span class="line">add![](../../../img/blog/<span class="number">5692748f</span>c8695ef575f5bda7306abe55_MD5.webp)<span class="number">06907f</span>78595c4750246de4e8e3cb8a_MD5.webp)</span><br><span class="line"></span><br><span class="line"># 案例分析</span><br><span class="line"></span><br><span class="line">## 接入层 Nginx 集群异常现象</span><br><span class="line"></span><br><span class="line">通过监控插件发现在 <span class="number">19</span> 点 nginx 集群请求流量出现大量的 <span class="number">499</span>，<span class="number">5</span> xx 状态码。并且发现机器 cpu 使用率![](../../../img/blog/ac3f5d8648d96f5e53a03c19f23b6ece_MD5.webp)../../../img/blog/ad5f454ed494b6d666e26cf4489af096_MD5.webp)</span><br><span class="line"></span><br><span class="line">**结论：**</span><br><span class="line"></span><br><span class="line">通过上图发现流量并![](../../../img/blog/<span class="number">540</span>aa5753a370a6d76cb4564700ef178_MD5.webp)mg/blog/<span class="number">5</span>a83253e3d1469a026b9f5b0bc3ee13a_MD5.webp)</span><br><span class="line"></span><br><span class="line">**结论：**</span><br><span class="line"></span><br><span class="line">通过上图发现 nginx 的响应时间有增加可能跟 nginx 自身有关系或者跟后端 upstream 响应时间有关系。</span><br><span class="line"></span><br><span class="line">**c) 分析 nginx upstream 响应时间**</span><br><span class="line"></span><br><span class="line">![](../../../../img/blog/<span class="number">5692748f</span>c8695ef575f5bda7306abe55_MD5.webp)</span><br><span class="line">![](../../../img/blog/<span class="number">949</span>a77099ee3127f2f2c7ea43ce1b3d2_MD5.webp)住 nginx，导致 nginx 出现请求流量异常。</span><br><span class="line"></span><br><span class="line">## 分析系统 Cpu 情况</span><br><span class="line"></span><br><span class="line">**a) 通过 top 观察系统指标**</span><br><span class="line"></span><br><span class="line">`Top`</span><br><span class="line"></span><br><span class="line">![](../../../../img/blog/ac3f5d8648d96f5e53a03c19f23b6ece_MD5.webp)</span><br><span class="line"></span><br><span class="line">**结论：**</span><br><span class="line"></span><br><span class="line">发现 nginx worker cpu 比较高</span><br><span class="line"></span><br><span class="line">**b) 分析 nginx 进程内部 cpu 情况**</span><br><span class="line"></span><br><span class="line">`Perf top -p pid`</span><br><span class="line"></span><br><span class="line">![](../../../../img/blog/<span class="number">540</span>aa5753a370a6d76cb4564700ef178_MD5.webp)</span><br><span class="line"></span><br><span class="line">**结论：**</span><br><span class="line"></span><br><span class="line">发现主要开销在 <span class="built_in">free</span>, <span class="built_in">malloc</span>, json 解析上面</span><br><span class="line"></span><br><span class="line">## 火焰图分析 Cpu</span><br><span class="line"></span><br><span class="line">**a) 生成用户态 cpu 火焰图**</span><br><span class="line"></span><br><span class="line">```sh</span><br><span class="line"><span class="comment">//on-CPU user</span></span><br><span class="line">sh ngx_on_cpu_u.sh pid</span><br><span class="line"></span><br><span class="line"><span class="comment">//进入结果目录</span></span><br><span class="line">cd ngx_on_cpu_u</span><br><span class="line"></span><br><span class="line"><span class="comment">//开一个临时端口 8088</span></span><br><span class="line">python -m SimpleHTTPServer <span class="number">8088</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//打开浏览器输入地址</span></span><br><span class="line">:<span class="number">8088</span>/pid.svg</span><br></pre></td></tr></table></figure><p><img src="/../../../../img/blog/949a77099ee3127f2f2c7ea43ce1b3d2_MD5.webp"></p><p><strong>结论：</strong></p><p>发现代码里面有频繁的解析 json 操作，并且发现这个 json 库性能不高，占用 cpu 挺高。</p><h2 id="案例总结"><a href="#案例总结" class="headerlink" title="案例总结"></a>案例总结</h2><p>**a) ** 分析请求流量异常，得出 nginx upstream 后端机器响应时间拉长</p><p>**b) **分析 nginx 进程 cpu 高，得出 nginx 内部模块代码有耗时的 json 解析以及内存分配回收操作</p><h3 id="深入分析"><a href="#深入分析" class="headerlink" title="深入分析"></a>深入分析</h3><p>根据以上两点问题分析的结论，我们进一步深入分析。</p><p>后端 upstream 响应拉长，最多可能影响 nginx 的处理能力。但是不可能会影响 nginx 内部模块占用过多的 cpu 操作。并且当时占用 cpu 高的模块，是在请求的时候才会走的逻辑。不太可能是 upstram 后端拖住 nginx，从而触发这个 cpu 的耗时操作。</p><h3 id="解决方式"><a href="#解决方式" class="headerlink" title="解决方式"></a>解决方式</h3><p>遇到这种问题，我们优先解决已知的，并且非常明确的问题。那就是 cpu 高的问题。解决方式先降级关闭占用 cpu 过高的模块，然后进行观察。经过降级关闭该模块 cpu 降下来了，并且 nginx 请求流量也正常了。之所以会影响 upstream 时间拉长，因为 upstream 后端的服务调用的接口可能是个环路再次走回到 nginx。</p><h1 id="参考仓库"><a href="#参考仓库" class="headerlink" title="参考仓库"></a>参考仓库</h1><ul><li><a href="https://links.jianshu.com/go?to=https://github.com/openresty/openresty-systemtap-toolkit">https://github.com/openresty/openresty-systemtap-toolkit</a></li><li><a href="https://links.jianshu.com/go?to=https://github.com/brendangregg/FlameGraph">https://github.com/brendangregg/FlameGraph</a></li><li><a href="https://github.com/openresty/stapxx">openresty&#x2F;stapxx: Simple macro language extentions to systemtap (github.com)</a></li></ul><h1 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h1><p><a href="https://www.jianshu.com/p/0bbac570fa4c">接入层问题故障定位 - 简书 (jianshu.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> 系统 </category>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Git常用命令和介绍</title>
      <link href="/posts/%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7/Git/Git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%92%8C%E4%BB%8B%E7%BB%8D.html"/>
      <url>/posts/%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7/Git/Git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%92%8C%E4%BB%8B%E7%BB%8D.html</url>
      
        <content type="html"><![CDATA[<h1 id="一、Git-介绍"><a href="#一、Git-介绍" class="headerlink" title="一、Git 介绍"></a>一、Git 介绍</h1><h2 id="1-1、Git-的作用"><a href="#1-1、Git-的作用" class="headerlink" title="1.1、Git 的作用"></a>1.1、Git 的作用</h2><p>Git 是一个开源的分布式版本控制系统，用于管理一个或多个文件的整个历史记录。它有助于跟踪文件的变化，同时让多个开发者对同一个文件做出更改，并帮助开发者们在不同时间点进行历史查阅和版本比较。</p><h2 id="1-2、Git-的理念"><a href="#1-2、Git-的理念" class="headerlink" title="1.2、Git 的理念"></a>1.2、Git 的理念</h2><p>Git 拥有一个独特的理念，即分布式版本控制系统。它采用客户端 - 服务器模式，将文件、数据和代码以分布式仓库的形式保存在不同的服务器上，以便用户进行版本控制、代码管理和共享。Git 的分布式版本控制系统可以更快地处理版本控制任务，比传统的集中式版本控制系统更安全、更可靠、更高效。</p><h2 id="1-3、Git-的特点"><a href="#1-3、Git-的特点" class="headerlink" title="1.3、Git 的特点"></a>1.3、Git 的特点</h2><ol><li><p>分布式：每个开发者都拥有完整的代码库，可以离线工作，不需要依赖中央服务器。</p></li><li><p>非线性开发：可以创建多个分支，并行开发多个功能，通过合并分支进行代码整合。</p></li><li><p>高效性：Git 的设计可以快速地进行代码比较和合并，使得开发者可以快速迭代。</p></li><li><p>安全性：Git 使用 SHA-1 散列值来保证代码的完整性，具有防篡改的能力。</p></li><li><p>易于学习和使用：Git 的命令行操作简单，且有大量的可视化工具和第三方工具支持。</p></li><li><p>开放源代码：Git 是自由软件，任何人都可以自由地使用、修改和分发它。</p></li><li><p>大规模协作：Git 可以支持上千人同时协作开发同一项目，通过不同分支的合并和冲突解决保证项目的稳定性和质量。</p></li></ol><h1 id="二、Git-的概念"><a href="#二、Git-的概念" class="headerlink" title="二、Git 的概念"></a>二、Git 的概念</h1><p>想要使用 Git 需要先掌握 Git 的一些基础概念，更好地理解 Git。</p><ol><li><p>仓库（Repository）：仓库是 Git 中最重要的概念之一，它是用来存储项目代码的地方。所有的修改记录都保存在仓库中，包括提交的代码历史、分支信息、标签等。当我们将修改记录提交到仓库后，它们就会成为代码的一部分。</p></li><li><p>提交（Commit）：Git 中的提交是指将文件或代码变更记录下来，并且提交一个说明（commit message）。</p></li><li><p>分支（Branch）：Git 中的分支是指代码版本的不同分支。可以创建新的分支来尝试新的代码，而不会影响到主分支。</p></li><li><p>合并（Merge）：Git 中的合并是指将一个分支中的代码合并到另一个分支中。</p></li><li><p>拉取（Pull）：Git 中的拉取是指将远程仓库中的代码更新到本地仓库中。</p></li><li><p>推送（Push）：Git 中的推送是指将本地仓库中的代码更新到远程仓库中。</p></li><li><p>标签（Tag）：Git 中的标签是指给某一个特定的提交打上一个标签，用于区分这个提交与其他提交的不同。</p></li><li><p>工作区（Working Directory）：工作区是指项目代码所在的目录，也就是我们平时编辑和修改代码的地方，在工作区中，我们可以创建、修改和删除文件等。</p></li><li><p>暂存区（Staging Area）：暂存区是介于工作区和仓库之间的一个缓冲区域。在提交代码之前，我们需要将修改过的文件添加到暂存区中。暂存区中保存了待提交的修改记录，包括哪些文件被修改了，修改了哪些部分，但还没有真正提交到仓库。</p></li></ol><p>可以用下面的图来更好地理解这三个概念之间的关系：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> git add              git commit  </span><br><span class="line">工作区 --------------&gt; 暂存区 --------------&gt; 仓库</span><br></pre></td></tr></table></figure><p>简单来说，我们在工作区中修改代码后，通过 <code>git add</code> 命令将修改的文件添加到暂存区，然后通过 <code>git commit</code> 命令将暂存区中的修改记录提交到仓库中。在提交之前，我们可以通过 <code>git status</code> 命令来查看工作区和暂存区的状态，以及哪些文件被修改过、添加到了暂存区等信息。</p><h1 id="三、Git-的基本操作"><a href="#三、Git-的基本操作" class="headerlink" title="三、Git 的基本操作"></a>三、Git 的基本操作</h1><h2 id="3-1、使用-Git-管理一个代码仓库的流程"><a href="#3-1、使用-Git-管理一个代码仓库的流程" class="headerlink" title="3.1、使用 Git 管理一个代码仓库的流程"></a>3.1、使用 Git 管理一个代码仓库的流程</h2><ol><li><p>初始化仓库：使用 <code>git init</code> 命令在本地创建一个新的 Git 仓库。</p></li><li><p>添加文件：将项目文件添加到仓库中，使用 <code>git add</code> 命令将修改后的文件添加到 Git 的暂存区中。</p></li><li><p>提交代码：使用 <code>git commit</code> 命令提交修改记录到 Git 仓库中。每次提交需要添加一条注释，简要描述修改了哪些内容。</p></li><li><p>创建分支：使用 <code>git branch</code> 命令创建一个新的分支，并切换到该分支。这个分支可以用于开发新的功能或修复错误，不会影响主分支（通常为 <code>master</code>）的代码。</p></li><li><p>合并分支：在开发新功能或修复错误后，需要将分支合并到主分支上，使用 <code>git merge</code> 命令将分支合并到主分支上。</p></li><li><p>拉取代码：在多人协作开发中，需要将远程仓库中的代码拉取到本地进行开发。使用 <code>git pull</code> 命令将远程仓库中的代码更新到本地仓库中。</p></li><li><p>推送代码：在完成开发并且测试通过后，需要将修改的代码推送到远程仓库中。使用 <code>git push</code> 命令将本地仓库中的代码更新到远程仓库中。</p></li><li><p>标记版本：当完成一个里程碑或者发布一个版本时，可以使用 <code>git tag</code> 命令创建一个新的标签，用于标记当前的版本号。</p></li></ol><h2 id="3-2、Git-常用命令介绍"><a href="#3-2、Git-常用命令介绍" class="headerlink" title="3.2、Git 常用命令介绍"></a>3.2、Git 常用命令介绍</h2><p>Git 是一个强大的版本控制工具，提供了众多命令来管理代码仓库，以下是一些常用的 Git 命令介绍：</p><ol><li><p><code>git init</code>：初始化一个新的 Git 仓库。</p></li><li><p><code>git add</code>：将文件或目录添加到 Git 的暂存区中。</p></li><li><p><code>git commit</code>：将暂存区的修改记录提交到 Git 仓库中。</p></li><li><p><code>git clone</code>：从远程 Git 仓库中克隆一个副本到本地。</p></li><li><p><code>git status</code>：查看当前 Git 仓库的状态，包括哪些文件被修改过、添加到了暂存区等信息。</p></li><li><p><code>git log</code>：查看 Git 仓库中的提交历史记录，包括每个提交的作者、时间、注释等信息。</p></li><li><p><code>git branch</code>：查看 Git 仓库中的分支信息，并可以创建、删除、重命名等操作。</p></li><li><p><code>git merge</code>：将一个分支的修改合并到当前分支中。</p></li><li><p><code>git pull</code>：从远程 Git 仓库中拉取最新的代码到本地仓库中。</p></li><li><p><code>git push</code>：将本地 Git 仓库中的修改推送到远程 Git 仓库中。</p></li><li><p><code>git checkout</code>：切换到指定分支或提交。</p></li><li><p><code>git tag</code>：为当前的提交打上一个标签，用于标识当前版本。</p></li><li><p><code>git remote</code>：管理与远程仓库的连接，可以添加、删除、重命名等操作。</p></li><li><p><code>git diff</code>：查看当前修改和之前提交的版本之间的差异。</p></li></ol><p>这些命令只是 Git 提供的众多命令中的一部分，可以根据具体需求进行选择和使用。同时，可以通过 <code>git --help</code> 命令查看 Git 的帮助文档，以获得更多的信息和帮助。</p><h1 id="四、Git-状态的变化"><a href="#四、Git-状态的变化" class="headerlink" title="四、Git 状态的变化"></a>四、Git 状态的变化</h1><p>在 Git 中，有三个主要的概念：工作区、暂存区和仓库。它们分别代表了不同的状态，可以通过 Git 命令进行变化。</p><ol><li><p>工作区（Working Directory）：指的是你在本地电脑上实际修改的文件。当你修改了文件，但没有执行 Git 命令时，这些文件的状态就是 “ 未跟踪 “ 或 “ 已修改 “。</p></li><li><p>暂存区（Staging Area）：也称为索引（Index），是一个临时的存储区域，用于存储即将被提交到 Git 仓库的文件。当你执行 <code>git add</code> 命令时，修改的文件会被添加到暂存区，此时这些文件的状态为 “ 已暂存 “。</p></li><li><p>仓库（Repository）：也称为版本库，是 Git 用来存储历史提交记录的地方。当你执行 <code>git commit</code> 命令时，暂存区中的文件会被提交到仓库中，此时这些文件的状态为 “ 已提交 “。</p></li></ol><p>下面是这些状态如何相互转换的说明：</p><ul><li>将修改的文件添加到暂存区：<code>git add</code>，此时文件的状态由 “ 未跟踪 “ 或 “ 已修改 “ 变为 “ 已暂存 “；</li><li>将暂存区的文件提交到仓库：<code>git commit -m &quot;commit message&quot;</code>，此时文件的状态由 “ 已暂存 “ 变为 “ 已提交 “；</li><li>查看文件状态：<code>git status</code>，此命令可以查看工作区、暂存区和仓库中文件的状态；</li><li>撤销暂存区的修改：<code>git reset</code>，此命令可以将暂存区的文件恢复为未暂存的状态；</li><li>撤销工作区的修改：<code>git checkout --</code>，此命令可以将工作区的文件恢复到上次提交的状态；</li><li>恢复仓库中的文件：<code>git checkout</code>，此命令可以将指定提交中的文件恢复到当前分支上。</li></ul><p>需要注意的是，上述命令在执行时需要指定对应的文件或提交。同时，这些命令还有更多的选项和参数可以使用，可以通过 <code>git help</code> 命令来查看 Git 的文档。</p><h1 id="五、Git-安装和配置"><a href="#五、Git-安装和配置" class="headerlink" title="五、Git 安装和配置"></a>五、Git 安装和配置</h1><h2 id="5-1、Git-的安装"><a href="#5-1、Git-的安装" class="headerlink" title="5.1、Git 的安装"></a>5.1、Git 的安装</h2><p><a href="https://www.runoob.com/git/git-install-setup.html">Git 安装配置 | 菜鸟教程 (runoob.com)</a></p><h2 id="5-2、Git-的配置"><a href="#5-2、Git-的配置" class="headerlink" title="5.2、Git 的配置"></a>5.2、Git 的配置</h2><p>git 提供了 <code>git config</code> 命令用于配置或读取相应的工作环境变量,其主要配置文件分为三层，从上到下分别是：</p><ul><li><code>/etc/gitconfig</code> 文件：系统中对所有用户都普遍适用的配置。若使用 <code>git config</code> 时用 <code>--system</code> 选项，读写的就是这个文件。</li><li><code>~/.gitconfig</code> 文件：用户目录下的配置文件只适用于该用户。若使用 <code>git config</code> 时用 <code>--global</code> 选项，读写的就是这个文件。</li><li><code>.git/config</code> 文件：仅针对当前项目有效，<code>.git/config</code> 里的配置会覆盖 <code>/etc/gitconfig</code> 中的同名变量。</li></ul><p>最重要的配置就是配置用户名和电子邮件，使用以下命令即可：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.name <span class="string">&quot;lucas&quot;</span></span><br><span class="line">$ git config --global user.email lucas@foxmail.com</span><br></pre></td></tr></table></figure><p>如果想要查看已有配置信息，可以使用以下命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git config --list</span><br></pre></td></tr></table></figure><h1 id="六、Git-的高级操作"><a href="#六、Git-的高级操作" class="headerlink" title="六、Git 的高级操作"></a>六、Git 的高级操作</h1><h2 id="6-1、-gitignore-文件的使用"><a href="#6-1、-gitignore-文件的使用" class="headerlink" title="6.1、.gitignore 文件的使用"></a>6.1、.gitignore 文件的使用</h2><p>在使用 Git 管理代码仓库时，有些文件或目录不应该被 Git 进行版本控制，例如编译输出文件、日志文件等。这时可以使用 <code>.gitignore</code> 文件来告诉 Git 忽略这些文件或目录。</p><p><code>.gitignore</code> 文件是一个文本文件，列出了 Git 应该忽略的文件或目录的规则。每一行规则都是一个模式，可以包含通配符、反斜线等符号，表示需要忽略的文件或目录的名称或路径。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 忽略所有 .txt 文件</span><br><span class="line">*.txt</span><br><span class="line"></span><br><span class="line"># 忽略 build 目录及其下的所有内容</span><br><span class="line">/build/</span><br><span class="line"></span><br><span class="line"># 忽略指定的文件</span><br><span class="line">example.log</span><br></pre></td></tr></table></figure><p>在上述例子中，第一行规则使用了通配符 <code>*</code> 来匹配所有 <code>.txt</code> 结尾的文件；第二行规则使用了反斜线 <code>/</code> 来指定需要忽略的目录 <code>build</code>，并在末尾加上了斜线 <code>/</code> 来表示忽略该目录下的所有内容；第三行规则指定了需要忽略的文件名 <code>example.log</code>。</p><p><code>.gitignore</code> 文件可以放置在代码仓库的任何级别上，从仓库根目录到任意子目录都可以。一般建议将其放置在代码仓库的根目录下，以便更方便地管理和维护。</p><p>需要注意的是，如果在 <code>.gitignore</code> 文件中忽略了某个文件或目录，那么 Git 将不会对其进行版本控制，也不会将其包含在提交中，因此需要确保 <code>.gitignore</code> 文件中的规则正确地列出了需要忽略的文件或目录。</p><h2 id="6-2、git-Diff-的使用"><a href="#6-2、git-Diff-的使用" class="headerlink" title="6.2、git Diff 的使用"></a>6.2、git Diff 的使用</h2><p><code>git diff</code> 是一个常用的 Git 命令，用于比较 Git 仓库中的不同版本之间的差异。它可以用于比较两个提交之间的差异，或比较工作目录中的文件与暂存区或最新提交之间的差异。</p><p>下面是 <code>git diff</code> 命令的一些常见用法：</p><ul><li>比较工作目录中的文件与最新提交之间的差异：</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff</span><br></pre></td></tr></table></figure><ul><li>比较工作目录中的文件与暂存区之间的差异：</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff --cached</span><br></pre></td></tr></table></figure><ul><li>比较两个提交之间的差异：</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff &lt;commit1&gt; &lt;commit2&gt;</span><br></pre></td></tr></table></figure><p>其中 <code>&lt;commit1&gt;</code> 和 <code>&lt;commit2&gt;</code> 分别是要比较的两个提交的 SHA-1 标识符，可以使用提交的短标识符或分支名代替。</p><ul><li>比较指定文件或目录的差异：</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff &lt;commit1&gt; &lt;commit2&gt; &lt;file&gt;</span><br></pre></td></tr></table></figure><p>其中 <code>&lt;file&gt;</code> 可以是文件或目录的路径，可以只比较某个文件或目录的差异。</p><ul><li>比较两个分支之间的差异：</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff &lt;branch1&gt;..&lt;branch2&gt;</span><br></pre></td></tr></table></figure><p>其中 <code>&lt;branch1&gt;</code> 和 <code>&lt;branch2&gt;</code> 分别是要比较的两个分支的名称，可以使用分支的短名称或完整名称代替。</p><p>以上是 <code>git diff</code> 命令的一些常见用法，使用这些命令可以帮助开发者比较不同版本之间的差异，从而更好地管理代码仓库。</p><h2 id="6-3、git-如何处理代码冲突"><a href="#6-3、git-如何处理代码冲突" class="headerlink" title="6.3、git 如何处理代码冲突"></a>6.3、git 如何处理代码冲突</h2><p>在多人协作开发时，经常会出现代码冲突的情况。当两个或多个开发者同时修改同一个文件的同一部分时，就会发生冲突。Git 提供了一些命令和工具来帮助开发者处理代码冲突，下面是处理代码冲突的一般步骤：</p><h3 id="6-3-1、更新本地代码库"><a href="#6-3-1、更新本地代码库" class="headerlink" title="6.3.1、更新本地代码库"></a>6.3.1、更新本地代码库</h3><p>在处理代码冲突之前，需要先更新本地代码库。使用 <code>git pull</code> 命令从远程仓库获取最新的代码。</p><h3 id="6-3-2、查找冲突"><a href="#6-3-2、查找冲突" class="headerlink" title="6.3.2、查找冲突"></a>6.3.2、查找冲突</h3><p>在更新代码库之后，如果有冲突，使用 <code>git status</code> 命令查看冲突文件的状态，冲突文件的状态为 <code>both modified</code>。</p><h3 id="6-3-3、手动解决冲突"><a href="#6-3-3、手动解决冲突" class="headerlink" title="6.3.3、手动解决冲突"></a>6.3.3、手动解决冲突</h3><p>手动编辑冲突文件，将冲突部分保留下来，删除其他部分。可以使用编辑器或其他工具来帮助解决冲突。</p><h3 id="6-3-4、添加解决后的文件"><a href="#6-3-4、添加解决后的文件" class="headerlink" title="6.3.4、添加解决后的文件"></a>6.3.4、添加解决后的文件</h3><p>在解决冲突之后，使用 <code>git add</code> 命令将解决后的文件添加到暂存区。</p><h3 id="6-3-5、提交解决后的文件"><a href="#6-3-5、提交解决后的文件" class="headerlink" title="6.3.5、提交解决后的文件"></a>6.3.5、提交解决后的文件</h3><p>在将解决后的文件添加到暂存区后，使用 <code>git commit</code> 命令提交修改。</p><p>如果在解决冲突的过程中遇到问题或错误，可以使用 <code>git merge --abort</code> 命令取消合并操作，返回到合并前的状态。</p><p>需要注意的是，在多人协作开发时，最好避免同时修改同一个文件的同一部分，可以通过拆分任务、分工协作等方式来避免冲突的发生。此外，在处理冲突时，需要保持沟通和协作，及时解决问题。</p><h2 id="6-4、git-Merge-合并代码"><a href="#6-4、git-Merge-合并代码" class="headerlink" title="6.4、git Merge 合并代码"></a>6.4、git Merge 合并代码</h2><p>Git merge 是将两个或多个分支的代码合并到一个分支中的操作。在合并过程中，Git 会自动尝试将两个分支的代码进行比较和合并，以生成一个新的合并提交。</p><p>以下是使用 Git merge 合并代码的一些步骤：</p><ol><li><p>确保你已经切换到需要合并到的目标分支，例如 master 分支：<code>git checkout master</code></p></li><li><p>运行 merge 命令来将目标分支与要合并的分支进行合并：<code>git merge</code></p></li><li><p>Git 会尝试自动合并分支的代码。如果 Git 遇到了冲突，它会提示你手动解决冲突。你需要手动编辑有冲突的文件，以解决冲突。</p></li><li><p>如果合并成功，Git 会生成一个新的合并提交。在这个提交消息中，Git 会包含有关合并的信息，如何合并的分支等等。</p></li><li><p>最后，使用 <code>git push</code> 命令将合并的代码推送到远程仓库。</p></li></ol><p>注意：在进行合并操作之前，建议先从远程仓库获取最新的代码并将其合并到本地分支。这样可以避免不必要的冲突和合并问题。</p><h2 id="6-5、git-代码回退"><a href="#6-5、git-代码回退" class="headerlink" title="6.5、git 代码回退"></a>6.5、git 代码回退</h2><p>在 Git 中，可以使用多种方法回退代码，包括撤销工作区的修改、恢复指定版本的代码等。下面介绍一些常用的回退代码的方法：</p><ol><li><p>撤销工作区的修改：<code>git checkout --</code>，此命令可以将工作区的文件恢复到上次提交的状态。如果你已经使用 <code>git add</code> 将修改的文件添加到暂存区，但还没有提交，可以使用 <code>git reset HEAD</code> 来撤销暂存区的修改。</p></li><li><p>恢复指定版本的代码：<code>git checkout</code>，此命令可以将指定提交中的文件恢复到当前分支上。你可以使用 <code>git log</code> 命令来查看提交历史记录，并选择需要恢复的版本。如果你想恢复到某个历史提交的状态，可以使用 <code>git checkout</code> 命令，这将使得 HEAD 指向这个提交，并将工作区和暂存区都恢复到这个提交的状态。</p></li><li><p>回退提交：<code>git revert</code>，此命令可以创建一个新的提交，用于撤销指定提交的更改。该命令将会生成一个新的提交，包含了回退操作的更改，但是不会删除原始提交。如果你需要完全删除某个提交，可以使用 <code>git reset</code> 命令，但是需要注意，这将会删除该提交及其之后的提交，因此需要谨慎使用。</p></li></ol><p>需要注意的是，在使用 Git 回退代码时，需要注意不要将未提交的修改丢失，并且需要保留历史提交记录。如果你不确定该如何回退代码，可以先创建一个新的分支，进行实验，确保不会对主分支造成不可逆的影响。</p><h1 id="七、Git-的常用命令"><a href="#七、Git-的常用命令" class="headerlink" title="七、Git 的常用命令"></a>七、Git 的常用命令</h1><ol><li><p>Git checkout -b xxx：git checkout xxx 是指切换到 xxx 相当于复制了 remote 的仓库到本地的 xxx 分支上，-b 意味着 branch，即创建新分支，这条指令合起来意思是创建并切换到 xxx。</p></li><li><p>git diff 查看自己对代码做出的改变，也就是查看暂存区与 disk 区文件的差异。</p></li><li><p>git add xxx：将 xxx 文件添加到暂存区。</p></li><li><p>git commit：将暂存区内容添加到 local 区的当前分支中。</p></li><li><p>git push RemoteHostName LocalBranchName：将 local 区的 LocalBranchName 分支推送到 RemoteHostName 主机的同名分支。（若加 -f 表示无视本地与远程分支的差异强行 push）</p></li><li><p>git branch -d xxx 删除本地的 git 分支；git branch -D xxx：不加 -D 表示创建新 local 分支 xxx，加 -D 表示强制删除 local 分支 xxx。</p></li><li><p>git pull RemoteHostName RemoteBranchName：同上，不过改成从远程主机下载远程分支并与本地同名分支合并。</p></li><li><p>git rebase xxx：假设当前分支与 xxx 分支存在共同部分 common，该指令用 xxx 分支包括 common 在内的整体替换当前分支的 common 部分（原先 xxx 分支内容为 common-&gt;diversityA，当前分支内容为 common-&gt;diversityB，执行完该指令后当前分支内容为 common-&gt;diversityA-&gt;diversityB）。</p></li></ol><p>以下 5 条命令适用于在写自己的代码过程中发现远端 GitHub 上代码出现改变的情况，这个时候你可以按照下面这种方式来进行代码推送和合并。</p><ol><li><p>git checkout main 切换回 main 分支</p></li><li><p>git pull origin master(main) 将远端修改过的代码再更新到本地</p></li><li><p>git checkout xxx 回到 xxx 分支</p></li><li><p>git rebase main 我在 xxx 分支上，先把 main 移过来，然后根据我的 commit 来修改成新的内容（中途可能会出现，rebase conflict —–》手动选择保留哪段代码）</p></li><li><p>git push -f origin xxx 把 rebase 后并且更新过的代码再 push 到远端 github 上 （-f —》强行）</p></li></ol><h1 id="八、如何使用-Git-在-Github-上贡献代码"><a href="#八、如何使用-Git-在-Github-上贡献代码" class="headerlink" title="八、如何使用 Git 在 Github 上贡献代码"></a>八、如何使用 Git 在 Github 上贡献代码</h1><ol><li><p>在 GitHub 上创建一个账户并登录。</p></li><li><p>找到要贡献代码的项目，并在项目主页上点击 “Fork” 按钮，将项目复制到自己的账户下。</p></li><li><p>在自己的电脑上安装 Git 工具。</p></li><li><p>使用 Git 将项目克隆到本地计算机中。可以通过在命令行终端中使用以下命令来克隆项目：</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/你的用户名/项目名.git</span><br></pre></td></tr></table></figure><p>在本地修改代码，并使用以下命令将更改提交到本地 Git 仓库：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add .git commit -m &quot; 提交信息 &quot;</span><br></pre></td></tr></table></figure><p>其中，<code>git add .</code> 命令将所有修改添加到暂存区，<code>git commit</code> 命令将提交更改，并在提交信息中描述更改。</p><p>将本地更改推送到自己的 GitHub 账户中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin master</span><br></pre></td></tr></table></figure><p>这将把本地的更改推送到 GitHub 上。</p><ol><li><p>在自己的 GitHub 账户上打开一个 Pull Request (PR) 请求，请求将更改合并到原始项目中。在 GitHub 上点击 “New pull request” 按钮，填写 PR 请求的标题和描述，并选择要合并的分支。</p></li><li><p>等待原始项目的维护者审核并接受你的 PR 请求。如果需要进一步修改，原始项目的维护者可以在 PR 请求中提出评论和建议。</p></li><li><p>当 PR 请求被接受并合并到原始项目后，你的代码贡献就完成了。</p></li></ol><p>以上是在 GitHub 上贡献代码的基本步骤。在此过程中，你需要注意遵循项目的代码风格和贡献规范，避免与其他贡献者冲突，以便顺利地将你的代码贡献到项目中。</p><h1 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h1><p><a href="https://mp.weixin.qq.com/s/I4VIT0aj_WMiEbVfHhhqpA">我看还有谁不动Git (qq.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> 编程工具 </category>
          
          <category> Git </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Vim使用</title>
      <link href="/posts/%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7/Vim/Vim%E4%BD%BF%E7%94%A8.html"/>
      <url>/posts/%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7/Vim/Vim%E4%BD%BF%E7%94%A8.html</url>
      
        <content type="html"><![CDATA[<h1 id="Vim-编辑器"><a href="#Vim-编辑器" class="headerlink" title="Vim 编辑器"></a>Vim 编辑器</h1><h2 id="Vim-常用模式"><a href="#Vim-常用模式" class="headerlink" title="Vim 常用模式"></a>Vim 常用模式</h2><ul><li>交互模式</li><li>插入模式</li><li>命令模式</li><li>可视模式</li></ul><h3 id="插入模式"><a href="#插入模式" class="headerlink" title="插入模式"></a>插入模式</h3><p>这个模式是我们熟悉的文本编辑器的模式，就是可以输入任何你想输入的内容。进入这个模式有几种方法，最常用的方法是按字母键 <code>i</code> （ <code>i、I、a、A、o、O</code> 都可以进入插入模式，只是所处的位置不同），退出这种模式，只需要按下 <code>Esc</code> 键。</p><ul><li><code>i, I</code> 进入输入模式 <code>Insert mode</code> ：<code>i</code> 为 “ 从目前光标所在处输入 “， <code>I</code> 为 “ 在目前所在行的第一个非空格符处开始输入 “；</li><li><code>a, A</code> 进入输入模式 <code>Insert mode</code> ：<code>a</code> 为 “ 从目前光标所在的下一个字符处开始输入 “， <code>A</code> 为 “ 从光标所在行的最后一个字符处开始输入 “；</li><li><code>o, O</code> 进入输入模式 <code>Insert mode</code> ：<code>o</code> 为 “ 在目前光标所在的下一行处输入新的一行 “；<code>O</code> 为在目前光标所在处的上一行<img src="/../../../img/blog/540137844751841.jpg" alt="图片">mg&#x2F;blog&#x2F;540137844751841.jpg)</li></ul><h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><h3 id="跳至行首和行末"><a href="#跳至行首和行末" class="headerlink" title="跳至行首和行末"></a>跳至行首和行末</h3><ul><li>行首：在交互模式下，为了将光标定位到一行的开始位置，只需要按下数字键 <code>0</code> 即可，键盘上的 <code>Home</code> 键也有相同效果。</li><li>行末：在交互模式下，为了将光标定位到一行的末尾，只需要按下美元符号键 <code>$</code> 即可，键盘上的 <code>End</code> 键也有相同效果。</li></ul><h3 id="按单词移动"><a href="#按单词移动" class="headerlink" title="按单词移动"></a>按单词移动</h3><p>在交互模式下，按字母键 <code>w</code> 可以一个单词一个单词的移动。</p><h3 id="退出文件"><a href="#退出文件" class="headerlink" title="退出文件"></a>退出文件</h3><p>在交互模式下，按下冒号键 <code>:</code> 进入命令模式，再按下 <code>q</code> 键，就可以退出了。</p><p>如果在退出之前又修改了文件，就直接想用 <code>:q</code> 退出 <code>Vim</code> ，那么 <code>Vim</code> 会显示一个红字标明错误信息。此时我们有两个选择：</p><ol><li><p>保存并退出 <code>:wq</code> 或 <code>:x</code> ；</p></li><li><p>不保存且退出 <code>:q!</code> 。</p></li></ol><h2 id="标准操作"><a href="#标准操作" class="headerlink" title="标准操作"></a>标准操作</h2><h3 id="删除字符"><a href="#删除字符" class="headerlink" title="删除字符"></a>删除字符</h3><p>在交互模式下，将光标定位到一个你想要删除的字符上，按下字母键 <code>x</code> 你会发现这个字符被删除了。</p><p>也可以一次性删除多个字符，只需要在按 <code>x</code> 键之前输入数字即可。</p><h3 id="删除（剪切）单词，行"><a href="#删除（剪切）单词，行" class="headerlink" title="删除（剪切）单词，行"></a>删除（剪切）单词，行</h3><ul><li>删除一行：连按两次 <code>d</code> 来删除光标所在的那一行。</li><li>删除多行：例如先输入数字 <code>2</code> ，再按下 <code>dd</code> ，就会删除从光标所在行开始的两行。</li><li>删除一个单词：将光标置于一个单词的首字母处，然后按下 <code>dw</code> 。</li><li>删除多个单词：例如先按数字键 <code>2</code> 再按 <code>dw</code> 就可以删除两个单词了。</li><li>从光标所在位置删除至行首：<code>d0</code> 。</li><li>从光标所在位置删除至行末：<code>d$</code> 。</li></ul><h3 id="复制单词，行"><a href="#复制单词，行" class="headerlink" title="复制单词，行"></a>复制单词，行</h3><ul><li>复制行：按两次 <code>y</code> 会把光标所在行复制到内存中，和 <code>dd</code> 类似， <code>dd</code> 用于 “ 剪切 “ 光标所在行。</li><li>复制单词：<code>yw</code> 会复制一个单词。</li><li>复制到行末：<code>y$</code> 是复制从光标所在处到行末的所有字符。</li><li>复制到行首：<code>y0</code> 是复制光标所在处到行首的所有字符。</li></ul><h3 id="粘贴"><a href="#粘贴" class="headerlink" title="粘贴"></a>粘贴</h3><p>如果之前用 <code>dd</code> 或者 <code>yy</code> 剪切复制过来的，可以使用 <code>p</code> 来粘贴。同样也可以使用 <code>数字+p</code> 来表示复制多次。</p><h3 id="替换一个字符"><a href="#替换一个字符" class="headerlink" title="替换一个字符"></a>替换一个字符</h3><p>在交互模式下，将光标置于想要替换的字符上。按下 <code>r</code> 键，接着输入你要替换的字符即可。</p><h3 id="撤销操作"><a href="#撤销操作" class="headerlink" title="撤销操作"></a>撤销操作</h3><p>如果要撤销最近的修改，只需要按下 <code>u</code> 键，如果想要撤销最近四次修改，可以按下 4，再按下 <code>u</code> 。</p><h3 id="重做"><a href="#重做" class="headerlink" title="重做"></a>重做</h3><p>取消撤销，也就是重做之前的修改使用 <code>ctrl + r</code> 。</p><h3 id="跳转到指定行"><a href="#跳转到指定行" class="headerlink" title="跳转到指定行"></a>跳转到指定行</h3><p><code>Vim</code> 编辑的文件中，每一行都有一个行号，行号从 1 开始，逐一递增。</p><p>行号默认是不显示，如果需要它显示的话，可以进入命令模式，然后输入 <code>set nu</code> ，如果要隐藏行号的话，使用 <code>set nonu</code> 。</p><ul><li>跳转到指定行：<code>数字+gg</code> ，例如 <code>7gg</code> ，表示跳转到第 7 行。</li><li>要跳转到最后一行，按下 <code>G</code> 。</li><li>要跳转到第一行，按下 <code>gg</code> 。</li></ul><h2 id="高级操作"><a href="#高级操作" class="headerlink" title="高级操作"></a>高级操作</h2><h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><p>处于交互模式下，按下 <code>/</code> 键，那么就进入查找模式，输入你要查找的字符串，然后按下回车。光标就会跳转到文件中下一个查找到的匹配处。如果字符串不存在，那么会显示 <code>&quot;pattern not found&quot;</code> 。</p><ul><li><code>n</code> 跳转到下一个匹配项；</li><li><code>N</code> 跳转到上一个匹配项。</li></ul><p>[注意] 用斜杠来进行的查找是从当前光标处开始向文件尾搜索，如果你要从当前光标处开始，向文件头搜索则使用 <code>?</code> ，当然也可以先按下 <code>gg</code> 跳转到第一行在进行全文搜索。</p><h3 id="查找并替换"><a href="#查找并替换" class="headerlink" title="查找并替换"></a>查找并替换</h3><p>替换光标所在行第一个匹配的字符串：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 语法</span><br><span class="line">:s/旧字符串/新字符串</span><br><span class="line"></span><br><span class="line"># 实例</span><br><span class="line">:s/one/two</span><br></pre></td></tr></table></figure><p>替换光标所在行所有旧字符串为新字符串：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 语法</span><br><span class="line">:s/旧字符串/新字符串/g</span><br></pre></td></tr></table></figure><p>替换第几行到第几行中所有字符串：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 语法</span><br><span class="line">:n,m s/旧字符串/新字符串/g</span><br><span class="line"></span><br><span class="line"># 实例</span><br><span class="line">:2,4 s/one/two/g</span><br></pre></td></tr></table></figure><p>最常用的就是全文替换了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 语法</span><br><span class="line">:%s/旧字符串/新字符串/g</span><br></pre></td></tr></table></figure><h3 id="合并文件"><a href="#合并文件" class="headerlink" title="合并文件"></a>合并文件</h3><p>可以用冒号 <code>+r</code> ( <code>:r</code> ) 实现在光标处插入一个文件的内容。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:r filename # 可以用Tab键来自动补全另外一个文件的路径</span><br></pre></td></tr></table></figure><h3 id="分屏"><a href="#分屏" class="headerlink" title="分屏"></a>分屏</h3><p><code>Vim</code> 有一个特别便捷的功能那就是分屏，可以同时打开好几个文件，分屏之后，屏幕每一块被称为一个 <code>viewport</code> ，表示 “ 视口 “。</p><ul><li>横向分屏 <code>:sp 文件名</code></li><li>垂直分屏 <code>:vsp 文件名</code></li></ul><h4 id="分屏模式下的快捷键"><a href="#分屏模式下的快捷键" class="headerlink" title="分屏模式下的快捷键"></a>分屏模式下的快捷键</h4><ul><li><code>Ctrl + w</code> 再加 <code>Ctrl + w</code> ，表示从一个 <code>viewport</code> 移动光标到另外一个 <code>viewport</code> ；</li><li><code>Ctrl + w</code> 再加 “ 方向键 “，就可以移动到这个方向所处的下一个视口了；</li><li><code>Ctrl + w</code> 再加 <code>+</code> 号，表示扩大当前视口；</li><li><code>Ctrl + w</code> 再加 <code>-</code> 号，表示缩小当前视口；</li><li><code>Ctrl + w</code> 再加 <code>=</code> 号，表示平均当前视口；</li><li><code>Ctrl + w</code> 再加 <code>r</code> 键，会反向调换视口位置；</li><li><code>Ctrl + w</code> 再加 <code>q</code> 键，会关闭当前视口；</li><li><code>Ctrl + w</code> 再加 <code>o</code> 键，会关闭除当前视口以外的所有视口；</li></ul><h3 id="运行外部命令"><a href="#运行外部命令" class="headerlink" title="运行外部命令 :!"></a>运行外部命令 :!</h3><p>在 <code>Vim</code> 中可以运行一些终端命令，只要先输入 <code>:!</code> ，然后接命令名称。</p><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:!ls # 在Vim中打开的文件所在的目录运行ls命令</span><br></pre></td></tr></table></figure><h3 id="可视模式"><a href="#可视模式" class="headerlink" title="可视模式"></a>可视模式</h3><p>前面只讲了 <code>Vim</code> 的三种模式，其实还有一种模式叫做可视模式。</p><p>进入它的三种方式（都是从交互模式开始）：</p><ul><li><code>v</code> 字符可视模式，进入后配合方向键选中字符后，然后再按 <code>d</code> 键可以删除选中。</li><li><code>V</code> 行可视模式，进入后光标所在行默认被选中，然后再按 <code>d</code> 键可以删除所在行。</li><li><code>Ctrl + v</code> 块可视模式，它是可视模式最有用的功能了，配合 <code>d</code> 和 <code>I</code> 键可以实现删除选中的内容和插入内容。</li></ul><p>同时选中多行，并在选中行头部插入内容的具体操作步骤：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. ctrl + v 进入块可视模式</span><br><span class="line">2. 使用方向键进行选中（上下左右）假设选中5行</span><br><span class="line">3. 输入 I 键进行多行同时插入操作</span><br><span class="line">4. 插入完成后连续按两下 esc 键，实现多行同时插入相同字符</span><br></pre></td></tr></table></figure><p>进入可视模式之后的操作键：</p><ul><li><code>d</code> 键，表示删除选中；</li><li><code>I</code> 键，表示在选中之前插入；</li><li><code>u</code> 键，表示选中变为小写；</li><li><code>U</code> 键，表示选中变为大写；</li></ul><h2 id="Vim-配置"><a href="#Vim-配置" class="headerlink" title="Vim 配置"></a>Vim 配置</h2><h3 id="选项参数"><a href="#选项参数" class="headerlink" title="选项参数"></a>选项参数</h3><p>在 <code>Vim</code> 被启动后，可以运行一些指令来激活一些选项参数，但是这些选项参数的配置在退出 <code>Vim</code> 时会被忘记，例如前面讲解的激活行号。如果希望所在的配置是永久性的，那么需要在家目录（ <code>cd ~</code> ）创建一个 <code>Vim</code> 的配置文件 <code>.vimrc</code> 。</p><h3 id="vimrc"><a href="#vimrc" class="headerlink" title=".vimrc"></a>.vimrc</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">set number &quot; 显示行号</span><br><span class="line">syntax on &quot; 激活语法高亮</span><br><span class="line">set showcmd &quot; 实时看到输入的命令</span><br><span class="line">set ignorecase &quot; 搜索时不区分大小写</span><br><span class="line">set mouse=a &quot; 激活鼠标，用鼠标选中时相当于进入可视模式</span><br></pre></td></tr></table></figure><p><code>Vim</code> 配置非常丰富，我们可以通过个性化配置把 <code>Vim</code> 打造成属于自己的 <code>IDE</code> 等等。在 <code>github</code> 上也可以搜索到一些强大的 <code>Vim</code> 配置文件。</p>]]></content>
      
      
      <categories>
          
          <category> 编程工具 </category>
          
          <category> Vim </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux常用命令和系统总结</title>
      <link href="/posts/%E7%B3%BB%E7%BB%9F/Linux/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%92%8C%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%93.html"/>
      <url>/posts/%E7%B3%BB%E7%BB%9F/Linux/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%92%8C%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%93.html</url>
      
        <content type="html"><![CDATA[<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://mp.weixin.qq.com/s/JJM6eZMUKfgpfU2Kjj__Sw">2.6W字系统总结，带你实现 Linux 自由！ (qq.com)</a></li><li><a href="./https://github.com/jlevy/the-art-of-command-line/blob/master/README-zh">the-art-of-command-line</a></li><li><a href="https://coolshell.cn/articles/19219.html">打造高效的工作环境 – Shell 篇 | 酷 壳 - CoolShell</a></li></ul><h1 id="Linux-基础"><a href="#Linux-基础" class="headerlink" title="Linux 基础"></a>Linux 基础</h1><h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><p>操作系统 <code>Operating System</code> 简称 <code>OS</code> ，是软件的一部分，它是硬件基础上的第一层软件，是硬件和其它软件沟通的桥梁。</p><p>操作系统会控制其他程序运行，管理系统资源，提供最基本的计算功能，如管理及配置内存、决定系统资源供需的<img src="/../../../img/blog/3221dbdba0fc551d296565a126a91b4f_MD5.jpg" alt="图片">296565a126a91b4f_MD5.jpg)</p><h2 id="什么是-Linux"><a href="#什么是-Linux" class="headerlink" title="什么是 Linux"></a>什么是 Linux</h2><h3 id="Linux-系统内核与-Linux-发行套件的区别"><a href="#Linux-系统内核与-Linux-发行套件的区别" class="headerlink" title="Linux 系统内核与 Linux 发行套件的区别"></a>Linux 系统内核与 Linux 发行套件的区别</h3><ul><li><code>Linux</code> 系统内核指的是由 <code>Linus Torvalds</code> 负责维护，提供硬件抽象层、硬盘及文件系统控制及多任务功能的系统核心程序。</li><li><code>Linux</code> 发行套件系统是我们常说的 <code>Linux</code> 操作系统，也即是由 <code>Linux</code> 内核与各种常用软件的集合产品。</li></ul><p><strong>总结：真正的 <code>Linux</code> 指的是系统内核，而我们常说的 <code>Linux</code> 指的是 “ 发行版完整的包含一些基础软件的操作系统 “。</strong></p><h3 id="Linux-对比-Windows"><a href="#Linux-对比-Windows" class="headerlink" title="Linux 对比 Windows"></a>Linux 对比 Windows</h3><ol><li><p>稳定且有效率；</p></li><li><p>免费（或少许费用）；</p></li><li><p>漏洞少且快速修补；</p></li><li><p>多任务多用户；</p></li><li><p>更加安全的用户与文件权限策略；</p></li><li><p>适合小内核程序的嵌入系统；</p></li><li><p>相对不耗资源。</p></li></ol><h3 id="Linux-系统种类"><a href="#Linux-系统种类" class="headerlink" title="Linux 系统种类"></a>Linux 系统种类</h3><ul><li>红帽企业版 <code>Linux</code> ：<code>RHEL</code> 是全世界内使用最广泛的 <code>Linux</code> 系统。它具有极强的性能与稳定性，是众多生成环境中使用的（收费的）系统。</li><li><code>Fedora</code> ：由红帽公司发布的桌面版系统套件，用户可以免费体验到最新的技术或工具，这些技术或工具在成熟后会被加入到 <code>RHEL</code> 系统中，因此 <code>Fedora</code> 也成为 <code>RHEL</code> 系统的试验版本。</li><li><code>CentOS</code> ：通过把 <code>RHEL</code> 系统重新编译并发布给用户免费使用的 <code>Linux</code> 系统，具有广泛的使用人群。</li><li><code>Deepin</code> ：中国发行，对优秀的开源成品进行集成和配置。</li><li><code>Debian</code> ：稳定性、安全性强，提供了免费的基础支持，在国外拥有很高的认可度和使用率。</li><li><code>Ubuntu</code> ：是一款派生自 <code>Debian</code> 的操作系统，对新款硬件具有极强的兼容能力。<code>Ubuntu</code> 与 <code>Fedora</code> 都是极其出色的 <code>Linux</code> 桌面系统，而且 <code>Ubuntu</code> 也可用于服务器领域。</li></ul><h2 id="Shell"><a href="#Shell" class="headerlink" title="Shell"></a>Shell</h2><p><code>Shell</code> 这个单词的原意是 “ 外壳 “，跟 <code>kernel</code>（内核）相对应，比喻内核外面的一层，即用户跟内核交互的对话界面。</p><ul><li><code>Shell</code> 是一个程序，提供一个与用户对话的环境。这个环境只有一个命令提示符，让用户从键盘输入命令，所以又称为命令行环境（ <code>command line interface</code> ，简写为 <code>CLI</code> ）。<code>Shell</code> 接收到用户输入的命令，将命令送入操作系统执行，并将结果返回给用户。</li><li><code>Shell</code> 是一个命令解释器，解释用户输入的命令。它支持变量、条件判断、循环操作等语法，所以用户可以用 <code>Shell</code> 命令写出各种小程序，又称为 <code>Shell</code> 脚本。这些脚本都通过 <code>Shell</code> 的解释执行，而不通过编译。</li><li><code>Shell</code> 是一个工具箱，提供了各种小工具，供用户方便地使用操作系统的功能。</li></ul><p><code>Shell</code> 有很多种，只要能给用户提供命令行环境的程序，都可以看作是 <code>Shell</code> 。</p><p>通过执行 <code>echo $SHELL</code> 命令可以查看到当前正在使用的 <code>Shell</code> 。还可以通过 <code>cat /etc/shells</code> 查看当前系统安装的所有 <code>Shell</code> 种类。</p><h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><h2 id="快捷方式"><a href="#快捷方式" class="headerlink" title="快捷方式"></a>快捷方式</h2><p>在开始学习 <code>Linux</code> 命令之前，有这么一些快捷方式，是必须要提前掌握的，它将贯穿整个 <code>Linux</code> 使用生涯。</p><ul><li>通过上下方向键 ↑ ↓ 来调取过往执行过的 <code>Linux</code> 命令；</li><li>命令或参数仅需输入前几位就可以用 <code>Tab</code> 键补全；</li><li><code>Ctrl + R</code> ：用于查找使用过的命令（<code>history</code> 命令用于列出之前使用过的所有命令，然后输入 <code>!</code> 命令加上编号 ( <code>!2</code> ) 就可以直接执行该历史命令）；</li><li><code>Ctrl + L</code>：清除屏幕并将当前行移到页面顶部；</li><li><code>Ctrl + C</code>：中止当前正在执行的命令；</li><li><code>Ctrl + U</code>：从光标位置剪切到行首；</li><li><code>Ctrl + K</code>：从光标位置剪切到行尾；</li><li><code>Ctrl + W</code>：剪切光标左侧的一个单词；</li><li><code>Ctrl + Y</code>：粘贴 <code>Ctrl + U | K | Y</code> 剪切的命令；</li><li><code>Ctrl + A</code><img src="/../../../img/blog/11cd0e627f8bd2d76f4946aa81a4b2af_MD5.png">；</li></ul><h2 id="文件和目录"><a href="#文件和目录" class="headerlink" title="文件和目录"></a>文件和目录</h2><h3 id="文件的组织"><a href="#文件的组织" class="headerlink" title="文件的组织"></a>文件的组织</h3><p><img src="/../../../../img/blog/11cd0e627f8bd2d76f4946aa81a4b2af_MD5.png"></p><h3 id="查看路径"><a href="#查看路径" class="headerlink" title="查看路径"></a>查看路径</h3><h4 id="pwd"><a href="#pwd" class="headerlink" title="pwd"></a>pwd</h4><p>显示当前目录的路径</p><h4 id="which"><a href="#which" class="headerlink" title="which"></a>which</h4><p>查看命令的可执行文件所在路径， <code>Linux![图片](../../../img/blog/396daba53cba87b89e4618b016275e66_MD5.jpg)序也存在于 </code>Linux&#96; 中。</p><p>总的来说一个命令就是一个可执行程序。</p><p><img src="/../../../../img/blog/396daba53cba87b89e4618b016275e66_MD5.jpg" alt="图片"></p><h3 id="浏览和切换目录"><a href="#浏览和切换目录" class="headerlink" title="浏览和切换目录"></a>浏览和切换目录</h3><h4 id="ls"><a href="#ls" class="headerlink" title="ls"></a>ls</h4><p>列出文件和目录，它是 <code>Linux</code> 最常用的命令之一。</p><p>【常用参数】</p><ul><li><code>-a</code> 显示所有文件和目录包括隐藏的</li><li><code>-l</code> 显示详细列表</li><li><code>-h</code> 适合人类阅读的</li><li><code>-t</code> 按文件最近一次修改时间排序</li><li><code>-i</code> 显示文件的 <code>inode</code> （ <code>inode</code> 是文件内容的标识）</li></ul><h4 id="cd"><a href="#cd" class="headerlink" title="cd"></a>cd</h4><p><code>cd</code> 是英语 <code>change directory</code> 的缩写，表示切换目录。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cd / --&gt; 跳转到根目录</span><br><span class="line">cd ~ --&gt; 跳转到家目录</span><br><span class="line">cd .. --&gt; 跳转到上级目录</span><br><span class="line">cd ./home --&gt; 跳转到当前目录的home目录下</span><br><span class="line">cd /home/lion --&gt; 跳转到根目录下的home目录下的lion目录</span><br><span class="line">cd --&gt; 不添加任何参数，也是回到家目录</span><br></pre></td></tr></table></figure><p>[注意] 输入 <code>cd /ho</code> + 单次 <code>tab</code> 键会自动补全路径 + 两次 <code>tab</code> 键会列出所有可能的目录列表。</p><h4 id="du"><a href="#du" class="headerlink" title="du"></a>du</h4><p>列举目录大小信息。</p><p>【常用参数】</p><ul><li><code>-h</code> 适合人类阅读的；</li><li><code>-a</code> 同时列举出目录下文件的大小信息；</li><li><code>-s</code> 只显示总计大小，不显示具体信息。</li></ul><h3 id="浏览和创建文件"><a href="#浏览和创建文件" class="headerlink" title="浏览和创建文件"></a>浏览和创建文件</h3><h4 id="cat"><a href="#cat" class="headerlink" title="cat"></a>cat</h4><p>一次性显示文件所有内容，更适合查看小的文件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat cloud-init.log</span><br></pre></td></tr></table></figure><p>【常用参数】</p><ul><li><code>-n</code> 显示行号。</li></ul><h4 id="less"><a href="#less" class="headerlink" title="less"></a>less</h4><p>分页显示文件内容，更适合查看大的文件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">less cloud-init.log</span><br></pre></td></tr></table></figure><p>【快捷操作】</p><ul><li>空格键：前进一页（一个屏幕）；</li><li><code>b</code> 键：后退一页；</li><li>回车键：前进一行；</li><li><code>y</code> 键：后退一行；</li><li>上下键：回退或前进一行；</li><li><code>d</code> 键：前进半页；</li><li><code>u</code> 键：后退半页；</li><li><code>q</code> 键：停止读取文件，中止 <code>less</code> 命令；</li><li><code>=</code> 键：显示当前页面的内容是文件中的第几行到第几行以及一些其它关于本页内容的详细信息；</li><li><code>h</code> 键：显示帮助文档；</li><li><code>/</code> 键：进入搜索模式后，按 <code>n</code> 键跳到一个符合项目，按 <code>N</code> 键跳到上一个符合项目，同时也可以输入正则表达式匹配。</li></ul><h4 id="head"><a href="#head" class="headerlink" title="head"></a>head</h4><p>显示文件的开头几行（默认是 10 行）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">head cloud-init.log</span><br></pre></td></tr></table></figure><p>【参数】</p><ul><li><code>-n</code> 指定行数 <code>head cloud-init.log -n 2</code></li></ul><h4 id="tail"><a href="#tail" class="headerlink" title="tail"></a>tail</h4><p>显示文件的结尾几行（默认是 10 行）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tail cloud-init.log</span><br></pre></td></tr></table></figure><p>【参数】</p><ul><li><code>-n</code> 指定行数 <code>tail cloud-init.log -n 2</code></li><li><code>-f</code> 会每过 1 秒检查下文件是否有更新内容，也可以用 <code>-s</code> 参数指定间隔时间 <code>tail -f -s 4 xxx.log</code></li></ul><h4 id="touch"><a href="#touch" class="headerlink" title="touch"></a>touch</h4><p>创建一个文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch new_file</span><br></pre></td></tr></table></figure><h4 id="mkdir"><a href="#mkdir" class="headerlink" title="mkdir"></a>mkdir</h4><p>创建一个目录</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir new_folder</span><br></pre></td></tr></table></figure><p>【常用参数】</p><ul><li><code>-p</code> 递归的创建目录结构 <code>mkdir -p one/two/three</code></li></ul><h3 id="文件的复制和移动"><a href="#文件的复制和移动" class="headerlink" title="文件的复制和移动"></a>文件的复制和移动</h3><h4 id="cp"><a href="#cp" class="headerlink" title="cp"></a>cp</h4><p>拷贝文件和目录</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cp file file_copy --&gt; file 是目标文件，file_copy 是拷贝出来的文件</span><br><span class="line">cp file one --&gt; 把 file 文件拷贝到 one 目录下，并且文件名依然为 file</span><br><span class="line">cp file one/file_copy --&gt; 把 file 文件拷贝到 one 目录下，文件名为file_copy</span><br><span class="line">cp *.txt folder --&gt; 把当前目录下所有 txt 文件拷贝到 folder 目录下</span><br></pre></td></tr></table></figure><p>【常用参数】</p><ul><li><code>-r</code> 递归的拷贝，常用来拷贝一整个目录</li></ul><h4 id="mv"><a href="#mv" class="headerlink" title="mv"></a>mv</h4><p>移动（重命名）文件或目录，与 cp 命令用法相似。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mv file one --&gt; 将 file 文件移动到 one 目录下</span><br><span class="line">mv new_folder one --&gt; 将 new_folder 文件夹移动到one目录下</span><br><span class="line">mv *.txt folder --&gt; 把当前目录下所有 txt 文件移动到 folder 目录下</span><br><span class="line">mv file new_file --&gt; file 文件重命名为 new_file</span><br></pre></td></tr></table></figure><h3 id="文件的删除和链接"><a href="#文件的删除和链接" class="headerlink" title="文件的删除和链接"></a>文件的删除和链接</h3><h4 id="rm"><a href="#rm" class="headerlink" title="rm"></a>rm</h4><p>删除文件和目录，由于 <code>Linux</code> 下没有回收站，一旦删除非常难恢复，因此需要谨慎操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rm new_file  --&gt; 删除 new_file 文件</span><br><span class="line">rm f1 f2 f3  --&gt; 同时删除 f1 f2 f3 <span class="number">3</span>个文件</span><br></pre></td></tr></table></figure><p>【常用参数】</p><ul><li><code>-i</code> 向用户确认是否删除；</li><li><code>-f</code> 文件强制删除；</li><li><code>-r</code> 递归删除文件夹，著名的删除操作 <code>rm -rf</code> 。</li></ul><h4 id="ln"><a href="#ln" class="headerlink" title="ln"></a>ln</h4><p>英文 <code>Link</code> 的缩写，表示创建链接。</p><p>学习创建链接之前，首先要理解链接是什么，我们先来看看 <code>Linux</code> 的文件是如何存储的：</p><p><code>Linux</code> 文件的存储方式分为 3 个部分，文件名、文件内容以及权限，其中文件名<img src="/../../../img/blog/77b554a678c96307761b10b6c489ed0a_MD5.jpg" alt="图片">类型：硬链接和软链接。</p><h5 id="硬链接"><a href="#硬链接" class="headerlink" title="硬链接"></a>硬链接</h5><p>使链接的两个文件共享同样文件内容，就是同样的 <code>inode</code> ，一旦文件 1 和文件 2 之间有了硬链接，那么修改任何一个文件，修改的都是同一块内容，它的缺点是，只能创建指向文件的硬链接，不能创建指向目录的（其实也可以，但比较复杂）而软链接都可以，因此软链接使用更加广泛。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ln file1 file2  --&gt; 创建![图片](../../../img/blog/3e325a566fb7f92fea10ffff4d8785f3_MD5.jpg)307761b10b6c489ed0a_MD5.jpg)</span><br><span class="line"></span><br><span class="line">如果我们用 `rm file1` 来删除 `file1` ，对 `file2` 没有什么影响，对于硬链接来说，删除任意一方的文件，共同指向的文件内容并不会从硬盘上删除。只有同时删除了 `file1` 与 `file2` 后，它们共同指向的文件内容才会消失。</span><br><span class="line"></span><br><span class="line">##### 软链接</span><br><span class="line"></span><br><span class="line">软链接就类似 `windows` 下快捷方式。</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">ln -s file1 file2</span><br></pre></td></tr></table></figure><p><img src="/../../../../img/blog/3e325a566fb7f92fea10ffff4d8785f3_MD5.jpg" alt="图片"></p><p>执行 <code>ls -l</code> 命名查看当前目录下文件的具体信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">total <span class="number">0</span></span><br><span class="line">-rw-r--r-- <span class="number">1</span> root root <span class="number">0</span> Jan <span class="number">14</span> <span class="number">06</span>:<span class="number">29</span> file1</span><br><span class="line">lrwxrwxrwx <span class="number">1</span> root root <span class="number">5</span> Jan <span class="number">14</span> <span class="number">06</span>:<span class="number">42</span> file2 -&gt; file1  # 表示file2 指向 file1</span><br></pre></td></tr></table></figure><p><img src="/../../../img/blog/3f82ca7f43429ccc76e6bbff38538fd8_MD5.jpg" alt="图片">实 <code>file2</code> 的 <code>inode</code> 与 <code>file1</code> 并不相同。如果我们删除了 <code>file2</code> 的话， <code>file1</code> 是不会受影响的，但如果删除 <code>file1</code> 的话， <code>file2</code> 就会变成死链接，因为指向的文件不见了。</p><h2 id="用户与权限"><a href="#用户与权限" class="headerlink" title="用户与权限"></a>用户与权限</h2><h3 id="用户"><a href="#用户" class="headerlink" title="用户"></a>用户</h3><p><code>Linux</code> 是一个多用户的操作系统。在 <code>Linux</code> 中，理论上来说，我们可以创建无数个用户，但是这些用户是被划分到不同的群组里面的，有一个用户，名叫 <code>root</code> ，是一个很特殊的用户，它是超级用户，拥有最高权限。</p><p><img src="/../../../../img/blog/3f82ca7f43429ccc76e6bbff38538fd8_MD5.jpg" alt="图片"></p><p>自己创建的用户是有限权限的用户，这样大大提高了 <code>Linux</code> 系统的安全性，有效防止误操作或是病毒攻击，但是我们执行的某些命令需要更高权限时可以使用 <code>sudo</code> 命令。</p><h4 id="sudo"><a href="#sudo" class="headerlink" title="sudo"></a>sudo</h4><p>以 <code>root</code> 身份运行命令</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo date  --&gt; 当然查看日期是不需要sudo的这里只是演示，sudo 完之后一般还需要输入用户密码的</span><br></pre></td></tr></table></figure><h4 id="useradd-passwd"><a href="#useradd-passwd" class="headerlink" title="useradd + passwd"></a>useradd + passwd</h4><ul><li><code>useradd</code> 添加新用户</li><li><code>passwd</code> 修改用户密码</li></ul><p>这两个命令需要 <code>root</code> 用户权限</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">useradd lion --&gt; 添加一个lion用户，添加完之后在 /home 路径下可以查看</span><br><span class="line">passwd lion --&gt; 修改lion用户的密码</span><br></pre></td></tr></table></figure><h4 id="userdel"><a href="#userdel" class="headerlink" title="userdel"></a>userdel</h4><p>删除用户，需要 <code>root</code> 用户权限</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">userdel lion --&gt; 只会删除用户名，不会从/home中删除对应文件夹</span><br><span class="line">userdel lion -r --&gt; 会同时删除/home下的对应文件夹</span><br></pre></td></tr></table></figure><h4 id="su"><a href="#su" class="headerlink" title="su"></a>su</h4><p>切换用户，需要 <code>root</code> 用户权限</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo su --&gt; 切换为root用户（exit 命令或 CTRL + D 快捷键都可以使普通用户切换为 root 用户）</span><br><span class="line">su lion --&gt; 切换为普通用户</span><br><span class="line">su - --&gt; 切换为root用户</span><br></pre></td></tr></table></figure><h3 id="群组的管理"><a href="#群组的管理" class="headerlink" title="群组的管理"></a>群组的管理</h3><p><code>Linux</code> 中每个用户都属于一个特定的群组，如果你不设置用户的群组，默认会创建一个和它的用户名一样的群组，并且把用户划归到这个群组。</p><h4 id="groupadd"><a href="#groupadd" class="headerlink" title="groupadd"></a>groupadd</h4><p>创建群组，用法和 <code>useradd</code> 类似。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">groupadd friends</span><br></pre></td></tr></table></figure><h4 id="groupdel"><a href="#groupdel" class="headerlink" title="groupdel"></a>groupdel</h4><p>删除一个已存在的群组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">groupdel foo  --&gt; 删除foo群组</span><br></pre></td></tr></table></figure><h4 id="groups"><a href="#groups" class="headerlink" title="groups"></a>groups</h4><p>查看用户所在群组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">groups lion  --&gt; 查看 lion 用户所在的群组</span><br></pre></td></tr></table></figure><h4 id="usermod"><a href="#usermod" class="headerlink" title="usermod"></a>usermod</h4><p>用于修改用户的账户。</p><p>【常用参数】</p><ul><li><code>-l</code> 对用户重命名。需要注意的是 <code>/home</code> 中的用户家目录的名字不会改变，需要手动修改。</li><li><code>-g</code> 修改用户所在的群组，例如 <code>usermod -g friends lion</code> 修改 <code>lion</code> 用户的群组为 <code>friends</code> 。</li><li><code>-G</code> 一次性让用户添加多个群组，例如 <code>usermod -G friends,foo,bar lion</code> 。</li><li><code>-a</code> <code>-G</code> 会让你离开原先的群组，如果你不想这样做的话，就得再添加 <code>-a</code> 参数，意味着 <code>append</code> 追加的意思。</li></ul><h4 id="chgrp"><a href="#chgrp" class="headerlink" title="chgrp"></a>chgrp</h4><p>用于修改文件的群组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chgrp bar file.txt --&gt; file.txt文件的群组修改为bar</span><br></pre></td></tr></table></figure><h4 id="chown"><a href="#chown" class="headerlink" title="chown"></a>chown</h4><p>改变文件的所有者，需要 <code>root</code> 身份才能运行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chown lion file.txt --&gt; 把其它用户创建的file.txt转让给lion用户</span><br><span class="line">chown lion:bar file.txt --&gt; 把file.txt的用户改为lion，群组改为bar</span><br></pre></td></tr></table></figure><p>【常用参数】</p><ul><li><code>-R</code> 递归设置子目录和子文件， <code>chown -R lion:lion /home/frank</code> 把 <code>frank</code> 文件夹的用户和群组都改为 <code>lion</code> 。</li></ul><h3 id="文件权限管理"><a href="#文件权限管理" class="headerlink" title="文件权限管理"></a>文件权限管理</h3><h4 id="chmod"><a href="#chmod" class="headerlink" title="chmod"></a>chmod</h4><p>修改访问权限。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod <span class="number">740</span> file.txt</span><br></pre></td></tr></table></figure><p>【常用参数】</p><ul><li><code>-R</code> 可以递归地修改文件访问权限，例如 <code>chmod -R 777 /home/lion</code></li></ul><p>修改权限的确简单，但是理解其深层次的意<img src="/../../../img/blog/a2c6d556f37b0f4f4673661f47d615cf_MD5.jpg" alt="图片"><br>drwxr-xr-x 5 root root 4096 Apr 13  2020 climb<br>lrwxrwxrwx 1 root root    7 Jan 14 06:41 hello2.c -&gt; hello.c<br>-rw-r–r– 1 root root  149 Jan 13 06:14 hello.c</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">其中 `drwxr-xr-x` 表示文件或目录的权限。让我们一起来解读它具体代表什么？</span><br><span class="line"></span><br><span class="line">- `d` ：表示目录，就是说这是一个目录，普通文件是 `-` ，链接是 `l` 。</span><br><span class="line">- `r` ：`read` 表示文件可读。</span><br><span class="line">- `w` ：`write` 表示文件可写，一般有写的权限，就有删除的权限。</span><br><span class="line">- `x` ：`execute` 表示文件可执行。</span><br><span class="line">- `-` ：表示没有相应权限。</span><br><span class="line"></span><br><span class="line">权限的整体是按用户来划分的，如下图所示：</span><br><span class="line"></span><br><span class="line">![图片](../../../../img/blog/a2c6d556f37b0f4f4673661f47d615cf_MD5.jpg)</span><br><span class="line"></span><br><span class="line">现在再来理解这句权限 `drwxr-xr-x` 的意思：</span><br><span class="line"></span><br><span class="line">- 它是一个文件夹；</span><br><span class="line">- 它的所有者具有：读、写、执行权限；</span><br><span class="line">- 它的群组用户具有：读、执行的权限，没有写的权限；</span><br><span class="line">- 它的其它用户具有：读、执行的权限，没有写的权限。</span><br><span class="line"></span><br><span class="line">现在理解了权限，我们使用 `chmod` 来尝试修改权限。`chmod` 它不需要是 `root` 用户才能运行的，只要你是此文件所有者，就可以用 `chmod` 来修改文件的访问权限。</span><br><span class="line"></span><br><span class="line">##### 数字分配权限</span><br><span class="line"></span><br><span class="line">| 权限 | 数字 |</span><br><span class="line">| --- | --- |</span><br><span class="line">| r | 4 |</span><br><span class="line">| w | 2 |</span><br><span class="line">| x | 1 |</span><br><span class="line"></span><br><span class="line">因此要改变权限，只要做一些简单的加法就行：</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">chmod 640 hello.c </span><br><span class="line"></span><br><span class="line"># 分析</span><br><span class="line">6 = 4 + 2 + 0 表示所有者具有 rw 权限</span><br><span class="line">4 = 4 + 0 + 0 表示群组用户具有 r 权限</span><br><span class="line">0 = 0 + 0 + 0 表示其它用户没有权限</span><br><span class="line"></span><br><span class="line">对应文字权限为：-rw-r-----</span><br></pre></td></tr></table></figure><h5 id="用字母来分配权限"><a href="#用字母来分配权限" class="headerlink" title="用字母来分配权限"></a>用字母来分配权限</h5><ul><li><code>u</code> ：<code>user</code> 的缩写，用户的意思，表示所有者。</li><li><code>g</code> ：<code>group</code> 的缩写，群组的意思，表示群组用户。</li><li><code>o</code> ：<code>other</code> 的缩写，其它的意思，表示其它用户。</li><li><code>a</code> ：<code>all</code> 的缩写，所有的意思，表示所有用户。</li><li><code>+</code> ：加号，表示添加权限。</li><li><code>-</code> ：减号，表示去除权限。</li><li><code>=</code> ：等于号，表示分配权限。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">chmod u+rx file --&gt; 文件file的所有者增加读和运行的权限</span><br><span class="line">chmod g+r file --&gt; 文件file的群组用户增加读的权限</span><br><span class="line">chmod o-r file --&gt; 文件file的其它用户移除读的权限</span><br><span class="line">chmod g+r o-r file --&gt; 文件file的群组用户增加读的权限，其它用户移除读的权限</span><br><span class="line">chmod go-r file --&gt; 文件file的群组和其他用户移除读的权限</span><br><span class="line">chmod +x file --&gt; 文件file的所有用户增加运行的权限</span><br><span class="line">chmod u=rwx,g=r,o=- file --&gt; 文件file的所有者分配读写和执行的权限，群组其它用户分配读的权限，其他用户没有任何权限</span><br></pre></td></tr></table></figure><h2 id="查找文件"><a href="#查找文件" class="headerlink" title="查找文件"></a>查找文件</h2><h3 id="locate"><a href="#locate" class="headerlink" title="locate"></a>locate</h3><p>搜索包含关键字的所有文件和目录。后接需要查找的文件名，也可以用正则表达式。</p><h4 id="安装-locate"><a href="#安装-locate" class="headerlink" title="安装 locate"></a>安装 locate</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum -y install mlocate --&gt; 安装包</span><br><span class="line">updatedb --&gt; 更新数据库</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">locate file.txt</span><br><span class="line">locate fil*.txt</span><br></pre></td></tr></table></figure><p>[注意] <code>locate</code> 命令会去文件数据库中查找命令，而不是全磁盘查找，因此刚创建的文件并不会更新到数据库中，所以无法被查找到，可以执行 <code>updatedb</code> 命令去更新数据库。</p><h3 id="find"><a href="#find" class="headerlink" title="find"></a>find</h3><p>用于查找文件，它会去遍历你的实际硬盘进行查找，而且它允许我们对每个找到的文件进行后续操作，功能非常强大。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find &lt;何处&gt; &lt;何物&gt; &lt;做什么&gt;</span><br></pre></td></tr></table></figure><ul><li>何处：指定在哪个目录查找，此目录的所有子目录也会被查找。</li><li>何物：查找什么，可以根据文件的名字来查找，也可以根据其大小来查找，还可以根据其最近访问时间来查找。</li><li>做什么：找到文件后，可以进行后续处理，如果不指定这个参数， <code>find</code> 命令只会显示找到的文件。</li></ul><h4 id="根据文件名查找"><a href="#根据文件名查找" class="headerlink" title="根据文件名查找"></a>根据文件名查找</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">find -name <span class="string">&quot;file.txt&quot;</span> --&gt; 当前目录以及子目录下通过名称查找文件</span><br><span class="line">find . -name <span class="string">&quot;syslog&quot;</span> --&gt; 当前目录以及子目录下通过名称查找文件</span><br><span class="line">find / -name <span class="string">&quot;syslog&quot;</span> --&gt; 整个硬盘下查找syslog</span><br><span class="line">find /<span class="keyword">var</span>/log -name <span class="string">&quot;syslog&quot;</span> --&gt; 在指定的目录/<span class="keyword">var</span>/log下查找syslog文件</span><br><span class="line">find /<span class="keyword">var</span>/log -name <span class="string">&quot;syslog*&quot;</span> --&gt; 查找syslog1、syslog2 ... 等文件，通配符表示所有</span><br><span class="line">find /<span class="keyword">var</span>/log -name <span class="string">&quot;*syslog*&quot;</span> --&gt; 查找包含syslog的文件 </span><br></pre></td></tr></table></figure><p>[注意] <code>find</code> 命令只会查找完全符合 “ 何物 “ 字符串的文件，而 <code>locate</code> 会查找所有包含关键字的文件。</p><h4 id="根据文件大小查找"><a href="#根据文件大小查找" class="headerlink" title="根据文件大小查找"></a>根据文件大小查找</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">find /<span class="keyword">var</span> -size +10M --&gt; /<span class="keyword">var</span> 目录下查找文件大小超过 10M 的文件</span><br><span class="line">find /<span class="keyword">var</span> -size -50k --&gt; /<span class="keyword">var</span> 目录下查找文件大小小于 50k 的文件</span><br><span class="line">find /<span class="keyword">var</span> -size +1G --&gt; /<span class="keyword">var</span> 目录下查找文件大小查过 1G 的文件</span><br><span class="line">find /<span class="keyword">var</span> -size 1M --&gt; /<span class="keyword">var</span> 目录下查找文件大小等于 1M 的文件</span><br></pre></td></tr></table></figure><h4 id="根据文件最近访问时间查找"><a href="#根据文件最近访问时间查找" class="headerlink" title="根据文件最近访问时间查找"></a>根据文件最近访问时间查找</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find -name <span class="string">&quot;*.txt&quot;</span> -atime -<span class="number">7</span>  --&gt; 近 <span class="number">7</span>天内访问过的.txt结尾的文件</span><br></pre></td></tr></table></figure><h4 id="仅查找目录或文件"><a href="#仅查找目录或文件" class="headerlink" title="仅查找目录或文件"></a>仅查找目录或文件</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">find . -name <span class="string">&quot;file&quot;</span> -type f  --&gt; 只查找当前目录下的file文件</span><br><span class="line">find . -name <span class="string">&quot;file&quot;</span> -type d  --&gt; 只查找当前目录下的file目录</span><br></pre></td></tr></table></figure><h4 id="操作查找结果"><a href="#操作查找结果" class="headerlink" title="操作查找结果"></a>操作查找结果</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">find -name <span class="string">&quot;*.txt&quot;</span> -printf <span class="string">&quot;%p - %u\n&quot;</span> --&gt; 找出所有后缀为txt的文件，并按照 %p - %u\n 格式打印，其中%p=文件名，%u=文件所有者</span><br><span class="line">find -name <span class="string">&quot;*.jpg&quot;</span> -delete --&gt; 删除当前目录以及子目录下所有.jpg为后缀的文件，不会有删除提示，因此要慎用</span><br><span class="line">find -name <span class="string">&quot;*.c&quot;</span> -exec chmod <span class="number">600</span> &#123;&#125; \; --&gt; 对每个.c结尾的文件，都进行 -exec 参数指定的操作，&#123;&#125; 会被查找到的文件替代，\; 是必须的结尾</span><br><span class="line">find -name <span class="string">&quot;*.c&quot;</span> -ok chmod <span class="number">600</span> &#123;&#125; \; --&gt; 和上面的功能一直，会多一个确认提示</span><br></pre></td></tr></table></figure><h2 id="软件仓库"><a href="#软件仓库" class="headerlink" title="软件仓库"></a>软件仓库</h2><p><code>Linux</code> 下软件是以包的形式存在，一个软件包其实就是软件的所有文件的压缩包，是二进制的形式，包含了安装软件的所有指令。<code>Red Hat</code> 家族的软件包后缀名一般为 <code>.rpm</code> ， <code>Debian</code> 家族的软件包后缀是 <code>.deb</code> 。</p><p><code>Linux</code> 的包都存在一个仓库，叫做软件仓库，它可以使用 <code>yum</code> 来管理软件包， <code>yum</code> 是 <code>CentOS</code> 中默认的包管理工具，适用于 <code>Red Hat</code> 一族。可以理解成 <code>Node.js</code> 的 <code>npm</code> 。</p><h3 id="yum-常用命令"><a href="#yum-常用命令" class="headerlink" title="yum 常用命令"></a>yum 常用命令</h3><ul><li><code>yum update | yum upgrade</code> 更新软件包</li><li><code>yum search xxx</code> 搜索相应的软件包</li><li><code>yum install xxx</code> 安装软件包</li><li><code>yum remove xxx</code> 删除软件包</li></ul><h3 id="切换-CentOS-软件源"><a href="#切换-CentOS-软件源" class="headerlink" title="切换 CentOS 软件源"></a>切换 CentOS 软件源</h3><p>有时候 <code>CentOS</code> 默认的 <code>yum</code> 源不一定是国内镜像，导致 <code>yum</code> 在线安装及更新速度不是很理想。这时候需要将 <code>yum</code> 源设置为国内镜像站点。国内主要开源的镜像站点是网易和阿里云。</p><p>1、首先备份系统自带 <code>yum</code> 源配置文件 <code>mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup</code></p><p>2、下载阿里云的 <code>yum</code> 源配置文件到 <code>/etc/yum.repos.d/CentOS7</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget -O /etc/yum.repos.d/CentOS-Base.repo http:<span class="comment">//mirrors.aliyun.com/repo/Centos-7.repo</span></span><br></pre></td></tr></table></figure><p>3、生成缓存</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum makecache</span><br></pre></td></tr></table></figure><h2 id="阅读手册"><a href="#阅读手册" class="headerlink" title="阅读手册"></a>阅读手册</h2><p><code>Linux</code> 命令种类繁杂，我们凭借记忆不可能全部记住，因此学会查用手册是非常重要的。</p><h3 id="man"><a href="#man" class="headerlink" title="man"></a>man</h3><h4 id="安装更新-man"><a href="#安装更新-man" class="headerlink" title="安装更新 man"></a>安装更新 man</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install -y man-pages --&gt; 安装</span><br><span class="line">sudo mandb --&gt; 更新</span><br></pre></td></tr></table></figure><h4 id="man-手册种类"><a href="#man-手册种类" class="headerlink" title="man 手册种类"></a>man 手册种类</h4><ol><li><p>可执行程序或 <code>Shell</code> 命令；</p></li><li><p>系统调用（ <code>Linux</code> 内核提供的函数）；</p></li><li><p>库调用（程序库中的函数）；</p></li><li><p>文件（例如 <code>/etc/passwd</code> ）；</p></li><li><p>特殊文件（通常在 <code>/dev</code> 下）；</p></li><li><p>游戏；</p></li><li><p>杂项（ <code>man(7)</code> ，<code>groff(7)</code> ）；</p></li><li><p>系统管理命令（通常只能被 <code>root</code> 用户使用）；</p></li><li><p>内核子程序。</p></li></ol><h4 id="man-参数-命令"><a href="#man-参数-命令" class="headerlink" title="man + 参数 + 命令"></a>man + 参数 + 命令</h4><p>输入 man + 数字 + 命令&#x2F;函数，可以查到相关的命令和函数，若不加数字， <code>man</code> 默认从数字较小的手册中寻找相关命令和函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">man <span class="number">3</span> rand  --&gt; 表示在手册的第三部分查找 rand 函数</span><br><span class="line">man ls    --&gt; 查找 ls 用法手册</span><br><span class="line">man -k printf   --&gt; 将关键词 printf 作为正则表达式来搜索对应的手册页概述和手册页名称，并打印所有匹配结果。等效于apropos printf.</span><br><span class="line">man -f smail --&gt; 查找 smail 引用的手册页并输出找到的所有概述。等效于 whatis smail.</span><br></pre></td></tr></table></figure><p>man 手册核心区域解析：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">NAME # 命令名称和简单描述  </span><br><span class="line"></span><br><span class="line">SYNOPSIS # 使用此命令的所有方法</span><br><span class="line"></span><br><span class="line">DESCRIPTION # 包括所有参数以及用法</span><br><span class="line"></span><br><span class="line">SEE ALSO # 扩展阅读相关命令</span><br></pre></td></tr></table></figure><h3 id="cheat"><a href="#cheat" class="headerlink" title="cheat"></a>cheat</h3><p>man 虽然很重要，但有些命令看了帮助还不会用，初学者需要例子，<a href="https://github.com/cheat/cheat">cheat</a> 就是这个身边的小抄。类似的有 <a href="https://github.com/tldr-pages/tldr">tldr-pages&#x2F;tldr：📚控制台命令的协作备忘单</a></p><h3 id="help"><a href="#help" class="headerlink" title="help"></a>help</h3><p><code>man</code> 命令像新华词典一样可以查询到命令或函数的详细信息，但其实我们还有更加快捷的方式去查询， <code>command --help</code> 或 <code>command -h</code> ，它没有 <code>man</code> 命令显示的那么详细，但是它更加易于阅读。</p><h1 id="Linux-进阶"><a href="#Linux-进阶" class="headerlink" title="Linux 进阶"></a>Linux 进阶</h1><h2 id="文本操作"><a href="#文本操作" class="headerlink" title="文本操作"></a>文本操作</h2><h3 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h3><p>全局搜索一个正则表达式，并且打印到屏幕。简单来说就是，在文件中查找关键字，并显示关键字所在行。</p><h4 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">grep text file # text代表要搜索的文本，file代表供搜索的文件</span><br><span class="line"></span><br><span class="line"># 实例</span><br><span class="line">[root<span class="meta">@lion</span> ~]# grep path /etc/profile</span><br><span class="line"><span class="title function_">pathmunge</span> <span class="params">()</span> &#123;</span><br><span class="line">    pathmunge /usr/sbin</span><br><span class="line">    pathmunge /usr/local/sbin</span><br><span class="line">    pathmunge /usr/local/sbin after</span><br><span class="line">    pathmunge /usr/sbin after</span><br><span class="line">unset -f pathmunge</span><br></pre></td></tr></table></figure><h4 id="常用参数"><a href="#常用参数" class="headerlink" title="常用参数"></a>常用参数</h4><ul><li><code>-i</code> 忽略大小写， <code>grep -i path /etc/profile</code></li><li><code>-n</code> 显示行号，<code>grep -n path /etc/profile</code></li><li><code>-v</code> 只显示搜索文本不在的那些行，<code>grep -v path /etc/profile</code></li><li><code>-r</code> 递归查找， <code>grep -r hello /etc</code> ，Linux 中还有一个 rgrep 命令，作用相当于 <code>grep -r</code></li></ul><h4 id="高级用法"><a href="#高级用法" class="headerlink" title="高级用法"></a>高级用法</h4><p><code>grep</code> 可以配合正则表达式使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">grep -E path /etc/profile --&gt; 完全匹配path</span><br><span class="line">grep -E ^path /etc/profile --&gt; 匹配path开头的字符串</span><br><span class="line">grep -E [Pp]ath /etc/profile --&gt; 匹配path或Path</span><br></pre></td></tr></table></figure><h3 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h3><p>对文件的行进行排序。</p><h4 id="基础语法-1"><a href="#基础语法-1" class="headerlink" title="基础语法"></a>基础语法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sort name.txt # 对name.txt文件进行排序</span><br></pre></td></tr></table></figure><h4 id="实例用法"><a href="#实例用法" class="headerlink" title="实例用法"></a>实例用法</h4><p>为了演示方便，我们首先创建一个文件 <code>name.txt</code> ，放入以下内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Christopher</span><br><span class="line">Shawn</span><br><span class="line">Ted</span><br><span class="line">Rock</span><br><span class="line">Noah</span><br><span class="line">Zachary</span><br><span class="line">Bella</span><br></pre></td></tr></table></figure><p>执行 <code>sort name.txt</code> 命令，会对文本内容进行排序。</p><h4 id="常用参数-1"><a href="#常用参数-1" class="headerlink" title="常用参数"></a>常用参数</h4><ul><li><code>-o</code> 将排序后的文件写入新文件， <code>sort -o name_sorted.txt name.txt</code> ；</li><li><code>-r</code> 倒序排序， <code>sort -r name.txt</code> ；</li><li><code>-R</code> 随机排序， <code>sort -R name.txt</code> ；</li><li><code>-n</code> 对数字进行排序，默认是把数字识别成字符串的，因此 138 会排在 25 前面，如果添加了 <code>-n</code> 数字排序的话，则 25 会在 138 前面。</li></ul><h3 id="wc"><a href="#wc" class="headerlink" title="wc"></a>wc</h3><p><code>word count</code> 的缩写，用于文件的统计。它可以统计单词数目、行数、字符数，字节数等。</p><h4 id="基础语法-2"><a href="#基础语法-2" class="headerlink" title="基础语法"></a>基础语法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wc name.txt # 统计name.txt</span><br></pre></td></tr></table></figure><h4 id="实例用法-1"><a href="#实例用法-1" class="headerlink" title="实例用法"></a>实例用法</h4><p><img src="/../../../img/blog/39ed50e0aa849edc19fe5baac3dc9fcb_MD5.jpg" alt="图片">个 13，表示行数；</p><ul><li>第二个 13，表示单词数；</li><li>第三个 91，表示字节数。</li></ul><h4 id="常用参数-2"><a href="#常用参数-2" class="headerlink" title="常用参数"></a>常用参数</h4><ul><li><code>-l</code> 只统计行数， <code>wc -l name.txt</code> ；</li><li><code>-w</code> 只统计单词数， <code>wc -w name.txt</code> ；</li><li><code>-c</code> 只统计字节数， <code>wc -c name.txt</code> ；</li><li><code>-m</code> 只<img src="/../../../img/blog/05f3f6a977d20d9fc0463d50cdde3dda_MD5.jpg" alt="图片"></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">uniq name.txt # 去除name.txt重复的行数，并打印到屏幕上</span><br><span class="line">uniq name.txt uniq_name.txt # 把去除重复后的文件保存为 uniq_name.txt</span><br></pre></td></tr></table></figure><p>【注意】它只能去除连续重复的行数。</p><h4 id="常用参数-3"><a href="#常用参数-3" class="headerlink" title="常用参数"></a>常用参数</h4><ul><li><code>-c</code> 统计重复行数， <code>uniq -c name.txt</code> ；</li><li><code>-d</code> 只显示重复的行数， <code>uniq -d name.txt</code> 。</li></ul><h3 id="cut"><a href="#cut" class="headerlink" title="cut"></a>cut</h3><p>剪切文件的一部分内容。</p><h4 id="基础语法-3"><a href="#基础语法-3" class="headerlink" title="基础语法"></a>基础语法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cut -c <span class="number">2</span>-<span class="number">4</span> name.txt # 剪切每一行第二到第四个字符</span><br></pre></td></tr></table></figure><h4 id="常用参数-4"><a href="#常用参数-4" class="headerlink" title="常用参数"></a>常用参数</h4><ul><li><code>-d</code> 用于指定用什么分隔符（比如逗号、分号、双引号等等） <code>cut -d , name.txt</code> ；</li><li><code>-f</code> 表示剪切下用分隔符分割的哪一块或哪几块区域， <code>cut -d , -f 1 name.txt</code> 。</li></ul><h2 id="重定向-管道-流"><a href="#重定向-管道-流" class="headerlink" title="重定向 管道 流"></a>重定向 管道 流</h2><p>在 <code>Linux</code> 中一个命令的去向可以有 3 个地方：终端、文件、作为另外一个命令的入参。<br><img src="/../../../../img/blog/39ed50e0aa849edc19fe5baac3dc9fcb_MD5.jpg" alt="图片"><br>命令一般都是通过键盘输入，然后输出到终端、文件等地方，它的标准用语是 <code>stdin</code> 、 <code>stdout</code> 以及 <code>stderr</code> 。</p><ul><li>标准输入 <code>stdin</code> ，终端接收键盘输入的命令，会产生两种输出；</li><li>标准输出 <code>stdout</code> ，终端输出的信息（不包含错误信息）；</li><li>标准错误输出 <code>stderr</code> ，终端输出的错误信息。</li></ul><p><img src="/../../../../img/blog/05f3f6a977d20d9fc0463d50cdde3dda_MD5.jpg" alt="图片"></p><h3 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h3><p>把本来要显示在终端的命令结果，输送到别的地方（到文件中或者作为其他命令的输入）。</p><h4 id="输出重定向-gt"><a href="#输出重定向-gt" class="headerlink" title="输出重定向 &gt;"></a>输出重定向 &gt;</h4><p><code>&gt;</code> 表示重定向到新的文件， <code>cut -d , -f 1 notes.csv &gt; name.csv</code> ，它表示通过逗号剪切 <code>notes.csv</code> 文件（剪切完有 3 个部分）获取第一个部分，重定向到 <code>name.csv</code> 文件。</p><p>我们来看一个具体示例，学习它的使用，假设我们有一个文件 <code>notes.csv</code> ，文件内容如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Mark1,<span class="number">951</span>/<span class="number">100</span>,很不错<span class="number">1</span></span><br><span class="line">Mark2,<span class="number">952</span>/<span class="number">100</span>,很不错<span class="number">2</span></span><br><span class="line">Mark3,<span class="number">953</span>/<span class="number">100</span>,很不错<span class="number">3</span></span><br><span class="line">Mark4,<span class="number">954</span>/<span class="number">100</span>,很不错<span class="number">4</span></span><br><span class="line">Mark5,<span class="number">955</span>/<span class="number">100</span>,很不错<span class="number">5</span></span><br><span class="line">Mark6,<span class="number">956</span>/<span class="number">100</span>,很不错<span class="number">6</span></span><br></pre></td></tr></table></figure><p>执行命令：<code>cut -d , -f 1 notes.csv &gt; name.csv</code> 最后输出如下内容<img src="/../../../img/blog/c8c5174435605edd5fc58ce5b2e83705_MD5.jpg" alt="图片">用 <code>&gt;</code> 要注意，如果输出的文件不存在它会新建一个，如果输出的文件已经存在，则会覆盖。因此执行这个操作要非常小心，以免覆盖其它重要文件。</p><h4 id="输出重定向-gt-gt"><a href="#输出重定向-gt-gt" class="headerlink" title="输出重定向 &gt;&gt;"></a>输出重定向 &gt;&gt;</h4><p>表示重定向到文件末尾，因此它不会像 <code>&gt;</code> 命令这么危险，它是追加到文件的末尾（当然如果文件不存在，也会被创建）。</p><p>再次执行 <code>cut -d , -f 1 notes.csv &gt;&gt; name.csv</code> ，则会把名字追加到 <code>name.csv</code> 里面。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Mark1</span><br><span class="line">Mark2</span><br><span class="line">Mark3</span><br><span class="line">Mark4</span><br><span class="line">Mark5</span><br><span class="line">Mark6</span><br><span class="line">Mark1</span><br><span class="line">Mark2</span><br><span class="line">Mark3</span><br><span class="line">Mark4</span><br><span class="line">Mark5</span><br><span class="line">Mark6</span><br></pre></td></tr></table></figure><p>我们平时读的 <code>log</code> 日志文件其实都是用这个命令输出的。</p><h4 id="输出重定向-2-gt"><a href="#输出重定向-2-gt" class="headerlink" title="输出重定向 2&gt;"></a>输出重定向 2&gt;</h4><p>标准错误输出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat not_exist_file.csv &gt; res.txt <span class="number">2</span>&gt; errors.log</span><br></pre></td></tr></table></figure><ul><li>当我们 <code>cat</code> 一个文件时，会把文件内容打印到屏幕上，这个是标准输出；</li><li>当使用了 <code>&gt; res.txt</code> 时，则不会打印到屏幕，会把标准输出写入文件 &#96;<img src="/../../../img/blog/327c6fef8f6726cf6a2f039d26531695_MD5.jpg" alt="图片"> 输出重定向 2&gt;&gt;</li></ul><p>标准错误输出（追加到文件末尾）同 <code>&gt;&gt;</code> 相似。</p><h4 id="输出重定向-2-gt-amp-1"><a href="#输出重定向-2-gt-amp-1" class="headerlink" title="输出重定向 2&gt;&amp;1"></a>输出重定向 2&gt;&amp;1</h4><p>标准输出和标准错误输出都重定向都一个地方</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cat not_exist_file.csv &gt; res.txt <span class="number">2</span>&gt;&amp;<span class="number">1</span>  # 覆盖输出</span><br><span class="line">cat not_exist_file.csv &gt;&gt; res.txt <span class="number">2</span>&gt;&amp;<span class="number">1</span> # 追加输出</span><br></pre></td></tr></table></figure><p>目前为止，我们接触的命令的输入都来自命令的参数，其实命令的输入还可以来自文件或者键盘的输入。</p><p><img src="/../../../../img/blog/c8c5174435605edd5fc58ce5b2e83705_MD5.jpg" alt="图片"></p><h4 id="输入重定向-lt"><a href="#输入重定向-lt" class="headerlink" title="输入重定向 &lt;"></a>输入重定向 &lt;</h4><p><code>&lt;</code> 符号用于指定命令的输入。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat &lt; name.csv # 指定命令的输入为 name.csv</span><br></pre></td></tr></table></figure><p>虽然它的运行结果与 <code>cat name.csv</code> 一样，但是它们的原理却完全不同。</p><ul><li><code>cat name.csv</code> 表示 <code>cat</code> 命令接收的输入是 <code>notes.csv</code> 文件名，那么要先打开这个文件，然后打印出文件内容。</li><li><code>cat &lt; name.csv</code> 表示 <code>cat</code> 命令接收的输入直接是 <code>notes.csv</code> 这个文件的内容， <code>cat</code> 命令只负责将其内容打印，打开文件并将文件内容传递给 <code>cat</code> 命令的工作则交给终端完成。</li></ul><h4 id="输入重定向-lt-lt"><a href="#输入重定向-lt-lt" class="headerlink" title="输入重定向 &lt;&lt;"></a>输入重定向 &lt;&lt;</h4><p>将键盘的输入重定向为某个命令的输入。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sort -n &lt;&lt; END # 输入这个命令之后，按下回车，终端就进入键盘输入模式，其中END为结束命令（这个可以自定义）</span><br><span class="line"></span><br><span class="line">wc -m &lt;&lt; END # 统计输入的单词</span><br></pre></td></tr></table></figure><h3 id="管道"><a href="#管道" class="headerlink" title="管道 |"></a>管道 |</h3><p>把两个命令连起来使用，一个命令的输出作为另外一个命令的输入，英文是 <code>pipeline</code> ，可以想象一个个水管连接起来，管道算是重定向流的一种。</p><p><img src="/../../../../img/blog/327c6fef8f6726cf6a2f039d26531695_MD5.jpg" alt="图片"></p><p>举几个实际用法案例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">cut -d , -f <span class="number">1</span> name.csv | sort &gt; sorted_name.txt </span><br><span class="line"># 第一步获取到的 name 列表，通过管道符再进行排序，最后输出到sorted_name.txt</span><br><span class="line"></span><br><span class="line">du | sort -nr | head </span><br><span class="line"># du 表示列举目录大小信息</span><br><span class="line"># sort 进行排序,-n 表示按数字排序，-r 表示倒序</span><br><span class="line"># head 前<span class="number">10</span>行文件</span><br><span class="line"></span><br><span class="line">grep log -Ir /<span class="keyword">var</span>/log | cut -d : -f <span class="number">1</span> | sort | uniq</span><br><span class="line"># grep log -Ir /<span class="keyword">var</span>/log 表示在log文件夹下搜索 /<span class="keyword">var</span>/log 文本，-r 表示递归，-I 用于排除二进制文件</span><br><span class="line"># cut -d : -f <span class="number">1</span> 表示通过冒号进行剪切，获取剪切的第一部分</span><br><span class="line"># sort 进行排序</span><br><span class="line"># uniq 进行去重</span><br></pre></td></tr></table></figure><h3 id="流"><a href="#流" class="headerlink" title="流"></a>流</h3><p>流并非一个命令，在计算机科学中，流 <code>stream</code> 的含义是比较难理解的，记住一点即可：<strong>流就是读一点数据, 处理一点点数据。其中数据一般就是二进制格式。</strong> 上面提及的重定向或管道，就是把数据当做流去运转的。</p><p>到此我们就接触了，流、重定向、管道等 <code>Linux</code> 高级概念及指令。其实你会发现关于流和管道在其它语言中也有广泛的应用。<code>Angular</code> 中的模板语法中可以使用管道。<code>Node.js</code> 中也有 <code>stream</code> 流的概念。</p><h2 id="查看进程"><a href="#查看进程" class="headerlink" title="查看进程"></a>查看进程</h2><p>在 <code>Windows</code> 中通过 <code>Ctrl + Alt + Delete</code> 快捷键查看软件进程。</p><h3 id="w"><a href="#w" class="headerlink" title="w"></a>w</h3><p>帮助我们快速了解系统中目前有哪些用户登录着，以及他们在干什么。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[root<span class="meta">@lion</span> ~]# w</span><br><span class="line"> <span class="number">06</span>:<span class="number">31</span>:<span class="number">53</span> up <span class="number">25</span> days,  <span class="number">9</span>:<span class="number">53</span>,  <span class="number">1</span> user,  load average: <span class="number">0.00</span>, <span class="number">0.01</span>, <span class="number">0.05</span></span><br><span class="line">USER     TTY      FROM             LOGIN@   IDLE   JCPU   PCPU WHAT</span><br><span class="line">root     pts/<span class="number">0</span>    <span class="number">118.31</span><span class="number">.243</span><span class="number">.53</span>    <span class="number">05</span>:<span class="number">56</span>    <span class="number">1.</span>00s  <span class="number">0.</span>02s  <span class="number">0.</span>00s w</span><br><span class="line"> </span><br><span class="line"><span class="number">06</span>:<span class="number">31</span>:<span class="number">53</span>：表示当前时间</span><br><span class="line">up <span class="number">25</span> days, <span class="number">9</span>:<span class="number">53</span>：表示系统已经正常运行了“<span class="number">25</span>天<span class="number">9</span>小时<span class="number">53</span>分钟”</span><br><span class="line"><span class="number">1</span> user：表示一个用户</span><br><span class="line">load average: <span class="number">0.00</span>, <span class="number">0.01</span>, <span class="number">0.05</span>：表示系统的负载，<span class="number">3</span>个值分别表示“<span class="number">1</span>分钟的平均负载”，“<span class="number">5</span>分钟的平均负载”，“<span class="number">15</span>分钟的平均负载”</span><br><span class="line"></span><br><span class="line"> USER：表示登录的用于</span><br><span class="line"> TTY：登录的终端名称为pts/<span class="number">0</span></span><br><span class="line"> FROM：连接到服务器的ip地址</span><br><span class="line"> LOGIN@：登录时间</span><br><span class="line"> IDLE：用户有多久没有活跃了</span><br><span class="line"> JCPU：该终端所有相关的进程使用的 CPU 时间，每当进程结束就停止计时，开始新的进程则会重新计时</span><br><span class="line"> PCPU：表示 CPU 执行当前程序所消耗的时间，当前进程就是在 WHAT 列里显示的程序</span><br><span class="line"> WHAT：表示当下用户正运行的程序是什么，这里我运行的是 w</span><br></pre></td></tr></table></figure><h3 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h3><p>用于显示当前系统中的进程， <code>ps</code> 命令显示的进程列表不会随时间而更新，是静态的，是运行 <code>ps</code> 命令那个时刻的状态或者说是一个进程快照。</p><h4 id="基础语法-4"><a href="#基础语法-4" class="headerlink" title="基础语法"></a>基础语法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root<span class="meta">@lion</span> ~]# ps</span><br><span class="line">  PID TTY          TIME CMD</span><br><span class="line"> <span class="number">1793</span> pts/<span class="number">0</span>    <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> bash</span><br><span class="line"> <span class="number">4756</span> pts/<span class="number">0</span>    <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> ps</span><br><span class="line"> </span><br><span class="line"> PID：进程号，每个进程都有唯一的进程号</span><br><span class="line"> TTY：进程运行所在的终端</span><br><span class="line"> TIME：进程运行时间</span><br><span class="line"> CMD：产生这个进程的程序名，如果在进程列表中看到有好几行都是同样的程序名，那么就是同样的程序产生了不止一个进程</span><br></pre></td></tr></table></figure><h4 id="常用参数-5"><a href="#常用参数-5" class="headerlink" title="常用参数"></a>常用参数</h4><ul><li><code>-ef</code> 列出所有进程;</li><li><code>-efH</code> 以乔木状列举出所有进程;</li><li><code>-u</code> 列出此用户运行的进程;</li><li><code>-aux</code> 通过 <code>CPU</code> 和内存使用来过滤进程 <code>ps -aux | less</code> ;</li><li><code>-aux --sort -pcpu</code> 按 <code>CPU</code> 使用降序排列， <code>-aux --sort -pmem</code> 表示按内存使用降序排列;</li><li><code>-axjf</code> 以树形结构显示进程， <code>ps -axjf</code> 它和 <code>pstree</code> 效果类似。</li></ul><h3 id="top"><a href="#top" class="headerlink" title="top"></a>top</h3><p>获取进程的动态列表。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">top - <span class="number">07</span>:<span class="number">20</span>:<span class="number">07</span> up <span class="number">25</span> days, <span class="number">10</span>:<span class="number">41</span>,  <span class="number">1</span> user,  load average: <span class="number">0.30</span>, <span class="number">0.10</span>, <span class="number">0.07</span></span><br><span class="line">Tasks:  <span class="number">67</span> total,   <span class="number">1</span> running,  <span class="number">66</span> sleeping,   <span class="number">0</span> stopped,   <span class="number">0</span> zombie</span><br><span class="line">%Cpu(s):  <span class="number">0.7</span> us,  <span class="number">0.3</span> sy,  <span class="number">0.0</span> ni, <span class="number">99.0</span> id,  <span class="number">0.0</span> wa,  <span class="number">0.0</span> hi,  <span class="number">0.0</span> si,  <span class="number">0.0</span> st</span><br><span class="line">KiB Mem :  <span class="number">1882072</span> total,   <span class="number">552148</span> free,   <span class="number">101048</span> used,  <span class="number">1228876</span> buff/cache</span><br><span class="line">KiB Swap:        <span class="number">0</span> total,        <span class="number">0</span> free,        <span class="number">0</span> used.  <span class="number">1594080</span> avail Mem </span><br><span class="line"></span><br><span class="line">  PID USER      PR  NI    VIRT    RES    SHR S %CPU %MEM     TIME+ COMMAND                                                                                                       </span><br><span class="line">  <span class="number">956</span> root      <span class="number">10</span> -<span class="number">10</span>  <span class="number">133964</span>  <span class="number">15848</span>  <span class="number">10240</span> S  <span class="number">0.7</span>  <span class="number">0.8</span> <span class="number">263</span>:<span class="number">13.01</span> AliYunDun                                                                                                     </span><br><span class="line">    <span class="number">1</span> root      <span class="number">20</span>   <span class="number">0</span>   <span class="number">51644</span>   <span class="number">3664</span>   <span class="number">2400</span> S  <span class="number">0.0</span>  <span class="number">0.2</span>   <span class="number">3</span>:<span class="number">23.63</span> systemd                                                                                                       </span><br><span class="line">    <span class="number">2</span> root      <span class="number">20</span>   <span class="number">0</span>       <span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span> S  <span class="number">0.0</span>  <span class="number">0.0</span>   <span class="number">0</span>:<span class="number">00.05</span> kthreadd                                                                                                      </span><br><span class="line">    <span class="number">4</span> root       <span class="number">0</span> -<span class="number">20</span>       <span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span> S  <span class="number">0.0</span>  <span class="number">0.0</span>   <span class="number">0</span>:<span class="number">00.00</span> kworker/<span class="number">0</span>:0H    </span><br></pre></td></tr></table></figure><ul><li><code>top - 07:20:07 up 25 days, 10:41, 1 user, load average: 0.30, 0.10, 0.07</code> 相当 <code>w</code> 命令的第一行的信息。</li><li>展示的这些进程是按照使用处理器 <code>%CPU</code> 的使用率来排序的。</li></ul><h3 id="kill"><a href="#kill" class="headerlink" title="kill"></a>kill</h3><p>结束一个进程， <code>kill + PID</code> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kill <span class="number">956</span> # 结束进程号为<span class="number">956</span>的进程</span><br><span class="line">kill <span class="number">956</span> <span class="number">957</span> # 结束多个进程</span><br><span class="line">kill -<span class="number">9</span> <span class="number">7291</span> # 强制结束进程</span><br></pre></td></tr></table></figure><h2 id="管理进程"><a href="#管理进程" class="headerlink" title="管理进程"></a>管理进程</h2><h3 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h3><p>主要是切换进程的状态。我们先了解下 <code>Linux</code> 下进程的五种状态：</p><ol><li><p>状态码 <code>R</code> ：表示正在运行的状态；</p></li><li><p>状态码 <code>S</code> ：表示中断（休眠中，受阻，当某个条件形成后或接受到信号时，则脱离该状态）；</p></li><li><p>状态码 <code>D</code> ：表示不可中断（进程不响应系统异步信号，即使用 kill 命令也不能使其中断）；</p></li><li><p>状态码 <code>Z</code> ：表示僵死（进程已终止，但进程描述符依然存在，直到父进程调用 <code>wait4()</code> 系统函数后将进程释放）；</p></li><li><p>状态码 &#96;T<img src="/../../../img/blog/1eb7f39e04805b5c10e07310cc252ac7_MD5.jpg" alt="图片"></p></li></ol><h3 id="前台进程-amp-后台进程"><a href="#前台进程-amp-后台进程" class="headerlink" title="前台进程 &amp; 后台进程"></a>前台进程 &amp; 后台进程</h3><p>默认情况下，用户创建的进程都是前台进程，前台进程从键盘读取数据，并把处理结果输出到显示器。例如运行 <code>top</code> 命令，这就是一个一直运行的前台进程。</p><p>后台进程的优点是不必等待程序运行结束，就可以输入其它命令。在需要执行的命令后面添加 <code>&amp;</code> 符号，就表示启动一个后台进程。</p><h3 id="amp"><a href="#amp" class="headerlink" title="&amp;"></a>&amp;</h3><p>启动后台进程，它的缺点是后台进程与终端相关联，一旦关闭终端，进程就自动结束了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp name.csv name-copy.csv &amp;</span><br></pre></td></tr></table></figure><h3 id="nohup"><a href="#nohup" class="headerlink" title="nohup"></a>nohup</h3><p>使进程不受挂断（关闭终端等动作）的影响。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup cp name.csv name-copy.csv</span><br></pre></td></tr></table></figure><p><code>nohup</code> 命令也可以和 <code>&amp;</code> 结合使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup cp name.csv name-copy.csv &amp;</span><br></pre></td></tr></table></figure><h3 id="bg"><a href="#bg" class="headerlink" title="bg"></a>bg</h3><p>使一个 “ 后台暂停运行 “ 的进程，状态改为 “ 后台运行 “。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bg %<span class="number">1</span> # 不加任何参数的情况下，bg命令会默认作用于最近的一个后台进程，如果添加参数则会作用于指定标号的进程</span><br></pre></td></tr></table></figure><p>实际案例 1：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 执行 grep -r <span class="string">&quot;log&quot;</span> / &gt; grep_log <span class="number">2</span>&gt;&amp;<span class="number">1</span> 命令启动一个前台进程，并且忘记添加 &amp; 符号</span><br><span class="line"><span class="number">2.</span> ctrl + z 使进程状态转为后台暂停</span><br><span class="line"><span class="number">3.</span> 执行 bg 将命令转为后台运行</span><br></pre></td></tr></table></figure><p>实际案例 2：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">前端开发时我们经常会执行 yarn start 启动项目</span><br><span class="line">此时我们执行 ctrl + z 先使其暂停</span><br><span class="line">然后执行 bg 使其转为后台运行</span><br><span class="line">这样当前终端就空闲出来可以干其它事情了，如果想要唤醒它就使用 fg 命令即可（后面会讲）</span><br></pre></td></tr></table></figure><h3 id="jobs"><a href="#jobs" class="headerlink" title="jobs"></a>jobs</h3><p>显示当前终端后台进程状态。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root<span class="meta">@lion</span> ~]# jobs</span><br><span class="line">[<span class="number">1</span>]+  Stopped                 top</span><br><span class="line">[<span class="number">2</span>]-  Running                 grep --color=auto -r <span class="string">&quot;log&quot;</span> / &gt; grep_log <span class="number">2</span>&gt;&amp;<span class="number">1</span> &amp;</span><br></pre></td></tr></table></figure><h3 id="fg"><a href="#fg" class="headerlink" title="fg"></a>fg</h3><p><code>fg</code> 使进程转为前台运行，用法和 <code>bg</code> 命令类似。</p><p>我们用一张图来表示前后台进程切换：</p><p><img src="/../../../../img/blog/1eb7f39e04805b5c10e07310cc252ac7_MD5.jpg" alt="图片"></p><p>我们可以使程序在后台运行，成为后台进程，这样在当前终端中我们就可以做其他事情了，而不必等待此进程运行结<img src="/../../../img/blog/00e8bfd088aed9124a583e231a24bb99_MD5.jpg" alt="图片">份如何，都在后台运行，这些进程的父进程是 <code>PID</code> 为 1 的进程， <code>PID</code> 为 1 的进程只在系统关闭时才会被销毁。它们会在后台一直运行等待分配工作。我们将这类进程称之为守护进程 <code>daemon</code> 。</p><p>守护进程的名字通常会在最后有一个 <code>d</code> ，表示 <code>daemon</code> 守护的意思，例如 <code>systemd</code> 、<code>httpd</code> 。</p><h3 id="systemd"><a href="#systemd" class="headerlink" title="systemd"></a>systemd</h3><p><code>systemd</code> 是一个 <code>Linux</code> 系统基础组件的集合，提供了一个系统和服务管理器，运行为 <code>PID 1</code> 并负责启动其它程序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root<span class="meta">@lion</span> ~]# ps -aux</span><br><span class="line">USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND</span><br><span class="line">root         <span class="number">1</span>  <span class="number">0.0</span>  <span class="number">0.2</span>  <span class="number">51648</span>  <span class="number">3852</span> ?        Ss   Feb01   <span class="number">1</span>:<span class="number">50</span> /usr/lib/systemd/systemd --switched-root --system --deserialize <span class="number">22</span></span><br></pre></td></tr></table></figure><p>通过命令也可以看到 <code>PID</code> 为 1 的进程就是 <code>systemd</code> 的系统进程。</p><p><code>systemd</code> 常用命令（它是一组命令的集合）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">systemctl start nginx # 启动服务</span><br><span class="line">systemctl stop nginx # 停止服务</span><br><span class="line">systemctl restart nginx # 重启服务</span><br><span class="line">systemctl status nginx # 查看服务状态</span><br><span class="line">systemctl reload nginx # 重载配置文件(不停止服务的情况)</span><br><span class="line">systemctl enable nginx # 开机自动启动服务</span><br><span class="line">systemctl disable nginx # 开机不自动启动服务</span><br><span class="line">systemctl is-enabled nginx # 查看服务是否开机自动启动</span><br><span class="line">systemctl list-unit-files --type=service # 查看各个级别下服务的启动和禁用情况</span><br></pre></td></tr></table></figure><h2 id="文件压缩解压"><a href="#文件压缩解压" class="headerlink" title="文件压缩解压"></a>文件压缩解压</h2><ul><li>打包：是将多个文件变成一个总的文件，它的学名叫存档、归档。</li><li>压缩：是将一个大文件（通常指归档）压缩变成一个小文件。</li></ul><p>我们常常使用 <code>tar</code> 将多个文件归档为一个总的文件，称为 <code>archive</code> 。然后用 <code>gzip</code> 或 <code>bzip2</code> 命令将 <code>archive</code> 压缩为更小的文件。</p><p><img src="/../../../../img/blog/00e8bfd088aed9124a583e231a24bb99_MD5.jpg" alt="图片"></p><h3 id="tar"><a href="#tar" class="headerlink" title="tar"></a>tar</h3><p>创建一个 <code>tar</code> 归档。</p><h4 id="基础用法"><a href="#基础用法" class="headerlink" title="基础用法"></a>基础用法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tar -cvf sort.tar sort/ # 将sort文件夹归档为sort.tar</span><br><span class="line">tar -cvf archive.tar file1 file2 file3 # 将 file1 file2 file3 归档为archive.tar</span><br></pre></td></tr></table></figure><h4 id="常用参数-6"><a href="#常用参数-6" class="headerlink" title="常用参数"></a>常用参数</h4><ul><li><code>-cvf</code> 表示 <code>create</code>（创建）+ <code>verbose</code>（细节）+ <code>file</code>（文件），创建归档文件并显示操作细节；</li><li><code>-tf</code> 显示归档里的内容，并不解开归档；</li><li><code>-rvf</code> 追加文件到归档， <code>tar -rvf archive.tar file.txt</code> ；</li><li><code>-xvf</code> 解开归档， <code>tar -xvf archive.tar</code> 。</li></ul><h3 id="gzip-x2F-gunzip"><a href="#gzip-x2F-gunzip" class="headerlink" title="gzip &#x2F; gunzip"></a>gzip &#x2F; gunzip</h3><p>“ 压缩&#x2F;解压 “ 归档，默认用 <code>gzip</code> 命令，压缩后的文件后缀名为 <code>.tar.gz</code> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gzip archive.tar # 压缩</span><br><span class="line">gunzip archive.tar.gz # 解压</span><br></pre></td></tr></table></figure><h3 id="tar-归档-压缩"><a href="#tar-归档-压缩" class="headerlink" title="tar 归档 + 压缩"></a>tar 归档 + 压缩</h3><p>可以用 <code>tar</code> 命令同时完成归档和压缩的操作，就是给 <code>tar</code> 命令多加一个选项参数，使之完成归档操作后，还是调用 <code>gzip</code> 或 <code>bzip2</code> 命令来完成压缩操作。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tar -zcvf archive.tar.gz archive/ # 将archive文件夹归档并压缩</span><br><span class="line">tar -zxvf archive.tar.gz # 将archive.tar.gz归档压缩文件解压</span><br></pre></td></tr></table></figure><h3 id="zcat、zless、zmore"><a href="#zcat、zless、zmore" class="headerlink" title="zcat、zless、zmore"></a>zcat、zless、zmore</h3><p>之前讲过使用 <code>cat less more</code> 可以查看文件内容，但是压缩文件的内容是不能使用这些命令进行查看的，而要使用 <code>zcat、zless、zmore</code> 进行查看。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zcat archive.tar.gz</span><br></pre></td></tr></table></figure><h3 id="zip-x2F-unzip"><a href="#zip-x2F-unzip" class="headerlink" title="zip&#x2F;unzip"></a>zip&#x2F;unzip</h3><p>“ 压缩&#x2F;解压 “ <code>zip</code> 文件（ <code>zip</code> 压缩文件一般来自 <code>windows</code> 操作系统）。</p><h4 id="命令安装"><a href="#命令安装" class="headerlink" title="命令安装"></a>命令安装</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># Red Hat 一族中的安装方式</span><br><span class="line">yum install zip </span><br><span class="line">yum install unzip </span><br></pre></td></tr></table></figure><h4 id="基础用法-1"><a href="#基础用法-1" class="headerlink" title="基础用法"></a>基础用法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">unzip archive.zip # 解压 .zip 文件</span><br><span class="line">unzip -l archive.zip # 不解开 .zip 文件，只看其中内容</span><br><span class="line"></span><br><span class="line">zip -r sort.zip sort/ # 将sort文件夹压缩为 sort.zip，其中-r表示递归</span><br></pre></td></tr></table></figure><h2 id="编译安装软件"><a href="#编译安装软件" class="headerlink" title="编译安装软件"></a>编译安装软件</h2><p>之前我们学会了使用 <code>yum</code> 命令进行软件安装，如果碰到 <code>yum</code> 仓库中没有的软件，我们就需要会更高级的软件安装 “ 源码编译安装 “。</p><h3 id="编译安装"><a href="#编译安装" class="headerlink" title="编译安装"></a>编译安装</h3><p>简单来说，编译就是将程序的源代码转换成可执行文件的过程。大多数 <code>Linux</code> 的程序都是开放源码的，可以编译成适合我们的电脑和操纵系统属性的可执行文件。</p><p>基本步骤如下：</p><ol><li><p>下载源代码</p></li><li><p>解压压缩包</p></li><li><p>配置</p></li><li><p>编译</p></li><li><p>安装</p></li></ol><h4 id="实际案例"><a href="#实际案例" class="headerlink" title="实际案例"></a>实际案例</h4><h5 id="1、下载"><a href="#1、下载" class="headerlink" title="1、下载"></a>1、下载</h5><p>我们来编译安装 <code>htop</code> 软件，首先在它的官网下载源码：<a href="https://bintray.com/htop/source/htop#files">https://bintray.com/htop/source/htop#files</a></p><p>下载好的源码在本机电脑上使用如下命令同步到服务器上：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">scp 文件名 用户名@服务器ip:目标路径</span><br><span class="line"></span><br><span class="line">scp ~/Desktop/htop-<span class="number">3.0</span><span class="number">.0</span>.tar.gz root@<span class="number">121.42</span><span class="number">.11</span><span class="number">.34</span>:.</span><br></pre></td></tr></table></figure><p>也可以使用 <code>wegt</code> 进行下载：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wegt+下载地址</span><br><span class="line"></span><br><span class="line">wegt https:<span class="comment">//bintray.com/htop/source/download_file?file_path=htop-3.0.0.tar.gz</span></span><br></pre></td></tr></table></figure><h5 id="2、解压文件"><a href="#2、解压文件" class="headerlink" title="2、解压文件"></a>2、解压文件</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf htop-<span class="number">3.0</span><span class="number">.0</span>.tar.gz # 解压</span><br><span class="line"></span><br><span class="line">cd htop-<span class="number">3.0</span><span class="number">.0</span> # 进入目录</span><br></pre></td></tr></table></figure><h5 id="3、配置"><a href="#3、配置" class="headerlink" title="3、配置"></a>3、配置</h5><p>执行 <code>./configure</code> ，它会分析你的电脑去确认编译所需的工具是否都已经安装了。</p><h5 id="4、编译"><a href="#4、编译" class="headerlink" title="4、编译"></a>4、编译</h5><p>执行 <code>make</code> 命令</p><h5 id="5、安装"><a href="#5、安装" class="headerlink" title="5、安装"></a>5、安装</h5><p>执行 <code>make install</code> 命令，安装完成后执行 <code>ls /usr/local/bin/</code> 查看是否有 <code>htop</code> 命令。如果有就可以执行 <code>htop</code> 命令查看系统进程了。</p><h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><h3 id="ifconfig"><a href="#ifconfig" class="headerlink" title="ifconfig"></a>ifconfig</h3><p>查看 <code>ip</code> 网络相关信息，如果命令不存在的话， 执行命令 <code>yum install net-tools</code> 安装。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[root<span class="meta">@lion</span> ~]# ifconfig</span><br><span class="line"></span><br><span class="line">eth0: flags=<span class="number">4163</span>&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu <span class="number">1500</span></span><br><span class="line">        inet <span class="number">172.31</span><span class="number">.24</span><span class="number">.78</span>  netmask <span class="number">255.255</span><span class="number">.240</span><span class="number">.0</span>  broadcast <span class="number">172.31</span><span class="number">.31</span><span class="number">.255</span></span><br><span class="line">        ether <span class="number">00</span>:<span class="number">16</span>:3e:<span class="number">04</span>:9c:cd  txqueuelen <span class="number">1000</span>  (Ethernet)</span><br><span class="line">        RX packets <span class="number">1592318</span>  bytes <span class="number">183722250</span> (<span class="number">175.2</span> MiB)</span><br><span class="line">        RX errors <span class="number">0</span>  dropped <span class="number">0</span>  overruns <span class="number">0</span>  frame <span class="number">0</span></span><br><span class="line">        TX packets <span class="number">1539361</span>  bytes <span class="number">154044090</span> (<span class="number">146.9</span> MiB)</span><br><span class="line">        TX errors <span class="number">0</span>  dropped <span class="number">0</span> overruns <span class="number">0</span>  carrier <span class="number">0</span>  collisions <span class="number">0</span></span><br><span class="line"></span><br><span class="line">lo: flags=<span class="number">73</span>&lt;UP,LOOPBACK,RUNNING&gt;  mtu <span class="number">65536</span></span><br><span class="line">        inet <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>  netmask <span class="number">255.0</span><span class="number">.0</span><span class="number">.0</span></span><br><span class="line">        loop  txqueuelen <span class="number">1000</span>  (Local Loopback)</span><br><span class="line">        RX packets <span class="number">0</span>  bytes <span class="number">0</span> (<span class="number">0.0</span> B)</span><br><span class="line">        RX errors <span class="number">0</span>  dropped <span class="number">0</span>  overruns <span class="number">0</span>  frame <span class="number">0</span></span><br><span class="line">        TX packets <span class="number">0</span>  bytes <span class="number">0</span> (<span class="number">0.0</span> B)</span><br><span class="line">        TX errors <span class="number">0</span>  dropped <span class="number">0</span> overruns <span class="number">0</span>  carrier <span class="number">0</span>  collisions <span class="number">0</span></span><br></pre></td></tr></table></figure><p>参数解析：</p><ul><li><code>eth0</code> 对应有线连接（对应你的有线网卡），就是用网线来连接的上网。<code>eth</code> 是 <code>Ethernet</code> 的缩写，表示 “ 以太网 “。有些电脑可能同时有好几条网线连着，例如服务器，那么除了 <code>eht0</code> ，你还会看到 <code>eth1</code> 、 <code>eth2</code> 等。</li><li><code>lo</code> 表示本地回环（ <code>Local Loopback</code> 的缩写，对应一个虚拟网卡）可以看到它的 <code>ip</code> 地址是 <code>127.0.0.1</code> 。每台电脑都应该有这个接口，因为它对应着 “ 连向自己的链接 “。这也是被称之为 “ 本地回环 “ 的原因。所有经由这个接口发送的东西都会回到你自己的电脑。看起来好像并没有什么用，但有时为了某些缘故，我们需要连接自己。例如用来测试一个网络程序，但又不想让局域网或外网的用户查看，只能在此台主机上运行和查看所有的网络接口。例如在我们启动一个前端工程时，在浏览器输入 <code>127.0.0.1:3000</code> 启动项目就能查看到自己的 <code>web</code> 网站，并且它只有你能看到。</li><li><code>wlan0</code> 表示无线局域网（上面案例并未展示）。</li></ul><h3 id="host"><a href="#host" class="headerlink" title="host"></a>host</h3><p><code>ip</code> 地址和主机名的互相转换。</p><h4 id="软件安装"><a href="#软件安装" class="headerlink" title="软件安装"></a>软件安装</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install bind-utils</span><br></pre></td></tr></table></figure><h4 id="基础用法-2"><a href="#基础用法-2" class="headerlink" title="基础用法"></a>基础用法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root<span class="meta">@lion</span> ~]# host github.com</span><br><span class="line">baidu.com has address <span class="number">13.229</span><span class="number">.188</span><span class="number">.59</span></span><br><span class="line"> </span><br><span class="line">[root<span class="meta">@lion</span> ~]# host <span class="number">13.229</span><span class="number">.188</span><span class="number">.59</span></span><br><span class="line"><span class="number">59.188</span><span class="number">.229</span><span class="number">.13</span>.in-addr.arpa domain name pointer ec2-<span class="number">13</span>-<span class="number">229</span>-<span class="number">188</span>-<span class="number">59.</span>ap-southeast-<span class="number">1.</span>compute.amazonaws.com.</span><br></pre></td></tr></table></figure><h3 id="ssh-连接远程服务器"><a href="#ssh-连接远程服务器" class="headerlink" title="ssh 连接远程服务器"></a>ssh 连接远程服务器</h3><p>通过非对称加密以及对称加密的方式（同 <code>HTTPS</code> 安全连接原理相似）连接到远端服务器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ssh 用户<span class="meta">@ip</span>:port</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>、ssh root@<span class="number">172.20</span><span class="number">.10</span><span class="number">.1</span>:<span class="number">22</span> # 端口号可以省略不写，默认是<span class="number">22</span>端口</span><br><span class="line"><span class="number">2</span>、输入连接密码后就可以操作远端服务器了</span><br></pre></td></tr></table></figure><h4 id="配置-ssh"><a href="#配置-ssh" class="headerlink" title="配置 ssh"></a>配置 ssh</h4><p><code>config</code> 文件可以配置 <code>ssh</code> ，方便批量管理多个 <code>ssh</code> 连接。</p><p>配置文件分为以下几种：</p><ul><li>全局 <code>ssh</code> 服务端的配置：<code>/etc/ssh/sshd_config</code> ；</li><li>全局 <code>ssh</code> 客户端的配置：<code>/etc/ssh/ssh_config</code>（很少修改）；</li><li>当前用户 <code>ssh</code> 客户端的配置：<code>~/.ssh/config</code> 。</li></ul><p>【服务端 <code>config</code> 文件的常用配置参数】</p><table><thead><tr><th>服务端 config 参数</th><th>作用</th></tr></thead><tbody><tr><td>Port</td><td>sshd 服务端口号（默认是 22）</td></tr><tr><td>PermitRootLogin</td><td>是否允许以 root 用户身份登录（默认是可以）</td></tr><tr><td>PasswordAuthentication</td><td>是否允许密码验证登录（默认是可以）</td></tr><tr><td>PubkeyAuthentication</td><td>是否允许公钥验证登录（默认是可以）</td></tr><tr><td>PermitEmptyPasswords</td><td>是否允许空密码登录（不安全，默认不可以）</td></tr></tbody></table><p>[注意] 修改完服务端配置文件需要重启服务 <code>systemctl restart sshd</code></p><p>【客户端 <code>config</code> 文件的常用配置参数】</p><table><thead><tr><th>客户端 config 参数</th><th>作用</th></tr></thead><tbody><tr><td>Host</td><td>别名</td></tr><tr><td>HostName</td><td>远程主机名（或 IP 地址）</td></tr><tr><td>Port</td><td>连接到远程主机的端口</td></tr><tr><td>User</td><td>用户名</td></tr></tbody></table><p>配置当前用户的 <code>config</code> ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 创建config</span><br><span class="line">vim ~/.ssh/config</span><br><span class="line"></span><br><span class="line"># 填写一下内容</span><br><span class="line">Host lion # 别名</span><br><span class="line"> HostName <span class="number">172.</span>x.x.x # ip 地址</span><br><span class="line">  Port <span class="number">22</span> # 端口</span><br><span class="line">  User root # 用户</span><br></pre></td></tr></table></figure><p>这样配置完成后，下次登录时，可以这样登录 <code>ssh lion</code> 会自动识别为 <code>root</code> 用户。</p><p>[注意] 这段配置不是在服务器上，而是你自己的机器上，它仅仅是设置了一个别名。</p><h4 id="免密登录"><a href="#免密登录" class="headerlink" title="免密登录"></a>免密登录</h4><p><code>ssh</code> 登录分两种，一种是基于口令（账号密码），另外一种是基于密钥的方式。</p><p>基于口令，就是每次登录输入账号和密码，显然这样做是比较麻烦的，今天主要学习如何基于密钥实现免密登录。</p><h5 id="基于密钥验证原理"><a href="#基于密钥验证原理" class="headerlink" title="基于密钥验证原理"></a>基于密钥验证原理</h5><p>客户机生成密钥对（公钥和私钥），把公钥上传到服务器，每次登录会与服务器的公钥进行比较，这种验证登录的方法更加安全，也被称为 “ 公钥验证登录 “。</p><h5 id="具体实现步骤"><a href="#具体实现步骤" class="headerlink" title="具体实现步骤"></a>具体实现步骤</h5><p>1、在客户机中生成密钥对（公钥和私钥） <code>ssh-keygen</code>（默认使用 RSA 非对称加密算法）</p><p>运行完 <code>ssh-keygen</code> 会在 <code>~/.ssh/</code> 目录下，生成两个文件：</p><ul><li><code>id_rsa.pub</code> ：公钥</li><li><code>id_rsa</code> ：私钥</li></ul><p>2、把客户机的公钥传送到服务</p><p>执行 <code>ssh-copy-id root@172.x.x.x</code>（<code>ssh-copy-id</code> 它会把客户机的公钥追加到服务器 <code>~/.ssh/authorized_keys</code> 的文件中）。</p><p>执行完成后，运行 <code>ssh root@172.x.x.x</code> 就可以实现免密登录服务器了。</p><p>配合上面设置好的别名，直接执行 <code>ssh lion</code> 就可以登录，是不是非常方便。</p><h3 id="wget"><a href="#wget" class="headerlink" title="wget"></a>wget</h3><p>可以使我们直接从终端控制台下载文件，只需要给出文件的 HTTP 或 FTP 地址。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wget [参数][URL地址]</span><br><span class="line"></span><br><span class="line">wget http:<span class="comment">//www.minjieren.com/wordpress-3.1-zh_CN.zip</span></span><br></pre></td></tr></table></figure><p><code>wget</code> 非常稳定，如果是由于网络原因下载失败， <code>wget</code> 会不断尝试，直到整个文件下载完毕。</p><h4 id="常用参数-7"><a href="#常用参数-7" class="headerlink" title="常用参数"></a>常用参数</h4><ul><li><code>-c</code> 继续中断的下载。</li></ul><h2 id="备份"><a href="#备份" class="headerlink" title="备份"></a>备份</h2><h3 id="scp"><a href="#scp" class="headerlink" title="scp"></a>scp</h3><p>它是 <code>Secure Copy</code> 的缩写，表示安全拷贝。<code>scp</code> 可以使我们通过网络，把文件从一台电脑拷贝到另一台电脑。</p><p><code>scp</code> 是基于 <code>ssh</code> 的原理来运作的， <code>ssh</code> 会在两台通过网络连接的电脑之间创建一条安全通信的管道， <code>scp</code> 就利用这条管道安全地拷贝文件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp source_file destination_file # source_file 表示源文件，destination_file 表示目标文件</span><br></pre></td></tr></table></figure><p>其中 <code>source_file</code> 和 <code>destination_file</code> 都可以这样表示：<code>user@ip:file_name</code> ， <code>user</code> 是登录名， <code>ip</code> 是域名或 <code>ip</code> 地址。<code>file_name</code> 是文件路径。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scp file.txt root@<span class="number">192.168</span><span class="number">.1</span><span class="number">.5</span>:/root # 表示把我的电脑中当前文件夹下的 file.txt 文件拷贝到远程电脑</span><br><span class="line">scp root@<span class="number">192.168</span><span class="number">.1</span><span class="number">.5</span>:/root/file.txt file.txt # 表示把远程电脑上的 file.txt 文件拷贝到本机</span><br></pre></td></tr></table></figure><h3 id="rsync"><a href="#rsync" class="headerlink" title="rsync"></a>rsync</h3><p><code>rsync</code> 命令主要用于远程同步文件。它可以同步两个目录，不管它们是否处于同一台电脑。它应该是最常用于 “ 增量备份 “ 的命令了。它就是智能版的 <code>scp</code> 命令。</p><h4 id="软件安装-1"><a href="#软件安装-1" class="headerlink" title="软件安装"></a>软件安装</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install rsync</span><br></pre></td></tr></table></figure><h4 id="基础用法-3"><a href="#基础用法-3" class="headerlink" title="基础用法"></a>基础用法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rsync -arv Images/ backups/ # 将Images 目录下的所有文件备份到 backups 目录下</span><br><span class="line">rsync -arv Images/ root@<span class="number">192.</span>x.x.x:backups/ # 同步到服务器的backups目录下</span><br></pre></td></tr></table></figure><h4 id="常用参数-8"><a href="#常用参数-8" class="headerlink" title="常用参数"></a>常用参数</h4><ul><li><code>-a</code> 保留文件的所有信息，包括权限，修改日期等；</li><li><code>-r</code> 递归调用，表示子目录的所有文件也都包括；</li><li><code>-v</code> 冗余模式，输出详细操作信息。</li></ul><p>默认地， <code>rsync</code> 在同步时并不会删除目标目录的文件，例如你在源目录中删除一个文件，但是用 <code>rsync</code> 同步时，它并不会删除同步目录中的相同文件。如果向删除也可以这么做：<code>rsync -arv --delete Images/ backups/</code> 。</p><h2 id="系统"><a href="#系统" class="headerlink" title="系统"></a>系统</h2><h3 id="halt"><a href="#halt" class="headerlink" title="halt"></a>halt</h3><p>关闭系统，需要 <code>root</code> 身份。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">halt</span><br></pre></td></tr></table></figure><h3 id="reboot"><a href="#reboot" class="headerlink" title="reboot"></a>reboot</h3><p>重启系统，需要 <code>root</code> 身份。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reboot</span><br></pre></td></tr></table></figure><h3 id="poweroff"><a href="#poweroff" class="headerlink" title="poweroff"></a>poweroff</h3><p>直接运行即可关机，不需要 <code>root</code> 身份。</p>]]></content>
      
      
      <categories>
          
          <category> 系统 </category>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>解决方案-docker</title>
      <link href="/posts/%E7%B3%BB%E7%BB%9F/Docker/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88-docker.html"/>
      <url>/posts/%E7%B3%BB%E7%BB%9F/Docker/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88-docker.html</url>
      
        <content type="html"><![CDATA[<h1 id="Docker-内程序如何访问宿主机的端口"><a href="#Docker-内程序如何访问宿主机的端口" class="headerlink" title="Docker 内程序如何访问宿主机的端口"></a>Docker 内程序如何访问宿主机的端口</h1><p>请在你的 <code>docker-compose.yml</code> 的服务中加上</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">extra_hosts:</span>  </span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;host.docker.internal:host-gateway&quot;</span></span><br></pre></td></tr></table></figure><p>例如</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3.5&#x27;</span>  </span><br><span class="line">  </span><br><span class="line"><span class="attr">services:</span>  </span><br><span class="line">  <span class="attr">hello-api:</span>  </span><br><span class="line">    <span class="attr">build:</span>  </span><br><span class="line">      <span class="attr">context:</span> <span class="string">.</span>  </span><br><span class="line">      <span class="attr">dockerfile:</span> <span class="string">hello/Dockerfile</span>  </span><br><span class="line">    <span class="attr">environment:</span>  </span><br><span class="line">      <span class="bullet">-</span> <span class="string">TZ=Asia/Shanghai</span>  </span><br><span class="line">    <span class="attr">privileged:</span> <span class="literal">true</span>  </span><br><span class="line">    <span class="attr">volumes:</span>  </span><br><span class="line">      <span class="bullet">-</span> <span class="string">./etc:/app/etc</span>  </span><br><span class="line">    <span class="attr">ports:</span>  </span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;8888:8888&quot;</span>  </span><br><span class="line">    <span class="attr">stdin_open:</span> <span class="literal">true</span>  </span><br><span class="line">    <span class="attr">tty:</span> <span class="literal">true</span>  </span><br><span class="line">    <span class="attr">extra_hosts:</span>  </span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;host.docker.internal:host-gateway&quot;</span></span><br></pre></td></tr></table></figure><p>来源：<a href="https://stackoverflow.com/questions/70505750/lookup-host-docker-internal-no-such-host">mongodb - lookup host.docker.internal: no such host - Stack Overflow</a></p>]]></content>
      
      
      <categories>
          
          <category> 系统 </category>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机/编程工具/docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>资源</title>
      <link href="/posts/%E5%BD%92%E6%A1%A3/%E8%B5%84%E6%BA%90.html"/>
      <url>/posts/%E5%BD%92%E6%A1%A3/%E8%B5%84%E6%BA%90.html</url>
      
        <content type="html"><![CDATA[<h1 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h1><ul><li><a href="https://t.bilibili.com/818168768566919224">电锯人黑白</a></li><li><a href="https://www.pexels.com/zh-cn/">免费素材图片 (pexels.com)</a></li></ul><h1 id="视频制作"><a href="#视频制作" class="headerlink" title="视频制作"></a>视频制作</h1><ul><li><a href="https://www.lookae.com/">LookAE.com-大众脸影视后期特效</a></li></ul><h1 id="推荐技术-UP-主"><a href="#推荐技术-UP-主" class="headerlink" title="推荐技术 UP 主"></a>推荐技术 UP 主</h1><ul><li>《深入理解计算机系统原理 CSAPP》 <a href="https://space.bilibili.com/4564101/">yaaangmin</a></li><li>C++ 协程 <a href="https://space.bilibili.com/35186937/?spm_id_from=333.999.0.0">等疾风</a></li><li>数据库论文 <a href="https://space.bilibili.com/629605267/">Gauss松鼠会</a></li><li>操作系统 <a href="https://space.bilibili.com/202224425/">绿导师原谅你了</a> 南大老师</li><li>分布式系统 <a href="https://space.bilibili.com/474662253?spm_id_from=333.337.search-card.all.click">算法主义</a> 南大老师</li><li>算法与数据结构 <a href="https://space.bilibili.com/7836741/">大雪菜</a></li><li>LeetCode 周赛 <a href="https://space.bilibili.com/206214/">灵茶山艾府</a></li><li>分布式数据库 <a href="https://space.bilibili.com/30933812/">木鸟杂记</a></li><li>Linux 网络编程 <a href="https://space.bilibili.com/319250589/">jaydenwen123</a></li><li>levelDB、存储、分布式论文 <a href="https://space.bilibili.com/1324259795?spm_id_from=333.337.0.0">硬核课堂</a></li><li>C++11&#x2F;kotlin <a href="https://space.bilibili.com/28615855?spm_id_from=333.337.search-card.all.click">bennyhuo不是算命的</a></li><li>CS 144 计算机网络 lab <a href="https://space.bilibili.com/16765968">阿苏EEer</a></li><li>编程知识 <a href="https://space.bilibili.com/372313671?spm_id_from=333.337.0.0">奇乐编程学院</a></li><li>分布式数据库 <a href="https://space.bilibili.com/61981458?spm_id_from=333.337.0.0">戌米的论文笔记</a></li></ul><h1 id="面经"><a href="#面经" class="headerlink" title="面经"></a>面经</h1><ul><li><a href="https://mp.weixin.qq.com/s/rJDkduDYl2lE0Za4f3GuHg">拿下鹅厂一面！ (qq.com)</a></li><li><a href="https://mp.weixin.qq.com/s/9YNaFDSfKJqF_vmttjHYyg">奇安信C++面经，问的很奇怪。。 (qq.com)</a><br>《【起风了，唯有努力生存】一个本硕非科班码农的后台开发之路》 <a href="https://www.yuque.com/docs/share/37b016b5-4877-4611-bb4b-08ced4e3cc89">https://www.yuque.com/docs/share/37b016b5-4877-4611-bb4b-08ced4e3cc89</a><br>《ACMer 渣铜的秋招总结与经验分享》<br><a href="https://www.yuque.com/docs/share/098ec555-c825-459b-94cd-f150cf6177c6">https://www.yuque.com/docs/share/098ec555-c825-459b-94cd-f150cf6177c6</a><br>《字节校招后端 C 面经》<br><a href="https://www.yuque.com/docs/share/d913dc0d-336c-408e-870e-0ba8fcc648c7">https://www.yuque.com/docs/share/d913dc0d-336c-408e-870e-0ba8fcc648c7</a><br>《国际化电商客户端提前批 1,2,3 面面经 (已凉)》<br><a href="https://www.yuque.com/docs/share/19c50f7e-176b-4dd9-abe9-3d0c4a29fd8e">https://www.yuque.com/docs/share/19c50f7e-176b-4dd9-abe9-3d0c4a29fd8e</a><br>《字节跳动七面面经 (提前批 3 轮，实习 4 轮)》<br><a href="https://www.yuque.com/docs/share/a5753e11-6157-4153-a9c7-af5f18dc6948">https://www.yuque.com/docs/share/a5753e11-6157-4153-a9c7-af5f18dc6948</a><br>《字节跳动 C 系统工程师春招面经》<br><a href="https://www.yuque.com/docs/share/e7bfd04c-8f94-437c-8ea6-d4841693d039">https://www.yuque.com/docs/share/e7bfd04c-8f94-437c-8ea6-d4841693d039</a><br>《字节跳动五轮技术面终于收获意向书（后端开发）》<br><a href="https://www.yuque.com/docs/share/d3337287-f5f7-43b7-b9e7-3318e5675c8c">https://www.yuque.com/docs/share/d3337287-f5f7-43b7-b9e7-3318e5675c8c</a><br> 《字节跳动教育后端春招面经》<br><a href="https://www.yuque.com/docs/share/42dfd66d-b981-4953-8284-bb301c3a15ad">https://www.yuque.com/docs/share/42dfd66d-b981-4953-8284-bb301c3a15ad</a><br>《字节跳动基础架构 C 一面二面三面》<br><a href="https://www.yuque.com/docs/share/def11acb-d36a-462d-9b13-0982be6cfafd">https://www.yuque.com/docs/share/def11acb-d36a-462d-9b13-0982be6cfafd</a><br>《字节后端提前批 - 业务研发（C）1、2、3 面面经，已意向》 <a href="https://www.yuque.com/docs/share/f5203921-d81f-404e-9495-d6d8bd06eaab">https://www.yuque.com/docs/share/f5203921-d81f-404e-9495-d6d8bd06eaab</a><br>《字节跳动后端一二三面 _ 笔经》<br><a href="https://www.yuque.com/docs/share/5ea492b4-964f-4749-9ca8-c52c4ee31074">https://www.yuque.com/docs/share/5ea492b4-964f-4749-9ca8-c52c4ee31074</a><br>《字节跳动 C 客户端一二三面 hr 面 820 已 OC》<br><a href="https://www.yuque.com/docs/share/abdb2590-2a27-4460-9805-dd5a53a7bffc">https://www.yuque.com/docs/share/abdb2590-2a27-4460-9805-dd5a53a7bffc</a><br>《字节提前批国际化电商后端一面二面三面已 oc+ 意向书》<br><a href="https://www.yuque.com/docs/share/17ca820e-76ae-498a-945b-a8bbad5f12bf">https://www.yuque.com/docs/share/17ca820e-76ae-498a-945b-a8bbad5f12bf</a><br>《字节跳动 C 后端今日头条校招》<br><a href="https://www.yuque.com/docs/share/2223791a-ee2a-480a-a046-adcd8f83e97f">https://www.yuque.com/docs/share/2223791a-ee2a-480a-a046-adcd8f83e97f</a><br>《字节跳动电商后端一二三面面经（已意向书）》<br><a href="https://www.yuque.com/docs/share/39693ebe-4eac-4b2c-999e-e515bc3e7d50">https://www.yuque.com/docs/share/39693ebe-4eac-4b2c-999e-e515bc3e7d50</a><br>《字节客户端一二三面（已 OC）》<br><a href="https://www.yuque.com/docs/share/f6d9a46a-8b42-4323-9a26-c9cd772ab154">https://www.yuque.com/docs/share/f6d9a46a-8b42-4323-9a26-c9cd772ab154</a><br>《字节教育 (上海) C++ 一二三面面经 (已 offer)》<br><a href="https://www.yuque.com/docs/share/6aba31b2-f97e-4554-98b5-d1a1390def18">https://www.yuque.com/docs/share/6aba31b2-f97e-4554-98b5-d1a1390def18</a><br>《字节技术中台后端三面面经 (许愿 hr 面)》<br><a href="https://www.yuque.com/docs/share/ccad5e61-003e-400c-94e3-c39953c0bee1">https://www.yuque.com/docs/share/ccad5e61-003e-400c-94e3-c39953c0bee1</a><br>《字节抖音后端一二三面 (已 OC)》<br><a href="https://www.yuque.com/docs/share/ee5ac591-4d9c-4c6f-bc8f-de090f0a8cfc">https://www.yuque.com/docs/share/ee5ac591-4d9c-4c6f-bc8f-de090f0a8cfc</a><br>《春招面经，许愿上岸》<br><a href="https://www.yuque.com/docs/share/3354aa55-b413-4a32-abef-bcee152623c4">https://www.yuque.com/docs/share/3354aa55-b413-4a32-abef-bcee152623c4</a><br>《2022 字节跳动提前批四轮面试 (已完结)》<br><a href="https://www.yuque.com/docs/share/bdade855-779d-4472-b117-26e8f71b348a">https://www.yuque.com/docs/share/bdade855-779d-4472-b117-26e8f71b348a</a><br>《【字节国际化电商后端】123 面》<br><a href="https://www.yuque.com/docs/share/5d68bb91-5488-4cbd-a659-66b563c39ded">https://www.yuque.com/docs/share/5d68bb91-5488-4cbd-a659-66b563c39ded</a></li></ul><h1 id="面试利器"><a href="#面试利器" class="headerlink" title="面试利器"></a>面试利器</h1><h2 id="前短时间分享了一个能在面试中增加面试官印象分的利器，也就是红黑树"><a href="#前短时间分享了一个能在面试中增加面试官印象分的利器，也就是红黑树" class="headerlink" title="前短时间分享了一个能在面试中增加面试官印象分的利器，也就是红黑树"></a>前短时间分享了一个能在面试中增加面试官印象分的利器，也就是红黑树</h2><p><a href="https://www.yuque.com/docs/share/38cc330f-1646-4fb5-96a4-5fad3acad0b3">https://www.yuque.com/docs/share/38cc330f-1646-4fb5-96a4-5fad3acad0b3</a></p><h2 id="今天再分享一个-C-开发者比较适合的一个利器，也是源码系列的研究！并且和-Web-服务器搭配一起使用很好使！"><a href="#今天再分享一个-C-开发者比较适合的一个利器，也是源码系列的研究！并且和-Web-服务器搭配一起使用很好使！" class="headerlink" title="今天再分享一个 C++ 开发者比较适合的一个利器，也是源码系列的研究！并且和 Web 服务器搭配一起使用很好使！"></a>今天再分享一个 C++ 开发者比较适合的一个利器，也是源码系列的研究！并且和 Web 服务器搭配一起使用很好使！</h2><p>要说难，还是有点难的；可绝对值得研究，如果有看过我简历的朋友可能会记得我简历上有这么一句话：对 Linux 下的 I&#x2F;O 复用有深刻理解<br>其实这里说的 IO 多路复用主要指的就是 select、poll、epoll 这几个关键字。<br>以下是文章全部内容：<a href="https://www.yuque.com/docs/share/2a66768a-2fcf-486f-bbd5-37347da69ad5">https://www.yuque.com/docs/share/2a66768a-2fcf-486f-bbd5-37347da69ad5</a></p><h2 id="前人给你留下的-15-条-CS-校招金玉良言"><a href="#前人给你留下的-15-条-CS-校招金玉良言" class="headerlink" title="前人给你留下的 15 条 CS 校招金玉良言"></a>前人给你留下的 15 条 CS 校招金玉良言</h2><p>全文链接：<a href="https://www.yuque.com/docs/share/c2834829-c84b-4c35-9fc6-948a4d06a2eb">https://www.yuque.com/docs/share/c2834829-c84b-4c35-9fc6-948a4d06a2eb</a></p><h2 id="如何设计一个高性能-x2F-高并发-x2F-高可用-x2F-高可靠-x2F-可扩展的系统"><a href="#如何设计一个高性能-x2F-高并发-x2F-高可用-x2F-高可靠-x2F-可扩展的系统" class="headerlink" title="如何设计一个高性能&#x2F;高并发&#x2F;高可用&#x2F;高可靠&#x2F;可扩展的系统?"></a>如何设计一个高性能&#x2F;高并发&#x2F;高可用&#x2F;高可靠&#x2F;可扩展的系统?</h2><p><a href="https://top.interviewguide.cn/issue/736">InterviewGuide大厂面试真题</a></p><h1 id="学习资源"><a href="#学习资源" class="headerlink" title="学习资源"></a>学习资源</h1><h2 id="从-0-教你写好一份属于自己的简历"><a href="#从-0-教你写好一份属于自己的简历" class="headerlink" title="从 0 教你写好一份属于自己的简历"></a>从 0 教你写好一份属于自己的简历</h2><p>一份合格的简历是怎样的？ 已完结链接：<a href="https://www.yuque.com/docs/share/29d989cc-86e1-48cf-b731-d39030388685">https://www.yuque.com/docs/share/29d989cc-86e1-48cf-b731-d39030388685</a><br>个人信息模块要这么写已完结链接：<a href="https://www.yuque.com/docs/share/526aa724-f87b-43bd-b519-6058537891ec">https://www.yuque.com/docs/share/526aa724-f87b-43bd-b519-6058537891ec</a><br>教育背景模块要这么写已完结链接：<a href="https://www.yuque.com/docs/share/6d1698af-6a68-451f-b95e-496527a8f7cb">https://www.yuque.com/docs/share/6d1698af-6a68-451f-b95e-496527a8f7cb</a><br>专业技能模块要这么写已完结链接：<a href="https://www.yuque.com/docs/share/8d71bc4e-6426-4141-9d44-0710b45205bd">https://www.yuque.com/docs/share/8d71bc4e-6426-4141-9d44-0710b45205bd</a><br>实习经历模块要这么写已完结链接：<a href="https://www.yuque.com/docs/share/f44e4e04-35e1-4b63-ac1c-32fa508f7b49">https://www.yuque.com/docs/share/f44e4e04-35e1-4b63-ac1c-32fa508f7b49</a><br>项目经验模块要这么写已完结链接：<a href="https://www.yuque.com/docs/share/30fd8b4c-ce0d-486f-aacd-bc094d6e7a27">https://www.yuque.com/docs/share/30fd8b4c-ce0d-486f-aacd-bc094d6e7a27</a><br>校园经历模块要这么写已完结链接：<a href="https://www.yuque.com/docs/share/e0ecb501-5879-4676-9da2-e5c1d04a39fe">https://www.yuque.com/docs/share/e0ecb501-5879-4676-9da2-e5c1d04a39fe</a><br>奖项证书模块要这么写已完结链接：<a href="https://www.yuque.com/docs/share/26c7c18e-5d59-45a1-a1c7-e8b895cb9b96">https://www.yuque.com/docs/share/26c7c18e-5d59-45a1-a1c7-e8b895cb9b96</a><br>科研论文模块要这么写已完结链接：<a href="https://www.yuque.com/docs/share/4120ccbd-b4fc-4292-8762-d1dd577ce802">https://www.yuque.com/docs/share/4120ccbd-b4fc-4292-8762-d1dd577ce802</a><br>自我评价模块要这么写已完结链接：<a href="https://www.yuque.com/docs/share/a32f6781-5d9a-4286-8db9-35746b082624">https://www.yuque.com/docs/share/a32f6781-5d9a-4286-8db9-35746b082624</a><br>简历优秀文案&amp;叙述分享已完结链接：<a href="https://www.yuque.com/docs/share/bedc9a5b-4eb1-4166-a8ab-5cb1de7c6e7d">https://www.yuque.com/docs/share/bedc9a5b-4eb1-4166-a8ab-5cb1de7c6e7d</a><br>优秀简历模板分享已完结链接：<a href="https://www.yuque.com/docs/share/d51586de-b3c2-44ed-a409-5aac10b233c0">https://www.yuque.com/docs/share/d51586de-b3c2-44ed-a409-5aac10b233c0</a></p><h2 id="校招面试详细解读（一二三轮技术面-HR-面）"><a href="#校招面试详细解读（一二三轮技术面-HR-面）" class="headerlink" title="校招面试详细解读（一二三轮技术面 + HR 面）"></a>校招面试详细解读（一二三轮技术面 + HR 面）</h2><p>校招大厂技术岗面试基本知识已完结链接：<a href="https://www.yuque.com/docs/share/023e3cea-fc87-4823-9e59-9f6cdee3b32d">https://www.yuque.com/docs/share/023e3cea-fc87-4823-9e59-9f6cdee3b32d</a><br>一轮技术面已完结链接：<a href="https://www.yuque.com/docs/share/9f9545e2-4efa-4a95-9f7f-0a4f78de3f51">https://www.yuque.com/docs/share/9f9545e2-4efa-4a95-9f7f-0a4f78de3f51</a><br>二轮技术面已完结链接：<a href="https://www.yuque.com/docs/share/81d7d11b-fcff-4a37-90fd-ae0dec622ccf">https://www.yuque.com/docs/share/81d7d11b-fcff-4a37-90fd-ae0dec622ccf</a><br>三轮技术面已完结链接：<a href="https://www.yuque.com/docs/share/d7264ba9-0d08-4d3e-b248-e9ce13375949">https://www.yuque.com/docs/share/d7264ba9-0d08-4d3e-b248-e9ce13375949</a><br>交叉面已完结链接：<a href="https://www.yuque.com/docs/share/cf8e8fa9-92ed-4a17-be56-a90cf280d431">https://www.yuque.com/docs/share/cf8e8fa9-92ed-4a17-be56-a90cf280d431</a><br>HR 面详细解读已完结（包括常见回答话术） 链接： <a href="https://www.yuque.com/docs/share/bca09dd9-16f8-43a6-b231-79fdfa5ea084">https://www.yuque.com/docs/share/bca09dd9-16f8-43a6-b231-79fdfa5ea084</a></p><h2 id="全国一二线城市知名互联网公司大盘点"><a href="#全国一二线城市知名互联网公司大盘点" class="headerlink" title="全国一二线城市知名互联网公司大盘点"></a>全国一二线城市知名互联网公司大盘点</h2><p>上海互联网公司盘点（已完结，共 225 家）链接：<a href="https://www.yuque.com/docs/share/49d754e1-b868-46e4-ab02-8e2b153799fc">https://www.yuque.com/docs/share/49d754e1-b868-46e4-ab02-8e2b153799fc</a><br>北京互联网公司盘点（已完结，共 82 家) 链接：<a href="https://www.yuque.com/docs/share/239796b1-bca4-4048-a63d-3e421dd10ea4">https://www.yuque.com/docs/share/239796b1-bca4-4048-a63d-3e421dd10ea4</a><br>杭州互联网公司盘点（已完结，共 101 家） 链接：<a href="https://www.yuque.com/docs/share/dd41eee7-6c88-4659-a21c-9fdf11d1b12e">https://www.yuque.com/docs/share/dd41eee7-6c88-4659-a21c-9fdf11d1b12e</a><br>广州互联网盘点（已完结，共 96 家）链接：<a href="https://www.yuque.com/docs/share/69a6d864-7806-4e4c-84c0-506c543dfc93">https://www.yuque.com/docs/share/69a6d864-7806-4e4c-84c0-506c543dfc93</a><br>深圳互联网盘点 (已完结, 共 108 家)    链接：<a href="https://www.yuque.com/docs/share/ed985935-65a7-489e-82b0-c1e2259ede50">https://www.yuque.com/docs/share/ed985935-65a7-489e-82b0-c1e2259ede50</a><br>武汉互联网盘点（已完结，共 68 家） 链接：<a href="https://www.yuque.com/docs/share/09175e89-382a-4a0c-9299-4f2c2d8c32ae">https://www.yuque.com/docs/share/09175e89-382a-4a0c-9299-4f2c2d8c32ae</a><br>西安互联网盘点（已完结，共 45 家）链接：<a href="https://www.yuque.com/docs/share/7a4fcaf2-81fe-42ba-b1a5-5daa64a41d71">https://www.yuque.com/docs/share/7a4fcaf2-81fe-42ba-b1a5-5daa64a41d71</a><br>济南互联网盘点（已完结，共 14 家）链接：<a href="https://www.yuque.com/docs/share/62be2e0b-5e61-4de5-8d90-706519f1c3bc">https://www.yuque.com/docs/share/62be2e0b-5e61-4de5-8d90-706519f1c3bc</a><br>山东互联网盘点（已完结，共 28 家） 链接 <a href="https://www.yuque.com/docs/share/122f8d61-9876-4160-ba2e-ed56047c9080">https://www.yuque.com/docs/share/122f8d61-9876-4160-ba2e-ed56047c9080</a><br>苏州互联网公司盘点（已完结，共 38 家） 链接：<a href="https://www.yuque.com/docs/share/8a010f17-a528-4068-a577-43d4ca6b9256">https://www.yuque.com/docs/share/8a010f17-a528-4068-a577-43d4ca6b9256</a></p><h2 id="学习路线-amp-项目推荐"><a href="#学习路线-amp-项目推荐" class="headerlink" title="学习路线&amp;项目推荐"></a>学习路线&amp;项目推荐</h2><p>学习路线导读（强烈建议看一看）已完结 <a href="https://www.yuque.com/docs/share/c01a4794-9a04-4adb-ba74-965401399e9d">https://www.yuque.com/docs/share/c01a4794-9a04-4adb-ba74-965401399e9d</a><br>阿秀自己自学 CS 过程中的学习心得 （已完结） <a href="https://www.yuque.com/docs/share/e34d01e9-0b23-4f02-ab17-9353d201a357">https://www.yuque.com/docs/share/e34d01e9-0b23-4f02-ab17-9353d201a357</a><br>C 学习路线（小白求职版）（已完结） <a href="https://www.yuque.com/docs/share/2f0fde4a-1ae5-45f3-90b7-21e81dd4fa76">https://www.yuque.com/docs/share/2f0fde4a-1ae5-45f3-90b7-21e81dd4fa76</a><br>C&#x2F;C 项目推荐已完结共 8 个 <a href="https://www.yuque.com/docs/share/55b9d089-37cc-4060-a0f5-40f018befb85">https://www.yuque.com/docs/share/55b9d089-37cc-4060-a0f5-40f018befb85</a></p><h2 id="读书笔记分享"><a href="#读书笔记分享" class="headerlink" title="读书笔记分享"></a>读书笔记分享</h2><p>《深度探索 C++ 对象模型》读书笔记已完结链接：<a href="https://www.yuque.com/docs/share/e3869134-783f-4179-b641-51a4ee018ae6">https://www.yuque.com/docs/share/e3869134-783f-4179-b641-51a4ee018ae6</a><br>《MySQL 必知必会》读书笔记已完结 <a href="https://www.yuque.com/docs/share/208b1355-f5cc-4feb-8fe7-42e4ff3e1e72">https://www.yuque.com/docs/share/208b1355-f5cc-4feb-8fe7-42e4ff3e1e72</a></p><h1 id="考公"><a href="#考公" class="headerlink" title="考公"></a>考公</h1><ul><li><a href="https://www.nowcoder.com/discuss/361219661281738752">一年半我考了11次公务员，内附考试细节，不看血亏_牛客网 (nowcoder.com)</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 归档 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>使用Azure Open AI</title>
      <link href="/posts/%E7%BD%91%E7%BB%9C/ai/%E4%BD%BF%E7%94%A8Azure%20Open%20AI.html"/>
      <url>/posts/%E7%BD%91%E7%BB%9C/ai/%E4%BD%BF%E7%94%A8Azure%20Open%20AI.html</url>
      
        <content type="html"><![CDATA[<h1 id="申请"><a href="#申请" class="headerlink" title="申请"></a>申请</h1><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://zhuanlan.zhihu.com/p/614242045">分享Azure申请及使用OpenAI的经历 - 知乎 (zhihu.com)</a></p><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>如果是教育邮箱，可以通过 <a href="http://link.zhihu.com/?target=https://azure.microsoft.com/zh-cn/free/students/">这个地址</a> 开通 azure 服务，会多一个 Azure for Students 的订阅，再用这个订阅的 id 再去申请一次 openai 就可以得到 1 年 +100 刀的使用期限，可在该网页查看剩余额度 <a href="https://learn.microsoft.com/zh-cn/azure/cost-management-billing/manage/azurestudents-subscription-disabled">重新激活已禁用的面向学生的 Azure 订阅 - Microsoft Cost Management | Microsoft Learn</a></p><p>此外，可以用微信账号申请一个腾讯企业邮箱，就选最基础的免费版就行了，审批很快，半天时间都不到。</p><h2 id="申请-1"><a href="#申请-1" class="headerlink" title="申请"></a>申请</h2><p>登录 <a href="http://portal.azure.com/">http://portal.azure.com</a> 后，依次查找：所有服务——AI+ 机器学习——认知服务——Azure OpenAI。点击创建，会提示需要提交申请才能使用。<br>可以根据这篇文章来申请<br><a href="https://51.ruyo.net/18402.html">微软Azure申请OpenAI以及部署使用教程 - 如有乐享 (ruyo.net)</a></p><h2 id="开通"><a href="#开通" class="headerlink" title="开通"></a>开通</h2><p>其实早在之前文章中也提到了：<a href="https://51.ruyo.net/18360.html">目前OpenAI账号开通获取高额度方法分享</a></p><p>首先，你需要有一个 Azure。可用是免费试用版，Azure Stu 版，Azure 企业版 等等。</p><p><a href="https://aka.ms/oai/access">申请开通OpenAI</a>&#x2F;<a href="https://aka.ms/oai/get-gpt4">申请GPT-4</a></p><p>第二，申请的时候官方也表明需要用企业邮箱！不用用 gmail，outlook 等</p><p>第三，还需要填写企业官网（官网域名和邮箱域名得一致）</p><p>然后就是看运气了等审核通过了。短的 4 小时，长的可能得几个月。</p><p>部分人审核期间可能需要补充一些资料。也有几个小时就通过的。</p><p>当然了这个申请也是有技巧的。有朋友基本上目前 100% 几小时就通过了。</p><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><h3 id="创建-OpenAI"><a href="#创建-OpenAI" class="headerlink" title="创建 OpenAI"></a>创建 OpenAI</h3><p>1，搜索资源 OpenAI 可找到 Azure OpenAI。点击创建！</p><p>填写信息！名称随意！定价选 S0 区域，可选美国东部（法国和欧洲，看你使用情况可选）</p><p><img src="/../../../img/blog/ad02411904c665a355c1e3dd23cb896c_MD5.jpg" alt="微软Azure申请OpenAI以及部署使用教程"></p><p>2，网络选择所有网络 即可。</p><p>3，标记。没有啥标记的直接下一步！</p><p>4，验证相关信息，验证通过后，直接点击创建即可！</p><p>5，稍等几分钟，部署完成！</p><p><img src="/../../../img/blog/84dfe46ea1f2187b1a81a010c610c775_MD5.jpg" alt="微软Azure申请OpenAI以及部署使用教程"></p><h3 id="记录关键信息"><a href="#记录关键信息" class="headerlink" title="记录关键信息"></a>记录关键信息</h3><p>打开新建的 OpenAI 有几个关键的内容，保存好后面会使用！</p><p>1，终结点 ，如图就是我们专属的接口域名地址</p><p>2，密钥，点击管理密钥可看见密钥内容</p><p><img src="/../../../img/blog/3634349193426f351fb14c307d3dfdc3_MD5.jpg" alt="微软Azure申请OpenAI以及部署使用教程"></p><h3 id="模型部署"><a href="#模型部署" class="headerlink" title="模型部署"></a>模型部署</h3><p>1，点击 模型部署，点击 【管理部署】按钮。浏览器会在当前页面打开模型管理的另一个平台。</p><p><img src="/../../../img/blog/a2079f222dd28cac03e618ae1d756cb2_MD5.jpg" alt="微软Azure申请OpenAI以及部署使用教程"></p><p>2，在 Azure AI 平台中，点击【新建部署】</p><p><img src="/../../../img/blog/178f45db5c416f32e4e5a3df1463113e_MD5.jpg" alt="微软Azure申请OpenAI以及部署使用教程"></p><p>3，这里需要选择模型，以及填写部署名称。</p><p>模型，选择 gpt-35-turbo（如果你有 gpt-4.0，选择这个也行）</p><p><strong>部署名，填写即可。这个部署名后面也会用到！</strong></p><p>高级选项， 可设置 Token 上限，最高支持 240K（酌情选择设置）</p><p>自定义过滤器，按需设置即可</p><p><img src="/../../../img/blog/308ff3dc807d2b80c9321479bd5fe6ef_MD5.jpg" alt="微软Azure申请OpenAI以及部署使用教程"></p><p><img src="/../../../img/blog/29014f630df013de45c8823ed5ed54ec_MD5.jpg" alt="微软Azure申请OpenAI以及部署使用教程"></p><p>4，分分钟创建成功！Azure AI 中也提供了和可以直接聊天的功能，操场设置各类参数。</p><p><img src="/../../../img/blog/4806b1e974ad57d2bb0e0cb4956c4f96_MD5.jpg" alt="微软Azure申请OpenAI以及部署使用教程"></p><p><img src="/../../../img/blog/1a95fb11920c7fa68a55774c5edafac1_MD5.jpg" alt="微软Azure申请OpenAI以及部署使用教程"></p><p>5，体验自带的会话功能。</p><p><img src="/../../../img/blog/50996137e171b1e6a85c596e2f51913f_MD5.jpg" alt="微软Azure申请OpenAI以及部署使用教程"></p><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>Azure OpenAI 和 OpenAI 官方的调用方式基本相似。只有 3 处需要注意。</p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><h3 id="终结点"><a href="#终结点" class="headerlink" title="终结点"></a>终结点</h3><p>OpenAI 官方是 api.openai.com</p><p>Azure OpenAI 则是 ruyo-openai.openai.azure.com （ 每个都不太一样，别直接使用这个哈）</p><h3 id="APIKEY"><a href="#APIKEY" class="headerlink" title="APIKEY"></a>APIKEY</h3><p>OpenAI 官方是是以 sky 开头的一段</p><p>Azure OpenAI 是无规律的一段</p><h3 id="部署名称（Deployment-Name）"><a href="#部署名称（Deployment-Name）" class="headerlink" title="部署名称（Deployment Name）"></a>部署名称（Deployment Name）</h3><p>部署模型时填写的名称</p><h2 id="HTTP-调用"><a href="#HTTP-调用" class="headerlink" title="HTTP 调用"></a>HTTP 调用</h2><p>接口地址：<a href="https://ruyo-openai.openai.azure.com/openai/deployments/ruyo-gpt/chat/completions/?api-version=2023-05-15">https://ruyo-openai.openai.azure.com/openai/deployments/ruyo-gpt/chat/completions/?api-version=2023-05-15</a></p><p>请求方式：POST</p><p>BODY：</p><p>这部分和 OpenAI 基本一致！这里不做太多的介绍！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;messages&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;role&quot;: &quot;system&quot;,</span><br><span class="line">            &quot;content&quot;: &quot;如有乐享博客AI助手&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;role&quot;: &quot;user&quot;,</span><br><span class="line">            &quot;content&quot;: &quot;如有乐享博客怎么样&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/../../../img/blog/2f0d23c4f1057b0dc765bfa04a9cfcd4_MD5.jpg" alt="微软Azure申请OpenAI以及部署使用教程"></p><p>更多其他调用方式，参考官方文档：<a href="https://learn.microsoft.com/zh-cn/azure/cognitive-services/openai/chatgpt-quickstart?tabs=bash&pivots=programming-language-studio">https://learn.microsoft.com/zh-cn/azure/cognitive-services/openai/chatgpt-quickstart?tabs=bash&amp;pivots=programming-language-studio</a></p><h2 id="CloudFlare-代理"><a href="#CloudFlare-代理" class="headerlink" title="CloudFlare 代理"></a>CloudFlare 代理</h2><p>由于大多数互联网产品暂不支持 <code>Azure OpenAI</code> 的调用接口，我们可以使用 <a href="https://link.juejin.cn/?target=https://dash.cloudflare.com/login" title="https://dash.cloudflare.com/login">CloudFlare Workers</a> 进行代理设置。</p><p>首先注册该网站的账户，然后按以下步骤操作：</p><ol><li><p>创建一个 Workers</p></li><li><p>阅读 github 文档 <a href="https://github.com/haibbo/cf-openai-azure-proxy">github.com&#x2F;haibbo&#x2F;cf-o…</a></p></li></ol><h2 id="部署-ChatGPT-Next-Web"><a href="#部署-ChatGPT-Next-Web" class="headerlink" title="部署 ChatGPT-Next-Web"></a>部署 ChatGPT-Next-Web</h2><p><a href="https://github.com/Yidadaa/ChatGPT-Next-Web/issues/371">[Feature] 添加对 Azure OpenAI API 的支持 · Issue #371 · Yidadaa&#x2F;ChatGPT-Next-Web (github.com)</a></p><p>可以根据文档 <a href="https://github.com/Yidadaa/ChatGPT-Next-Web">Yidadaa&#x2F;ChatGPT-Next-Web:   一键拥有你自己的跨平台 ChatGPT 应用。)</a> 在 Vercel 部署 ChatGPT-Next-Web，配置环境变量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BASE_URL：cloudfare worker 部署的URL</span><br><span class="line">OPENAI_API_KEY：在Azure Portal OpenAI 找到 API key，有两个key，用其中一个即可</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>或者搭配 <a href="https://github.com/diemus/azure-openai-proxy">stulzq&#x2F;azure-openai-proxy</a> 使用，可以直接 <code>docker-compose</code> 来启动。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">chatgpt-next-web:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">yidadaa/chatgpt-next-web</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">3000</span><span class="string">:3000</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">OPENAI_API_KEY:</span> <span class="string">&lt;Auzre</span> <span class="string">OpenAI</span> <span class="string">API</span> <span class="string">Key&gt;</span></span><br><span class="line">      <span class="attr">BASE_URL:</span> <span class="string">http://azure-openai:8080</span></span><br><span class="line">      <span class="attr">DISABLE_GPT4:</span> <span class="number">1</span></span><br><span class="line">      <span class="attr">CODE:</span> <span class="string">&quot;password&quot;</span></span><br><span class="line">      <span class="attr">HIDE_BALANCE_QUERY:</span> <span class="number">1</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">azure-openai</span></span><br><span class="line">    <span class="attr">links:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">azure-openai</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">chatgpt-ns</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">azure-openai:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">stulzq/azure-openai-proxy</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">8080</span><span class="string">:8080</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">AZURE_OPENAI_ENDPOINT:</span> <span class="string">&lt;Auzre</span> <span class="string">OpenAI</span> <span class="string">API</span> <span class="string">Endpoint&gt;</span></span><br><span class="line">      <span class="attr">AZURE_OPENAI_MODEL_MAPPER:</span> <span class="string">&lt;Auzre</span> <span class="string">OpenAI</span> <span class="string">API</span> <span class="string">Deployment</span> <span class="string">Mapper&gt;</span></span><br><span class="line">      <span class="attr">AZURE_OPENAI_API_VER:</span> <span class="number">2023-05-15</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">chatgpt-ns</span></span><br><span class="line"></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">chatgpt-ns:</span></span><br><span class="line">    <span class="attr">driver:</span> <span class="string">bridge</span></span><br></pre></td></tr></table></figure><p>启动有 3 个环境变量需要配置：</p><table><thead><tr><th>变量名</th><th>说明</th></tr></thead><tbody><tr><td>OPENAI_API_KEY</td><td>Azure <strong>密钥和终结点</strong> 里提供的 Key</td></tr><tr><td>AZURE_OPENAI_ENDPOINT</td><td>Azure <strong>密钥和终结点</strong> 里提供的终结点</td></tr><tr><td>AZURE_OPENAI_MODEL_MAPPER</td><td>Azure 部署模型名称映射到 OpenAI 官方模型名称</td></tr></tbody></table><p>特别说明一下 <code>AZURE_OPENAI_MODEL_MAPPER</code> 使用 OpenAI 官方标准发起的请求里包含的模型名称是固定的，在这里可以 <a href="https://platform.openai.com/docs/models">查询</a>，而在 Azure OpenAI 模型部署时是可以自定义名称的，请求 Azure yes 需要提供这个部署模型的名称，所以建立了一个映射关系。</p><p>比如我在 Azure 部署了一个 <code>gpt-3.5-turbo</code> 模型，我设置的部署名称为：<code>xc-gpt-35</code>，此时我的设置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">AZURE_OPENAI_MODEL_MAPPER:</span> <span class="string">gpt-3.5-turbo=xc-gpt-35</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 网络 </category>
          
          <category> ai </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>项目软件收藏</title>
      <link href="/posts/%E5%BD%92%E6%A1%A3/%E9%A1%B9%E7%9B%AE%E8%BD%AF%E4%BB%B6%E6%94%B6%E8%97%8F.html"/>
      <url>/posts/%E5%BD%92%E6%A1%A3/%E9%A1%B9%E7%9B%AE%E8%BD%AF%E4%BB%B6%E6%94%B6%E8%97%8F.html</url>
      
        <content type="html"><![CDATA[<h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><h2 id="Github"><a href="#Github" class="headerlink" title="Github"></a>Github</h2><ul><li><a href="https://github.com/localsend/localsend">跨平台无缝传输文件localsend</a></li><li><a href="https://github.com/liyupi/sql-mother">liyupi&#x2F;sql-mother: 免费的闯关式 SQL 自学教程网站</a></li><li><a href="https://www.filebrowser.cn/">filebrowser,功能是可以通过浏览器对服务器上的文件进行管理</a></li><li><a href="https://github.com/vastsa/FileCodeBox/tree/master">vastsa&#x2F;FileCodeBox: 文件快递柜-匿名口令分享文本，文件，像拿快递一样取文件</a></li><li><a href="https://github.com/wmjordan/PDFPatcher">PDF补丁丁——PDF工具箱，可以编辑书签、剪裁旋转页面、解除限制、提取或合并文档，探查文档结构，提取图片、转成图片等等</a></li><li><a href="https://github.com/rememberber/WePush">rememberber&#x2F;WePush: 专注批量推送的小而美的工具</a></li></ul><h2 id="Gitee"><a href="#Gitee" class="headerlink" title="Gitee"></a>Gitee</h2><ul><li><a href="https://gitee.com/zmister/MrDoc">MrDoc: MrDoc觅思文档，适合于个人和中小型团队的在线文档、知识库管理私有化部署方案，全面支持跨平台（Windows、macOS、Linux）和跨终端（Web、PC、手机）同步 (gitee.com)</a></li><li><a href="https://gitee.com/dromara/zyplayer-doc#https://gitee.com/link?target=http%3A%2F%2Fzyplayer.com">zyplayer-doc: zyplayer-doc是一款适合团队和个人私有化部署使用的知识库、笔记、WIKI文档管理工具，同时还包含数据库管理、Api接口管理等模块 (gitee.com)</a></li></ul><h2 id="网页"><a href="#网页" class="headerlink" title="网页"></a>网页</h2><ul><li><a href="https://tuya.xinxiao.tech/">图压 - 简单易用的图片压缩软件 (xinxiao.tech)</a></li><li><a href="https://www.xunjiepdf.com/shipinzhuanwenzi">视频转文字助手 - 专业的视频语音转文字软件 (xunjiepdf.com)</a></li><li><a href="https://github.com/chatanywhere/GPT_API_free">Free ChatGPT API Key，免费ChatGPT API，支持GPT4 API（低价）</a></li></ul><h2 id="docker"><a href="#docker" class="headerlink" title="docker"></a>docker</h2><ul><li><a href="https://hub.grapps.cn/marketplace/apps/1303">it-tools (grapps.cn)</a></li></ul><h2 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h2><ul><li><a href="https://github.com/awesome-selfhosted/awesome-selfhosted">awesome-selfhosted</a></li><li><a href="https://dev.amazoncloud.cn/video/videoList?catagory&col=646de6e699ab8c6709d15323&sortIndex=0&sortId&tagIndex=0&tagId&visitfrom=git">视频-亚马逊云科技开发者社区 (amazoncloud.cn)</a></li></ul><h3 id="memos"><a href="#memos" class="headerlink" title="memos"></a>memos</h3><ul><li><a href="https://zhuanlan.zhihu.com/p/650596106">Memos：私有、轻量、开源、自托管的备忘录 - 知乎 (zhihu.com)</a></li><li><a href="https://www.usememos.com/docs/advanced-settings/cloudflare-r2">Configuring Cloudflare R2 Storage - Memos (usememos.com)</a></li></ul><h1 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h1><ul><li><a href="https://github.com/sogou/workflow">sogou&#x2F;workflow: C++ Parallel Computing and Asynchronous Networking Engine (github.com)</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 归档 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Rust 安装</title>
      <link href="/posts/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Rust%20%E5%AE%89%E8%A3%85.html"/>
      <url>/posts/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Rust%20%E5%AE%89%E8%A3%85.html</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.rust-lang.org/tools/install">https://www.rust-lang.org/tools/install</a></p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机/编程语言/语言环境配置 </tag>
            
            <tag> 计算机/编程语言/rust </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>代码格式化和静态分析检查工作流 Cpp Linter</title>
      <link href="/posts/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/%E4%BB%A3%E7%A0%81%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%92%8C%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90%E6%A3%80%E6%9F%A5%E5%B7%A5%E4%BD%9C%E6%B5%81%20Cpp%20Linter.html"/>
      <url>/posts/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/%E4%BB%A3%E7%A0%81%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%92%8C%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90%E6%A3%80%E6%9F%A5%E5%B7%A5%E4%BD%9C%E6%B5%81%20Cpp%20Linter.html</url>
      
        <content type="html"><![CDATA[<h1 id="Clang-tools-Binaries"><a href="#Clang-tools-Binaries" class="headerlink" title="Clang-tools Binaries"></a>Clang-tools Binaries</h1><p>如果你需要使用 clang-tools binaries，以 Windows 为例，通常下载指定版本的 clang-tools 需要先安装 LLVM 这个大的安装包才能获得 clang-format &amp; clang-tidy 这些工具；在 Linux 上会方便很多，可以使用命令来下载，但如果想下载指定版本的 clang-format &amp; clang-tidy 可能要面临手动下载和安装。</p><p>clang-tools-pip 提供并支持在 Windows，Linux，MacOs 上通过命令行下载任何指定版本的 clang-tools 可执行文件。</p><p>只需要使用 <code>pip</code> 安装 <code>clang-tools</code> （即 <code>pip install clang-tools</code>）后，然后通过 <code>clang-tools</code> 命令就可以安装任何版本的可执行文件了。</p><p>例如，安装 clang-tools 版本 13：<br><code>$ clang-tools --install 13</code><br>也可以将它安装到指定目录下面：<br><code>$ clang-tools --install 13 --directory .</code></p><p><code>clang-tools</code> CLI 还提供了其他选项，比如自动帮你创建链接等，可以查看它的 CLI 文档来获得帮助。<br><a href="https://cpp-linter.github.io/clang-tools-pip/cli_args.html">Command Line Interface Options - clang-tools installer (cpp-linter.github.io)</a></p><h1 id="把-Clang-tools-集成到工作流"><a href="#把-Clang-tools-集成到工作流" class="headerlink" title="把 Clang-tools 集成到工作流"></a>把 Clang-tools 集成到工作流</h1><ol><li><p>cpp-linter-action 提供了通过 CI 进行检查，当发现没有格式化或有诊断错误的代码时 CI 会失败，来防止合并到主分的代码没有通过代码检查；</p></li><li><p>cpp-linter-hooks 通过 git hook 在提交代码的时候自动运行 clang-format 和 clang-tidy，如果不符合规范则提交失败，并提示并自动格式化。</p></li></ol><h1 id="Cpp-linter-action-在代码合并前做自动检查"><a href="#Cpp-linter-action-在代码合并前做自动检查" class="headerlink" title="Cpp-linter-action 在代码合并前做自动检查"></a>Cpp-linter-action 在代码合并前做自动检查</h1><p>如果你使用的是 GitHub，那么非常推荐你使用 cpp-linter-action 这个 GitHub Action。</p><p>以下是它的一些重要特性：</p><ol><li><p>运行结果支持 Annotations 和 Thread Comment 两种方式展示</p></li><li><p>支持 GitHub 的 public 和 private 仓库</p></li><li><p>支持绝大多数 Clang 版本</p></li><li><p>还有很多其他的 optional-inputs<br><a href="https://github.com/cpp-linter/cpp-linter-action#optional-inputs">cpp-linter&#x2F;cpp-linter-action: Lint C&#x2F;C++ code with clang-format and clang-tidy then post annotations, comments, and step summary with results. (github.com)</a></p></li></ol><p>使用这个 Action 只需要在 <code>.github/workflows/</code> 下面创建一个 cpp-linter.yml，内容如下：</p><blockquote><p>当然也可以把下面的配置加到一个已经存在的 Workflow，例如 build。</p></blockquote><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">name:</span> <span class="string">cpp-linter</span>  </span><br><span class="line">  </span><br><span class="line"><span class="attr">on:</span>  </span><br><span class="line">  <span class="attr">pull_request:</span>  </span><br><span class="line">    <span class="string">types:</span> [<span class="string">opened</span>, <span class="string">reopened</span>]  </span><br><span class="line">  <span class="attr">push:</span>  </span><br><span class="line">  </span><br><span class="line"><span class="attr">jobs:</span>  </span><br><span class="line">  <span class="attr">cpp-linter:</span>  </span><br><span class="line">    <span class="string">runs-on:</span> <span class="string">ubuntu-latest</span>  </span><br><span class="line">    <span class="attr">steps:</span>  </span><br><span class="line">      <span class="string">-</span> <span class="string">uses:</span> <span class="string">actions/checkout@v3</span>  </span><br><span class="line">      <span class="string">-</span> <span class="string">uses:</span> <span class="string">cpp-linter/cpp-linter-action@v1</span>  </span><br><span class="line">        <span class="string">id:</span> <span class="string">linter</span>  </span><br><span class="line">        <span class="attr">env:</span>  </span><br><span class="line">          <span class="string">GITHUB_TOKEN:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.GITHUB_TOKEN</span> <span class="string">&#125;&#125;</span>  </span><br><span class="line">        <span class="attr">with:</span>  </span><br><span class="line">          <span class="string">style:</span> <span class="string">file</span>  </span><br><span class="line">  </span><br><span class="line">      <span class="string">-</span> <span class="string">name:</span> <span class="string">Fail</span> <span class="string">fast?!</span>  </span><br><span class="line">        <span class="string">if:</span> <span class="string">steps.linter.outputs.checks-failed</span> <span class="string">&gt;</span> <span class="number">0</span>  </span><br><span class="line">        <span class="string">run:</span> <span class="string">|</span>  </span><br><span class="line">          <span class="string">echo</span> <span class="string">&quot;Some files failed the linting checks!&quot;</span>  </span><br><span class="line">          <span class="string">exit</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><p>如果发现存在没有进行格式化或是静代码态检查，CI workflow 会失败，并且会有如下注释说明，annotations 默认是开启的。</p><p><img src="/../../img/blog/d2442aea62f1dfffc472f6a23b2fa035_MD5.png" alt="图片"></p><p>如果开启了 Thread Comment 选项（即 <code>thread-comments: true</code>）就会将在 Pull Request 中自动添加如下错误评论。</p><p><img src="/../../img/blog/8b0a2ba3494fffa5c66cc83391964abb_MD5.png" alt="图片"></p><h1 id="Cpp-linter-hooks-在提交代码时自动检查"><a href="#Cpp-linter-hooks-在提交代码时自动检查" class="headerlink" title="Cpp-linter-hooks 在提交代码时自动检查"></a>Cpp-linter-hooks 在提交代码时自动检查</h1><p>cpp-linter-hooks 是通过 git hook 在提交代码时做自动检查，这种方式不限制使用任何 SCM。</p><p>只需要在项目仓库中添加一个 <code>.pre-commit-config.yaml</code> 配置文件，然后将 cpp-linter-hooks 这个 hook 添加到 <code>.pre-commit-config.yaml</code> 中，具体设置如下：</p><blockquote><p><code>.pre-commit-config.yaml</code> 是 <code>pre-commit</code> framework 的默认配置文件。</p></blockquote><p> 安装 pre-commit</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install pre-commit</span><br></pre></td></tr></table></figure><p> 创建配置文件 <code>.pre-commit-config.yaml</code>，设置如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">repos:</span></span><br><span class="line"><span class="string">-</span> <span class="string">repo:</span> <span class="string">https://github.com/cpp-linter/cpp-linter-hooks</span></span><br><span class="line">  <span class="string">rev:</span> <span class="string">v0.2.1</span></span><br><span class="line">  <span class="attr">hooks:</span></span><br><span class="line">    <span class="string">-</span> <span class="string">id:</span> <span class="string">clang-format</span></span><br><span class="line">      <span class="string">args:</span> [<span class="string">--style=file</span>]  <span class="comment"># to load .clang-format</span></span><br><span class="line">    <span class="string">-</span> <span class="string">id:</span> <span class="string">clang-tidy</span></span><br><span class="line">      <span class="string">args:</span> [<span class="string">--checks=.clang-tidy</span>] <span class="comment"># path/to/.clang-tidy</span></span><br></pre></td></tr></table></figure><blockquote><p>这里的 file 是指 <code>.clang-format</code>, clang-format 默认支持的编码格式包括 LLVM, GNU, Google, Chromium, Microsoft, Mozilla, WebKit，如果需要特殊设置可以在仓库的根目录下面创建配置文件 <code>.clang-format</code>。同理，如果默认的静态分析设置不满足要求，可以在仓库的根目录下创建 <code>.clang-tidy</code> 配置文件。</p></blockquote><p>更多配置可以参考 <a href="https://github.com/cpp-linter/cpp-linter-hooks">cpp-linter&#x2F;cpp-linter-hooks: C&#x2F;C++ linter hooks for pre-commit (github.com)</a></p><p> 安装 git hook 脚本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ pre-commit install</span><br><span class="line">pre-commit installed at .git/hooks/pre-commit</span><br></pre></td></tr></table></figure><p> 之后每次 <code>git commit</code> 都会自动执行 clang-format 和 chang-tidy。</p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机/编程语言/cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>安装配置</title>
      <link href="/posts/%E7%B3%BB%E7%BB%9F/%E8%99%9A%E6%8B%9F%E6%9C%BA/Vmware%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AEUbuntu.html"/>
      <url>/posts/%E7%B3%BB%E7%BB%9F/%E8%99%9A%E6%8B%9F%E6%9C%BA/Vmware%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AEUbuntu.html</url>
      
        <content type="html"><![CDATA[<h1 id="下载-Ubuntu"><a href="#下载-Ubuntu" class="headerlink" title="下载 Ubuntu"></a>下载 Ubuntu</h1><p><a href="https://mirrors.tuna.tsinghua.edu.cn/ubuntu-releases/">Index of &#x2F;ubuntu-releases&#x2F; | 清华大学开源软件镜像站 | Tsinghua Open Source Mirror</a><br>vmware 安装方法<br><a href="https://blog.csdn.net/trackxiaoxin321/article/details/115591796">(12条消息) 虚拟机ubuntu16.04超详细安装教程（零基础照做即可）_ubuntun16.04 安装虚拟机_LKTracker的博客-CSDN博客</a></p><h1 id="安装-VMware-Tools"><a href="#安装-VMware-Tools" class="headerlink" title="安装 VMware Tools"></a>安装 VMware Tools</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install open-vm-tools-desktop -y</span><br><span class="line">sudo reboot</span><br></pre></td></tr></table></figure><h1 id="换源"><a href="#换源" class="headerlink" title="换源"></a>换源</h1><h2 id="备份文件"><a href="#备份文件" class="headerlink" title="备份文件"></a>备份文件</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo cp /etc/apt/sources.list sources_backup.list</span><br></pre></td></tr></table></figure><h2 id="修改文件"><a href="#修改文件" class="headerlink" title="修改文件"></a>修改文件</h2><p><code>sudo gedit /etc/apt/sources.list</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#清华大学源</span><br><span class="line">deb http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial main restricted</span><br><span class="line">deb http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-updates main restricted</span><br><span class="line">deb http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial universe</span><br><span class="line">deb http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-updates universe</span><br><span class="line">deb http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial multiverse</span><br><span class="line">deb http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-updates multiverse</span><br><span class="line">deb http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-backports main restricted universe multiverse</span><br><span class="line">deb http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-security main restricted</span><br><span class="line">deb http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-security universe</span><br><span class="line">deb http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-security multiverse</span><br></pre></td></tr></table></figure><h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get -f install</span><br><span class="line">sudo apt-get upgrade</span><br></pre></td></tr></table></figure><h1 id="SSH-连接"><a href="#SSH-连接" class="headerlink" title="SSH 连接"></a>SSH 连接</h1><p><a href="https://cloud.tencent.com/developer/article/1679861">windows宿主机如何SSH连接VMware的Linux虚拟机 - 腾讯云开发者社区-腾讯云 (tencent.com)</a></p><h1 id="共享文件夹"><a href="#共享文件夹" class="headerlink" title="共享文件夹"></a>共享文件夹</h1><ol><li><p>在 vmware 中设置共享文件夹<br>即在 VMware workstation 中：虚拟机设置 -》选项 -》共享文件夹，浏览要共享的文件夹，继续按照说明设置即可。</p></li><li><p>在 linux 中链接一下即可<br>第 1 步完成后，共享文件夹已经挂载到了 <code>/mnt/hgfs/share/</code> ,share 是我的共享文件夹的名字，然后在创建一个软连接方便以后访问：</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ln -s /mnt/hgfs/share/ /home/share</span><br></pre></td></tr></table></figure><h2 id="Ubuntu-重启后不显示共享文件夹"><a href="#Ubuntu-重启后不显示共享文件夹" class="headerlink" title="Ubuntu 重启后不显示共享文件夹"></a>Ubuntu 重启后不显示共享文件夹</h2><p>重启 Ubuntu20.04 后，发现共享文件夹进不去也不显示了<br>首先查看共享文件夹是否已经存在并且设置为总是开启<br>使用命令查看当前挂载的共享文件夹</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vmware-hgfsclient</span><br></pre></td></tr></table></figure><p>存在的情况下，然后使用下面命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo /usr/bin/vmhgfs-fuse .host:/ /mnt/hgfs -o subtype=vmhgfs-fuse,allow_other</span><br></pre></td></tr></table></figure><p><a href="https://docs.vmware.com/cn/VMware-Workstation-Pro/17/com.vmware.ws.using.doc/GUID-AB5C80FE-9B8A-4899-8186-3DB8201B1758.html">在 Linux 客户机中装载共享文件夹 (vmware.com)</a></p><p>但是由于上面的方法需要每次重启后都去设置一遍，可以把执行的命令放到&#x2F;etc&#x2F;rc.local 文件下；让它开机自动执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vi /etc/rc.local</span><br></pre></td></tr></table></figure><p>若&#x2F;etc&#x2F;rc.local 是一个空文件则在里面添加</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/sh -e</span><br><span class="line">sudo vmhgfs-fuse .host:/ /mnt/hgfs -o nonempty -o allow_other</span><br></pre></td></tr></table></figure><p>给文件执行权限</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo chmod +x /etc/rc.local</span><br></pre></td></tr></table></figure><p>最后重启虚拟机</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reboot</span><br></pre></td></tr></table></figure><h1 id="无法应用原保存的显示器配置（屏幕显示问题）"><a href="#无法应用原保存的显示器配置（屏幕显示问题）" class="headerlink" title="无法应用原保存的显示器配置（屏幕显示问题）"></a>无法应用原保存的显示器配置（屏幕显示问题）</h1><p><a href="https://blog.csdn.net/a22635798/article/details/103643708">(12条消息) 虚拟机Ubuntu开机后提示：无法应用原保存的显示器配置（屏幕显示问题）_DTU-CFDer的博客-CSDN博客</a></p>]]></content>
      
      
      <categories>
          
          <category> 系统 </category>
          
          <category> 虚拟机 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>网站</title>
      <link href="/posts/%E5%BD%92%E6%A1%A3/%E7%BD%91%E7%AB%99.html"/>
      <url>/posts/%E5%BD%92%E6%A1%A3/%E7%BD%91%E7%AB%99.html</url>
      
        <content type="html"><![CDATA[<h1 id="书籍-x2F-资源"><a href="#书籍-x2F-资源" class="headerlink" title="书籍&#x2F;资源"></a>书籍&#x2F;资源</h1><ul><li><a href="https://zh.annas-archive.org/account/">Account - 安娜的档案 (annas-archive.org)</a></li><li><a href="https://chrome.google.com/webstore/category/extensions">Chrome 应用商店 - 扩展程序 (google.com)</a></li><li><a href="https://nuaa.vip/">资源分享 (wolai.com)</a></li><li><a href="https://zlibrary-china.se/">Z-Library – the world’s largest e-book library. Your gateway to knowledge and culture. (zlibrary-china.se)</a></li></ul><h1 id="服务器和网盘"><a href="#服务器和网盘" class="headerlink" title="服务器和网盘"></a>服务器和网盘</h1><ul><li><a href="https://cloud.tencent.com/login?s_url=https://console.cloud.tencent.com/lighthouse/instance/index?rid=1">登录 - 腾讯云 (tencent.com)</a></li><li><a href="https://infini-cloud.net/en/">InfiniCLOUD (infini-cloud.net)</a></li><li><a href="https://aws.amazon.com/cn/campaigns/server-hk/?trk=75645f8c-b0ff-4478-9a68-26a0f81c6da8&sc_channel=ba">免费香港服务器_云服务器vps_亚马逊云科技 (amazon.com)</a></li></ul><h1 id="国外-Lab-相关"><a href="#国外-Lab-相关" class="headerlink" title="国外 Lab 相关"></a>国外 Lab 相关</h1><ul><li><a href="https://mit-public-courses-cn-translatio.gitbook.io/mit6-824/">简介 - MIT6.824 (gitbook.io)</a></li><li><a href="https://gaozhiyuan.net/database/cmu-database-systems-introduction-and-relational-model.html">CMU15-445数据库系统：课程简介与关系模型 - 高志远的个人主页 (gaozhiyuan.net)</a></li><li><a href="https://blog.josejg.com/debugging-pretty/">Debugging by Pretty Printing (josejg.com)</a></li><li><a href="https://blog.eleven.wiki/posts/cmu15-445-project1-buffer-pool-manager/">https://blog.eleven.wiki/posts/cmu15-445-project1-buffer-pool-manager/</a></li></ul><h1 id="官方文档"><a href="#官方文档" class="headerlink" title="官方文档"></a>官方文档</h1><ul><li><a href="https://xmake.io/#/zh-cn/">xmake</a></li><li><a href="https://coffeetea.top/zh/">Obsidian文档咖啡豆版 | obsidian文档咖啡豆版 (coffeetea.top)</a></li><li><a href="https://opensource.guide/zh-hans/">开源软件指南 | Open Source Guides</a></li><li><a href="https://wiki.tttt.ee/wiki/idm.html">📗如何使用IDM | TT快下 (tttt.ee)</a></li></ul><h1 id="学习网站"><a href="#学习网站" class="headerlink" title="学习网站"></a>学习网站</h1><ul><li><a href="https://labuladong.gitee.io/algo/">labuladong 的算法小抄 :: labuladong的算法小抄 (gitee.io)</a></li><li><a href="https://www.nowcoder.com/study/live/504">课程列表_牛客网 (nowcoder.com)</a></li><li><a href="https://top.interviewguide.cn/">InterviewGuide大厂面试真题</a></li><li><a href="https://conanhujinming.github.io/comments-for-awesome-courses/">名校公开课程评价网 (conanhujinming.github.io)</a></li><li><a href="https://github.com/sindresorhus/awesome">sindresorhus&#x2F;awesome</a></li><li><a href="https://github.com/codecrafters-io/build-your-own-x">codecrafters-io&#x2F;build-your-own-x</a></li><li><a href="https://github.com/donnemartin/system-design-primer">donnemartin&#x2F;system-design-primer</a></li></ul><h1 id="机场"><a href="#机场" class="headerlink" title="机场"></a>机场</h1><ul><li><a href="https://一元机场.com/#/dashboard">一元机场 (xn–4gq62f52gdss.com)</a></li><li><a href="https://glados.rocks/console">GLaDOS</a></li><li><a href="https://ciyy.cc/#/dashboard">次元雲☁️魔法之境 (ciyy.cc)</a></li><li><a href="https://www.fccloud.vip/#/dashboard">FCCloud</a></li></ul><h1 id="工具配置"><a href="#工具配置" class="headerlink" title="工具配置"></a>工具配置</h1><ul><li><a href="https://juejin.cn/post/7194435171633299513">C++工程实践必备技能 - 掘金 (juejin.cn)</a></li><li><a href="https://juejin.cn/post/7184793007302901820#heading-10">CLion开发环境配置完全解析（Qt开发？STM32？速通cmake？ - 掘金 (juejin.cn)</a></li></ul><h1 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h1><ul><li><a href="https://author.cnki.net/#/index">格式精灵 (cnki.net)</a></li><li><a href="https://zenvideo.qq.com/">腾讯智影-在线智能视频创作平台 (qq.com)</a></li><li><a href="https://qingtu.cn/">清图 - 模糊图片秒转高清图 (qingtu.cn)</a></li><li><a href="https://qinglian.tencent.com/console/">腾讯轻联 (tencent.com)</a></li><li><a href="https://www.thataicollection.com/zh-CN/">生成式 AI 景观 (thataicollection.com)</a></li><li><a href="https://academic.chatwithpaper.org/">GPT 学术优化 (chatwithpaper.org)</a></li></ul><h1 id="Ai"><a href="#Ai" class="headerlink" title="Ai"></a>Ai</h1><ul><li><a href="https://poe.com/Sage">https://poe.com/Sage</a></li><li><a href="https://chatgpt-plus.github.io/chatgpt-plus/">国内开通Chat GPT Plus保姆级教程【典藏】 | ChatGPT Plus官方推荐新手教程 (chatgpt-plus.github.io)</a></li><li><a href="https://portal.azure.com/#home">主页 - Microsoft Azure</a></li><li><a href="https://www.xfyun.cn/">讯飞开放平台-以语音交互为核心的人工智能开放平台 (xfyun.cn)</a></li><li><a href="https://www.perplexity.ai/">Perplexity AI</a></li></ul><h2 id="Openai"><a href="#Openai" class="headerlink" title="Openai"></a>Openai</h2><ul><li><a href="https://platform.openai.com/account/usage">Usage - OpenAI API</a></li></ul><h1 id="个人博客"><a href="#个人博客" class="headerlink" title="个人博客"></a>个人博客</h1><ul><li><a href="https://acking-you.github.io/">L_B__ (acking-you.github.io)</a></li><li><a href="https://www.nickxu.top/2022/12/14/%E3%80%8ECI-CD%E3%80%8F%E7%BB%93%E5%90%88GitHub-Actions-Docker%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2/#%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%8B%89%E5%8F%96%E6%B5%8B%E8%AF%95">『CI&#x2F;CD』结合 GitHub Actions+Docker 实现自动化部署 | NX の 博客 (nickxu.top)</a></li><li><a href="https://blog.misaka.rest/">MisakaNo の 小破站 - 这只是一个小破站而已！</a></li><li><a href="https://rigtorp.se/">Erik Rigtorp</a></li><li><a href="https://blog.csdn.net/weixin_60596960">北极熊~~_linux多线程-CSDN博客</a></li></ul><h1 id="病毒免杀"><a href="#病毒免杀" class="headerlink" title="病毒免杀"></a>病毒免杀</h1><ul><li><a href="https://link.springer.com/article/10.1007/s10207-021-00541-y">[m]allotROPism: a metamorphic engine for malicious software variation development | SpringerLink</a></li><li><a href="https://link.springer.com/article/10.1007/s11416-013-0194-3">Metamorphic code generation from LLVM bytecode | SpringerLink</a></li><li><a href="https://mp.weixin.qq.com/s/k6mi114uyzn2aMXy8uKy6A">绕过Windows Defender的十种方法 (qq.com)</a></li><li><a href="https://llm-attacks.org/index.html#ethics">Universal and Transferable Attacks on Aligned Language Models (llm-attacks.org)</a></li></ul><h1 id="Github"><a href="#Github" class="headerlink" title="Github"></a>Github</h1><p><strong>github.dev</strong> 或按下句号键帮你在线看源码。</p><p>&lt;<a href="http://www.gitpod.io>">www.gitpod.io&gt;</a> 帮你在云上搭建好开发环境并直接运行项目。</p><h1 id="ip-网络"><a href="#ip-网络" class="headerlink" title="ip 网络"></a>ip 网络</h1><ul><li><a href="https://ip.skk.moe/">查看我的 IP 地址 | 查询本机 IP 地址及归属地 | 查看 DNS 出口 IP | 测试 CDN 命中节点 | Sukka | https://ip.skk.moe</a></li><li><a href="https://ip.gs/">IP Address Lookup &#x2F; IPv4 &#x2F; IPv6 - IP.GS</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 归档 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>xmake从入门到精通</title>
      <link href="/posts/%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7/Xmake/xmake%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A.html"/>
      <url>/posts/%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7/Xmake/xmake%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A.html</url>
      
        <content type="html"><![CDATA[<p><a href="https://zhuanlan.zhihu.com/p/96031862">xmake从入门到精通9：交叉编译详解 - 知乎 (zhihu.com)</a><br><a href="https://zhuanlan.zhihu.com/p/97094249">xmake从入门到精通10：多个子工程目标的依赖配置 - 知乎 (zhihu.com)</a><br><a href="https://zhuanlan.zhihu.com/p/129064618">xmake从入门到精通11：如何组织构建大型工程 - 知乎 (zhihu.com)</a><br><a href="https://zhuanlan.zhihu.com/p/161553522">xmake从入门到精通12：通过自定义脚本实现更灵活地配置 - 知乎 (zhihu.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> 编程工具 </category>
          
          <category> Xmake </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Github主页美化</title>
      <link href="/posts/%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7/Git/Github%E4%B8%BB%E9%A1%B5%E7%BE%8E%E5%8C%96.html"/>
      <url>/posts/%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7/Git/Github%E4%B8%BB%E9%A1%B5%E7%BE%8E%E5%8C%96.html</url>
      
        <content type="html"><![CDATA[<h1 id="1、创建你的主页"><a href="#1、创建你的主页" class="headerlink" title="1、创建你的主页"></a>1、创建你的主页</h1><p>首先，你可以进入你的 GitHub，创建一个和你 _ 用户名相同 _ 的仓库，然后在里面创建 README 文件。</p><p>由于你这个仓库名和你的用户名是相同的，所以这个仓库就变得比较特殊了。</p><p>因为你在这里面的 README 写东西，都会显示到<img src="/../../../img/blog/0cab18216da93fad8edffdba961283f3_MD5.jpg" alt="图片">a961283f3_MD5.jpg)</p><h1 id="2、美化的工具"><a href="#2、美化的工具" class="headerlink" title="2、美化的工具"></a>2、美化的工具</h1><p>如果你会点 <code>MarkDown</code> 或 <code>HTML 语言</code>，那么你基本就可以在自己的 <code>README</code> 中 diy 自己的主页了。</p><p>但是没有一些好看好玩的素材，是不是会显得有点单调？</p><p>来，给你推荐一些不错的素材。</p><h2 id="2-1-Emoji"><a href="#2-1-Emoji" class="headerlink" title="2.1 Emoji"></a>2.1 Emoji</h2><p>在这里有许多 emoji 的符号代码，你可以直接将它们用到 README 中。</p><blockquote><p><a href="https://www.webf![图片](../../../../img/blog/c5f21e5f5b071b1d6de7bf1e05cf9177_MD5.jpg)f5b071b1d6de7bf1e05cf9177_MD5.jpg">https://www.webf![图片](../../../../img/blog/c5f21e5f5b071b1d6de7bf1e05cf9177_MD5.jpg)f5b071b1d6de7bf1e05cf9177_MD5.jpg</a>)</p></blockquote><h2 id="2-2-GitHub-统计卡片"><a href="#2-2-GitHub-统计卡片" class="headerlink" title="2.2 GitHub 统计卡片"></a>2.2 GitHub 统计卡片</h2><p>在这里有不同主题的 GitHub 统计卡片，可以统计到你的 star，commit 等数据。</p><blockquote><p><a href="https://github.com/img/img/blog/564d94a6e310d6fed31589c18580850b_MD5.jpg)blog/564d94a6e310d6fed31589c18580850b_MD5.jpg">https://github.com/anuraghazra/github-read![图片](../../../../img/blog/e66d9a5708632818ce431af7934c1a53_MD5.jpg)/e66d9a5708632818c![图片](../../../../img/blog/564d94a6e310d6fed31589c18580850b_MD5.jpg)blog/564d94a6e310d6fed31589c18580850b_MD5.jpg</a>)</p></blockquote><h2 id="2-3-各种按钮"><a href="#2-3-各种按钮" class="headerlink" title="2.3 各种按钮"></a>2.3 各种按钮</h2><p>在这里有许多<img src="/../../../img/blog/66c9e0a9fbe4644e36c1167b8cb061e5_MD5.jpg" alt="图片">..&#x2F;..&#x2F;img&#x2F;blog&#x2F;66<img src="/../../../img/blog/db6ad38c705ca822f51a7baa6142f680_MD5.jpg" alt="图片">(..&#x2F;..&#x2F;..&#x2F;img&#x2F;blog&#x2F;db6ad38c705ca822f51a7baa6142f680_MD5.jpg)</p><h2 id="2-4-显示你最近的状态"><a href="#2-4-显示你最近的状态" class="headerlink" title="2.4 显示你最近的状态"></a>2.4 显示你最近的状态</h2><p>在这里可以显示你最近在 GitHub 上面做了些什<img src="/../../../img/blog/314314c3a4bc6c8b17eb6c88867934a3_MD5.jpg" alt="图片"></p><p><img src="/../../../img/blog/314314c3a4bc6c8b17eb6c88867934a3_MD!%5B%E5%9B%BE%E7%89%87%5D(../../../img/blog/5d49d7e176287cf10dff53dc943d6f1b_MD5.jpg" alt="图片">ns.org&#x2F;</p><p><img src="/../../../img/blog/5d49d7e176287cf10dff53dc943d6f1b_MD5.jpg" alt="图片"></p><h2 id="2-6-展示奖杯"><a href="#2-6-展示奖杯" class="headerlink" title="2.6 展示奖杯"></a>2.6 展示奖杯</h2><p>在这里可以统计 GitHub 的数据，并以奖杯的<img src="/../../../img/blog/dea9c545e6b946f0b80b793169d3a83f_MD5.jpg" alt="图片">aster&#x2F;README.md</p><p><img src="/../../../img/blog/dea9c545e6b946f0b80b793169d3a83f_MD5.jpg" alt="图片"></p><h2 id="2-7-更多素材资源"><a href="#2-7-更多素材资源" class="headerlink" title="2.7 更多素材资源"></a>2.7 更多素材资源</h2><p>上面这些基本够你用了，如果你还想找更多的素材，可以<img src="/../../../img/blog/4d1f232a664f9d81d6acb3edd4af227c_MD5.jpg" alt="图片">ub-profile-readme#tools</p><p><img src="/../../../img/blog/4d1f232a664f9d81d6acb3ed!%5B%E5%9B%BE%E7%89%87%5D(../../../img/blog/e78f22cb866fd6c2a9cf58279259e94c_MD5.jpg" alt="图片">页啦。</p><p>你可以直接在 GitHub 上一边编辑一边预览。</p><p><img src="/../../../img/blog/e78f22cb8!%5B%E5%9B%BE%E7%89%87%5D(../../../img/blog/9b7048b613cdc7d60ce0646e3ca76c28_MD5.jpg" alt="图片">ME 里面引用它们。</p><p>比如我就上传了自己的头像，然后让它显示并居中：</p><p><img src="/../../../img/blog/!%5B%E5%9B%BE%E7%89%87%5D(../../../../img/blog/4dd01be39d0480004196390243e7d781_MD5.jpg)%E6%B3%95!%5B%E5%9B%BE%E7%89%87%5D(../../../../img/blog/42c54cfe7404f7477314709b07249214_MD5.jpg)og/4dd01be39d0480004196390243e7d781_MD5.jpg" alt="图片"> <img src="/../../../img/blog/42c54cfe7404f7477314709b07249214_MD5.jpg" alt="图片"></p><p>对<img src="/../../../img/blog/3a9957a806b6fd8e0b5b40905f7320ed_MD5.jpg" alt="图片">github.io&#x2F;gh-profile-r<img src="/../../../img/blog/15fa6a21ef953cde035a4be238a92e08_MD5.jpg" alt="图片">b6fd8e0b5<img src="/../../../img/blog/05623752e1ae843aa51a71f6acb1e1b6_MD5.jpg" alt="图片">g&#x2F;blog&#x2F;15fa6a21ef953cde035a4be238a92e08_MD5.jpg)</p><p>用就是了：</p><p><img src="/../../../img/blog/05623752e1ae843aa51a71f6acb1e1b6_MD5.jpg" alt="图片"></p><p>对于其他素材的使用方式，你可以直接参照相应文档食用，还是很方便的。</p>]]></content>
      
      
      <categories>
          
          <category> 编程工具 </category>
          
          <category> Git </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>A Tour of xmake - 06. 测试发布</title>
      <link href="/posts/%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7/Xmake/A%20Tour%20of%20xmake%20-%2006.%20%E6%B5%8B%E8%AF%95%E5%8F%91%E5%B8%83.html"/>
      <url>/posts/%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7/Xmake/A%20Tour%20of%20xmake%20-%2006.%20%E6%B5%8B%E8%AF%95%E5%8F%91%E5%B8%83.html</url>
      
        <content type="html"><![CDATA[<h1 id="工程信息"><a href="#工程信息" class="headerlink" title="工程信息"></a>工程信息</h1><p>对于较为正式的工程，xmake 推荐设置几个工程信息：</p><ul><li>工程名称。使用 <code>set_project</code> 语句设定，在一份 <code>xmake.lua</code> 中只能存在一份。</li><li>工程版本。使用 <code>set_version</code> 语句设定。</li><li>最低允许的 xmake 版本。使用 <code>set_xmakever</code> 指定。无法使用低于此版本的 xmake 编译项目。</li></ul><p>举例如下：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set_project(<span class="string">&quot;mylib&quot;</span>)</span><br><span class="line">set_version(<span class="string">&quot;1.0.0&quot;</span>)</span><br><span class="line">set_xmakever(<span class="string">&quot;2.6.1&quot;</span>)</span><br></pre></td></tr></table></figure><p>在此处设置的版本号会产生几个自动定义的配置变量：<code>$&#123;VERSION&#125;</code>、<code>$&#123;VERSION_MAJOR&#125;</code> 等。如果工程使用 Git 进行版本管理，xmake 还会定义 <code>$&#123;GIT_COMMIT&#125;</code> 等变量。</p><blockquote><p>Tips. Windows 上对于产生的二进制&#x2F;动态库，可以为其添加版本信息。这需要编写 resource 文件并将其加入工程中。xmake 中可以直接使用 <code>add_files</code> 接口添加这些文件。</p></blockquote><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><p>以 google test 框架为例进行说明。建立以下 C++ 库结构：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">root</span><br><span class="line">|- include</span><br><span class="line">    |- mylib.h</span><br><span class="line">|- src</span><br><span class="line">    |- mylib.cpp</span><br><span class="line">    |- mylib.def</span><br><span class="line">|- test</span><br><span class="line">    |- add.cpp</span><br><span class="line">    |- distract.cpp</span><br><span class="line">|- xmake.lua</span><br></pre></td></tr></table></figure><p>其中 mylib.cpp 中定义了 <code>int mylib_add(int, int)</code> 和 <code>int mylib_distract(int, int)</code> 两个函数。mylib.def 文件为 Windows definition module 文件，这个文件可以在不声明 <code>__declspec(dllexport)</code> 的情况下生成动态链接库，xmake 中可直接使用 <code>add_files</code> 接口将其加入项目。mylib.def 内容如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LIBRARY mylib</span><br><span class="line">EXPORTS</span><br><span class="line">    mylib_add</span><br><span class="line">    mylib_distract</span><br></pre></td></tr></table></figure><blockquote><p>Tips. xmake 中也可使用 <code>add_rules(&quot;utils.symbols.export_all&quot;)</code> 来生成 def 文件，并导出所有符号。</p></blockquote><p>test 文件夹下含有两个测试文件。add.cpp 内容如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;gtest/gtest.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mylib.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    ::testing::<span class="built_in">InitGoogleTest</span>(&amp;argc, argv);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">RUN_ALL_TESTS</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">TEST</span>(mylib, sum_zero) &#123;</span><br><span class="line">    <span class="keyword">auto</span> result = <span class="built_in">mylib_add</span>(<span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">ASSERT_EQ</span>(result, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">TEST</span>(mylib, sum_five) &#123;</span><br><span class="line">    <span class="keyword">auto</span> result = <span class="built_in">mylib_add</span>(<span class="number">1</span>, <span class="number">4</span>);</span><br><span class="line">    <span class="built_in">ASSERT_EQ</span>(result, <span class="number">5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>distract.cpp 类似，包含两个 distract 函数的测试。xmake.lua 内容如下</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">set_project(<span class="string">&quot;mylib&quot;</span>)</span><br><span class="line">set_version(<span class="string">&quot;1.0.0&quot;</span>)</span><br><span class="line">set_xmakever(<span class="string">&quot;2.6.9&quot;</span>)</span><br><span class="line"></span><br><span class="line">add_rules(<span class="string">&quot;mode.debug&quot;</span>, <span class="string">&quot;mode.release&quot;</span>)</span><br><span class="line">add_requires(<span class="string">&quot;gtest&quot;</span>)</span><br><span class="line"></span><br><span class="line">target(<span class="string">&quot;mylib&quot;</span>)</span><br><span class="line">    set_kind(<span class="string">&quot;$(kind)&quot;</span>)</span><br><span class="line">    add_files(<span class="string">&quot;src/mylib.cpp&quot;</span>)</span><br><span class="line">    add_includedirs(<span class="string">&quot;include&quot;</span>, &#123;public = <span class="literal">true</span>&#125;)</span><br><span class="line">    <span class="keyword">if</span> is_plat(<span class="string">&quot;windows&quot;</span>) <span class="keyword">and</span> is_kind(<span class="string">&quot;shared&quot;</span>) <span class="keyword">then</span></span><br><span class="line">        add_files(<span class="string">&quot;src/mylib.def&quot;</span>)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">target(<span class="string">&quot;test_add&quot;</span>)</span><br><span class="line">    set_kind(<span class="string">&quot;binary&quot;</span>)</span><br><span class="line">    set_group(<span class="string">&quot;tests&quot;</span>)</span><br><span class="line">    add_files(<span class="string">&quot;test/add.cpp&quot;</span>)</span><br><span class="line">    add_deps(<span class="string">&quot;mylib&quot;</span>)</span><br><span class="line">    add_packages(<span class="string">&quot;gtest&quot;</span>)</span><br><span class="line"></span><br><span class="line">target(<span class="string">&quot;test_distract&quot;</span>)</span><br><span class="line">    set_kind(<span class="string">&quot;binary&quot;</span>)</span><br><span class="line">    set_group(<span class="string">&quot;tests&quot;</span>)</span><br><span class="line">    add_files(<span class="string">&quot;test/distract.cpp&quot;</span>)</span><br><span class="line">    add_deps(<span class="string">&quot;mylib&quot;</span>)</span><br><span class="line">    add_packages(<span class="string">&quot;gtest&quot;</span>)</span><br></pre></td></tr></table></figure><p>运行 <code>xmake</code> 编译上述程序。再运行 <code>xmake run test_add</code> 即可看到 add.cpp 测试的结果：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ xmake run test_add</span><br></pre></td></tr></table></figure><p>注意 xmake.lua 中出现了一个新语句 <code>set_group</code>。这一语句将 target 加入一个名为 tests 的 group 中，在运行时可以一键全部运行：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ xmake run -g tests</span><br></pre></td></tr></table></figure><p>用这种方法可以执行项目中的全部测试。当某项测试失败时，该命令会直接退出。</p><p>测试当然也并不局限于框架。在测试 target 中可以通过 <code>on_run</code> 接口执行任意命令：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">target(<span class="string">&quot;test_script&quot;</span>)</span><br><span class="line">    set_kind(<span class="string">&quot;phony&quot;</span>)</span><br><span class="line">    set_group(<span class="string">&quot;tests&quot;</span>)</span><br><span class="line">    on_run(<span class="function"><span class="keyword">function</span> <span class="params">(target)</span></span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;log message&quot;</span>)</span><br><span class="line">        <span class="built_in">os</span>.exec(<span class="string">&quot;whatever you want&quot;</span>)</span><br><span class="line">    <span class="keyword">end</span>)</span><br></pre></td></tr></table></figure><blockquote><p>Tips. 类型为 <code>phony</code> 的 target 不会产生任何库或者可执行文件。它们可以用于理顺依赖结构、处理自定义命令等。</p></blockquote><h1 id="安装与发布"><a href="#安装与发布" class="headerlink" title="安装与发布"></a>安装与发布</h1><p>如果测试过程没有找到问题，那么就可以准备安装&#x2F;发布了。按照一般约定，C&#x2F;C++ 程序的安装目录结构如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">root</span><br><span class="line">|- bin</span><br><span class="line">|- include</span><br><span class="line">|- lib</span><br><span class="line">|- share</span><br><span class="line">|- ...</span><br></pre></td></tr></table></figure><p>这里 <code>bin</code> 存放生成的二进制文件和 Windows 上动态链接库文件，<code>include</code> 存放头文件，<code>lib</code> 存放链接库以及 Windows 上动态链接库的导入库（import library），<code>share</code> 则存放文档、数据等其他文件。当然这一目录也并不绝对，根据需求的不同，有时不按照约定反而更加方便。</p><p>xmake 中使用如下命令来安装一个项目：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ xmake install -o &lt;dist&gt;</span><br></pre></td></tr></table></figure><p><code>&lt;dist&gt;</code> 既可以是系统上存放第三方库的目录，也可以是自定义的其他目录（用于后续打包发布）。不同于 cmake 等构建系统，xmake 中安装路径是在编译完毕安装时进行指定的（而不是编译前），因此同一个项目在编译完成后可以被安装到多个位置。</p><h2 id="指定头文件"><a href="#指定头文件" class="headerlink" title="指定头文件"></a>指定头文件</h2><p>执行安装命令时，如果在 xmake.lua 中没有特殊指定，target 生成的二进制和库文件都会自动按上述约定路径安装。而要安装的头文件比较复杂，需要使用 <code>add_headerfiles</code> 语句指定。这一语句的基本用法如下：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add_headerfiles(<span class="string">&quot;include/(**.h)&quot;</span>, &#123;prefixdir = <span class="string">&quot;mylib&quot;</span>&#125;)</span><br></pre></td></tr></table></figure><p>通配符 <code>include/**.h</code> 匹配 include 目录及其子目录的所有.h 后缀文件。对于 <code>add_headerfiles</code> 语句，如果不加括号，则所有文件都会被直接安装到 <code>include</code> 文件夹下，目录结构将会丢失；而括号的作用在于保持括号内的目录结构。例如 <code>a/(b/c.h)</code> 安装后会变成 <code>include/b/c.h</code>。而在设置中的 <code>prefixdir</code> 选项则将所有头文件放在 <code>include</code> 的子目录中。如对于上述设置 <code>&#123;prefixdir = &quot;mylib&quot;&#125;</code>，<code>a/(b/c.h)</code> 安装后会变成 <code>include/mylib/b/c.h</code>。</p><blockquote><p>Tips. 对部分 IDE 项目生成器，<code>add_headerfiles</code> 不仅指定安装时安装的头文件，还设定了 IDE 项目中可见的头文件。如果仅将此语句用于项目生成，不希望对应头文件被安装，可以使用 <code>add_headerfiles(&lt;file&gt;, &#123;install = false&#125;)</code> 选项。</p></blockquote><h2 id="生成配置文件"><a href="#生成配置文件" class="headerlink" title="生成配置文件"></a>生成配置文件</h2><p>有时候使用 xmake 构建的库需要导出给使用其他构建系统的项目使用，这就需要对应构建工具的配置文件。xmake 提供 pkg-config 配置文件和 cmake 配置文件的生成。对于需要导出的 target，使用如下语句：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">add_rules(<span class="string">&quot;utils.install.pkgconfig_importfiles&quot;</span>)</span><br><span class="line">add_rules(<span class="string">&quot;utils.install.cmake_importfiles&quot;</span>)</span><br></pre></td></tr></table></figure><p>这两个语句会在 <code>lib</code> 文件夹下生成对应的配置文件。关于如何使用这些配置文件，请参考对应构建工具的文档。</p><h2 id="安装其它文件"><a href="#安装其它文件" class="headerlink" title="安装其它文件"></a>安装其它文件</h2><p>对于头文件之外的安装文件，xmake 提供了类似的接口 <code>add_installfiles</code>，它与 <code>add_headerfiles</code> 的区别在于，<code>prefixdir</code> 将直接放在安装目录下而不是 <code>include</code> 文件夹下。例如文档安装可以写</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add_installfiles(<span class="string">&quot;doc/*.md&quot;</span>, &#123;prefixdir = <span class="string">&quot;share/doc&quot;</span>&#125;)</span><br></pre></td></tr></table></figure><p>数据等文件同理。</p><h2 id="自定义安装过程"><a href="#自定义安装过程" class="headerlink" title="自定义安装过程"></a>自定义安装过程</h2><p>有时候，项目生成的库和二进制不要按约定的 <code>bin</code> 和 <code>lib</code> 目录存放，甚至不需要被安装。还有时候，安装的文件需要根据安装目录做一定的更改。这时可以使用 <code>on_install</code> 语句来重载 target 的安装过程。例如，将生成的库文件安装到 <code>mylib</code> 文件夹：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">target(<span class="string">&quot;mylib&quot;</span>)</span><br><span class="line">    ...</span><br><span class="line">    on_install(<span class="function"><span class="keyword">function</span> <span class="params">(target)</span></span></span><br><span class="line">        <span class="keyword">local</span> libdir = <span class="built_in">path</span>.join(target:installdir(), <span class="string">&quot;mylib&quot;</span>)</span><br><span class="line">        <span class="built_in">os</span>.mkdir(libdir)</span><br><span class="line">        <span class="built_in">os</span>.cp(target:targetfile(), libdir)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">local</span> includedir = <span class="built_in">path</span>.join(target:installdir(), <span class="string">&quot;myinclude&quot;</span>)</span><br><span class="line">        <span class="built_in">os</span>.mkdir(includedir)</span><br><span class="line">        <span class="keyword">for</span> _, headerfile <span class="keyword">in</span> <span class="built_in">ipairs</span>(target:headerfiles()) <span class="keyword">do</span></span><br><span class="line">            <span class="built_in">os</span>.cp(headerfile, includedir)</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span>)</span><br></pre></td></tr></table></figure><p>在重载 target 中部分过程时，可以参考 xmake 内部的实现。可以使用 git clone xmake 项目到本地，使用 IDE 中的搜索功能搜索需要的实现部分（例如搜索 install_headers），也可以访问 <a href="https://link.zhihu.com/?target=https://github1s.com/xmake-io/xmake">在线编辑器</a> 来查看。</p>]]></content>
      
      
      <categories>
          
          <category> 编程工具 </category>
          
          <category> Xmake </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>A Tour of xmake - 05. 构建选项</title>
      <link href="/posts/%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7/Xmake/A%20Tour%20of%20xmake%20-%2005.%20%E6%9E%84%E5%BB%BA%E9%80%89%E9%A1%B9.html"/>
      <url>/posts/%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7/Xmake/A%20Tour%20of%20xmake%20-%2005.%20%E6%9E%84%E5%BB%BA%E9%80%89%E9%A1%B9.html</url>
      
        <content type="html"><![CDATA[<h1 id="常用-C-x2F-C-项目描述设置详解"><a href="#常用-C-x2F-C-项目描述设置详解" class="headerlink" title="常用 C&#x2F;C++ 项目描述设置详解"></a>常用 C&#x2F;C++ 项目描述设置详解</h1><h2 id="先来一段最简短的"><a href="#先来一段最简短的" class="headerlink" title="先来一段最简短的"></a>先来一段最简短的</h2><p>一行描述即可编译 src 目录下所有 c 源文件，然后生成一个名为 demo 的可执行文件。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">target(<span class="string">&quot;demo&quot;</span>, &#123;kind = <span class="string">&quot;binary&quot;</span>, files = <span class="string">&quot;src/*.c&quot;</span>&#125;)</span><br></pre></td></tr></table></figure><p>上面的写法是精简写法，通常我们更推荐使用下面展开式写法：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">target(<span class="string">&quot;demo&quot;</span>) </span><br><span class="line">    set_kind(<span class="string">&quot;binary&quot;</span>) </span><br><span class="line">    add_files(<span class="string">&quot;src/*.c&quot;</span>)</span><br></pre></td></tr></table></figure><p>这两者完全等价，如果配置很简短，可以完全精简成一行，而拆分成多行更加方便灵活配置。</p><p>如果没有特殊目的，下文我们都会采用第二段的写法。</p><h2 id="配置项目目标类型"><a href="#配置项目目标类型" class="headerlink" title="配置项目目标类型"></a>配置项目目标类型</h2><p>通常的 C&#x2F;C++ 项目生成的目标文件猪油三大类：可执行程序，静态库，动态库。</p><p>我们可以通过 <code>set_kind()</code> 配置来设置，分别对应：binary, static, shared</p><p>例如，我们想要编译动态库，只需要修改 kind：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">target(<span class="string">&quot;demo&quot;</span>) </span><br><span class="line">    set_kind(<span class="string">&quot;shared&quot;</span>) </span><br><span class="line">    add_files(<span class="string">&quot;src/*.c&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="添加宏定义"><a href="#添加宏定义" class="headerlink" title="添加宏定义"></a>添加宏定义</h2><p>编译宏的设置，大多数 c&#x2F;c++ 项目都会用到，一般如果我们设置编译 flags 传给 gcc&#x2F;clang，都是要配置：<code>-DXXX</code></p><p>而在 xmake 里面，提供了 <code>add_defines()</code> 内置接口来配置：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">target(<span class="string">&quot;demo&quot;</span>) </span><br><span class="line">    set_kind(<span class="string">&quot;shared&quot;</span>) </span><br><span class="line">    add_files(<span class="string">&quot;src/*.c&quot;</span>) </span><br><span class="line">    add_defines(<span class="string">&quot;XXX&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="条件配置"><a href="#条件配置" class="headerlink" title="条件配置"></a>条件配置</h2><p>那如果我们想在不同编译平台，分别设置不同的宏开关呢？我们可以利用 lua 内置的 if 语句很方便的实现：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">target(<span class="string">&quot;demo&quot;</span>) </span><br><span class="line">    set_kind(<span class="string">&quot;shared&quot;</span>) </span><br><span class="line">    add_files(<span class="string">&quot;src/*.c&quot;</span>) </span><br><span class="line">    add_defines(<span class="string">&quot;XXX&quot;</span>) </span><br><span class="line">    <span class="keyword">if</span> is_plat(<span class="string">&quot;linux&quot;</span>, <span class="string">&quot;macosx&quot;</span>) <span class="keyword">then</span> </span><br><span class="line">       add_defines(<span class="string">&quot;YYY&quot;</span>) </span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>我们通过 <code>is_plat()</code> 判断，如果当前编译目标平台是 linux 或者 macosx，那么 target 会额外增加 <code>-DYYY</code> 宏定义。</p><h2 id="全局配置"><a href="#全局配置" class="headerlink" title="全局配置"></a>全局配置</h2><p>我们在 <code>target(&quot;demo&quot;)</code> 下面的所有配置，都属于 demo 这个 target 子域，并不是全局的，所以你会看到通常配置上都加了缩进，就是为了凸显作用域的影响范围。</p><p>通常如果多个 target 连续定义，下一个 target 定义就会自动结束上个 target 的作用域，每个 target 的配置完全独立，互不干扰：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">target(<span class="string">&quot;test1&quot;</span>)</span><br><span class="line">    set_kind(<span class="string">&quot;shared&quot;</span>)</span><br><span class="line">    add_files(<span class="string">&quot;src/*.c&quot;</span>)</span><br><span class="line">    add_defines(<span class="string">&quot;TEST1&quot;</span>)</span><br><span class="line"></span><br><span class="line">target(<span class="string">&quot;test2&quot;</span>)</span><br><span class="line">    set_kind(<span class="string">&quot;shared&quot;</span>)</span><br><span class="line">    add_files(<span class="string">&quot;src/*.c&quot;</span>)</span><br><span class="line">    add_defines(<span class="string">&quot;TEST2&quot;</span>)</span><br></pre></td></tr></table></figure><p>例如，上面的配置两个 target，各自拥有自己独立的宏定义：<code>TEST1</code> 和 <code>TEST2</code>。</p><p>那么，我们要对这两个 target，设置共用的宏定义，应该如何配置呢？</p><p>每个 target 下面都配置一遍 <code>add_defines(&quot;TEST&quot;)</code>? 当然可以，不过这样就有点冗余了，配置多了就会很难维护，其实我们只需要放置到全局根作用域就行了：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 全局设置</span></span><br><span class="line">add_defines(<span class="string">&quot;TEST&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> is_arch(<span class="string">&quot;arm64&quot;</span>, <span class="string">&quot;armv7&quot;</span>) <span class="keyword">then</span></span><br><span class="line">    add_defines(<span class="string">&quot;ARM&quot;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">target(<span class="string">&quot;test1&quot;</span>)</span><br><span class="line">    set_kind(<span class="string">&quot;shared&quot;</span>)</span><br><span class="line">    add_files(<span class="string">&quot;src/*.c&quot;</span>)</span><br><span class="line">    add_defines(<span class="string">&quot;TEST1&quot;</span>)</span><br><span class="line"></span><br><span class="line">target(<span class="string">&quot;test2&quot;</span>)</span><br><span class="line">    set_kind(<span class="string">&quot;shared&quot;</span>)</span><br><span class="line">    add_files(<span class="string">&quot;src/*.c&quot;</span>)</span><br><span class="line">    add_defines(<span class="string">&quot;TEST2&quot;</span>)</span><br></pre></td></tr></table></figure><p>在 target 的外层的所有配置都属于全局配置，我们也可以调用 <code>target_end()</code> 强制结束 target 子域，切回全局作用域：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">target(<span class="string">&quot;test1&quot;</span>)</span><br><span class="line">    set_kind(<span class="string">&quot;shared&quot;</span>)</span><br><span class="line">    add_files(<span class="string">&quot;src/*.c&quot;</span>)</span><br><span class="line">    add_defines(<span class="string">&quot;TEST1&quot;</span>)</span><br><span class="line">target_end()</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 全局设置</span></span><br><span class="line">add_defines(<span class="string">&quot;TEST&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> is_arch(<span class="string">&quot;arm64&quot;</span>, <span class="string">&quot;armv7&quot;</span>) <span class="keyword">then</span></span><br><span class="line">    add_defines(<span class="string">&quot;ARM&quot;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">target(<span class="string">&quot;test2&quot;</span>)</span><br><span class="line">    set_kind(<span class="string">&quot;shared&quot;</span>)</span><br><span class="line">    add_files(<span class="string">&quot;src/*.c&quot;</span>)</span><br><span class="line">    add_defines(<span class="string">&quot;TEST2&quot;</span>)</span><br><span class="line">target_end()</span><br></pre></td></tr></table></figure><h2 id="添加编译选项"><a href="#添加编译选项" class="headerlink" title="添加编译选项"></a>添加编译选项</h2><p>如果有些编译选项，xmake 没有提供内置 api 设置，那么我们可以退化到 <code>add_cflags</code>, <code>add_cxflags</code>, <code>add_cxxflags</code> 来设置， 不过这就需要用户自己去判断编译平台了，因为并不是所有编译 flags 每个平台都支持。</p><p>比如：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">add_cflags(<span class="string">&quot;-g&quot;</span>, <span class="string">&quot;-O2&quot;</span>, <span class="string">&quot;-DDEBUG&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> is_plat(<span class="string">&quot;windows&quot;</span>) <span class="keyword">then</span></span><br><span class="line">    add_cflags(<span class="string">&quot;/MT&quot;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>所有选项值都基于 gcc 的定义为标准，如果其他编译器不兼容（例如：vc），xmake 会自动内部将其转换成对应编译器支持的选项值。 用户无需操心其兼容性，如果其他编译器没有对应的匹配值，那么 xmake 会自动忽略器设置。</p><p>我们也可以通过 force 参数来强制禁用 flags 的自动检测，直接传入编译器，哪怕编译器有可能不支持，也会设置：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add_cflags(<span class="string">&quot;-g&quot;</span>, <span class="string">&quot;-O2&quot;</span>, &#123;force = <span class="literal">true</span>&#125;)</span><br></pre></td></tr></table></figure><p>那如何知道，哪些 flags 检测失败给忽略了呢，带 <code>-v</code> 编译就可以看到，比如：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ xmake -v</span><br><span class="line">checking <span class="keyword">for</span> the /usr/bin/xcrun -sdk macosx clang ... ok</span><br><span class="line">checking <span class="keyword">for</span> the flags (-Oz) ... ok</span><br><span class="line">checking <span class="keyword">for</span> the flags (-Wno-error=deprecated-declarations) ... ok</span><br><span class="line">checking <span class="keyword">for</span> the flags (-fno-strict-aliasing) ... ok</span><br><span class="line">checking <span class="keyword">for</span> the flags (-Wno-error=expansion-to-defined) ... no</span><br></pre></td></tr></table></figure><p>最后备注下这三个 api 的区别：</p><ul><li><code>add_cflags</code>：仅添加 C 代码相关编译 flags</li><li><code>add_cxflags</code>：添加 C&#x2F;C++ 代码相关编译 flags</li><li><code>add_cxxflags</code>：仅添加 C++ 代码相关编译 flags</li></ul><h2 id="添加库相关设置"><a href="#添加库相关设置" class="headerlink" title="添加库相关设置"></a>添加库相关设置</h2><p>一个 C&#x2F;C++ 库的集成使用，通常需要设置头文件搜索目录，链接库名，库搜索目录，比如：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">target(<span class="string">&quot;test&quot;</span>)</span><br><span class="line">    set_kind(<span class="string">&quot;binary&quot;</span>)</span><br><span class="line">    add_links(<span class="string">&quot;pthread&quot;</span>)</span><br><span class="line">    add_includedirs(<span class="string">&quot;/usr/local/include&quot;</span>)</span><br><span class="line">    add_linkdirs(<span class="string">&quot;/usr/local/lib&quot;</span>)</span><br></pre></td></tr></table></figure><p>通常，为了保证链接库的依赖顺序，系统库链接通常都会比较靠后，我们通过 <code>add_syslinks()</code> 来专门设置系统库链接，而 <code>add_links()</code> 通常用于非系统库链接：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">target(<span class="string">&quot;test&quot;</span>) </span><br><span class="line">    set_kind(<span class="string">&quot;binary&quot;</span>) </span><br><span class="line">    add_links(<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>) </span><br><span class="line">    add_syslinks(<span class="string">&quot;pthread&quot;</span>)</span><br></pre></td></tr></table></figure><p>上面的配置，我们添加了两个第三方链接库：A, B，以及系统库 pthread，整个完整的链接顺序是：<code>-lA -lB -lpthread</code>，syslinks 会放在最后面。</p><p>如果你不确定实际的链接顺序，我们可以执行 <code>xmake -v</code> 编译，查看完整的链接参数命令行。</p><h2 id="设置语言标准"><a href="#设置语言标准" class="headerlink" title="设置语言标准"></a>设置语言标准</h2><p>c 标准和 c++ 标准可同时进行设置，例如：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 设置c代码标准：c99， c++代码标准：c++11</span></span><br><span class="line">set_languages(<span class="string">&quot;c99&quot;</span>, <span class="string">&quot;c++11&quot;</span>)</span><br></pre></td></tr></table></figure><p>注：并不是设置了指定的标准，编译器就一定会按这个标准来编译，毕竟每个编译器支持的力度不一样，但是 xmake 会尽最大可能的去适配当前编译工具的支持标准。</p><p>例如：windows 下 vs 的编译器并不支持按 c99 的标准来编译 c 代码，只能支持到 c89，但是 xmake 为了尽可能的支持它，所以在设置 c99 的标准后， xmake 会强制按 c++ 代码模式去编译 c 代码，从一定程度上解决了 windows 下编译 c99 的 c 代码问题。</p><h2 id="设置编译优化"><a href="#设置编译优化" class="headerlink" title="设置编译优化"></a>设置编译优化</h2><p>xmake 提供了几种内置的编译优化配置：none, fast, faster, fastest, smallest, aggressive，来实现各种级别的编译优化。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set_optimize(<span class="string">&quot;fastest&quot;</span>)</span><br></pre></td></tr></table></figure><p>如果用户通过 flags 来设置，还需额外考虑不同编译器的不同编译选项，xmake 对其进行了内部映射处理，极大程度方便用户提供跨平台性。</p><p>如果想查看详细的映射规则，可以到 xmake 的官方文档进行查看：<a href="https://link.zhihu.com/?target=https://xmake.io/%23/zh-cn/manual/project_target?id=targetset_optimize">编译优化设置</a></p><h2 id="调试和发布模式"><a href="#调试和发布模式" class="headerlink" title="调试和发布模式"></a>调试和发布模式</h2><p>即使 xmake 提供了 <code>set_optimize</code> 简化了不同编译器的复杂配置，但是对于不同的编译模式: debug&#x2F;release，还是要自己做一些繁琐的判断和配置：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> is_mode(<span class="string">&quot;debug&quot;</span>) <span class="keyword">then</span></span><br><span class="line">    set_symbols(<span class="string">&quot;debug&quot;</span>)</span><br><span class="line">    set_optimize(<span class="string">&quot;none&quot;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">if</span> is_mode(<span class="string">&quot;release&quot;</span>) <span class="keyword">then</span></span><br><span class="line">    set_symbols(<span class="string">&quot;hidden&quot;</span>)</span><br><span class="line">    set_strip(<span class="string">&quot;all&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> is_plat(<span class="string">&quot;iphoneos&quot;</span>, <span class="string">&quot;android&quot;</span>) <span class="keyword">then</span></span><br><span class="line">        set_optimize(<span class="string">&quot;smallest&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        set_optimize(<span class="string">&quot;fastest&quot;</span>)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>这些看似常用的设置，如果每个项目都来一遍，那也很繁琐了，导致 xmake.lua 不够精简可读，因此 xmake 提供了一些常用内置规则来简化设置：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add_rules(<span class="string">&quot;mode.release&quot;</span>, <span class="string">&quot;mode.debug&quot;</span>)</span><br></pre></td></tr></table></figure><p>只需这一行即可，效果是完全一致，用户还可以基于此在做一些额外的定制化配置来改写：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">add_rules(<span class="string">&quot;mode.release&quot;</span>, <span class="string">&quot;mode.debug&quot;</span>) </span><br><span class="line"><span class="keyword">if</span> is_mode(<span class="string">&quot;release&quot;</span>) <span class="keyword">then</span> </span><br><span class="line">    set_optimize(<span class="string">&quot;fastest&quot;</span>) </span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>比如我想在 release 模式下，强制启用 fastest 编译优化，既然有了模式配置，那我们怎么切换到 debug 模式编译呢？（默认是 release 编译）</p><p>答案：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xmake f -m debug; xmake</span><br></pre></td></tr></table></figure><h2 id="添加源文件"><a href="#添加源文件" class="headerlink" title="添加源文件"></a>添加源文件</h2><p>最后，我们在介绍下 xmake 最常用，也最为强大的设置之一，也就是对编译源文件的配置管理：<code>add_files()</code>。</p><p>我们可以用这个接口，添加各类 xmake 支持的源文件，比如：c&#x2F;c++, asm, objc, swift, go, dlang 等源文件，甚至是：<code>.obj</code>, <code>.a/.lib</code> 等二进制对象和库文件。</p><p>例如：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">add_files(&quot;src/test_*.c&quot;) </span><br><span class="line">add_files(&quot;src/xxx/**.cpp&quot;) </span><br><span class="line">add_files(&quot;src/asm/*.S&quot;, &quot;src/objc/**/hello.m&quot;)</span><br></pre></td></tr></table></figure><p>其中通配符 <code>*</code> 表示匹配当前目录下文件，而 <code>**</code> 则匹配多级目录下的文件。</p><p><code>add_files</code> 的使用其实是相当灵活方便的，其匹配模式借鉴了 premake 的风格，但是又对其进行了改善和增强。</p><p>使得不仅可以匹配文件，还有可以在添加文件同时，过滤排除指定模式的一批文件。</p><p>例如：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 递归添加src下的所有c文件，但是不包括src/impl/下的所有c文件</span></span><br><span class="line">add_files(<span class="string">&quot;src/**.c|impl/*.c&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 添加src下的所有cpp文件，但是不包括src/test.cpp、src/hello.cpp以及src下所有带xx_前缀的cpp文件</span></span><br><span class="line">add_files(<span class="string">&quot;src/*.cpp|test.cpp|hello.cpp|xx_*.cpp&quot;</span>)</span><br></pre></td></tr></table></figure><p>其中分隔符 <code>|</code> 之后的都是需要排除的文件，这些文件也同样支持匹配模式，并且可以同时添加多个过滤模式，只要中间用 <code>|</code> 分割就行了。。</p><p>添加文件的时候支持过滤一些文件的一个好处就是，可以为后续根据不同开关逻辑添加文件提供基础。</p><p>注：为了使得描述上更加的精简，<code>|</code> 之后的过滤描述都是基于起一个模式：<code>src/*.cpp</code> 中 <code>*</code> 之前的目录为基础的。 所以上面的例子后面过滤的都是在 src 下的文件，这个是要注意的。</p><p>2.1.6 版本之后，对 <code>add_files</code> 进行了改进，支持基于 files 更细粒度的编译选项控制，例如：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">target(<span class="string">&quot;test&quot;</span>)</span><br><span class="line">    add_defines(<span class="string">&quot;TEST1&quot;</span>)</span><br><span class="line">    add_files(<span class="string">&quot;src/*.c&quot;</span>)</span><br><span class="line">    add_files(<span class="string">&quot;test/*.c&quot;</span>, <span class="string">&quot;test2/test2.c&quot;</span>, &#123;defines = <span class="string">&quot;TEST2&quot;</span>, languages = <span class="string">&quot;c99&quot;</span>, includedirs = <span class="string">&quot;.&quot;</span>, cflags = <span class="string">&quot;-O0&quot;</span>&#125;)</span><br></pre></td></tr></table></figure><p>可以在 <code>add_files</code> 的最后一个参数，传入一个配置 table，去控制指定 files 的编译选项，里面的配置参数跟 target 的一致，并且这些文件还会继承 target 的通用配置 <code>-DTEST1</code>。</p><p>2.1.9 版本之后，支持添加未知的代码文件，通过设置 rule 自定义规则，实现这些文件的自定义构建，例如：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">target(<span class="string">&quot;test&quot;</span>) </span><br><span class="line">    <span class="comment">-- ... </span></span><br><span class="line">    add_files(<span class="string">&quot;src/test/*.md&quot;</span>, &#123;rule = <span class="string">&quot;markdown&quot;</span>&#125;)</span><br></pre></td></tr></table></figure><p>并且在 2.1.9 版本之后，可以通过 force 参数来强制禁用 cxflags,cflags 等编译选项的自动检测，直接传入编译器，哪怕编译器有可能不支持，也会设置：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add_files(<span class="string">&quot;src/*.c&quot;</span>, &#123;force = &#123;cxflags = <span class="string">&quot;-DTEST&quot;</span>, mflags = <span class="string">&quot;-framework xxx&quot;</span>&#125;&#125;)</span><br></pre></td></tr></table></figure><h2 id="删除指定源文件"><a href="#删除指定源文件" class="headerlink" title="删除指定源文件"></a>删除指定源文件</h2><p>既然讲到了添加源文件，那么如何删除，我们也顺带着讲下吧，我们只需要通过 <code>del_files()</code> 接口，就可以从前面 <code>add_files</code> 接口添加的文件列表中，删除指定的文件，例如：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">target(<span class="string">&quot;test&quot;</span>) </span><br><span class="line">    add_files(<span class="string">&quot;src/*.c&quot;</span>) </span><br><span class="line">    del_files(<span class="string">&quot;src/test.c&quot;</span>)</span><br></pre></td></tr></table></figure><p>上面的例子，可以从 <code>src</code> 目录下添加除 <code>test.c</code> 以外的所有文件，当然这个也可以通过 <code>add_files(&quot;src/*.c|test.c&quot;)</code> 来达到相同的目的，但是这种方式更加灵活。</p><p>例如，我们可以条件判断来控制删除哪些文件，并且此接口也支持 <code>add_files</code> 的匹配模式，过滤模式，进行批量移除。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">target(<span class="string">&quot;test&quot;</span>) </span><br><span class="line">    add_files(<span class="string">&quot;src/**.c&quot;</span>) </span><br><span class="line">    del_files(<span class="string">&quot;src/test*.c&quot;</span>) </span><br><span class="line">    del_files(<span class="string">&quot;src/subdir/*.c|xxx.c&quot;</span>) </span><br><span class="line">    <span class="keyword">if</span> is_plat(<span class="string">&quot;iphoneos&quot;</span>) <span class="keyword">then</span> </span><br><span class="line">        add_files(<span class="string">&quot;xxx.m&quot;</span>) </span><br><span class="line">    <span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>通过上面的例子，我们可以看出 <code>add_files</code> 和 <code>del_files</code> 是根据调用顺序，进行顺序添加和删除的，并且通过 <code>del_files(&quot;src/subdir/*.c|xxx.c&quot;)</code> 删除一批文件， 并且排除 <code>src/subdir/xxx.c</code>（就是说，不删除这个文件）。</p><h1 id="使用选项切换构建参数"><a href="#使用选项切换构建参数" class="headerlink" title="使用选项切换构建参数"></a>使用选项切换构建参数</h1><h2 id="添加构建选项"><a href="#添加构建选项" class="headerlink" title="添加构建选项"></a>添加构建选项</h2><p>xmake 中使用 <code>option</code> 语句来声明构建选项。<code>option</code> 的基本用法如下：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">add_rules(<span class="string">&quot;mode.debug&quot;</span>, <span class="string">&quot;mode.release&quot;</span>)</span><br><span class="line">option(<span class="string">&quot;enable-verbose&quot;</span>)</span><br><span class="line">    set_default(<span class="literal">false</span>)</span><br><span class="line">    set_description(<span class="string">&quot;Enable verbose logging.&quot;</span>)</span><br><span class="line">    add_defines(<span class="string">&quot;MYEXE_VERBOSE&quot;</span>)</span><br><span class="line">target(<span class="string">&quot;myexe&quot;</span>)</span><br><span class="line">    set_kind(<span class="string">&quot;binary&quot;</span>)</span><br><span class="line">    add_files(<span class="string">&quot;src/*.cpp&quot;</span>)</span><br><span class="line">    add_options(<span class="string">&quot;enable-verbose&quot;</span>)</span><br></pre></td></tr></table></figure><p>注意与 <code>target</code> 语句类似，<code>option</code> 也是一个作用域的开始，之后一直到另一个作用域开始，或者显式的 <code>option_end</code> 调用之前的语句都是修饰当前 option 的。在上面的语句中，<code>option</code> 作用域一共含有三条语句。</p><ul><li><code>set_default</code> 语句设置 option 的默认值。xmake 中 option 可分为两类：boolean 和 string。boolean 类型的默认值可以是 <code>true</code>、<code>false</code> 或者 <code>nil</code>，string 类型的默认值可以是任意字符串或者 <code>nil</code>。</li><li><code>set_description</code> 语句设置 option 的描述语句。这一描述可以在通过运行 <code>xmake config -h</code> 或者 <code>xmake config --menu</code> 查看所有 option 时看到。</li><li><code>add_defines</code> 为 option 加入了一个预定义宏。默认情况下，在使用 <code>add_options</code> 将 option 加入 target 时，如果 option 含有预定义宏、编译参数等，并且 option 的状态是启用的（不是 <code>nil</code> 或 <code>false</code>），则 target 也会加入这些预定义宏和编译参数。</li></ul><blockquote><p>Tips. xmake 中作用域级别的语句有六种：<code>target</code> 和 <code>target_end</code>、<code>package</code> 和 <code>package_end</code>，<code>option</code> 和 <code>option_end</code>、<code>rule</code> 和 <code>rule_end</code>、<code>toolchain</code> 和 <code>toolchain_end</code>、<code>task</code> 和 <code>task_end</code>。其中前面三种比较常用。</p></blockquote><p>除了 <code>add_defines</code> 之外，xmake 中的 option 还支持 <code>add_&lt;language&gt;flags</code> 系列函数。如果要作更复杂的控制，可以使用 <code>has_config</code> 和 <code>is_config</code> 语句来进行判断：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">add_rules(<span class="string">&quot;mode.debug&quot;</span>, <span class="string">&quot;mode.release&quot;</span>)</span><br><span class="line">option(<span class="string">&quot;with-openssl&quot;</span>, &#123;default = <span class="literal">false</span>, description = <span class="string">&quot;Build with OpenSSL.&quot;</span>&#125;)</span><br><span class="line"><span class="keyword">if</span> has_config(<span class="string">&quot;with-openssl&quot;</span>) <span class="keyword">then</span></span><br><span class="line">    add_requires(<span class="string">&quot;openssl&quot;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">target(<span class="string">&quot;myexe&quot;</span>)</span><br><span class="line">    set_kind(<span class="string">&quot;binary&quot;</span>)</span><br><span class="line">    add_files(<span class="string">&quot;src/*.cpp&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> has_config(<span class="string">&quot;with-openssl&quot;</span>) <span class="keyword">then</span></span><br><span class="line">        add_packages(<span class="string">&quot;openssl&quot;</span>)</span><br><span class="line">        add_defines(<span class="string">&quot;MYEXE_HAVE_OPENSSL&quot;</span>)</span><br><span class="line">    <span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>这里用到了 <code>option</code> 的简写格式，这一格式下 <code>option</code> 不再作为作用域开始的标记。</p><h2 id="内置选项"><a href="#内置选项" class="headerlink" title="内置选项"></a>内置选项</h2><p>xmake 提供了一系列内置选项，在给自定义选项命名时记得避免与内置选项重名！常用的内置选项有：</p><ul><li><code>plat</code>：设置构建目标平台。</li><li><code>arch</code>：设置构建目标架构。</li><li><code>mode</code>：设置构建模式。</li><li><code>kind</code>：设置默认链接库类型。</li><li><code>buildir</code>：设置生成位置。默认为 <code>build</code>，可以使用这一选项更改。推荐对不同的选项组合使用不同的生成位置以避免冲突。</li></ul><p>还有一些可能比较少用但很容易重名的内置选项，包括 <code>qt</code>、<code>cuda</code>、<code>ndk</code>、<code>sdk</code> 等。这些选项的清单及其作用可以运行 <code>xmake config -h</code> 查看。</p><h2 id="指定构建选项"><a href="#指定构建选项" class="headerlink" title="指定构建选项"></a>指定构建选项</h2><p>xmake 在 configure 阶段指定各种构建选项。对 boolean 选项与 string 选项类型的指定方式类似，稍有不同：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ xmake config --opt1=yes --opt2=y --opt3=on # yes/no, y/n, on/off are all valid</span><br><span class="line">$ xmake config --str1=mystr &quot;--str2=some string&quot;</span><br></pre></td></tr></table></figure><p>当构建选项较多时，一个一个指定是一件很困难的事情。这时可以将一组选项导出为列表，切换时可以在列表间切换。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ xmake config --opt1=yes --opt2=mystr --buildir=build-preset1</span><br><span class="line">$ xmake config --export=preset1.txt</span><br></pre></td></tr></table></figure><p>这样就可以把当前所有构建选项导出到 preset1.txt 文件。需要导入构建选项时，执行</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ xmake config -c --import=preset1.txt</span><br></pre></td></tr></table></figure><p>这里 <code>-c</code> 表示先清除其他选项设置，避免干扰。</p><h2 id="构建选项依赖"><a href="#构建选项依赖" class="headerlink" title="构建选项依赖"></a>构建选项依赖</h2><p>xmake 中使用 <code>add_deps</code> 语句来声明选项之间的依赖关系。例如，选项 opt2 依赖选项 opt1，当设置 opt1 时 opt2 自动取消，xmake.lua 如下：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">option(<span class="string">&quot;opt1&quot;</span>, &#123;default = <span class="literal">false</span>&#125;)</span><br><span class="line">option(<span class="string">&quot;opt2&quot;</span>)</span><br><span class="line">    set_default(<span class="literal">true</span>)</span><br><span class="line">    add_deps(<span class="string">&quot;opt1&quot;</span>)</span><br><span class="line">    after_check(<span class="function"><span class="keyword">function</span> <span class="params">(option)</span></span></span><br><span class="line">        <span class="keyword">if</span> option:dep(<span class="string">&quot;opt1&quot;</span>):enabled() <span class="keyword">then</span></span><br><span class="line">            option:enable(<span class="literal">false</span>)</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span>)</span><br><span class="line">option_end()</span><br></pre></td></tr></table></figure><p>这里 <code>after_check</code> 语句接收了一个 Lua lambda 表达式作为参数，这个表达式函数会在选项的检查结束后执行，将 opt2 设置为与 opt1 相容的值。<code>option：enable(false)</code> 中 <code>option</code> 是函数的参数，调用函数时这个参数由 xmake 来构造。<code>enable</code> 是 <code>option</code> 的一个函数，用于修改 boolean 类型 option 的值。对于 string 类型的 option，这里可以使用 <code>set_value</code> 函数来设置：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> option:dep(<span class="string">&quot;opt1&quot;</span>):enabled() <span class="keyword">then</span></span><br><span class="line">    option:set_value(<span class="string">&quot;opt1&quot;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><blockquote><p>Tips. 所有 <code>option</code> 默认是并行检查的，其先后顺序仅能通过 <code>add_deps</code> 控制。不加 <code>add_deps</code> 语句，在 <code>after_check</code> 中取其他 <code>option</code> 的值是未定义行为！</p></blockquote><p>xmake 中大量使用了这类函数式方法用来灵活控制构建的每个过程。在 lambda 表达式函数之内的部分称为 Script Scope，与之对应的 xmake.lua 中外面的部分称为 Description Scope。Description Scope 胜在简洁方便，易读易写；而只有在 Script Scope 内才可以使用 xmake 提供的全部功能，包括 xmake 提供的大量第三方 Lua 模块。这些功能可以在官方文档中找到。</p><blockquote><p>Tips. Description Scope 内的语句会多次解析执行，而 Script Scope 内的语句只会执行一遍。不同 option&#x2F;不同 target 的 Script Scope 默认是并行执行的。调试用的 <code>print</code> 语句应当写在 Script Scope 内，并标注当前所在的 option&#x2F;target。</p></blockquote><p>常用的能够进入 Script Scope 的语句目前有如下一些。</p><p>option：</p><ul><li><code>before_check</code>&#x2F;<code>on_check</code>&#x2F;<code>after_check</code> configure 阶段</li></ul><p>target：</p><ul><li><code>on_config</code> configure 阶段</li><li><code>before_build</code>&#x2F;<code>on_build</code>&#x2F;<code>after_build</code> build 阶段</li><li><code>before_link</code>&#x2F;<code>on_link</code>&#x2F;<code>after_link</code> build 阶段</li><li><code>before_run</code>&#x2F;<code>on_run</code>&#x2F;<code>after_run</code> 运行 <code>xmake run &lt;target&gt;</code> 时</li><li><code>before_install</code>&#x2F;<code>on_install</code>&#x2F;<code>after_install</code> 运行 <code>xmake install &lt;target&gt;</code> 时</li><li><code>on_uninstall</code> 运行 <code>xmake uninstall &lt;target&gt;</code> 时</li><li><code>before_clean</code>&#x2F;<code>on_clean</code>&#x2F;<code>after_clean</code> 运行 <code>xmake clean &lt;target&gt;</code> 时</li></ul><h1 id="检测开发环境"><a href="#检测开发环境" class="headerlink" title="检测开发环境"></a>检测开发环境</h1><p>xmake 中，option 不仅用来处理用户指定的构建选项，还可以用来执行环境检测。这时 option 的写法为</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">option(<span class="string">&quot;__have_longlong&quot;</span>)</span><br><span class="line">    set_default(<span class="literal">false</span>)</span><br><span class="line">    set_showmenu(<span class="literal">false</span>) <span class="comment">-- do not show this option in the configuration menu</span></span><br><span class="line">    add_ctypes(<span class="string">&quot;long long int&quot;</span>)</span><br><span class="line">option_end()</span><br><span class="line"><span class="keyword">if</span> has_config(<span class="string">&quot;__have_longlong&quot;</span>) <span class="keyword">then</span></span><br><span class="line">    add_defines(<span class="string">&quot;HAVE_LONGLONG&quot;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>这里在 <code>option</code> 中加入了 <code>add_ctypes</code> 语句，这使得 <code>__have_longlong</code> 这个 option 成为了一个检测 option。xmake 中，包含以下语句中一个或者多个的 option 为检测 option：</p><ul><li><code>add_cincludes</code>&#x2F;<code>add_cxxincludes</code>：检测是否能找到某个头文件。</li><li><code>add_ctypes</code>&#x2F;<code>add_cxxtypes</code>：检测是否声明某个类型。通常与上一条联合使用，通过 <code>add_cincludes</code> 添加头文件，再通过 <code>add_ctypes</code> 检测头文件中声明的类型。</li><li><code>add_cfuncs</code>&#x2F;<code>add_cxxfuncs</code>：检测是否声明某个函数。同上，通常通过 <code>add_cincludes</code> 添加头文件，再通过 <code>add_cfuncs</code> 检测头文件中声明的函数。</li><li><code>add_links</code>：检测是否能找到某个链接库。</li><li><code>add_features</code>：检测编译器功能，例如 <code>add_features(&quot;cxx_std_11&quot;)</code> 检测是否支持 C++11.</li><li><code>add_csnippets</code>&#x2F;<code>add_cxxsnippets</code>：检测是否能通过编译某代码片段。这条语句功能最强大，可以实现上面提到的各种功能，还可以通过添加参数来检测是否能运行某代码片段，获取该代码片段的输出。详情可参考官方文档。</li></ul><p>使用 option 进行检测有时还是太复杂了，这时可以使用 xmake 提供的更简单的检测接口。下面的代码段和上面检测 <code>long long int</code> 的片段作用相同：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">includes(<span class="string">&quot;check_ctypes.lua&quot;</span>)</span><br><span class="line">check_ctypes(<span class="string">&quot;HAVE_LONGLONG&quot;</span>, <span class="string">&quot;long long int&quot;</span>)</span><br><span class="line"><span class="comment">--[[ if has_config(&quot;__HAVE_LONGLONG&quot;) then</span></span><br><span class="line"><span class="comment">    do something</span></span><br><span class="line"><span class="comment">end --]]</span></span><br></pre></td></tr></table></figure><p>检测接口通过 <code>includes</code> 方法引入，其中 <code>check_ctypes.lua</code> 为 xmake 内置的扩展脚本。需要注意的是，为了避免选项冲突，xmake 会自动将这里定义的选项命名为双下划线 <code>__</code> 接要定义的宏名称 <code>HAVE_LONGLONG</code>。xmake 中一共提供了如下简化检测接口。</p><ul><li><code>check_cflags.lua</code>&#x2F;<code>check_cxxflags.lua</code></li><li><code>check_cincludes.lua</code>&#x2F;<code>check_cxxincludes.lua</code></li><li><code>check_ctypes.lua</code>&#x2F;<code>check_cxxtypes.lua</code></li><li><code>check_cfuncs.lua</code>&#x2F;<code>check_cxxfuncs.lua</code></li><li><code>check_csnippets.lua</code>&#x2F;<code>check_cxxsnippets.lua</code></li><li><code>check_links.lua</code></li><li><code>check_features.lua</code></li><li><code>check_macros.lua</code></li></ul><p>大部分接口都和上面 <code>option</code> 的同名函数一一对应。其中三个接口例外：<code>check_cflags</code> 和 <code>check_cxxflags</code> 检测编译器是否支持某个编译参数，而 <code>check_macros</code> 检测编译器是否设置某个预定义宏。<code>macros</code> 检测都可以通过在 <code>option</code> 中设置 <code>add_csnippets</code> 和 <code>add_cxxsnippets</code> 来实现，而 <code>flags</code> 检测需要借助 <code>on_check</code> 进入 Script Scope 来处理。感兴趣的读者可以从 <code>path/to/xmake/includes</code> 找到这些接口的实现。</p><h1 id="生成配置头文件"><a href="#生成配置头文件" class="headerlink" title="生成配置头文件"></a>生成配置头文件</h1><p>当各种配置选项定义的宏仅影响源文件时，上面的开发环境检测功能就足够了。但是，当这些宏还影响头文件时，光在构建期检测是不够的，因为打包发布库与头文件时，不会包含任何检测结果的数据，这会导致头文件与库中的函数不匹配，最终导致链接失败。解决办法就是使用配置头文件（Configuration Headers）。</p><p>配置头文件是一个在构建时生成的文件，它根据检测到的各类选项来设置其中定义的宏变量。在构建过程中，先生成配置头文件，然后将该头文件加入项目中一起编译，最后一起打包发布。由于配置头文件的内容在构建时已经固定下来，如果构建头文件使用正确，头文件中将不再含有不清晰的分支，这也就避免了函数不匹配的问题。</p><p>一个使用配置头文件的项目目录如下：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">root</span><br><span class="line">|- include</span><br><span class="line">    |- mylib</span><br><span class="line">        |- mylib.h</span><br><span class="line">        |- <span class="built_in">config</span>.h.<span class="keyword">in</span></span><br><span class="line">|- src</span><br><span class="line">    |- mylib.cpp</span><br><span class="line">|- xmake.lua</span><br></pre></td></tr></table></figure><p>其中 mylib.h 文件内容如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;config.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __WIN32__</span></span><br><span class="line"><span class="meta">#  <span class="keyword">ifdef</span> MYLIB_STATIC</span></span><br><span class="line"><span class="meta">#    <span class="keyword">define</span> MYLIB_EXPORT</span></span><br><span class="line"><span class="meta">#  <span class="keyword">elif</span> defined(MYLIB_BUILDING)</span></span><br><span class="line"><span class="meta">#    <span class="keyword">define</span> MYLIB_EXPORT __declspec(dllexport)</span></span><br><span class="line"><span class="meta">#  <span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#    <span class="keyword">define</span> MYLIB_EXPORT __declspec(dllimport)</span></span><br><span class="line"><span class="meta">#  <span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#  <span class="keyword">define</span> MYLIB_EXPORT</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">MYLIB_EXPORT <span class="type">int</span> <span class="title">myfunc</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>mylib.cpp 包含 <code>myfunc</code> 函数的实现</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mylib/mylib.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">myfunc</span><span class="params">(<span class="type">int</span> a)</span> </span>&#123; <span class="keyword">return</span> a + <span class="number">1</span>; &#125;</span><br></pre></td></tr></table></figure><p><a href="https://link.zhihu.com/?target=http://config.h.in">http://config.h.in</a> 文件内容如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line">$&#123;define MYLIB_STATIC&#125;</span><br></pre></td></tr></table></figure><p>xmake.lua 内容如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">add_rules</span>(<span class="string">&quot;mode.debug&quot;</span>, <span class="string">&quot;mode.release&quot;</span>)</span><br><span class="line"><span class="built_in">target</span>(<span class="string">&quot;mylib&quot;</span>)</span><br><span class="line">    <span class="built_in">set_kind</span>(<span class="string">&quot;$(kind)&quot;</span>)</span><br><span class="line">    <span class="built_in">add_files</span>(<span class="string">&quot;src/mylib.cpp&quot;</span>)</span><br><span class="line">    <span class="built_in">add_includedirs</span>(<span class="string">&quot;include&quot;</span>)</span><br><span class="line">    <span class="built_in">add_defines</span>(<span class="string">&quot;MYLIB_BUILDING&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="title">is_kind</span><span class="params">(<span class="string">&quot;static&quot;</span>)</span> then</span></span><br><span class="line"><span class="function">        <span class="title">set_configvar</span><span class="params">(<span class="string">&quot;MYLIB_STATIC&quot;</span>, <span class="number">1</span>)</span></span></span><br><span class="line"><span class="function">    end</span></span><br><span class="line"><span class="function">    <span class="title">set_configdir</span><span class="params">(<span class="string">&quot;$(buildir)/mylib&quot;</span>)</span></span></span><br><span class="line"><span class="function">    <span class="title">add_includedirs</span><span class="params">(<span class="string">&quot;$(buildir)/mylib&quot;</span>)</span></span></span><br><span class="line"><span class="function">    <span class="title">add_configfiles</span><span class="params">(<span class="string">&quot;include/mylib/config.h.in&quot;</span>)</span></span></span><br></pre></td></tr></table></figure><p>运行 <code>xmake</code> 构建以上项目后，可以在 <code>build/mylib</code> 文件夹下找到一个文件 config.h：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MYLIB_STATIC 1</span></span><br></pre></td></tr></table></figure><p>在 <code>mylib.h</code> 文件中引用的头文件 <code>config.h</code> 正是这一文件。在发布时，将这一文件与 <code>include</code> 文件夹下的头文件一同打包，即可把 <code>MYLIB_STATIC</code> 这个设置项固定下来了。当其他文件引用 <code>mylib.h</code> 时，宏 <code>MYLIB_EXPORT</code> 将始终展开为空值。</p><blockquote><p>Tips. 上面的头文件设置看似很复杂，但却是大型 C++ 项目中非常常见的做法。这么做的原因是在 Windows 上要使用 MSVC 导出可以链接的动态库，必须要显式声明需要导出的符号，声明的方式其一是在 <code>.def</code> 文件中集中声明，其二就是在函数前加 <code>__declspec(dllexport)</code>。加导出声明后，相应函数的符号会以 <code>__imp_</code> 开头，以区分于静态库符号。为了避免符号冲突，若需要其他项目链接该动态库，则必须在库的头文件相应函数前加 <code>__declspec(dllimport)</code>。<br>Tips. config.h 是一个很常见的名称，如果安装的时候直接把这个文件所在的文件夹放在 <code>include</code> 下，很容易引起混乱。解决办法有两种：一种是改名 mylib_config.h，另一种是放在文件夹 mylib 下。这也是上面写 <code>#include &quot;mylib/mylib.h&quot;</code> 的原因。</p></blockquote><p>xmake 中，默认配置头文件以后缀 <code>.h.in</code> 结尾，在生成文件时去掉后缀的 <code>.in</code>。这一行为也可以通过添加参数 <code>&#123;filename = …&#125;</code> 进行更改。在配置头文件中有两种方法声明需替换的配置变量：</p><ul><li><code>$&#123;VAR&#125;</code>：替换为变量 <code>VAR</code> 的值，或者空字符串。常用于 <code>#define VAR $&#123;VAR&#125;</code>。</li><li><code>$&#123;define VAR&#125;</code>：如果 <code>VAR</code> 的值存在，则定义 <code>VAR</code>，否则注释掉当前行。要求写在行首。</li></ul><p>变量的值可以用 <code>set_configvar</code> 语句指定。<code>set_configvar</code> 语句可以结合 <code>option</code> 使用，根据不同的选项设置不同的配置变量：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">option(<span class="string">&quot;with-openssl&quot;</span>, &#123;default = <span class="literal">false</span>, description = <span class="string">&quot;Build with OpenSSL.&quot;</span>&#125;)</span><br><span class="line"><span class="keyword">if</span> has_config(<span class="string">&quot;with-openssl&quot;</span>) <span class="keyword">then</span></span><br><span class="line">    add_requires(<span class="string">&quot;openssl&quot;</span>)</span><br><span class="line">    set_configvar(<span class="string">&quot;WITH_OPENSSL&quot;</span>, <span class="number">1</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>进一步还可以结合 <code>set_configvar</code> 与环境探测。xmake 中已经预先提供了这样的接口，它们与 <code>check_xxx</code> 系列接口一脉相承，命名为 <code>configvar_check_xxx</code>，用法如下：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">includes(<span class="string">&quot;check_ctypes.lua&quot;</span>)</span><br><span class="line">configvar_check_ctypes(<span class="string">&quot;HAVE_LONGLONG&quot;</span>, <span class="string">&quot;long long int&quot;</span>)</span><br></pre></td></tr></table></figure><p>如果类型 <code>long long int</code> 可以通过编译，则变量 <code>HAVE_LONGLONG</code> 将被替换为 1，否则变量 <code>HAVE_LONGLONG</code> 值不存在。使用 <code>configvar_check_xxx</code> 接口设置的 option 选项命名仍为双下划线 <code>__</code>+ 变量名。</p>]]></content>
      
      
      <categories>
          
          <category> 编程工具 </category>
          
          <category> Xmake </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>A Tour of xmake - 04. 依赖仓库</title>
      <link href="/posts/%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7/Xmake/A%20Tour%20of%20xmake%20-%2004.%20%E4%BE%9D%E8%B5%96%E4%BB%93%E5%BA%93.html"/>
      <url>/posts/%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7/Xmake/A%20Tour%20of%20xmake%20-%2004.%20%E4%BE%9D%E8%B5%96%E4%BB%93%E5%BA%93.html</url>
      
        <content type="html"><![CDATA[<h1 id="编写包描述文件"><a href="#编写包描述文件" class="headerlink" title="编写包描述文件"></a>编写包描述文件</h1><p>前文说到，当 xmake-repo 未收录时，可以自己编写包描述文件。xmake 的官方仓库 <a href="https://link.zhihu.com/?target=https://github.com/xmake-io/xmake-repo">xmake-repo</a> 就是由一个个包描述文件组成的；它们也是编写包描述文件的最佳参考。</p><h2 id="远程拉取源码编译"><a href="#远程拉取源码编译" class="headerlink" title="远程拉取源码编译"></a>远程拉取源码编译</h2><p>一个 package 描述文件由一个 package 作用域组成，以 <a href="https://link.zhihu.com/?target=https://github.com/xmake-io/xmake-repo/blob/master/packages/j/jsoncpp/xmake.lua">jsoncpp</a> 为例，其包描述文件如下（为方便起见作了部分删改）：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">package</span>(<span class="string">&quot;jsoncpp&quot;</span>)</span><br><span class="line"></span><br><span class="line">    set_homepage(<span class="string">&quot;https://github.com/open-source-parsers/jsoncpp/wiki&quot;</span>)</span><br><span class="line">    set_description(<span class="string">&quot;A C++ library for interacting with JSON.&quot;</span>)</span><br><span class="line"></span><br><span class="line">    add_urls(<span class="string">&quot;https://github.com/open-source-parsers/jsoncpp/archive/$(version).zip&quot;</span>,</span><br><span class="line">             <span class="string">&quot;https://github.com/open-source-parsers/jsoncpp.git&quot;</span>)</span><br><span class="line">    add_versions(<span class="string">&quot;1.9.5&quot;</span>, <span class="string">&quot;a074e1b38083484e8e07789fd683599d19da8bb960959c83751cd0284bdf2043&quot;</span>)</span><br><span class="line"></span><br><span class="line">    add_deps(<span class="string">&quot;cmake&quot;</span>)</span><br><span class="line">    on_load(<span class="function"><span class="keyword">function</span> <span class="params">(package)</span></span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">package</span>:<span class="built_in">config</span>(<span class="string">&quot;shared&quot;</span>) <span class="keyword">then</span></span><br><span class="line">            <span class="built_in">package</span>:add(<span class="string">&quot;defines&quot;</span>, <span class="string">&quot;JSON_DLL&quot;</span>)</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span>)</span><br><span class="line"></span><br><span class="line">    on_install(<span class="string">&quot;linux&quot;</span>, <span class="string">&quot;macosx&quot;</span>, <span class="string">&quot;android&quot;</span>, <span class="string">&quot;iphoneos&quot;</span>, <span class="string">&quot;windows&quot;</span>, <span class="string">&quot;mingw&quot;</span>, <span class="string">&quot;cross&quot;</span>, <span class="function"><span class="keyword">function</span> <span class="params">(package)</span></span></span><br><span class="line">        <span class="keyword">local</span> configs = &#123;<span class="string">&quot;-DJSONCPP_WITH_POST_BUILD_UNITTEST=OFF&quot;</span>, <span class="string">&quot;-DJSONCPP_WITH_TESTS=OFF&quot;</span>, <span class="string">&quot;-DJSONCPP_WITH_EXAMPLE=OFF&quot;</span>, <span class="string">&quot;-DBUILD_OBJECT_LIBS=OFF&quot;</span>&#125;</span><br><span class="line">        <span class="built_in">table</span>.<span class="built_in">insert</span>(configs, <span class="string">&quot;-DCMAKE_BUILD_TYPE=&quot;</span> .. (<span class="built_in">package</span>:<span class="built_in">debug</span>() <span class="keyword">and</span> <span class="string">&quot;Debug&quot;</span> <span class="keyword">or</span> <span class="string">&quot;Release&quot;</span>))</span><br><span class="line">        <span class="built_in">table</span>.<span class="built_in">insert</span>(configs, <span class="string">&quot;-DBUILD_SHARED_LIBS=&quot;</span> .. (<span class="built_in">package</span>:<span class="built_in">config</span>(<span class="string">&quot;shared&quot;</span>) <span class="keyword">and</span> <span class="string">&quot;ON&quot;</span> <span class="keyword">or</span> <span class="string">&quot;OFF&quot;</span>))</span><br><span class="line">        <span class="built_in">table</span>.<span class="built_in">insert</span>(configs, <span class="string">&quot;-DBUILD_STATIC_LIBS=&quot;</span> .. (<span class="built_in">package</span>:<span class="built_in">config</span>(<span class="string">&quot;shared&quot;</span>) <span class="keyword">and</span> <span class="string">&quot;OFF&quot;</span> <span class="keyword">or</span> <span class="string">&quot;ON&quot;</span>))</span><br><span class="line">        import(<span class="string">&quot;package.tools.cmake&quot;</span>).install(<span class="built_in">package</span>, configs)</span><br><span class="line">    <span class="keyword">end</span>)</span><br><span class="line"></span><br><span class="line">    on_test(<span class="function"><span class="keyword">function</span> <span class="params">(package)</span></span></span><br><span class="line">        <span class="built_in">assert</span>(<span class="built_in">package</span>:check_cxxsnippets(&#123;test = <span class="string">[[</span></span><br><span class="line"><span class="string">            void test() &#123;</span></span><br><span class="line"><span class="string">                Json::Value root;</span></span><br><span class="line"><span class="string">                Json::CharReaderBuilder builder;</span></span><br><span class="line"><span class="string">            &#125;</span></span><br><span class="line"><span class="string">        ]]</span>&#125;, &#123;configs = &#123;languages = <span class="string">&quot;c++11&quot;</span>&#125;, includes = <span class="string">&quot;json/json.h&quot;</span>&#125;))</span><br><span class="line">    <span class="keyword">end</span>)</span><br></pre></td></tr></table></figure><p>可以看到，整个包描述文件分为四部分：描述、加载、安装、测试。描述部分最简洁，也很容易读懂，这里包括包名、项目主页、项目简介、url、版本、依赖等。url 既可以声明版本对应源码包的下载地址，也可以声明 git 地址。<code>add_versions</code> 语句有两个参数，分别是版本号、对应版本号源码包的 sha256 或者对应版本号的 git commit id。<code>add_deps</code> 语句声明了包依赖的其他包。</p><blockquote><p>Tips. xmake 提供了计算 sha256 的命令行接口 <code>shell $ xmake lua hash.sha256 &lt;filename&gt;</code> 除了 sha256 之外，xmake 还提供了 hash.md5 等其他实用命令行接口。</p></blockquote><p>加载阶段和包描述阶段类似，区别在于加载阶段使用一个 lambda 函数（Lua 中格式为 <code>function(t) … end</code>）来描写加载过程，此处可以使用 Lua 脚本以及包设置项进行判断。jsoncpp 中判断当包作为动态链接库链接时，为使用此库的 target 添加 <code>JSON_DLL</code> 预定义宏。由于 msvc 引入动态库时往往需要在头文件中加限定符 <code>__declspec(dllimport)</code>，这样的预定义宏需求在跨平台 C++ 项目中非常常见。</p><p>接下来便是一个包描述文件的重头戏了：安装部分。jsoncpp 使用 cmake 作为构建系统，xmake 为之提供了一个模块用于处理 cmake 包的编译与安装：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import(<span class="string">&quot;package.tools.cmake&quot;</span>).install(<span class="built_in">package</span>, configs)</span><br></pre></td></tr></table></figure><p>这一语句自动调用 cmake 的安装功能。package 为 xmake 自动生成的代表当前包的对象，configs 是一个 table，这一语句会根据 configs 里面的声明来编译当前包。通常 configs 包含几个方面：</p><ul><li>禁用文档生成、测试与示例程序构建</li><li>编译模式处理（debug&#x2F;release）</li><li>链接库类型处理（static&#x2F;shared）</li><li>指定其他编译选项</li></ul><p>整个安装部分包含在 <code>on_install</code> 语句中。这个语句除最后一个参数用于描写安装过程之外，其他参数声明了包可以安装的平台&#x2F;架构。有时，一个包在不同平台上需要不同的处理，则可以写多个 <code>on_install</code> 语句来做跨平台处理，例如 <a href="https://link.zhihu.com/?target=https://github.com/xmake-io/xmake-repo/blob/master/packages/f/fftw/xmake.lua">fftw</a>。</p><p><code>on_install</code> 语句最后运行的理想结果，是在 <code>package:installdir()</code> 这个目录下产生如下目录结构：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$XMAKE_PKG_INSTALLDIR/m/mylib/&lt;version&gt;/&lt;hash&gt;</span><br><span class="line">|- bin</span><br><span class="line">|- include</span><br><span class="line">|- lib</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>xmake 会将 <code>include</code> 加入头文件目录，将 <code>lib</code> 加入链接目录，并自动扫描 <code>lib</code> 下生成的所有库文件对其进行链接。也就是说，无论采用什么方法，只要最后生成的库按此结构放置即可。对常用构建系统，xmake 提供了 <code>import(&quot;package.tools.xxx&quot;)</code> 的接口进行安装。对于使用 make&#x2F;nmake 管理、没有提供 install 功能的包，可能需要手动复制其生成文件到 <code>package:installdir()</code>，见后文 “ 直接下载包文件 “ 一节。</p><p>部分包不按照这种目录标准安装。xmake 也提供了保持其原有目录结构的途径：在<strong>描述阶段</strong>使用 <code>add_includedirs</code> 和 <code>add_linkdirs</code> 来指定头文件目录和链接目录（可以指定多个）。默认行为就相当于</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">package</span>(<span class="string">&quot;mylib&quot;</span>)</span><br><span class="line">    ...</span><br><span class="line">    add_includedirs(<span class="string">&quot;include&quot;</span>)</span><br><span class="line">    add_linkdirs(<span class="string">&quot;lib&quot;</span>)</span><br></pre></td></tr></table></figure><p>类似地，自动扫描链接库目录的行为也可以通过 <code>add_links</code> 语句自定义，以避免自动扫描时的链接顺序等问题。xmake 将按照声明的前后顺序链接各个声明的链接库。</p><p>测试过程发生在安装完毕之后，xmake 会试着编译一小段程序以保证包的可用性。这里常常使用 <code>assert</code> 语句与 <code>package:check_cxxsnippets</code> 或者 <code>package:check_cfuncs</code> 语句的组合。这些语句的用法和含义都很直接，其全部参数可以参考官方文档查阅。</p><p>包描述文件可以直接写在 xmake.lua 所有 target 定义之前，这样自定义包将可以和 xmake-repo 中提供的包一样，用 <code>add_requires</code> 引入。xmake.lua 的内容如下：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">package</span>(<span class="string">&quot;mylib&quot;</span>)</span><br><span class="line">    ...</span><br><span class="line">package_end() <span class="comment">-- explicitly quit the package description scope. IMPORTANT!</span></span><br><span class="line"></span><br><span class="line">add_rules(<span class="string">&quot;mode.debug&quot;</span>, <span class="string">&quot;mode.release&quot;</span>)</span><br><span class="line">add_requires(<span class="string">&quot;mylib&quot;</span>)</span><br><span class="line">target(<span class="string">&quot;myexec&quot;</span>)</span><br><span class="line">    set_kind(<span class="string">&quot;binary&quot;</span>)</span><br><span class="line">    add_files(<span class="string">&quot;src/*.cpp&quot;</span>)</span><br><span class="line">    add_packages(<span class="string">&quot;mylib&quot;</span>)</span><br></pre></td></tr></table></figure><p>如果包描述文件过于冗长，可以将其单独写在一个 lua 文件里（例如 mylib.lua），使用 <code>includes</code> 语句引入：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">includes(<span class="string">&quot;mylib.lua&quot;</span>)</span><br><span class="line"></span><br><span class="line">add_rules(<span class="string">&quot;mode.debug&quot;</span>, <span class="string">&quot;mode.release&quot;</span>)</span><br><span class="line">add_requires(<span class="string">&quot;mylib&quot;</span>)</span><br><span class="line">target(<span class="string">&quot;myexec&quot;</span>)</span><br><span class="line">    set_kind(<span class="string">&quot;binary&quot;</span>)</span><br><span class="line">    add_files(<span class="string">&quot;src/*.cpp&quot;</span>)</span><br><span class="line">    add_packages(<span class="string">&quot;mylib&quot;</span>)</span><br></pre></td></tr></table></figure><blockquote><p>Tips. <code>includes</code> 是一个非常实用的功能，尤其是在项目含有多个子项目的情况。<code>includes</code> 并不仅仅是简单的代码替换，在被包含的文件中，<code>add_files</code> 添加的相对路径会改为相对于被包含文件的路径。例如，文件目录如下 <code>root |- lib1 |- lib1.cpp |- xmake.lua |- lib2 |- lib2.cpp |- xmake.lua |- xmake.lua</code> 则在根目录下的 <code>xmake.lua</code> 可以这样写： <code>lua add_rules(&quot;mode.debug&quot;, &quot;mode.release&quot;) includes(&quot;lib1/xmake.lua&quot;) includes(&quot;lib2/xmake.lua&quot;)</code> 这样一来，更改一个子部分就不再需要对根目录的构建文件进行修改了，构建文件的易维护性大大提升。</p></blockquote><p>由于 C++ 的包构建千奇百怪，xmake 使用 Lua 脚本的形式对包的构建过程提供了充分的自由度，这也导致包描述文件相对构建文件往往更加复杂。但是即使没有完全理解也没有关系，对于包括 cmake 在内的常见构建系统（xmake，autoconf，etc.），xmake-repo 中大多都有对应的示例，可以在复制粘贴基础上进行改动。</p><h2 id="直接下载包文件"><a href="#直接下载包文件" class="headerlink" title="直接下载包文件"></a>直接下载包文件</h2><p>部分包（尤其是 header-only 的 C++ 库）直接提供头文件和二进制文件下载，无需从源码安装。这时只需要修改 <code>on_install</code> 的安装部分，将安装改为复制即可。下面的部分摘自 <a href="https://link.zhihu.com/?target=https://github.com/xmake-io/xmake-repo/blob/master/packages/o/openblas/xmake.lua">openblas</a>。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">package</span>(<span class="string">&quot;openblas&quot;</span>)</span><br><span class="line">    ...</span><br><span class="line">    on_install(<span class="string">&quot;windows&quot;</span>, <span class="function"><span class="keyword">function</span> <span class="params">(package)</span></span></span><br><span class="line">        <span class="built_in">os</span>.mv(<span class="built_in">path</span>.join(<span class="string">&quot;bin&quot;</span>, <span class="string">&quot;libopenblas.dll&quot;</span>), <span class="built_in">package</span>:installdir(<span class="string">&quot;bin&quot;</span>))</span><br><span class="line">        <span class="built_in">os</span>.mv(<span class="string">&quot;include&quot;</span>, <span class="built_in">package</span>:installdir())</span><br><span class="line">        <span class="built_in">os</span>.mv(<span class="built_in">path</span>.join(<span class="string">&quot;lib&quot;</span>, <span class="string">&quot;libopenblas.lib&quot;</span>), <span class="built_in">path</span>.join(<span class="built_in">package</span>:installdir(<span class="string">&quot;lib&quot;</span>), <span class="string">&quot;openblas.lib&quot;</span>))</span><br><span class="line">        <span class="built_in">package</span>:addenv(<span class="string">&quot;PATH&quot;</span>, <span class="string">&quot;bin&quot;</span>)</span><br><span class="line">    <span class="keyword">end</span>)</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><h2 id="从系统查找"><a href="#从系统查找" class="headerlink" title="从系统查找"></a>从系统查找</h2><p>有时候一些包没有独立的源码或二进制，而是由发行版提供，或者强制要求从安装包安装。这时从系统查找的功能就派上用场了。xmake 中用 <code>on_fetch</code> 语句实现查找功能。下面例子摘自 <a href="https://link.zhihu.com/?target=https://github.com/xmake-io/xmake-repo/blob/master/packages/m/msmpi/xmake.lua">msmpi</a>。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">package</span>(<span class="string">&quot;msmpi&quot;</span>)</span><br><span class="line">    ...</span><br><span class="line">    on_fetch(<span class="string">&quot;windows&quot;</span>, <span class="function"><span class="keyword">function</span> <span class="params">(package, opt)</span></span></span><br><span class="line">        <span class="keyword">if</span> opt.system <span class="keyword">then</span></span><br><span class="line">            import(<span class="string">&quot;lib.detect.find_path&quot;</span>)</span><br><span class="line">            import(<span class="string">&quot;lib.detect.find_library&quot;</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment">-- init search paths</span></span><br><span class="line">            <span class="keyword">local</span> paths = &#123;</span><br><span class="line">                <span class="string">&quot;$(env MSMPI_ROOT)&quot;</span>,</span><br><span class="line">                <span class="string">&quot;$(env MSMPI_INC)\\..&quot;</span>,</span><br><span class="line">                <span class="string">&quot;$(env PROGRAMFILES%(x86%))\\Microsoft SDKs\\MPI&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">-- find library</span></span><br><span class="line">            <span class="keyword">local</span> result = &#123;links = &#123;&#125;, linkdirs = &#123;&#125;, includedirs = &#123;&#125;&#125;</span><br><span class="line">            <span class="keyword">local</span> arch = <span class="built_in">package</span>:is_arch(<span class="string">&quot;x64&quot;</span>) <span class="keyword">and</span> <span class="string">&quot;x64&quot;</span> <span class="keyword">or</span> <span class="string">&quot;x86&quot;</span></span><br><span class="line">            <span class="keyword">for</span> _, lib <span class="keyword">in</span> <span class="built_in">ipairs</span>(&#123;<span class="string">&quot;msmpi&quot;</span>, <span class="string">&quot;msmpifec&quot;</span>, <span class="string">&quot;msmpifmc&quot;</span>&#125;) <span class="keyword">do</span></span><br><span class="line">                <span class="keyword">local</span> linkinfo = find_library(lib, paths, &#123;suffixes = <span class="built_in">path</span>.join(<span class="string">&quot;Lib&quot;</span>, arch)&#125;)</span><br><span class="line">                <span class="keyword">if</span> linkinfo <span class="keyword">then</span></span><br><span class="line">                    <span class="built_in">table</span>.<span class="built_in">insert</span>(result.linkdirs, linkinfo.linkdir)</span><br><span class="line">                    <span class="built_in">table</span>.<span class="built_in">insert</span>(result.links, lib)</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            result.linkdirs = <span class="built_in">table</span>.unique(result.linkdirs)</span><br><span class="line"></span><br><span class="line">            <span class="comment">-- find headers</span></span><br><span class="line">            <span class="keyword">local</span> <span class="built_in">path</span> = find_path(<span class="string">&quot;mpi.h&quot;</span>, paths, &#123;suffixes = <span class="string">&quot;Include&quot;</span>&#125;)</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">path</span> <span class="keyword">then</span></span><br><span class="line">                <span class="built_in">table</span>.<span class="built_in">insert</span>(result.includedirs, <span class="built_in">path</span>)</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">if</span> #result.includedirs &gt; <span class="number">0</span> <span class="keyword">and</span> #result.linkdirs &gt; <span class="number">0</span> <span class="keyword">then</span></span><br><span class="line">                <span class="keyword">return</span> result</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span>)</span><br></pre></td></tr></table></figure><p>从系统查找包，最重要的是路径的设置。一般来说，通过环境变量或者注册表获取路径是最佳选择，如果没有就默认安装路径查找，并且还需要提供一个用户可自定义的环境变量（此处 <code>MSMPI_ROOT</code>）用于手动指定查找路径。如果要与 cmake 保持一致，建议使用 <code>&lt;package&gt;_ROOT</code> 作为该环境变量的名称。有了路径之后，配合使用 <code>lib.detect.find_library</code> 模块与 <code>lib.detect.find_path</code> 模块即可完成包链接目录、头文件目录的设置。</p><p>除了显式查找之外，xmake 还会到系统包管理器查找，查找时使用的名称由 <code>add_extsources</code> 语句指定。下面的例子来自 <a href="https://link.zhihu.com/?target=https://github.com/xmake-io/xmake-repo/blob/master/packages/e/eigen/xmake.lua">eigen</a>。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">package</span>(<span class="string">&quot;eigen&quot;</span>)</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> is_plat(<span class="string">&quot;mingw&quot;</span>) <span class="keyword">and</span> is_subhost(<span class="string">&quot;msys&quot;</span>) <span class="keyword">then</span></span><br><span class="line">        add_extsources(<span class="string">&quot;pacman::eigen3&quot;</span>)</span><br><span class="line">    <span class="keyword">elseif</span> is_plat(<span class="string">&quot;linux&quot;</span>) <span class="keyword">then</span></span><br><span class="line">        add_extsources(<span class="string">&quot;pacman::eigen&quot;</span>, <span class="string">&quot;apt::libeigen3-dev&quot;</span>)</span><br><span class="line">    <span class="keyword">elseif</span> is_plat(<span class="string">&quot;macosx&quot;</span>) <span class="keyword">then</span></span><br><span class="line">        add_extsources(<span class="string">&quot;brew::eigen&quot;</span>)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><h2 id="远程拉取与系统查找相结合"><a href="#远程拉取与系统查找相结合" class="headerlink" title="远程拉取与系统查找相结合"></a>远程拉取与系统查找相结合</h2><p>一个包可以同时支持远程拉取与系统查找。例如 CUDA Samples 包的描述文件为：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">package</span>(<span class="string">&quot;cuda_samples&quot;</span>)</span><br><span class="line"></span><br><span class="line">    set_kind(<span class="string">&quot;library&quot;</span>, &#123;headeronly = <span class="literal">true</span>&#125;)</span><br><span class="line">    set_homepage(<span class="string">&quot;https://github.com/NVIDIA/cuda-samples&quot;</span>)</span><br><span class="line">    set_description(<span class="string">&quot;CUDA Sample Utility Code&quot;</span>)</span><br><span class="line"></span><br><span class="line">    add_urls(<span class="string">&quot;https://github.com/NVIDIA/cuda-samples/archive/refs/tags/$(version).tar.gz&quot;</span>,</span><br><span class="line">             <span class="string">&quot;https://github.com/NVIDIA/cuda-samples.git&quot;</span>)</span><br><span class="line">    add_versions(<span class="string">&quot;v11.6&quot;</span>, <span class="string">&quot;9b5542747bc0aa66371b29043e46b3438266586332637001f2184d75415b920d&quot;</span>)</span><br><span class="line"></span><br><span class="line">    on_fetch(<span class="function"><span class="keyword">function</span> <span class="params">(package, opt)</span></span></span><br><span class="line">        <span class="keyword">if</span> opt.system <span class="keyword">then</span></span><br><span class="line">            import(<span class="string">&quot;lib.detect.find_path&quot;</span>)</span><br><span class="line">            <span class="keyword">local</span> paths = &#123;</span><br><span class="line">                <span class="string">&quot;C:\\ProgramData\\NVIDIA Corporation\\CUDA Samples\\v*\\common&quot;</span></span><br><span class="line">                <span class="comment">-- add your custom path here</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">local</span> headerpath = find_path(<span class="string">&quot;helper_cuda.h&quot;</span>, paths, &#123;suffixes = &#123;<span class="string">&quot;inc&quot;</span>&#125;&#125;)</span><br><span class="line">            <span class="keyword">if</span> headerpath <span class="keyword">then</span></span><br><span class="line">                vprint(<span class="string">&quot;CUDA Samples Found: &quot;</span> .. <span class="built_in">path</span>.directory(headerpath))</span><br><span class="line">                <span class="keyword">return</span> &#123;includedirs = &#123;headerpath&#125;&#125;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span>)</span><br><span class="line"></span><br><span class="line">    add_includedirs(<span class="string">&quot;include/Common&quot;</span>)</span><br><span class="line">    on_install(<span class="function"><span class="keyword">function</span> <span class="params">(package)</span></span></span><br><span class="line">        <span class="built_in">os</span>.cp(<span class="string">&quot;Common&quot;</span>, <span class="built_in">package</span>:installdir(<span class="string">&quot;include&quot;</span>)) <span class="comment">-- for header only</span></span><br><span class="line">    <span class="keyword">end</span>)</span><br><span class="line"></span><br><span class="line">    on_test(<span class="function"><span class="keyword">function</span> <span class="params">(package)</span></span></span><br><span class="line">        <span class="built_in">assert</span>(<span class="built_in">os</span>.isfile(<span class="built_in">path</span>.join(<span class="built_in">package</span>:installdir(<span class="string">&quot;include&quot;</span>), <span class="string">&quot;Common&quot;</span>, <span class="string">&quot;helper_cuda.h&quot;</span>)))</span><br><span class="line">    <span class="keyword">end</span>)</span><br><span class="line"></span><br><span class="line">package_end()</span><br></pre></td></tr></table></figure><p>在使用 <code>add_requires</code> 集成时，xmake 会优先执行 <code>on_fetch</code> 定义的从系统查找过程，如果找到，则将其加入项目；如果没有找到，则从远程下载。由于仅用到 sample 里面的头文件，这里的 <code>on_install</code> 函数仅做了简单的 copy，这是纯头文件库的一大好处：安装方便。对纯头文件库，xmake 提供了语句 <code>set_kind(&quot;library&quot;, &#123;headeronly = true&#125;)</code>，这一语句写在描述域，作用是忽略该库的链接时设置，例如动态库&#x2F;静态库、动态 runtime&#x2F;静态 runtime 等。</p><h2 id="从本地源码编译"><a href="#从本地源码编译" class="headerlink" title="从本地源码编译"></a>从本地源码编译</h2><p>xmake 的包管理既支持远程路径，也支持本地路径。这一功能可以用于集成源码在本地的第三方库（特别是，使用 git submodules 管理的第三方库源码）。远程路径用 <code>add_urls</code> 来声明，本地路径则用 <code>set_sourcedir</code> 语句来声明。例如，第三方库放在相对于包描述文件（直接写进 xmake.lua 的情况，包描述文件也就是 xmake.lua 构建描述文件）的 <code>third_party/mylib</code> 文件夹下，则 <code>add_urls</code> 和 <code>add_versions</code> 语句换为：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set_sourcedir(<span class="built_in">path</span>.join(<span class="built_in">os</span>.scriptdir(), <span class="string">&quot;third_party&quot;</span>, <span class="string">&quot;mylib&quot;</span>))</span><br></pre></td></tr></table></figure><p>其他全部与前文一致即可。</p><p>从零开始编写包描述文件绝不是一件容易的事情，甚至仅仅完全读懂上面的代码、理解其中每一个函数也是有一定难度的。限于篇幅，此处无法对其一一介绍，感兴趣的读者可以在官方文档中找到更多说明。如果你希望编写某个包描述文件并发布到仓库，但现有仓库中的包描述文件都不满足需要时，欢迎来 GitHub 讨论区交流获取灵感！</p><h1 id="自建-Xmake-repo-仓库"><a href="#自建-Xmake-repo-仓库" class="headerlink" title="自建 Xmake-repo 仓库"></a>自建 Xmake-repo 仓库</h1><p>xmake 支持自建仓库与官方仓库共存。一个仓库的基本结构如下</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">root</span><br><span class="line">|- packages</span><br><span class="line">    |- a</span><br><span class="line">        |- abc</span><br><span class="line">            |- xmake.lua</span><br><span class="line">    ...</span><br><span class="line">|- xmake.lua</span><br></pre></td></tr></table></figure><p>package 文件夹存放所有的包描述文件。这些文件放在<strong>与包名一致</strong>的文件夹内，包名文件夹又按照其首字母区分放在不同的文件夹内。这里文件夹名一定要与包描述文件里 <code>package(&quot;xxx&quot;)</code> 语句写的包名一致！最外层的 xmake.lua 是仓库的描述文件，其结构如下：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set_xmakever(<span class="string">&quot;2.6.1&quot;</span>) <span class="comment">-- minimal xmake version requirement for the repository</span></span><br><span class="line">set_description(<span class="string">&quot;repository for project xxx&quot;</span>) <span class="comment">-- description of the repository</span></span><br></pre></td></tr></table></figure><p>这一仓库既可以放在本地，也可以放在云端。例如，仓库的文件夹名为 myrepo，放在项目根目录下，则可以用如下语句将仓库加入构建文件中：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add_repositories(<span class="string">&quot;local-repo myrepo&quot;</span>)</span><br></pre></td></tr></table></figure><p><code>add_repositories</code> 语句接收一个字符串，字符串的各个部分以空格进行拼接。第一部分表示仓库的显示名称，第二部分为仓库的路径。如果路径为相对路径，则默认为相对于项目根目录的路径。<code>add_repositories</code> 语句还可以声明远程仓库：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add_repositories(<span class="string">&quot;remote-repo git@github.com:myrepo/xmake-repo.git dev&quot;</span>)</span><br></pre></td></tr></table></figure><p>这里的第三部分表示 git 仓库的 branch 或者 commit，可以省略，此时 xmake 将使用其默认 branch。在 xmake.lua 中添加自建仓库后，自建仓库的<strong>所有包</strong>都可以直接通过 <code>add_requires</code> 引入了。也就是说，如果需要批量引入自定义第三方库，自建仓库是你最好的选择。</p><h1 id="集成-Vcpkg-包管理"><a href="#集成-Vcpkg-包管理" class="headerlink" title="集成 Vcpkg 包管理"></a>集成 Vcpkg 包管理</h1><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ xmake f --vcpkg=F:\vcpkg</span><br></pre></td></tr></table></figure><p>比如加载以下库，xmake.lua 示例：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">add_requires(<span class="string">&quot;vcpkg::zlib 1.2.11&quot;</span>)</span><br><span class="line">target(<span class="string">&quot;test&quot;</span>)    </span><br><span class="line">add_files(<span class="string">&quot;src/*.c&quot;</span>)    </span><br><span class="line">add_packages(<span class="string">&quot;vcpkg::zlib&quot;</span>)</span><br></pre></td></tr></table></figure><p>至于加载 conan 的库，需要下载 exe 文件。安装后，配置 path 路径，然后就可以使用了如下：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add_requires(<span class="string">&quot;conan::poco/1.9.4&quot;</span>, &#123;alias = <span class="string">&quot;poco&quot;</span>, <span class="built_in">debug</span> = <span class="literal">true</span>&#125;)</span><br></pre></td></tr></table></figure><h1 id="添加代理"><a href="#添加代理" class="headerlink" title="添加代理"></a>添加代理</h1><p>注意添加代理,这样访问 github 会快：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ xmake g --proxy_pac=github_mirror.lua  </span><br></pre></td></tr></table></figure><h1 id="Xmake-的包管理工具-Xrepo"><a href="#Xmake-的包管理工具-Xrepo" class="headerlink" title="Xmake 的包管理工具 Xrepo"></a>Xmake 的包管理工具 Xrepo</h1><p>使用举例：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ xrepo search xxx</span><br><span class="line">$ xrepo list-repo</span><br><span class="line">$ xrepo rm-repo xxx</span><br></pre></td></tr></table></figure><p>在 xmake.lua 下写就更简单了，增加一句话就行：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add_requires(<span class="string">&quot;zlib 1.2.11&quot;</span>)</span><br></pre></td></tr></table></figure><p>还可以用其他包管理器的包，比如：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">add_requires(<span class="string">&quot;vcpkg::zlib 1.2.11&quot;</span>)</span><br><span class="line">target(<span class="string">&quot;test&quot;</span>)</span><br><span class="line">    add_files(<span class="string">&quot;src/*.c&quot;</span>)</span><br><span class="line">    add_packages(<span class="string">&quot;vcpkg::zlib&quot;</span>)</span><br></pre></td></tr></table></figure><h1 id="Build-结果示例"><a href="#Build-结果示例" class="headerlink" title="Build 结果示例"></a>Build 结果示例</h1>]]></content>
      
      
      <categories>
          
          <category> 编程工具 </category>
          
          <category> Xmake </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>A Tour of xmake - 03. 依赖管理</title>
      <link href="/posts/%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7/Xmake/A%20Tour%20of%20xmake%20-%2003.%20%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86.html"/>
      <url>/posts/%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7/Xmake/A%20Tour%20of%20xmake%20-%2003.%20%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86.html</url>
      
        <content type="html"><![CDATA[<h1 id="引入远程依赖"><a href="#引入远程依赖" class="headerlink" title="引入远程依赖"></a>引入远程依赖</h1><p>xmake 中引入远程依赖的形式非常简单，一行 <code>add_requires</code> 语句即可。以 imgui 为例，建立目录结构如下</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root</span><br><span class="line">|- src</span><br><span class="line">    |- main.cpp</span><br><span class="line">|- xmake.lua</span><br></pre></td></tr></table></figure><p>源文件来自 imgui 的示例文件 <a href="https://link.zhihu.com/?target=https://github.com/ocornut/imgui/blob/v1.88/examples/example_glfw_opengl3/main.cpp">main.cpp</a>，在文件的开头需要加一行 <code>#include &quot;imgui_impl_opengl3_loader.h&quot;</code>。xmake.lua 文件内容如下</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">add_rules(<span class="string">&quot;mode.debug&quot;</span>, <span class="string">&quot;mode.release&quot;</span>)</span><br><span class="line">add_requires(<span class="string">&quot;imgui 1.88&quot;</span>, &#123;configs = &#123;glfw_opengl3 = <span class="literal">true</span>&#125;&#125;)</span><br><span class="line">target(<span class="string">&quot;imgui-demo&quot;</span>)</span><br><span class="line">    set_kind(<span class="string">&quot;binary&quot;</span>)</span><br><span class="line">    add_files(<span class="string">&quot;src/main.cpp&quot;</span>)</span><br><span class="line">    add_packages(<span class="string">&quot;imgui&quot;</span>)</span><br></pre></td></tr></table></figure><p>这里用到了 <code>add_requires</code> 语句。这一语句的基本用法为</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add_requires(<span class="string">&quot;&lt;package&gt; &lt;version-range&gt;&quot;</span>, &#123;&lt;options&gt;, configs = &#123;&lt;<span class="built_in">config</span>-options&gt;&#125;&#125;)</span><br></pre></td></tr></table></figure><ul><li><code>&lt;package&gt;</code> 顾名思义表示包名，一个包在 xmake-repo 中的名字可能与想象中不同，这时需要到 <a href="https://link.zhihu.com/?target=https://xrepo.xmake.io/%23/">xrepo</a> 网站查证，或者在本地命令行运行 <code>xrepo search &lt;package&gt;</code> 来查证。如果需要的包尚未收录，也不用着急，后面还会介绍其他引入依赖的方式。</li><li><code>&lt;version-range&gt;</code> 表示版本范围。xmake 支持多种版本范围声明，以下几种声明都是合法的：</li><li><code>mylib 1.x</code></li><li><code>mylib &gt;=1.0.0 &lt;1.2.0</code></li><li><code>mylib ~1.0.3</code> 详细的语义版本范围见 <a href="https://link.zhihu.com/?target=https://github.com/uael/sv%23versions">uael&#x2F;sv</a>。</li><li><code>&lt;options&gt;</code> 包含了一系列限定选项，例如 <code>&#123;system = true&#125;</code> 表示仅从系统查找，<code>&#123;optional = true&#125;</code> 表示允许查找和安装都失败，<code>&#123;verify = false&#125;</code> 表示跳过验证强制启用声明的版本，等等。</li><li><code>&lt;config-options&gt;</code> 用于声明包本身的构建选项。这一选项因项目而异，常用有 <code>&#123;shared = true&#125;</code> 表示使用动态库等。一个包可更改的构建选项可以用 <code>xrepo info &lt;package&gt;</code> 查看。</li></ul><p>从上面的 xmake.lua 代码片段还可以看到一个语句 <code>add_packages</code>。这一语句的作用是将引入的第三方库导入对应的 target 作为依赖。这一语句作用的 target 在编译时会自动带上第三方库的头文件目录，链接到第三方库，并设置第三方库可能带来的一些编译参数。默认情况下，引入的头文件目录不会继承给子 target，但是可以用 <code>add_packages(&lt;package&gt;, &#123;public = true&#125;)</code> 来更改这一默认行为。</p><p>上述代码设置好之后，输入 <code>xmake</code> 编译，<code>xmake run</code> 运行，就可以看到 imgui 的 demo 窗口了。是不是很简单呢？</p><p>imgui 是一个比较简单的库，没有太多的依赖项。然而，对于一些更复杂的库，他们本身又依赖其他的库，最终形成一个<strong>依赖链</strong>。仅仅更改库本身的选项，而不处理依赖链的选项，很容易造成依赖链上的库冲突。为了减少这种冲突现象，xmake 也提供了修改依赖链上库的语句：<code>add_requireconfs</code>。例如，libpng 依赖 zlib，要是希望 libpng 和 zlib 都被编译为动态链接库，则应该使用如下语句：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">add_requires(<span class="string">&quot;libpng&quot;</span>, &#123;configs = &#123;shared = <span class="literal">true</span>&#125;&#125;)</span><br><span class="line">add_requireconfs(<span class="string">&quot;libpng.zlib&quot;</span>, &#123;configs = &#123;shared = <span class="literal">true</span>&#125;&#125;)</span><br></pre></td></tr></table></figure><p>如果还希望使用的 zlib 为 1.2.12 版本，则可以这样写：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">add_requires(<span class="string">&quot;libpng&quot;</span>, &#123;configs = &#123;shared = <span class="literal">true</span>&#125;&#125;)</span><br><span class="line">add_requireconfs(<span class="string">&quot;libpng.zlib&quot;</span>, &#123;version = <span class="string">&quot;1.2.12&quot;</span>, configs = &#123;shared = <span class="literal">true</span>&#125;&#125;)</span><br></pre></td></tr></table></figure><p>这一功能还可以用于解决菱形依赖问题。xmake 中，可以用一行语句使依赖链上的每一个依赖 zlib 的包都依赖同一个 zlib 包（这时依赖链变成依赖图）：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add_requireconfs(<span class="string">&quot;*.zlib&quot;</span>, &#123;version = <span class="string">&quot;1.2.12&quot;</span>, configs = &#123;shared = <span class="literal">true</span>&#125;&#125;)</span><br></pre></td></tr></table></figure><p>关于 <code>add_requireconfs</code> 的更多用法，请参考 xmake 官方文档。</p><blockquote><p>Tips. 对于远程依赖，依赖的引入可能导致构建一致性被破坏。要想固定远程依赖的版本，xmake 也有相应的语句。只需要在 <code>add_requires</code> 之前写 <code>lua set_policy(&quot;package.requires_lock&quot;, true)</code> 这时，在第一次构建成功后会生成 <code>xmake-requires.lock</code> 文件。这一文件存在时，所有依赖的版本将被固定，不会自动升级。如果能将 <code>xmake-requires.lock</code> 上传到 git，其他人在编译你的项目时再也不会因为依赖版本不匹配而烦恼了！</p></blockquote><h1 id="使用本地依赖"><a href="#使用本地依赖" class="headerlink" title="使用本地依赖"></a>使用本地依赖</h1><p>第 0 节 - 简介中提到，xmake 可以使用来自系统包管理器、vcpkg、conan、conda 等多个包管理器的包。这些包的引入丰富了 xmake 支持的第三方库源，即使 xmake-repo 未能收录的包，也可以通过这些方式间接引入。部分包在包描述文件中已经写有搜索部分，直接使用 <code>add_requires</code> 就可以自动从系统查找，例如 <code>cuda</code>；而其他包则需要显示说明第三方包管理器源。引入其他包管理器的包基本语法仍是使用 <code>add_requires</code>：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">add_requires(<span class="string">&quot;conan::poco/1.12.1&quot;</span>, &#123;alias = <span class="string">&quot;poco&quot;</span>,</span><br><span class="line">    configs = &#123;settings = &#123;<span class="string">&quot;compiler=gcc&quot;</span>, <span class="string">&quot;compiler.libcxx=libstdc++11&quot;</span>&#125;&#125;&#125;)</span><br><span class="line">add_requires(<span class="string">&quot;apt::libudev-dev&quot;</span>, &#123;alias = <span class="string">&quot;libudev&quot;</span>&#125;)</span><br><span class="line">add_requires(<span class="string">&quot;conda::openssl&quot;</span>, &#123;alias = <span class="string">&quot;openssl&quot;</span>&#125;)</span><br></pre></td></tr></table></figure><p>各个包管理器的参数设置方式可以在官方文档中找到。这里设置 alias 别名的好处是后面使用 <code>add_packages</code> 添加包时较为简单，无需考虑包的来源。需要注意的是，Windows 上包管理器安装的包需要注意其 runtime 是静态还是动态。xmake 默认使用静态 runtime，但是大部分其他包管理器默认使用动态 runtime。可以使用如下语句切换 xmake 默认 runtime 为动态：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set_runtimes(<span class="string">&quot;MD&quot;</span>)</span><br></pre></td></tr></table></figure><p>这一语句通常放在所有 target 声明之前，全局生效，以避免链接冲突。</p><p>对于包管理器未收录的包，xmake 还支持从 pkg-config 文件和 cmake 文件中查找。其使用方法也类似于包管理器：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">add_requires(<span class="string">&quot;pkg-config::cairo&quot;</span>, &#123;alias = <span class="string">&quot;cairo&quot;</span>&#125;)</span><br><span class="line">add_requires(<span class="string">&quot;cmake::Vulkan&quot;</span>, &#123;alias = <span class="string">&quot;vulkan&quot;</span>,</span><br><span class="line">    configs = &#123;envs = &#123;CMAKE_PREFIX_PATH = <span class="string">&quot;/usr/local/vulkan-sdk&quot;</span>&#125;&#125;&#125;)</span><br></pre></td></tr></table></figure><p>从 cmake 查找包的功能还不是很成熟，如果遇到问题，请在 GitHub 的讨论区或 issue 报告。</p><p>如果上述方案都不奏效，怎么办呢？一种办法是回归最原始的依赖管理——submodule 形式，使用 submodule 将第三方库的源码也作为项目的一部分。这时可以写一个 xmake.lua 来编译第三方库，使用 <code>includes</code> 语句来引入第三方库，例如</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">add_rules(<span class="string">&quot;mode.debug&quot;</span>, <span class="string">&quot;mode.release&quot;</span>)</span><br><span class="line">includes(<span class="string">&quot;third_party/dep1&quot;</span>)</span><br><span class="line">target(<span class="string">&quot;example1&quot;</span>)</span><br><span class="line">    set_kind(<span class="string">&quot;binary&quot;</span>)</span><br><span class="line">    add_deps(<span class="string">&quot;dep1&quot;</span>)</span><br><span class="line">    add_files(<span class="string">&quot;examples/example1.cpp&quot;</span>)</span><br></pre></td></tr></table></figure><p>这种方法对中小型依赖都比较方便。一般情况下，使用 cmake 1000 行左右的构建文件，使用 xmake 重写只用大概 200 行。另一种办法就是下一节要讲到的依赖仓库功能了。你可以自己编写自己的包描述文件，xmake 会将你自己编写的包像已经收录到 xmake-repo 中一样处理。当然，如果能将你编写的包描述文件贡献到 xmake-repo 中造福后人，那就更好了！</p><h1 id="管理已安装的包"><a href="#管理已安装的包" class="headerlink" title="管理已安装的包"></a>管理已安装的包</h1><blockquote><p>Tips. xmake 默认会将第三方库安装到 <code>~/.xmake</code> 文件夹下（Windows 上为 <code>C:\Users\&lt;username&gt;\Appdata\Local\.xmake</code>）。这一行为可以通过环境变量 <code>XMAKE_PKG_CACHEDIR</code> 和 <code>XMAKE_PKG_INSTALLDIR</code> 更改。</p></blockquote><p>xmake 使用 xrepo 命令作为单独的包管理命令。xrepo 的一些常用功能列举如下：</p><ul><li><code>xrepo search &lt;package&gt;</code>：用于搜索含有特定字符串的包。如果有浏览器，也可以使用 <a href="https://link.zhihu.com/?target=https://xrepo.xmake.io/%23/">xrepo</a> 网站的搜索功能。</li><li><code>xrepo info &lt;package&gt;</code>：用于查看包的详细信息。</li><li><code>xrepo scan</code>：用于查看所有已安装的包。</li><li><code>xrepo clean</code>：用于清理安装远程包时的缓存，以及清理一段时间内未使用过的包。</li><li><code>xrepo install &lt;package&gt;</code>：用于安装远程包到本地。可以使用 <code>-f</code> 参数声明远程包的构建选项。</li><li><code>xrepo remove &lt;package&gt;</code>：用于移除本地包。这一命令只会移除默认参数的本地包，要想完全移除，需要加上 <code>--all</code> 参数。</li></ul><p>xrepo 命令还有一些非常强大的功能，这些功能将在后面的章节中展开。</p><h1 id="一些特殊的依赖库"><a href="#一些特殊的依赖库" class="headerlink" title="一些特殊的依赖库"></a>一些特殊的依赖库</h1><h2 id="OpenMP"><a href="#OpenMP" class="headerlink" title="OpenMP"></a>OpenMP</h2><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add_requires(<span class="string">&quot;openmp&quot;</span>)</span><br></pre></td></tr></table></figure><p>可用的 configs： - <code>runtime</code>：设置 OpenMP 提供商。有 <code>default</code> 和 <code>custom</code> 两种选项，默认使用第一种，即使用平台默认的 OpenMP，对 msvc 为内置的 OpenMP 实现 vcomp，对 gcc 采用 libgomp，对 clang 采用 libomp。如果想要使用其他的实现，可以设置该项为 <code>custom</code>，然后自己手动链接其他 openmp 实现。 - <code>experimental</code>：启用实验性的 OpenMP 功能，目前仅对 msvc 生效。</p><h2 id="CUDA"><a href="#CUDA" class="headerlink" title="CUDA"></a>CUDA</h2><p>正常使用 CUDA 语言无需引入依赖，使用 <code>add_files</code> 添加.cu 源文件即可。由于 NVIDIA 不开放 CUDA 的脚本安装，xmake 并不执行 CUDA 的下载安装部分，使用 CUDA 需要用户自行在机器上安装好 CUDA。如果 CUDA Toolkit 安装在默认位置，configure 阶段可以直接设置使用的 CUDA 版本：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ xmake config --cuda=11.7</span><br></pre></td></tr></table></figure><p>否则，需要声明 CUDA Toolkit 的安装位置：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ xmake config --cuda=/path/to/cuda-toolkit</span><br></pre></td></tr></table></figure><p>当使用 CUDA 提供的库（cublas，cusolver 等）时，这才需要引入依赖。引入 CUDA 依赖的语句为</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add_requires(<span class="string">&quot;cuda&quot;</span>, &#123;configs = &#123;utils = &#123;<span class="string">&quot;cublas&quot;</span>, <span class="string">&quot;cusolver&quot;</span>, ...&#125;&#125;&#125;)</span><br></pre></td></tr></table></figure><p>之后正常使用 <code>add_packages</code> 添加依赖即可。</p><h2 id="Boost"><a href="#Boost" class="headerlink" title="Boost"></a>Boost</h2><p>Boost 是一个很多库的集合，xmake 中使用 configs 控制需要安装的组件。如果只使用 Boost 纯头文件的部分，直接 <code>add_requires(&quot;boost&quot;)</code> 即可。如果用到 Boost 需要编译安装的组件（例如 filesystem，serialization）可以用如下语句：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add_requires(<span class="string">&quot;boost&quot;</span>, &#123;configs = &#123;filesystem = <span class="literal">true</span>, serialization = <span class="literal">true</span>, ...&#125;&#125;)</span><br></pre></td></tr></table></figure><p>如果图方便，可以直接安装 boost 的所有组件：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add_requires(<span class="string">&quot;boost&quot;</span>, &#123;configs = &#123;all = <span class="literal">true</span>&#125;&#125;)</span><br></pre></td></tr></table></figure><p>很多第三方库依赖 boost。为了避免菱形依赖问题，最好能自行分析好同时满足项目要求与第三方库要求的 boost 配置，然后使用 <code>add_requireconfs</code> 进行设置。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> boost_configs = &#123;filesystem = <span class="literal">true</span>, serialization = <span class="literal">true</span>, ...&#125;</span><br><span class="line">add_requires(<span class="string">&quot;boost 1.79.0&quot;</span>, &#123;configs = boost_configs&#125;)</span><br><span class="line">add_requireconfs(<span class="string">&quot;*.boost&quot;</span>, &#123;version = <span class="string">&quot;1.79.0&quot;</span>, configs = boost_configs&#125;)</span><br></pre></td></tr></table></figure><h2 id="Qt"><a href="#Qt" class="headerlink" title="Qt"></a>Qt</h2><p>Qt 是一个非常庞大的 C++ 类库，xmake 针对 Qt 做了特殊处理，部分语句有所变化。类似 CUDA，Qt 的安装较为复杂，最好能自行安装好 Qt，由 xmake 来查找。xmake 目前提供了部分 Qt 库的下载安装功能，但尚不完整。安装 Qt 后，可以在 configure 阶段设置 Qt 安装位置：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ xmake config --qt=/path/to/qt</span><br></pre></td></tr></table></figure><p>Qt 不仅提供了一系列类库，还提供了 moc、uic 等代码生成器，并通过这些生成器对 C++ 语言进行了扩展，因此 <code>add_requires</code> 无法满足 Qt 的需要。这时就该 <code>add_rules</code> 来发挥作用了。对于一个 Qt Widget Application，写法如下：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">add_rules(<span class="string">&quot;mode.debug&quot;</span>, <span class="string">&quot;mode.release&quot;</span>)</span><br><span class="line">target(<span class="string">&quot;qtmain&quot;</span>)</span><br><span class="line">    set_kind(<span class="string">&quot;binary&quot;</span>)</span><br><span class="line">    add_rules(<span class="string">&quot;qt.widget&quot;</span>)</span><br><span class="line">    add_files(<span class="string">&quot;src/*.cpp&quot;</span>)</span><br><span class="line">    add_files(<span class="string">&quot;src/*.h&quot;</span>) <span class="comment">-- pass header files to qt meta-object-compiler(moc)</span></span><br><span class="line">    add_frameworks(<span class="string">&quot;QtCore&quot;</span>, <span class="string">&quot;QtGui&quot;</span>, <span class="string">&quot;QtWidgets&quot;</span>) <span class="comment">-- set enabled qt frameworks</span></span><br></pre></td></tr></table></figure><p>关于 Qt 程序的更多细节，请参考官方文档。</p><blockquote><p>Tips. <code>add_frameworks</code> 的本来作用是在 Mac OS 上添加 Framework 依赖，例如 <code>add_frameworks(&quot;CoreFoundation&quot;)</code>。只有在 Qt 程序中才可以用来表示启用 Qt Framework。</p></blockquote><h2 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h2><p>如果系统已安装有 python3，可以用</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add_requires(<span class="string">&quot;python 3.x&quot;</span>, &#123;system = <span class="literal">true</span>, kind = <span class="string">&quot;binary&quot;</span>&#125;)</span><br></pre></td></tr></table></figure><p>引入 python 解释器作为依赖。如果 xmake 没有找到 python 解释器，就会报错。如果要引入 python 作为库链接到程序，去掉 <code>kind</code> 设定即可：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add_requires(<span class="string">&quot;python 3.x&quot;</span>, &#123;system = <span class="literal">true</span>&#125;)</span><br></pre></td></tr></table></figure><p>xmake 还提供 python 的下载安装功能。如果不想使用系统上的 python，可以使用 xmake 安装的 python：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add_requires(<span class="string">&quot;python 3.x&quot;</span>, &#123;system = <span class="literal">false</span>&#125;)</span><br></pre></td></tr></table></figure><p>如果使用 xmake 安装的 python，在项目根目录运行 <code>xrepo env shell</code> 即可进入虚拟环境，执行 <code>python</code> 进入 python 解释器，执行 <code>pip install numpy …</code> 来安装 python 的各种包。在虚拟环境执行的操作都会保存，直到这次 python 安装被清理。运行 <code>xrepo remove --all python</code> 可以交互式地移除 xmake 安装的 python 包。</p><blockquote><p>Tips. 如果系统上尚未安装 python，xmake 提供了一键下载安装激活 python 环境的命令： <code>shell $ xrepo env -b python3 shell</code></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 编程工具 </category>
          
          <category> Xmake </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>A Tour of xmake - 02. 编译选项</title>
      <link href="/posts/%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7/Xmake/A%20Tour%20of%20xmake%20-%2002.%20%E7%BC%96%E8%AF%91%E9%80%89%E9%A1%B9.html"/>
      <url>/posts/%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7/Xmake/A%20Tour%20of%20xmake%20-%2002.%20%E7%BC%96%E8%AF%91%E9%80%89%E9%A1%B9.html</url>
      
        <content type="html"><![CDATA[<h1 id="创建空工程"><a href="#创建空工程" class="headerlink" title="创建空工程"></a>创建空工程</h1><p>xmake 提供了 <code>xmake create</code> 命令，可以很方便的快速创建基于 c&#x2F;c++, swift, objc 等各种语言的空工程项目，比如：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ xmake create <span class="built_in">test</span>  </span><br></pre></td></tr></table></figure><p>可以用 <code>-P xxx</code> 来指定项目目录名，默认会创建一个 c++ 的 hello world 工程，根目录下会生成一个 xmake.lua 用于描述项目的构建规则。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">add_rules(<span class="string">&quot;mode.debug&quot;</span>, <span class="string">&quot;mode.release&quot;</span>) </span><br><span class="line">target(<span class="string">&quot;test&quot;</span>) </span><br><span class="line">    set_kind(<span class="string">&quot;binary&quot;</span>) </span><br><span class="line">    add_files(<span class="string">&quot;src/*.cpp&quot;</span>)</span><br></pre></td></tr></table></figure><p>这是一个非常简单的 xmake.lua 描述，<code>target(&quot;test&quot;)</code> 定义了一个子工程模块 test，每个 target 会生成一个对应的目标文件，此处的 binary 类型，指定创建一个最基础的可执行文件。</p><p>而最上面的 <code>mode.debug</code> 和 <code>mode.release</code> 规则设置，是可选设置，但是通常我们都会建议加上，这样默认就可以生效两种常用的构建模式：debug 和 release</p><h1 id="执行编译"><a href="#执行编译" class="headerlink" title="执行编译"></a>执行编译</h1><p>通常我们如果只是编译当前主机环境的可执行文件，只需要执行 xmake 这个命令就可以了。xmake 默认会检测当前环境已存在的构建环境，比如笔者当前的 xcode 环境，然后默认采用 release 模式编译，如果设置了 <code>mode.release</code> 规则，那么就会生效。</p><h1 id="编译模式切换"><a href="#编译模式切换" class="headerlink" title="编译模式切换"></a>编译模式切换</h1><p>而如果我们要切到 <code>mode.debug</code> 编译，只需要：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ xmake f -m <span class="built_in">debug</span></span><br><span class="line">$ xmake</span><br></pre></td></tr></table></figure><p>其中，<code>xmake f</code> 是 <code>xmake config</code> 命令的简写，用来快速的切换配置，如果上手之后，通常采用简写会更加方便，更多命令的简写，都可执行 <code>xmake --help</code> 查看。</p><h1 id="创建其他模板工程"><a href="#创建其他模板工程" class="headerlink" title="创建其他模板工程"></a>创建其他模板工程</h1><p><code>xmake create</code> 还可以用来创建各种其他类型的工程项目，我们可以敲 <code>xmake create --help</code></p><p>可以通过 <code>-l/--language</code> 来指定工程语言，而 <code>-t/--template</code> 用来指定创建的工程模板类型。</p><p>比如，我们创建一个基于 c 的静态库项目：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ xmake create -l c -t static <span class="built_in">test</span></span><br></pre></td></tr></table></figure><p>我们也可以创建基于 qt 的 quickapp 项目：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ xmake create -l c++ -t qt.quickapp <span class="built_in">test</span></span><br></pre></td></tr></table></figure><p>会自动检测你的 qt 本机安装的环境，自动的找到。当然也可以指定：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ xmake f --qt=/home/xxx/qtsdk</span><br></pre></td></tr></table></figure><p>或者设置到全局路径，避免每次编译切换都要配置一遍：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ xmake g --qt=/home/xxx/qtsdk</span><br></pre></td></tr></table></figure><p>除了源文件的添加，其他基本上都跟之前的可执行程序项目没什么不同，唯一的区别就是通过 <code>add_rules(&quot;qt.quickapp&quot;)</code> 这个内置的 Qt 构建规则来代替 <code>set_kind(&quot;binary&quot;)</code>。</p><p>其实 <code>qt.quickapp</code> 规则内部最终还是设置了 binary 类型，只不过在此基础上额外增加了一些只有 Qt 才需要的构建规则，比如：特定 links，flags 还有 includedirs 等。</p><p>除了 c&#x2F;c++ 项目，xmake 还支持其他语言的项目编译，但 xmake 重点还是在 c&#x2F;c++ 上，支持其他语言也主要是为了支持跟 c&#x2F;c++ 进行混合编译，毕竟其他语言向 rust 什么的官方有提供更好的构建方案。</p><p>不过我们还是可以使用 xmake 来尝试编译他们：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ xmake create -l rust <span class="built_in">test</span></span><br><span class="line">$ xmake</span><br></pre></td></tr></table></figure><h1 id="运行生成目标"><a href="#运行生成目标" class="headerlink" title="运行生成目标"></a>运行生成目标</h1><p>xmake 也提供了 run 命令，直接运行生成后的可执行文件，用于方便快速的进行测试，例如：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ xmake run</span><br><span class="line">hello xmake!</span><br></pre></td></tr></table></figure><h1 id="添加运行环境变量"><a href="#添加运行环境变量" class="headerlink" title="添加运行环境变量"></a>添加运行环境变量</h1><p>我们也可以在 xmake.lua 中通过 <code>add_runenvs</code> 接口来添加设置默认运行 target 程序的环境变量。</p><p>所以，对于 PATH 这种，通过此接口追加值是非常方便的，而且此接口支持多值设置，所以通常就是用来设置带有 path sep 的多值 env。。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">target(<span class="string">&quot;test&quot;</span>)</span><br><span class="line">    set_kind(<span class="string">&quot;binary&quot;</span>)</span><br><span class="line">    add_files(<span class="string">&quot;src/*.c&quot;</span>)</span><br><span class="line">    add_runenvs(<span class="string">&quot;PATH&quot;</span>, <span class="string">&quot;/tmp/bin&quot;</span>, <span class="string">&quot;xxx/bin&quot;</span>)</span><br><span class="line">    add_runenvs(<span class="string">&quot;LD_LIBRARY_PATH&quot;</span>, <span class="string">&quot;/tmp/lib&quot;</span>, <span class="string">&quot;xxx/lib&quot;</span>)</span><br></pre></td></tr></table></figure><p>更多关于此接口的描述，可以看下文档：<a href="https://link.zhihu.com/?target=https://xmake.io/%23/zh-cn/manual/project_target?id=targetadd_runenvs">add_runenvs接口文档</a></p><h1 id="自定义运行逻辑"><a href="#自定义运行逻辑" class="headerlink" title="自定义运行逻辑"></a>自定义运行逻辑</h1><p>如果单纯的环境设置，以及默认的加载运行规则不满足需求，我们可以通过定制化 <code>on_run</code> 脚本，实现更加复杂的运行逻辑：</p><p>例如，运行安装好的 apk 程序：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">target(<span class="string">&quot;test&quot;</span>)</span><br><span class="line">    <span class="comment">-- ...</span></span><br><span class="line">    <span class="comment">-- 设置自定义运行脚本，自动运行安装好的app程序，并且自动获取设备输出信息</span></span><br><span class="line">    on_run(<span class="function"><span class="keyword">function</span> <span class="params">(target)</span></span> </span><br><span class="line">        <span class="built_in">os</span>.run(<span class="string">&quot;adb shell am start -n com.demo/com.demo.DemoTest&quot;</span>)</span><br><span class="line">        <span class="built_in">os</span>.run(<span class="string">&quot;adb logcat&quot;</span>)</span><br><span class="line">    <span class="keyword">end</span>)</span><br></pre></td></tr></table></figure><h1 id="调试程序"><a href="#调试程序" class="headerlink" title="调试程序"></a>调试程序</h1><h1 id="命令行调试"><a href="#命令行调试" class="headerlink" title="命令行调试"></a>命令行调试</h1><p>我们也可以传递 <code>-d</code> 参数，调用 gdb&#x2F;lldb 等调试器程序，加载目标文件进行调试：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ xmake run -d</span><br></pre></td></tr></table></figure><p>xmake 将会使用系统自带的调试器去加载程序运行，目前支持：lldb, gdb, windbg, vsjitdebugger, ollydbg 等各种调试器。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[lldb]<span class="variable">$target</span> create <span class="string">&quot;build/hello&quot;</span></span><br><span class="line">[lldb]<span class="variable">$b</span> main</span><br><span class="line">[lldb]<span class="variable">$r</span></span><br></pre></td></tr></table></figure><h1 id="使用-Vscode-进行断点调试"><a href="#使用-Vscode-进行断点调试" class="headerlink" title="使用 Vscode 进行断点调试"></a>使用 Vscode 进行断点调试</h1><p>我们还可以通过 <a href="https://link.zhihu.com/?target=https://github.com/xmake-io/xmake-vscode">xmake-vscode</a> 插件配合 vscode 来实现对 c&#x2F;c++ 项目的断点调试支持。</p><p>另外我们还需要依赖 vscode 的 C++ 插件才能进行调试支持，不过由于开发 c&#x2F;c++ 程序，这个插件几乎是必需，所以并没有太大问题。</p><p>就算没有安装此插件，xmake-vscode 也会加载 lldb&#x2F;gdb&#x2F;vsjitdebugger 等系统调试器，直接加载调试。</p><h1 id="常用的编译器参数"><a href="#常用的编译器参数" class="headerlink" title="常用的编译器参数"></a>常用的编译器参数</h1><p>在 xmake 中添加编译参数的通用做法是使用 <code>add_&lt;language&gt;flags</code> 家族的几个函数：</p><ul><li><code>add_cflags</code>：添加 C 编译器的编译参数</li><li><code>add_cxxflags</code>：添加 C++ 编译器的编译参数</li><li><code>add_cuflags</code>：添加 CUDA 编译器的编译参数</li><li><code>add_asflags</code>：添加汇编语言的汇编参数</li><li><code>add_cxflags</code>：同时对 C 编译器和 C++ 编译器启用的编译参数</li><li><code>add_ldflags</code>：添加二进制文件链接参数</li><li><code>add_arflags</code>：添加静态库生成参数</li><li><code>add_shflags</code>：添加动态链接库生成参数</li></ul><p>在使用这些函数添加编译参数时，xmake 会自动检查编译参数的可用性，并对当前编译器启用可用的参数。若想略过这一检查过程，可以使用 <code>force</code> 参数指定。一个简单例子如下。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add_cxxflags(<span class="string">&quot;-march=native&quot;</span>, &#123;force = <span class="literal">true</span>&#125;) <span class="comment">-- skip the check</span></span><br></pre></td></tr></table></figure><blockquote><p>Tips. Lua 语言使用双横线 <code>--</code> 作为单行注释的标记。多行注释则使用 <code>--[[</code> 作为开头，<code>--]]</code> 作为结束。</p></blockquote><p>xmake 对一些常用的参数作了抽象，对这些参数无需手动指定其内容，实际编译时这些参数会自动根据编译器不同而变化。下面介绍其中的一些。</p><h2 id="指定语言版本"><a href="#指定语言版本" class="headerlink" title="指定语言版本"></a>指定语言版本</h2><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set_languages(<span class="string">&quot;c11&quot;</span>, <span class="string">&quot;cxx20&quot;</span>)</span><br></pre></td></tr></table></figure><p>xmake 中使用 <code>set_languages</code> 语句设置语言版本。与大部分声明不同，设置语言版本的语句通常放在所有 target 声明之前，全局生效，否则容易导致标准库冲突。xmake 中还提供了一个特殊的版本：<code>set_languages(&quot;cxxlatest&quot;)</code>，对 msvc 展开为 <code>-std:c++latest</code>，而对 gcc&#x2F;clang 则自动检测当前编译器支持的 C++ 标准并使用其中最新的标准。</p><h2 id="添加头文件目录"><a href="#添加头文件目录" class="headerlink" title="添加头文件目录"></a>添加头文件目录</h2><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add_includedirs(<span class="string">&quot;include&quot;</span>)</span><br></pre></td></tr></table></figure><p>头文件目录是 C&#x2F;C++ 编译器查找头文件的根目录，xmake 中使用 <code>add_includedirs</code> 指定。这一语句通常对单个 target 生效，在 msvc、gcc、clang 均展开为 <code>-Iinclude</code>。</p><h2 id="添加链接目录与链接库"><a href="#添加链接目录与链接库" class="headerlink" title="添加链接目录与链接库"></a>添加链接目录与链接库</h2><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">add_linkdirs(<span class="string">&quot;ext/lib&quot;</span>)</span><br><span class="line">add_links(<span class="string">&quot;myext&quot;</span>)</span><br><span class="line">add_syslinks(<span class="string">&quot;pthread&quot;</span>, <span class="string">&quot;m&quot;</span>)</span><br></pre></td></tr></table></figure><p>链接目录是链接器查找第三方链接库的目录，xmake 中使用 <code>add_linkdirs</code> 指定，而第三方链接库则使用 <code>add_links</code> 指定。有一些第三方链接库是系统提供的，这些库需要放在链接顺序的末尾以规避链接顺序问题，这时可使用 <code>add_syslinks</code> 来指定。通过 <code>add_syslinks</code> 添加的链接库会在所有通过 <code>add_links</code> 添加的链接库之后链接。</p><h2 id="添加预定义宏"><a href="#添加预定义宏" class="headerlink" title="添加预定义宏"></a>添加预定义宏</h2><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add_defines(<span class="string">&quot;MYMACRO=hello&quot;</span>)</span><br></pre></td></tr></table></figure><p>预定义宏是 C&#x2F;C++ 编译器在预处理阶段加入的额外宏定义，可以在编译时从命令行传入。这个功能是 C&#x2F;C++ 中通过选项控制编译内容的最常见方法。xmake 中使用 <code>add_defines</code> 来加入预定义宏，例如上面的语句将展开为 <code>-DMYMACRO=hello</code>。当预定义宏含有空格或歧义字符时，需要用户处理转义：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add_defines(<span class="string">&quot;MYMACRO=\&quot;hello world\&quot;&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="设置-Warning-等级"><a href="#设置-Warning-等级" class="headerlink" title="设置 Warning 等级"></a>设置 Warning 等级</h2><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set_warnings(<span class="string">&quot;all&quot;</span>)</span><br><span class="line">set_warnings(<span class="string">&quot;error&quot;</span>)</span><br></pre></td></tr></table></figure><p>xmake 中使用 <code>set_warnings</code> 来设置编译器警告的等级。例如，上述代码在 gcc 上展开为 <code>-Wall -Werror</code>。对 msvc，xmake 将自动将警告等级转换为 msvc 对应的级别，上述级别在 msvc 的对应为 <code>-W3 -WX</code>。需要注意的一点是，为了避免警告刷屏，xmake 默认不显示警告信息，除非设置 <code>set_warnings(&quot;error&quot;)</code> 将警告视为错误。要显示警告，可以运行 <code>xmake -w</code> 来查看。</p><h2 id="设置-Optimize-等级"><a href="#设置-Optimize-等级" class="headerlink" title="设置 Optimize 等级"></a>设置 Optimize 等级</h2><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set_optimize(<span class="string">&quot;faster&quot;</span>)</span><br></pre></td></tr></table></figure><p>通常情况下，引入 mode.debug 与 mode.release 后就无需单独设置 optimize 等级了。但是对于希望更精细优化等级控制的开发者而言，可能需要手动设置 optimize 等级。xmake 通过 <code>set_optimize</code> 函数提供了 4 个预定义的 optimize 等级：<code>none</code>、<code>faster</code>、<code>fastest</code>、<code>smallest</code>。<br>一般情况，即使需要这些等级，也用不着直接调用 <code>set_optimize</code>，因为内置的 mode 并不只有 debug 和 release，对应于这些等级有：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add_rules(<span class="string">&quot;mode.debug&quot;</span>, <span class="string">&quot;mode.releasedbg&quot;</span>, <span class="string">&quot;mode.release&quot;</span>, <span class="string">&quot;mode.minsizerel&quot;</span>)</span><br></pre></td></tr></table></figure><p>在 xmake 的 configure 过程，运行 <code>xmake config --mode &lt;mode&gt;</code> 即可在不同的优化等级之间切换。更多的内置 mode 可运行</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ xmake show -l buildmodes</span><br></pre></td></tr></table></figure><p>来查看。</p><h1 id="通过选择与循环添加编译器参数"><a href="#通过选择与循环添加编译器参数" class="headerlink" title="通过选择与循环添加编译器参数"></a>通过选择与循环添加编译器参数</h1><h2 id="选择结构"><a href="#选择结构" class="headerlink" title="选择结构"></a>选择结构</h2><p>Lua 语言中选择语句的结构如下：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> &lt;condition1&gt; <span class="keyword">then</span></span><br><span class="line">    &lt;task1&gt;</span><br><span class="line"><span class="keyword">elseif</span> &lt;condition2&gt; <span class="keyword">then</span></span><br><span class="line">    &lt;task2&gt;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    &lt;task3&gt;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>这一结构可以直接在 xmake.lua 中使用，在处理跨平台编译问题时尤为重要。例如，要在 windows 上和 linux 上定义不同的宏，可以这样写：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">set_allowedplats(<span class="string">&quot;windows&quot;</span>, <span class="string">&quot;linux&quot;</span>)</span><br><span class="line">target(<span class="string">&quot;helloworld&quot;</span>)</span><br><span class="line">    set_kind(<span class="string">&quot;binary&quot;</span>)</span><br><span class="line">    add_files(<span class="string">&quot;src/**.cpp&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> is_plat(<span class="string">&quot;windows&quot;</span>) <span class="keyword">then</span></span><br><span class="line">        add_defines(<span class="string">&quot;PLAT_WINDOWS&quot;</span>)</span><br><span class="line">    <span class="keyword">elseif</span> is_plat(<span class="string">&quot;linux&quot;</span>) <span class="keyword">then</span></span><br><span class="line">        add_defines(<span class="string">&quot;PLAT_LINUX&quot;</span>)</span><br><span class="line">    <span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>其中 <code>set_allowedplats</code> 用于限定支持的平台。可以注意到，这里用到了 <code>is_plat</code> 来判断编译的目标平台。xmake 提供了如下几个常用条件判断语句：</p><ul><li><code>is_plat</code>：判断编译的目标平台。configure 阶段选定。</li><li><code>is_host</code>：判断编译器的宿主平台（交叉编译时不同于目标平台）。</li><li><code>is_arch</code>：判断编译的目标架构。configure 阶段选定。</li><li><code>is_mode</code>：判断 configure 阶段选定的编译模式。</li><li><code>is_kind</code>：判断 configure 阶段选定的默认链接库类型。</li><li><code>has_config</code>：判断 option 是否被启用。这一语句的用法详见第 5 节 - 项目选项。</li></ul><blockquote><p>Tips. 这些判断支持 Lua 正则表达式匹配。这一功能的一个重要用途是判断目标架构是否为 64 位：<code>is_arch(&quot;.+64.*&quot;)</code>。关于 Lua 正则表达式的更多信息，请参考 Lua 语言文档。</p></blockquote><p>这些语句可以通过逻辑运算形成复合表达式。Lua 中逻辑判断的混合使用 <code>and</code>、<code>or</code> 和 <code>not</code> 运算符。例如，要限定 windows 系统 x64 架构，可以写</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> is_plat(<span class="string">&quot;windows&quot;</span>) <span class="keyword">and</span> is_arch(<span class="string">&quot;x64&quot;</span>) <span class="keyword">then</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>xmake 在各平台上支持的各架构名称可以运行如下命令查看：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ xmake show -l architectures</span><br></pre></td></tr></table></figure><p>前面提到，<code>plat</code>、<code>arch</code>、<code>mode</code>、<code>kind</code> 都是可以在 configure 阶段修改的。前两个参数的修改可以支持交叉编译时选择不同的平台与架构，后两个参数则可以调整编译模式以及默认链接库类型。也就是说，configure 阶段的完整写法应该是：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ xmake config --plat=... --<span class="built_in">arch</span>=... --mode=... --kind=... ...</span><br><span class="line">$ xmake f -p ... -a ... -m ... -k ... ... <span class="comment"># same with above</span></span><br></pre></td></tr></table></figure><p>实际使用大部分情况不需要这么复杂的设置，非交叉编译时 plat 和 arch 可以不用声明，只有 mode 默认为 release、kind 默认为 static 可能需要修改。</p><blockquote><p>Tips. Windows 上使用 mingw 也算交叉编译，所以需要运行 <code>xmake f -p mingw</code>，这就是第 1 节中提到的那个命令的由来。</p></blockquote><h2 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h2><p>Lua 语言支持三种循环结构：<code>for</code> 循环、<code>while</code> 循环与 <code>repeat</code> 循环。xmake 中常用第一种结构中的 table 循环，即 <code>for</code> 循环中的 table 循环。</p><p>说循环结构之前，得先说说 Lua 语言的变量系统。Lua 语言声明变量的方式如下：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> a = <span class="number">0</span></span><br><span class="line"><span class="keyword">local</span> b = a + <span class="number">1</span></span><br><span class="line"><span class="keyword">local</span> v = &#123;a, b, b + <span class="number">2</span>&#125;</span><br><span class="line"><span class="keyword">local</span> m = &#123;first = a, second = b&#125;</span><br></pre></td></tr></table></figure><p>其中，<code>local</code> 关键字表示声明变量为局部变量，<code>=</code> 用于赋值，常用的四则运算与比较运算符除了不等关系以外都与 C&#x2F;C++ 一致。Lua 中使用 <code>~=</code> 表示不等判断。Lua 中的变量有 nil、boolean、数值、字符串、table、function 等，table 还同时是数组（类似 std::vector）和映射（类似 std::map）。需要注意的一点是，Lua 中数组的下标从 1 开始。Lua 中使用运算符 <code>#</code> 来获取 table 的尺寸：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> len_v = #v</span><br></pre></td></tr></table></figure><p>关于 Lua 语言的更多内容请参考 <a href="https://link.zhihu.com/?target=https://www.lua.org/manual/5.4/manual.html">Lua官方文档</a>。</p><p><code>for</code> 循环中 table 循环结构如下：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> index, value <span class="keyword">in</span> <span class="built_in">ipairs</span>(&lt;<span class="built_in">table</span>-vector&gt;) <span class="keyword">do</span></span><br><span class="line">    &lt;task-vector&gt;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">for</span> name, value <span class="keyword">in</span> <span class="built_in">pairs</span>(&lt;<span class="built_in">table</span>-map&gt;) <span class="keyword">do</span></span><br><span class="line">    &lt;task-map&gt;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>这里 <code>ipairs</code> 和 <code>pairs</code> 是 Lua 的标准库函数，它们分别被用来遍历数组型 table 和映射型 table。这一功能常常可以用来简化 xmake.lua 的书写：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> supported_platform = &#123;<span class="string">&quot;windows&quot;</span>, <span class="string">&quot;macosx&quot;</span>, <span class="string">&quot;linux&quot;</span>, <span class="string">&quot;mingw&quot;</span>&#125;</span><br><span class="line">set_allowedplats(supported_platform) <span class="comment">-- xmake functions can accept table as input</span></span><br><span class="line">target(<span class="string">&quot;helloworld&quot;</span>)</span><br><span class="line">    set_kind(<span class="string">&quot;binary&quot;</span>)</span><br><span class="line">    add_files(<span class="string">&quot;src/**.cpp&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> _, p <span class="keyword">in</span> <span class="built_in">ipairs</span>(supported_platform) <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">if</span> is_plat(p) <span class="keyword">then</span></span><br><span class="line">            add_defines(<span class="string">&quot;PLAT_&quot;</span> .. p:<span class="built_in">upper</span>())</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>这里用到了 Lua 的两个特性：字符串拼接运算符 <code>..</code> 以及函数调用运算符 <code>:</code>。<code>..</code> 用于拼接两个字符串，将其合成一个；而 <code>p:upper()</code> 返回字符串 <code>p</code> 的全大写形式。例如，当 <code>p</code> 为 <code>&quot;windows&quot;</code> 时，添加的编译参数为 <code>-DPLAT_WINDOWS</code>。对这些特性感兴趣的读者可以参考 Lua 文档自行研究。</p><h2 id="编译参数在-Target-间的传递"><a href="#编译参数在-Target-间的传递" class="headerlink" title="编译参数在 Target 间的传递"></a>编译参数在 Target 间的传递</h2><p>当存在多个 target 时，往往 target 之间存在一定依赖关系。xmake 中使用 <code>add_deps</code> 来描述 target 间的依赖关系。我们用一个例子来说明这种情况。建立目录结构如下</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">root</span><br><span class="line">|- include</span><br><span class="line">    |- mylib.h</span><br><span class="line">|- src</span><br><span class="line">    |- mylib.cpp</span><br><span class="line">    |- myexe.cpp</span><br><span class="line">|- xmake.lua</span><br></pre></td></tr></table></figure><p>其中 mylib.h 包含函数 <code>myfunc</code> 声明，mylib.cpp 包含函数 <code>myfunc</code> 定义，myexe.cpp 使用 <code>myfunc</code>。xmake.lua 文件结构如下</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">add_rules(<span class="string">&quot;mode.debug&quot;</span>, <span class="string">&quot;mode.release&quot;</span>)</span><br><span class="line">set_languages(<span class="string">&quot;cxx20&quot;</span>)</span><br><span class="line">target(<span class="string">&quot;mylib&quot;</span>)</span><br><span class="line">    set_kind(<span class="string">&quot;static&quot;</span>)</span><br><span class="line">    add_includedirs(<span class="string">&quot;include&quot;</span>)</span><br><span class="line">    add_files(<span class="string">&quot;src/mylib.cpp&quot;</span>)</span><br><span class="line">target(<span class="string">&quot;myexe&quot;</span>)</span><br><span class="line">    set_kind(<span class="string">&quot;binary&quot;</span>)</span><br><span class="line">    add_files(<span class="string">&quot;src/myexe.cpp&quot;</span>)</span><br><span class="line">    add_deps(<span class="string">&quot;mylib&quot;</span>)</span><br></pre></td></tr></table></figure><p><code>add_deps</code> 将 <code>mylib</code> 设置为 <code>myexe</code> 的依赖，编译时将先链接 <code>mylib</code>，再链接 <code>myexe</code>，并在 <code>myexe</code> 链接时自动链接到 libmylib.a 或者 mylib.lib（取决于平台）。但是，这么写会编译报错找不到 ‘mylib.h’ 文件！为什么呢？因为 “include” 这个文件夹仅被设置为 <code>mylib</code> 的头文件目录，而没有被设置成 <code>myexe</code> 的头文件目录。为了解决这个问题，需要做一个小小的改动。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">add_rules(<span class="string">&quot;mode.debug&quot;</span>, <span class="string">&quot;mode.release&quot;</span>)</span><br><span class="line">set_languages(<span class="string">&quot;cxx20&quot;</span>)</span><br><span class="line">target(<span class="string">&quot;mylib&quot;</span>)</span><br><span class="line">    set_kind(<span class="string">&quot;static&quot;</span>)</span><br><span class="line">    add_includedirs(<span class="string">&quot;include&quot;</span>, &#123;public = <span class="literal">true</span>&#125;)</span><br><span class="line">    add_files(<span class="string">&quot;src/mylib.cpp&quot;</span>)</span><br><span class="line">target(<span class="string">&quot;myexe&quot;</span>)</span><br><span class="line">    set_kind(<span class="string">&quot;binary&quot;</span>)</span><br><span class="line">    add_files(<span class="string">&quot;src/myexe.cpp&quot;</span>)</span><br><span class="line">    add_deps(<span class="string">&quot;mylib&quot;</span>)</span><br></pre></td></tr></table></figure><p>再次输入 <code>xmake</code>，发现可以正确编译了！这是因为 <code>mylib</code> 的头文件目录被设置为 “public”，也就是说，这一属性会被依赖于 <code>mylib</code> 的 <code>myexe</code> 继承。对于 <code>add_defines</code>、<code>add_cxflags</code> 等接口，也有类似的设置选项。</p><p>在依赖时，xmake 默认会将依赖项生成的库文件链接到当前 target。然而，如果这一行为是不想要的，也可以通过选项来避免这一行为：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">add_rules(<span class="string">&quot;mode.debug&quot;</span>, <span class="string">&quot;mode.release&quot;</span>)</span><br><span class="line">set_languages(<span class="string">&quot;cxx20&quot;</span>)</span><br><span class="line">target(<span class="string">&quot;mylib&quot;</span>)</span><br><span class="line">    set_kind(<span class="string">&quot;static&quot;</span>)</span><br><span class="line">    add_includedirs(<span class="string">&quot;include&quot;</span>, &#123;public = <span class="literal">true</span>&#125;)</span><br><span class="line">    add_files(<span class="string">&quot;src/mylib.cpp&quot;</span>)</span><br><span class="line">target(<span class="string">&quot;myexe&quot;</span>)</span><br><span class="line">    set_kind(<span class="string">&quot;binary&quot;</span>)</span><br><span class="line">    add_files(<span class="string">&quot;src/myexe.cpp&quot;</span>)</span><br><span class="line">    add_deps(<span class="string">&quot;mylib&quot;</span>, &#123;inherit = <span class="literal">false</span>&#125;)</span><br></pre></td></tr></table></figure><p>这样一来 <code>myexe</code> 就不会链接到 <code>mylib</code> 了。</p><h1 id="切换编译模式"><a href="#切换编译模式" class="headerlink" title="切换编译模式"></a>切换编译模式</h1><h2 id="调试和发布模式"><a href="#调试和发布模式" class="headerlink" title="调试和发布模式"></a>调试和发布模式</h2><p>通常，如果我们是通过 <code>xmake create</code> 命令创建的项目，会在 xmake.lua 里面自动添加一行编译规则的配置，如下：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">add_rules(<span class="string">&quot;mode.release&quot;</span>, <span class="string">&quot;mode.debug&quot;</span>) </span><br><span class="line">target(<span class="string">&quot;hello&quot;</span>) </span><br><span class="line">    set_kind(<span class="string">&quot;binary&quot;</span>)</span><br><span class="line">    add_files(<span class="string">&quot;src/*.c&quot;</span>)</span><br></pre></td></tr></table></figure><p>通过 <code>add_rules</code> 接口，我们默认添加了 release 和 debug 两个常用的内置规则，它们会在编译的时候附带上对应模式相关的一些编译 flags，来开启优化用于发布或者调试编译。</p><p>如果仅仅执行了 <code>xmake</code> 命令，没有额外的配置，那么默认就会是 release 编译，等价于：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ xmake f -m release </span><br><span class="line">$ xmake</span><br></pre></td></tr></table></figure><p>如果我们要切换到 debug 编译模式，只需要：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ xmake f -m debug </span><br><span class="line">$ xmake </span><br></pre></td></tr></table></figure><p>上面的 <code>-m/--mode=</code> 参数就是用来设置编译模式，会跟 <code>mode.release</code> 和 <code>mode.debug</code> 这两个规则做关联。</p><p>那么，他们是如何关联上的呢？我们可以先来看下这两个规则的内部实现：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">rule(<span class="string">&quot;mode.debug&quot;</span>)</span><br><span class="line">    after_load(<span class="function"><span class="keyword">function</span> <span class="params">(target)</span></span></span><br><span class="line">        <span class="keyword">if</span> is_mode(<span class="string">&quot;debug&quot;</span>) <span class="keyword">then</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> target:get(<span class="string">&quot;symbols&quot;</span>) <span class="keyword">then</span></span><br><span class="line">                target:set(<span class="string">&quot;symbols&quot;</span>, <span class="string">&quot;debug&quot;</span>)</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> target:get(<span class="string">&quot;optimize&quot;</span>) <span class="keyword">then</span></span><br><span class="line">                target:set(<span class="string">&quot;optimize&quot;</span>, <span class="string">&quot;none&quot;</span>)</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span>)</span><br><span class="line"></span><br><span class="line">rule(<span class="string">&quot;mode.release&quot;</span>)</span><br><span class="line">    after_load(<span class="function"><span class="keyword">function</span> <span class="params">(target)</span></span></span><br><span class="line">        <span class="keyword">if</span> is_mode(<span class="string">&quot;release&quot;</span>) <span class="keyword">then</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> target:get(<span class="string">&quot;symbols&quot;</span>) <span class="keyword">and</span> target:targetkind() ~= <span class="string">&quot;shared&quot;</span> <span class="keyword">then</span></span><br><span class="line">                target:set(<span class="string">&quot;symbols&quot;</span>, <span class="string">&quot;hidden&quot;</span>)</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> target:get(<span class="string">&quot;optimize&quot;</span>) <span class="keyword">then</span></span><br><span class="line">                <span class="keyword">if</span> is_plat(<span class="string">&quot;android&quot;</span>, <span class="string">&quot;iphoneos&quot;</span>) <span class="keyword">then</span></span><br><span class="line">                    target:set(<span class="string">&quot;optimize&quot;</span>, <span class="string">&quot;smallest&quot;</span>)</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    target:set(<span class="string">&quot;optimize&quot;</span>, <span class="string">&quot;fastest&quot;</span>)</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> target:get(<span class="string">&quot;strip&quot;</span>) <span class="keyword">then</span></span><br><span class="line">                target:set(<span class="string">&quot;strip&quot;</span>, <span class="string">&quot;all&quot;</span>)</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span>)</span><br></pre></td></tr></table></figure><p>可以看到，在 target 被加载阶段，xmake 会去判断用户对 <code>xmake f --mode=xxx</code> 的参数配置，如果通过 <code>is_mode()</code> 接口获取到是 debug 模式，那么会禁用相关优化并且启用符号输出。 而如果是 release 模式，那么会开启编译优化并且 strip 掉所有调试符号。</p><h2 id="定制化的模式配置"><a href="#定制化的模式配置" class="headerlink" title="定制化的模式配置"></a>定制化的模式配置</h2><p>当然，内置的这两规则默认设置的这些编译配置，只能满足大部分场景的常规需求，如果用户想要在不同的编译模式下定制化一些个人的编译配置，那么需要自己在 xmake.lua 做判断。</p><p>例如，我们想在 release 下也启用调试符号，那么只需要：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> is_mode(<span class="string">&quot;release&quot;</span>) <span class="keyword">then</span></span><br><span class="line">   set_symbols(<span class="string">&quot;debug&quot;</span>) </span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>或者额外增加一些编译 flags：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> is_mode(<span class="string">&quot;release&quot;</span>) <span class="keyword">then</span> </span><br><span class="line">    add_cflags(<span class="string">&quot;-fomit-frame-pointer&quot;</span>) </span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>注：如果用户自己的配置和 <code>mode.release</code> 内置的配置冲突，会优先使用用户的设置。</p><p>当然，我们也可以完全不去通过 <code>add_rules(&quot;mode.debug&quot;, &quot;mode.release&quot;)</code> 添加默认的配置规则，让用户完全自己控制模式配置：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 如果当前编译模式是debug</span></span><br><span class="line"><span class="keyword">if</span> is_mode(<span class="string">&quot;debug&quot;</span>) <span class="keyword">then</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">-- 添加DEBUG编译宏</span></span><br><span class="line">    add_defines(<span class="string">&quot;DEBUG&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">-- 启用调试符号</span></span><br><span class="line">    set_symbols(<span class="string">&quot;debug&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">-- 禁用优化</span></span><br><span class="line">    set_optimize(<span class="string">&quot;none&quot;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 如果是release或者profile模式</span></span><br><span class="line"><span class="keyword">if</span> is_mode(<span class="string">&quot;release&quot;</span>, <span class="string">&quot;profile&quot;</span>) <span class="keyword">then</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">-- 如果是release模式</span></span><br><span class="line">    <span class="keyword">if</span> is_mode(<span class="string">&quot;release&quot;</span>) <span class="keyword">then</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">-- 隐藏符号</span></span><br><span class="line">        set_symbols(<span class="string">&quot;hidden&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">-- strip所有符号</span></span><br><span class="line">        set_strip(<span class="string">&quot;all&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">-- 忽略帧指针</span></span><br><span class="line">        add_cxflags(<span class="string">&quot;-fomit-frame-pointer&quot;</span>)</span><br><span class="line">        add_mxflags(<span class="string">&quot;-fomit-frame-pointer&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">-- 如果是profile模式</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">-- 启用调试符号</span></span><br><span class="line">        set_symbols(<span class="string">&quot;debug&quot;</span>)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">-- 添加扩展指令集</span></span><br><span class="line">    add_vectorexts(<span class="string">&quot;sse2&quot;</span>, <span class="string">&quot;sse3&quot;</span>, <span class="string">&quot;ssse3&quot;</span>, <span class="string">&quot;mmx&quot;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h2 id="其他内置模式规则"><a href="#其他内置模式规则" class="headerlink" title="其他内置模式规则"></a>其他内置模式规则</h2><p>通过上文的例子，我们看到除了 debug&#x2F;release 模式，还加了个 profile 模式的配置判断，其实 xmake 也提供了对应的内置模式，还有哪些，我们具体来看下：</p><h2 id="mode-debug"><a href="#mode-debug" class="headerlink" title="mode.debug"></a>mode.debug</h2><p>为当前工程 xmake.lua 添加 debug 编译模式的配置规则，例如：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add_rules(<span class="string">&quot;mode.debug&quot;</span>)</span><br></pre></td></tr></table></figure><p>相当于：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> is_mode(<span class="string">&quot;debug&quot;</span>) <span class="keyword">then</span> </span><br><span class="line">    set_symbols(<span class="string">&quot;debug&quot;</span>) </span><br><span class="line">    set_optimize(<span class="string">&quot;none&quot;</span>) </span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>我们可以通过：<code>xmake f -m debug</code> 来切换到此编译模式。</p><h2 id="mode-release"><a href="#mode-release" class="headerlink" title="mode.release"></a>mode.release</h2><p>为当前工程 xmake.lua 添加 release 编译模式的配置规则，例如：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add_rules(<span class="string">&quot;mode.release&quot;</span>)</span><br></pre></td></tr></table></figure><p>相当于：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> is_mode(<span class="string">&quot;release&quot;</span>) <span class="keyword">then</span> </span><br><span class="line">    set_symbols(<span class="string">&quot;hidden&quot;</span>) </span><br><span class="line">    set_optimize(<span class="string">&quot;fastest&quot;</span>) </span><br><span class="line">    set_strip(<span class="string">&quot;all&quot;</span>) </span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>我们可以通过：<code>xmake f -m release</code> 来切换到此编译模式。</p><h2 id="mode-check"><a href="#mode-check" class="headerlink" title="mode.check"></a>mode.check</h2><p>为当前工程 xmake.lua 添加 check 编译模式的配置规则，一般用于内存检测，例如：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add_rules(<span class="string">&quot;mode.check&quot;</span>)</span><br></pre></td></tr></table></figure><p>相当于：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> is_mode(<span class="string">&quot;check&quot;</span>) <span class="keyword">then</span></span><br><span class="line">    set_symbols(<span class="string">&quot;debug&quot;</span>)</span><br><span class="line">    set_optimize(<span class="string">&quot;none&quot;</span>)</span><br><span class="line">    add_cxflags(<span class="string">&quot;-fsanitize=address&quot;</span>, <span class="string">&quot;-ftrapv&quot;</span>)</span><br><span class="line">    add_mxflags(<span class="string">&quot;-fsanitize=address&quot;</span>, <span class="string">&quot;-ftrapv&quot;</span>)</span><br><span class="line">    add_ldflags(<span class="string">&quot;-fsanitize=address&quot;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>我们可以通过：<code>xmake f -m check</code> 来切换到此编译模式。</p><h2 id="mode-profile"><a href="#mode-profile" class="headerlink" title="mode.profile"></a>mode.profile</h2><p>为当前工程 xmake.lua 添加 profile 编译模式的配置规则，一般用于性能分析，例如：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add_rules(<span class="string">&quot;mode.profile&quot;</span>)</span><br></pre></td></tr></table></figure><p>相当于：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> is_mode(<span class="string">&quot;profile&quot;</span>) <span class="keyword">then</span></span><br><span class="line">    set_symbols(<span class="string">&quot;debug&quot;</span>)</span><br><span class="line">    add_cxflags(<span class="string">&quot;-pg&quot;</span>)</span><br><span class="line">    add_ldflags(<span class="string">&quot;-pg&quot;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>我们可以通过：<code>xmake f -m profile</code> 来切换到此编译模式。</p><h2 id="mode-coverage"><a href="#mode-coverage" class="headerlink" title="mode.coverage"></a>mode.coverage</h2><p>为当前工程 xmake.lua 添加 coverage 编译模式的配置规则，一般用于覆盖分析，例如：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add_rules(<span class="string">&quot;mode.coverage&quot;</span>)</span><br></pre></td></tr></table></figure><p>相当于：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> is_mode(<span class="string">&quot;coverage&quot;</span>) <span class="keyword">then</span></span><br><span class="line">    add_cxflags(<span class="string">&quot;--coverage&quot;</span>)</span><br><span class="line">    add_mxflags(<span class="string">&quot;--coverage&quot;</span>)</span><br><span class="line">    add_ldflags(<span class="string">&quot;--coverage&quot;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>我们可以通过：<code>xmake f -m coverage</code> 来切换到此编译模式。</p><p>注：生成的 gcno 文件一般都是个 obj 所在目录对应的哦，因此需要从 build 目录下去找。</p><h2 id="扩展自己的编译模式"><a href="#扩展自己的编译模式" class="headerlink" title="扩展自己的编译模式"></a>扩展自己的编译模式</h2><p>xmake 的模式配置，并没有固定值，用户可以随意传入和配置，只要 <code>xmake f -m/--mode=xxx</code> 传入的模式值和 xmake.lua 里面的 <code>is_mode(&quot;xxx&quot;)</code> 能对应上就行。</p><p>比如，我们设置了一个自己独有的编译模式 <code>my_mode</code>，可以直接在命令行配置切换；</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ xmake f -m my_mode </span><br><span class="line">$ xmake </span><br></pre></td></tr></table></figure><p>然后 xmake.lua 里面对相应的值进行判断即可：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> is_mode(<span class="string">&quot;my_mode&quot;</span>) <span class="keyword">then</span> </span><br><span class="line">    add_defines(<span class="string">&quot;ENABLE_MY_MODE&quot;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h2 id="使用模式变量"><a href="#使用模式变量" class="headerlink" title="使用模式变量"></a>使用模式变量</h2><p>我们也可以直接在配置值中传递模式变量 <code>$(mode)</code>，比如根据不同模式选择链接不同的库：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">target(<span class="string">&quot;test&quot;</span>)</span><br><span class="line">    set_kind(<span class="string">&quot;binary&quot;</span>)</span><br><span class="line">    add_files(<span class="string">&quot;src/*.c&quot;</span>)</span><br><span class="line">    add_links(<span class="string">&quot;xxx_$(mode)&quot;</span>)</span><br></pre></td></tr></table></figure><p>上面的配置，如果是调试模式编译就会选择链接：<code>libxxx_debug.a</code> 库，而 release 下就会链接 <code>libxxx_release.a</code>，当然，我们也可以设置到库搜索路径中，根据目录来选择对应的库。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">target(<span class="string">&quot;test&quot;</span>)</span><br><span class="line">    set_kind(<span class="string">&quot;binary&quot;</span>)</span><br><span class="line">    add_files(<span class="string">&quot;src/*.c&quot;</span>)</span><br><span class="line">    add_linkdirs(<span class="string">&quot;lib/$(mode)&quot;</span>)</span><br><span class="line">    add_links(<span class="string">&quot;xxx&quot;</span>)</span><br></pre></td></tr></table></figure><p>另外，我们可以通过 <code>get_config(&quot;mode&quot;)</code> 直接获取到传入的模式配置值，并且这几种获取方式，在自定义脚本也是同样有效的哦，例如：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">target(<span class="string">&quot;test&quot;</span>)</span><br><span class="line">    set_kind(<span class="string">&quot;binary&quot;</span>)</span><br><span class="line">    add_files(<span class="string">&quot;src/*.c&quot;</span>)</span><br><span class="line">    on_load(<span class="function"><span class="keyword">function</span> <span class="params">(target)</span></span></span><br><span class="line">        <span class="keyword">if</span> is_mode(<span class="string">&quot;release&quot;</span>) <span class="keyword">then</span></span><br><span class="line">            <span class="built_in">print</span>(get_config(<span class="string">&quot;mode&quot;</span>), <span class="string">&quot;$(mode)&quot;</span>)</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程工具 </category>
          
          <category> Xmake </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>A Tour of xmake - 00. 简介</title>
      <link href="/posts/%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7/Xmake/A%20Tour%20of%20xmake%20-%2000.%20%E7%AE%80%E4%BB%8B.html"/>
      <url>/posts/%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7/Xmake/A%20Tour%20of%20xmake%20-%2000.%20%E7%AE%80%E4%BB%8B.html</url>
      
        <content type="html"><![CDATA[<h1 id="什么是构建系统"><a href="#什么是构建系统" class="headerlink" title="什么是构建系统?"></a>什么是构建系统?</h1><p>程序从一段代码到可执行文件的构建过程，往往中间要经过编译、链接等步骤，因此在不同的运行平台上需要各种各样的编译器和链接器。除了编译与链接之外，在构建过程中经常还需要调整配置、管理依赖、生成代码、打包代码库等操作。管理构建过程的程序叫做构建系统。构建系统并不执行编译本身，只是调用编译器和其他工具来执行构建任务。通常构建系统会使用<strong>配置文件</strong>来描述构建过程。几乎所有编译型编程语言都有它们的构建系统，例如 C&#x2F;C++ 的 autotools、cmake、xmake 等，Java 的 maven、gradle，Rust 的 cargo 等。解释型编程语言通常在执行时即时编译并运行，因此其构建系统的重心不在编译链接而在构建过程中的其他需求（管理依赖、打包、优化等），例如 Python 的 pip、conda，JavaScript 的 npm、yarn 等。</p><h1 id="为什么需要构建系统？"><a href="#为什么需要构建系统？" class="headerlink" title="为什么需要构建系统？"></a>为什么需要构建系统？</h1><p>理论上只需要一个文本编辑器，一组合适的编译器与链接器就能完成开发任务了。然而，实际上在开发过程中会遇到很多麻烦的工作，而构建系统的任务就是将这些麻烦的工作自动化，解放程序员的双手。构建系统至少有如下几个作用：</p><ol><li><p>编写大型系统时，需要<strong>保证构建的可重复性</strong>。一个地方的 flag 出错，可能导致整个构建过程失败。只有将构建过程写进文件中，把构建过程交给构建系统，才能保证构建过程中使用的指令的稳定性。当然由于编译环境和外部依赖不同，使用构建系统也不能完全保证构建的可重复性，这一点需要程序员来保证。</p></li><li><p>编码过程中一个合适的 IDE 可以大大提高编码效率，而 IDE 需要一些构建描述文件才能 “ 认识 “ 项目。让构建系统来<strong>生成构建描述文件</strong>，则无需在每次增删文件时都手动修改构建描述文件，大大减少无意义的重复工作。</p></li><li><p>依赖管理是开发过程中最令人头疼的问题之一。手动引入第三方依赖库很容易遇到版本不对、编译不过、链接繁琐、更新困难、难以调整等问题。使用构建系统来<strong>管理依赖</strong>，大大降低了依赖引入和更新过程中的繁琐步骤。</p></li><li><p>开发过程中同一个项目常常需要根据开发环境与用户需要，使用不同的参数和宏来进行构建，生成不同参数的可执行文件。构建系统可以使用 option 来<strong>管理构建参数</strong>，方便随时切换，解放双手。</p></li><li><p>当项目有多个开发者时，一份清晰的构建系统配置文件能大大<strong>降低交流成本</strong>，尤其是对于开源项目，构建系统将成为让别人了解项目结构的第一站。当需要将生成的文件打包分发时，构建系统的打包功能也非常实用。</p></li></ol><p>对单文件的简单程序，确实不需要构建系统。但是，一旦开发的项目需要大量文件，或者需要引入依赖，或者需要多组构建参数配置，构建系统将成为不可或缺的一部分。</p><h1 id="教程概览"><a href="#教程概览" class="headerlink" title="教程概览"></a>教程概览</h1><p>本教程分为三部分：</p><p>第一部分 概述</p><ol><li>简介，简要介绍 xmake 与 C&#x2F;C++ 的构建系统史。</li></ol><p>第二部分 基本功能</p><ol><li><p>快速入门，介绍如何配置并运行第一个 xmake 项目。</p></li><li><p>编译选项，介绍一些 C&#x2F;C++ 项目中常用编译选项设置。</p></li><li><p>依赖管理，介绍如何在 xmake 项目中查找并引入第三方库。</p></li><li><p>依赖仓库，介绍 xmake 仓库的包描述文件，以及自建仓库&#x2F;引用其它项目的方法。</p></li><li><p>构建选项，介绍如何通过选项控制构建过程，以及如何根据环境检测控制选项。</p></li><li><p>测试发布，介绍如何添加测试、安装&#x2F;发布生成的库与可执行文件（以及可能的文档）。</p></li></ol><p>第三部分 高级特性（暂定）</p><ol><li><p>跨语言项目，介绍 C&#x2F;C++&#x2F;CUDA&#x2F;Python 等多语言混合项目在 xmake 中的设置。</p></li><li><p>自定义规则，介绍 xmake 中的自定义规则与自定义工具链。</p></li><li><p>Lua 编程，介绍如何在 xmake 中使用 Lua 语言编写脚本解决复杂问题。</p></li><li><p>代码生成，介绍 xmake 对编译时生成代码的处理方式。</p></li></ol><p>实际上，只需要阅读到第二部分即可满足大部分项目的需要了。对于具有特殊需求的项目，第三部分仅对其中一部分作简要介绍，一些重要特性例如分布式编译未能涵盖。对此类项目，在教程之外更应根据需求参考官方文档、已有的其他项目进行补充，必要时可以在讨论区提问。本教程或有一定疏漏之处，恳请读者批评指正！</p><h1 id="相关网站"><a href="#相关网站" class="headerlink" title="相关网站"></a>相关网站</h1><p>xmake 的官方文档：<a href="https://xmake.io/">xmake</a></p><p>xmake-repo 的搜索站：<a href="https://xrepo.xmake.io/">xrepo</a></p><p>xmake 的 GitHub 仓库：<a href="https://link.zhihu.com/?target=https://github.com/xmake-io/xmake">xmake-io&#x2F;xmake</a></p><p>xmake-repo 的 GitHub 仓库：<a href="https://link.zhihu.com/?target=https://github.com/xmake-io/xmake-repo">xmake-io&#x2F;xmake-repo</a></p><p>xmake 提问讨论区：<a href="https://link.zhihu.com/?target=https://github.com/xmake-io/xmake/discussions">Discussions</a></p><p>xmake Discord：<a href="https://link.zhihu.com/?target=https://discord.gg/xmake">xmake channel</a></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.zhihu.com/column/c_1537535487199281152">A Tour of xmake - 知乎 (zhihu.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> 编程工具 </category>
          
          <category> Xmake </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>A Tour of xmake - 01. 快速入门</title>
      <link href="/posts/%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7/Xmake/A%20Tour%20of%20xmake%20-%2001.%20%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8.html"/>
      <url>/posts/%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7/Xmake/A%20Tour%20of%20xmake%20-%2001.%20%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8.html</url>
      
        <content type="html"><![CDATA[<h1 id="安装-Xmake"><a href="#安装-Xmake" class="headerlink" title="安装 Xmake"></a>安装 Xmake</h1><p>xmake 推荐使用 shell 脚本安装。<br>Bash</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash &lt;(wget https://xmake.io/shget.text -O -)</span><br></pre></td></tr></table></figure><p>Powershell</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Invoke-Expression</span> (<span class="built_in">Invoke-Webrequest</span> <span class="string">&#x27;https://xmake.io/psget.text&#x27;</span> <span class="literal">-UseBasicParsing</span>).Content</span><br></pre></td></tr></table></figure><p>Windows 上也可下载 <a href="https://link.zhihu.com/?target=https://github.com/xmake-io/xmake/releases">安装包</a> 手动安装。运行</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xmake --help</span><br></pre></td></tr></table></figure><p>能正常输出则说明安装成功。</p><p>使用 shell 脚本安装的 xmake 已经带有自动补全和虚拟环境功能。对于其他方式安装的 xmake，如果想要启用 xmake 的自动补全和虚拟环境功能，需要在安装完毕后运行</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xmake update --integrate</span><br></pre></td></tr></table></figure><p>安装之后，若要将 xmake 更新至最新版，使用</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xmake update</span><br></pre></td></tr></table></figure><p>卸载 xmake 时，运行</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xmake update --uninstall</span><br></pre></td></tr></table></figure><h1 id="更新升级"><a href="#更新升级" class="headerlink" title="更新升级"></a>更新升级</h1><p>从 v2.2.3 版本开始，新增了 <code>xmake update</code> 命令，来快速进行自我更新和升级，默认是升级到最新版本，当然也可以指定升级或者回退到某个版本：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ xmake update 2.2.4</span><br></pre></td></tr></table></figure><p>我们也可以指定更新到 master&#x2F;dev 分支版本：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ xmake update master </span><br><span class="line">$ xmake update dev</span><br></pre></td></tr></table></figure><p>从指定 git 源更新</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ xmake update github:xmake-io/xmake#master </span><br><span class="line">$ xmake update gitee:tboox/xmake#dev # gitee镜像</span><br></pre></td></tr></table></figure><p>如果 xmake&#x2F;core 没动过，仅仅更新 xmake 的 lua 脚本改动，可以加 <code>-s/--scriptonly</code> 快速更新 lua 脚本</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ xmake update -s dev</span><br></pre></td></tr></table></figure><p>最后，我们如果要卸载 xmake，也是支持的：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xmake update --uninstall </span><br></pre></td></tr></table></figure><h1 id="一个最简单的-Xmake-项目"><a href="#一个最简单的-Xmake-项目" class="headerlink" title="一个最简单的 Xmake 项目"></a>一个最简单的 Xmake 项目</h1><blockquote><p>Hint. 在之后的示例中，如无特殊说明，均以 $ 符号开头表示在 shell 中运行的命令。</p></blockquote><p>使用 shell 切换至一个有足够权限的文件目录，运行</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xmake create helloworld</span><br></pre></td></tr></table></figure><p>即可产生一个最简单的 xmake 项目。项目仅包含 main.cpp 一个文件，配置文件 xmake.lua 的内容如下：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">add_rules(<span class="string">&quot;mode.debug&quot;</span>, <span class="string">&quot;mode.release&quot;</span>)</span><br><span class="line">target(<span class="string">&quot;helloworld&quot;</span>)</span><br><span class="line">    set_kind(<span class="string">&quot;binary&quot;</span>)</span><br><span class="line">    add_files(<span class="string">&quot;src/main.cpp&quot;</span>)</span><br></pre></td></tr></table></figure><p>如果你已经安装了 C&#x2F;C++ 的编译器（gcc&#x2F;XCode&#x2F;Visual Studio），那么可以直接在 shell 中编译并运行这个项目：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ cd helloworld</span><br><span class="line">$ xmake</span><br><span class="line">...</span><br><span class="line">$ xmake run helloworld</span><br><span class="line">Hello World!</span><br></pre></td></tr></table></figure><p>默认情况下，中间缓存会被存储在.xmake 文件夹，构建生成的中间文件和目标文件放在 build 文件夹。</p><p>Windows 上若不想安装 Visual Studio，可以安装 mingw 作为编译器。如果在安装时启用了虚拟环境功能，则可以使用 xmake 提供的 mingw 虚拟环境（需要联网下载安装）。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ xrepo env -b mingw-w64 shell</span><br></pre></td></tr></table></figure><blockquote><p>Tips. 国内由于众所周知的原因，无法顺利访问 github。对此，xmake 提供了镜像功能，可以将 github 重定向到国内的镜像站点： <code>shell $ xmake global --proxy_pac=github_mirror.lua</code> 当然，如果本地存在代理，也可以直接在 shell 中设置环境变量以启用本地代理。</p><p>Tips. xmake 提供了 msvc、python3 等一系列内置的虚拟环境，可以用 <code>xrepo env -l</code> 命令查看。关于手动添加虚拟环境的方法请参考官方文档。</p></blockquote><p>激活虚拟环境后，运行</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[mingw-w64] $ cd helloworld</span><br><span class="line">[mingw-w64] $ xmake config -p mingw</span><br><span class="line">...</span><br><span class="line">[mingw-w64] $ xmake</span><br><span class="line">...</span><br><span class="line">[mingw-w64] $ xmake run helloworld</span><br><span class="line">Hello World!</span><br></pre></td></tr></table></figure><p>其中，<code>xmake config</code> 语句切换编译目标平台为 mingw。若使用 mingw 编译器，则编译之前必须执行这一命令，此后不再说明。</p><blockquote><p>Tips. <code>xmake config</code> 可以缩写为 <code>xmake f</code>，这个阶段称为 configure 阶段。直接运行 xmake 之前若未经过这一阶段，xmake 将自动运行 configure，并采用所有选项的默认参数。运行 <code>xmake --help</code> 来查看更多缩写！</p></blockquote><p>若不想使用平台默认的工具链（例如想要使用 clang 而不是 gcc），可以通过 <code>--toolchain</code> 选项来实现。同样在 configure 阶段，运行</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ xmake config --toolchain=clang</span><br></pre></td></tr></table></figure><p>即可切换编译工具链为 clang。</p><p>编译完成后，如果想要清理生成的文件，可以运行 <code>xmake clean</code> 来清理中间文件与目标文件。<code>xmake clean -a</code> 可以连同 xmake 缓存一同清除。<code>xmake config -c</code> 命令仅仅清除 xmake 缓存并重新生成，不清理中间文件和目标文件。</p><blockquote><p>Tips. xmake 文件发生更改后，为提升效率默认原来的缓存继续生效，可能会影响构建过程。建议在 xmake 文件发生较大更改后，或者遇到问题的时候手动运行 <code>xmake f -c</code> 来清理缓存。</p></blockquote><h1 id="在-IDE-中使用-Xmake"><a href="#在-IDE-中使用-Xmake" class="headerlink" title="在 IDE 中使用 Xmake"></a>在 IDE 中使用 Xmake</h1><p>xmake 直接支持生成 Makefile、ninja、compile_commands.json 等编译数据文件，Visual Studio 工程文件，以及 CMakeLists.txt 文件。通过这些编译数据，xmake 可以直接或间接支持各种常见 IDE。下以 Visual Studio Code 为例配置 xmake 项目的智能提示。</p><p>首先需要安装 VSCode 以及 C&#x2F;C++ 插件、xmake 插件，这两个插件可以在 VSCode Marketplace 找到。打开项目文件夹，运行 <code>xmake config</code> 完成 configure 过程。从 View 打开 Command Palette（默认快捷键 Ctrl+Shift+P），运行 XMake: Update Intellisense。此时可以在.vscode 文件夹中找到自动生成的 compile_commands.json。再打开 Command Palette，运行 C&#x2F;C++: Edit Configurations (UI)，检查编译器、C++ 语言版本等设置无误后，下拉选中 Advanced Settings，再选中 Compile commands，输入</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&#123;workspaceFolder&#125;/.vscode/compile_commands.json</span><br></pre></td></tr></table></figure><p>退出，再打开 src&#x2F;main.cpp 文件。此时智能提示已经可以工作了。此后，当项目构建过程发生变化时，运行 <code>xmake config</code> 后打开 Command Palette 运行 XMake: Update Intellisense 即可。</p><p>对于其他 IDE&#x2F;编辑器，根据其需要，生成对应的工程文件&#x2F;Compile Commands&#x2F;CMakeLists.txt 即可配置智能提示等功能。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ xmake project -k compile_commands</span><br><span class="line">$ xmake project -k cmake</span><br><span class="line">$ xmake project -k vs</span><br><span class="line">$ xmake project -k vsxmake</span><br></pre></td></tr></table></figure><blockquote><p>Tips. 对 Visual Studio，xmake 提供了两种不同的 project 生成器：vs 和 vsxmake。vs 生成直接基于 MSBuild 的构建文件，方便移植到其他机器，但其构建过程与直接执行 xmake 有可能存在少量差异；vsxmake 则在 MSBuild 中调用 xmake 进行编译，其构建过程等同于直接执行 xmake，但不便移植。对单机项目建议优先使用 vsxmake，而有特别需求时可以考虑使用 vs。</p></blockquote><h1 id="xmake-lua-再探"><a href="#xmake-lua-再探" class="headerlink" title="xmake.lua 再探"></a>xmake.lua 再探</h1><p>让我们回到配置文件本身，看看各行命令的作用是什么。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">add_rules(<span class="string">&quot;mode.debug&quot;</span>, <span class="string">&quot;mode.release&quot;</span>)</span><br><span class="line">target(<span class="string">&quot;helloworld&quot;</span>)</span><br><span class="line">    set_kind(<span class="string">&quot;binary&quot;</span>)</span><br><span class="line">    add_files(<span class="string">&quot;src/main.cpp&quot;</span>)</span><br></pre></td></tr></table></figure><p>第一行的 <code>add_rules</code> 语句声明了两个 mode：debug 与 release（默认 release）。debug 模式会关闭编译器优化并保留程序中的调试信息，而 release 模式会加入更激进的编译器优化。这一行并不是必须的，如果不写这一语句，编译时实际执行的命令中将不含有任何额外的 flag。</p><blockquote><p>Tips. 你可以运行 <code>xmake -v</code> 来查看实际执行的编译命令。在 xmake 执行出错时，执行 <code>xmake -vD</code> 可以打印出错的类型与位置，这一点在调试时尤其有用。</p></blockquote><p>第二行的 <code>target</code> 语句声明了一个 target：helloworld。在 xmake 中，所有的构建目标都用 target 来表示。如无额外声明，target 的名字将被默认作为库&#x2F;可执行文件的名字的主要部分。例如，windows 上 binary 类型的 target helloworld 其输出文件名为 helloworld.exe，linux 上 static 类型的 target helloworld 其输出文件名为 libhelloworld.a。声明 target 之后进入该 target 的作用域，直到声明另一个 target 或者显式调用 <code>target_end</code> 之前，所有语句都是针对该 target 生效的。</p><p>第三行的 <code>set_kind</code> 语句限定 target 的类型为 binary。xmake 中 target 类型一共有 5 种：binary（默认），static，shared，headeronly，phony，分别对应可执行文件、静态库、动态链接库、纯头文件、伪 target。phony 类型的 target 仅用于添加一些可继承的 flag、协调 target 编译顺序，不会执行编译链接操作。</p><p>第四行的 <code>add_files</code> 语句为 target 加入了源文件。通过 <code>add_files</code> 加入的所有源文件都会被编译为中间文件，然后链接到目标文件中。xmake 支持通配符匹配添加文件：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">target(...)</span><br><span class="line">    add_files(<span class="string">&quot;src/*.cpp|standalone.cpp&quot;</span>, <span class="string">&quot;src/*.cu&quot;</span>)</span><br></pre></td></tr></table></figure><p>这一语句将 src 文件夹下所有.cu 后缀的文件、除 standalone.cpp 之外所有.cpp 后缀的文件加入 target。不显式声明 rule 重载的情况下，默认.c 后缀的文件会自动调用 C 编译器编译，.cpp&#x2F;.cc&#x2F;.cxx 后缀的文件会调用 C++ 编译器编译，.cu 后缀的文件会调用 CUDA 编译器编译，.asm&#x2F;.S 后缀的文件会调用汇编器汇编。</p><p>以上就是最简单的可执行文件 xmake.lua 结构。如果 helloworld.cpp 中没有 main() 函数，想要把 helloworld 编译为一个库，xmake.lua 也非常简单：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">add_rules(<span class="string">&quot;mode.debug&quot;</span>, <span class="string">&quot;mode.release&quot;</span>)</span><br><span class="line">target(<span class="string">&quot;helloworld&quot;</span>)</span><br><span class="line">    set_kind(<span class="string">&quot;$(kind)&quot;</span>)</span><br><span class="line">    add_files(<span class="string">&quot;src/main.cpp&quot;</span>)</span><br></pre></td></tr></table></figure><p>唯一的变化是 <code>set_kind</code> 语句。<code>set_kind(&quot;$(kind)&quot;)</code> 中使用了 xmake 的内置变量 <code>kind</code>。这一变量是在 configure 阶段指定的：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ xmake config --kind=shared # make libraries shared by default</span><br></pre></td></tr></table></figure><p>未指定情况下，<code>kind</code> 的默认值为 static。</p><blockquote><p>Tips. “$(val)” 的用法在 xmake 中仅限于字符串内部，其作用为简单的字符串替换。这一替换过程并非即时生效，而是解析完毕后再执行替换，因此不建议在 Script Scope 使用。详见 <a href="https://link.zhihu.com/?target=https://xmake.io/%23/manual/builtin_variables">文档</a>。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 编程工具 </category>
          
          <category> Xmake </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Obsidian 配置</title>
      <link href="/posts/%E6%9C%AC%E5%9C%B0/Obsidian%20%E9%85%8D%E7%BD%AE.html"/>
      <url>/posts/%E6%9C%AC%E5%9C%B0/Obsidian%20%E9%85%8D%E7%BD%AE.html</url>
      
        <content type="html"><![CDATA[<h1 id="Remotely-Save"><a href="#Remotely-Save" class="headerlink" title="Remotely Save"></a>Remotely Save</h1><p><a href="https://www.bilibili.com/video/BV1y54y1K7bV/?spm_id_from=333.999.0.0&vd_source=254fbc04b5fe132d6c95727aac670dea">obsidian+webDav网盘同步教程，笔记轻松同步，实现存储自由_哔哩哔哩_bilibili</a></p><h1 id="Memo"><a href="#Memo" class="headerlink" title="Memo"></a>Memo</h1><h2 id="设置-Memos"><a href="#设置-Memos" class="headerlink" title="设置 Memos"></a>设置 Memos</h2><p>Memos 的可设置选项比较复杂，这里仅对部分选项作简单说明。</p><p>下图设置了自定义 “ 用户名 “、” 发送按钮 “ 样式，部分订制 Memos 界面。</p><p><img src="/../../img/blog/44a754a46659b70e930de318adf04aee_MD5.webp"></p><p><img src="/../../img/blog/079958ee94351c462b858e6f092bdc45_MD5.webp"></p><p>这里我还设置了 <code># Memos</code> ，后面在具体使用 Memos 时会讲到。</p><h2 id="使用-Memos"><a href="#使用-Memos" class="headerlink" title="使用 Memos"></a>使用 Memos</h2><p>要注意的是，Obsidian Memos 中的文本是储存在核心插件日记中的，因此需要先对核心插件【日记】进行设置。</p><p><img src="/../../img/blog/4daf80be38c71d5e581c0d81d8564f3f_MD5.webp"></p><p>在设置中打开日记开关</p><p><img src="/../../img/blog/68857d4aedfa0ce25cf51181ea6572cd_MD5.webp"></p><p>对日记插件进行设置</p><p>至此，Memos 插件就可以运行了。</p><p><img src="/../../img/blog/e784e6c9840e9cc0bd91222f5c86f6a5_MD5.webp"></p><h3 id="3-1-基本用法"><a href="#3-1-基本用法" class="headerlink" title="3.1 基本用法"></a>3.1 基本用法</h3><p>首先在我的日记里设置标题 <code># Memos</code> 。</p><p><img src="/../../img/blog/ef756c5c3d46ba3a0e57c5c095907b53_MD5.webp"></p><p>打开 Memos 界面，输入 Memo，发送。然后就能在日记的 <code># Memos</code> 下看到刚刚发送的 Memo 了。</p><p><img src="/../../img/blog/742fb3bfd1cb95c801e0629c88cadf0a_MD5.webp"></p><p><img src="/../../img/blog/1adf63ca39a6b0cd7eff43dadc960c75_MD5.webp"></p><p>你还可以给你的 Memo 打上标签：</p><p><img src="/../../img/blog/0fe7df1743fa8dbdd731883fc0857e07_MD5.webp"></p><p><img src="/../../img/blog/d96b63327b01b4e95583c9d64fa59c10_MD5.webp"></p><p><strong>注意：</strong> Memos 中出现的标签，在 Obsidian 中也会出现。但 Obsidian 中的标签不会出现在 Memos 中（可通过设置 “ 使用在库内的所有标签 “ 来在 Memos 中查看库标签）</p><p>删除一条 Memo，该 Memo 会被移动到回收站，同时会在存放日记的文件夹下生成一个名为 “delete” 的文件，用于记录删除日志。 Memo 被删除后，日记中对应的内容也会被删除。</p><p><img src="/../../img/blog/4e06ead36a4682956512c82214255d8f_MD5.webp"></p><p><img src="/../../img/blog/2065ddcb125f3bbfce2bd2d95ccd1e9f_MD5.webp"></p><p><img src="/../../img/blog/daad1e6e2326ba2acb01040c4b45fcbf_MD5.webp"></p><p><strong>注意：</strong> 1. 请勿对 <code>delete</code> 文件进行直接编辑，容易导致 Memos 回收站出问题； 2. 回收站文件名可在 Memos 设置里更改。</p><p><img src="/../../img/blog/3c0d8979779c19d1d6c3dfb3aa8f0812_MD5.webp"></p><p>Memo 类型除了 “ 列表 “ 外，还可以是 “ 任务 “，可以在编辑时切换 Memo 类型，也可以在设置中设定默认类型（我不用 Memos 做待办，所以没改默认类型）</p><p><img src="/../../img/blog/64bf9ac46ba09bdf5f5cd46554c6905f_MD5.webp"></p><p><img src="/../../img/blog/6db5e42225adf70f480690a566eeaa2b_MD5.webp"></p><p><img src="/../../img/blog/3e6384c4f60e605879588a870b3c9b93_MD5.webp"></p><p><img src="/../../img/blog/d6c859bc028ab03499502a1b59953296_MD5.webp"></p><h3 id="3-2-检索式"><a href="#3-2-检索式" class="headerlink" title="3.2 检索式"></a>3.2 检索式</h3><p>Memos 中还有个 “ 检索式 “ 功能，你可以根据不同的 “ 标签 “、” 任务类型 “、” 文本内容 “、” 日期 “ 来创建检索器。 这里以标签 <code>#测试</code> 和 <code>#其他标签也可以加入检索式</code> 为例：</p><p><img src="/../../img/blog/322cffdd752ebdf49147ab622bfac4d6_MD5.webp"></p><p>创建完成后，” 检索式 “ 中多出了一个 “ 测试 “，作用是把带有标签 <code>#测试</code> 和 <code>#其他标签也可以加入检索式</code> 的 Memos 整合到了一个队列中。 检索式创建成功的同时，日记文件夹下会多出一个 “query” 文档，用于记录 “ 检索式的创建 “。同回收站，该文件名称可通过设置修改，且最好不要直接编辑该文件。</p><p><img src="/../../img/blog/b54b4a8140d0121b9971a48f1512101b_MD5.webp"></p><p>通过上面的例子不难看出，检索式的作用就是将 Memos 以一定的形式整合起来，即遵循卡片笔记写作法中 “ 将相关联的卡片笔记串联起来 “ 的原则。</p><h3 id="3-3-引用"><a href="#3-3-引用" class="headerlink" title="3.3 引用"></a>3.3 引用</h3><p>打开任意一个 Memo 的更多选项即可看到引用按钮，点击引用便会在编辑栏中生成一行 “ 引用 “ 文本。</p><p><img src="/../../img/blog/45449ff813d8bf18c9fe36e05300fc36_MD5.webp"></p><p><img src="/../../img/blog/e40a273b42fe33224fc61479b01ccccd_MD5.webp"></p><p>“ 阅读 “ 新发送的 “ 引用 “ 文本，即可看到该 Memo 的链接状态：</p><p><img src="/../../img/blog/0435c1d3dbc98840b8112972c24b5991_MD5.webp"></p><p><img src="/../../img/blog/069b4a39b3ce9e8da36c1bd5ec1c9868_MD5.webp"></p><p>“ 引用 “ 功能其实和 Obsidian 中的 “ 出链 “ 功能是一样的。学会了使用双链，也自然能用好这个功能。</p><h1 id="附件管理"><a href="#附件管理" class="headerlink" title="附件管理"></a>附件管理</h1><ul><li>在 Ob 库中建立一个附件文件夹，也就是专门用来存储附件的</li><li>打开设置→文件与链接 -&gt;指定的附件文件夹</li></ul><h1 id="快速插入模板"><a href="#快速插入模板" class="headerlink" title="快速插入模板"></a>快速插入模板</h1><ul><li>安装插件 Hotkeys for templates</li><li>打开 Hotkeys for templates 配置界面，一共分为三大块：Templator-obsidian 插件；核心模板插件；在特定的文件夹创建笔记会自动添加特定的模板</li></ul><p>咱们的需求是在特定的文件夹下新建笔记就会自动加载特定模板</p><p>那么，接下来就在 Templator-obsidian 模块或者核心模板模块中启用一个模板</p><p>来到 Create a new file in a specified folder with a specified template</p><p><img src="/../../img/blog/%E5%BF%AB%E9%80%9F%E6%8F%92%E5%85%A5%E6%A8%A1%E6%9D%BF-1.png"></p><p>点击 ADD 添加</p><h1 id="Obsidian-Git"><a href="#Obsidian-Git" class="headerlink" title="Obsidian Git"></a>Obsidian Git</h1><p>根目录创建一个 <code>.gitignore</code>，忽略掉 <code>.obsidian/workspace.json</code></p><h2 id="初始化仓库"><a href="#初始化仓库" class="headerlink" title="初始化仓库"></a>初始化仓库</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git init    </span><br><span class="line">git add .    </span><br><span class="line">git commit</span><br></pre></td></tr></table></figure><p>github 创建一个空仓库</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin git@github.com:xxx</span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p><img src="/../../img/blog/bb08041ebda0fd3abe12964bd6ca13bb_MD5.png"><br>打开插件设置界面，可以修改一下自动提交和手动提交的日志，我设置的是主机名 + 日期：</p><p><img src="/../../img/blog/4bfc7dad739c897acc45c75020c6e528_MD5.webp"></p><p>在提交信息设置里，可以修改主机名和日期格式，修改完成后点 Preview 可以预览提交信息：</p><p><img src="/../../img/blog/d9de7988f0b0e05d637c208ee1af1f12_MD5.webp"><br>快捷键 <code>Ctrl + P</code> 打开命令面板，输入 open source control view 启用可视化操作面板<br>然后在右侧菜单栏就可以看到操作面板了：</p><p><img src="/../../img/blog/2e724dfb7052ff16e35ad4083a764a48_MD5.webp"><br>一般操作就是：保存所有&gt;提交&gt;推送，就可以更新到 Git 服务器了，如下图顺序</p><p><img src="/../../img/blog/0e27ff82d7b40c4d1e96eaea51546248_MD5.jpg"></p><p>启用自动拉取功能，每次打开知识库就会自动拉取：</p><p><img src="/../../img/blog/0c1a0b636570aa507d23b4ffbddb0ed2_MD5.webp"></p><p>如果在使用过程中有报错的话，<code>Ctrl+Shift+I</code> 在控制台里可以查看详细日志，所有插件的日志都可以在这里看到：</p><p><img src="/../../img/blog/91a3e33577e44f1e48b2fb867ad67a60_MD5.webp"></p><h1 id="在-Obsidian-阅读并批注-Pdf-或-Epub-文档"><a href="#在-Obsidian-阅读并批注-Pdf-或-Epub-文档" class="headerlink" title="在 Obsidian 阅读并批注 Pdf 或 Epub 文档"></a>在 Obsidian 阅读并批注 Pdf 或 Epub 文档</h1><h2 id="下载-Annotator-插件"><a href="#下载-Annotator-插件" class="headerlink" title="下载 Annotator 插件"></a>下载 Annotator 插件</h2><h2 id="添加文件入-Obsidian"><a href="#添加文件入-Obsidian" class="headerlink" title="添加文件入 Obsidian"></a>添加文件入 Obsidian</h2><p>把你想要阅读的 pdf 或 epub 文件拖曳进指定的 obsidian 文件夹。当然，也可以直接拖曳到根目录下。我个人习惯是把 pdf 文件统一用一个文件夹放置，是为了让文件更有秩序。<br><img src="/../../img/blog/1aa4c304d8a14e8135bd00e7795c4a7e_MD5.png" alt="图片"></p><h2 id="编辑文档"><a href="#编辑文档" class="headerlink" title="编辑文档"></a>编辑文档</h2><p>在 obsidian 新建一个文档，这个文档就是你阅读这本书或者这篇论文之后的笔记文档。</p><p>在这个文档的开头，写上这三行代码：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">annotation-target:</span> <span class="string">xxxx.pdf</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure><p>其中，xxxx 的部分是写你目标文件所在的位置，比如我要提取王甦 - 认知心理学这个 pdf 文件，它所在的位置就是：Import Files&#x2F;PDF Files。</p><p>下图红色框框的部分就是你目标 pdf 文件的路径。记得最后要加上【.pdf】或者【.epub】这个后缀。</p><p><img src="/../../img/blog/202345e3c42e50d19624f047cf1730b6_MD5.png" alt="图片"></p><h2 id="切换成-Annotate-模式"><a href="#切换成-Annotate-模式" class="headerlink" title="切换成 Annotate 模式"></a>切换成 Annotate 模式</h2><p>完成第三步后，点开右上角的三个点，点击 Annotate 之后，就出现 pdf 文件和右侧栏标注视图了（如下图）。</p><p><img src="/../../img/blog/78633ce77103e46a1e6dfa8be8351e6c_MD5.png" alt="图片"></p><p><img src="/../../img/blog/40257ecda330e9a4e0e552297347b9e5_MD5.png" alt="图片"></p><h2 id="完成阅读后，切换回-Markdown-模式"><a href="#完成阅读后，切换回-Markdown-模式" class="headerlink" title="完成阅读后，切换回 Markdown 模式"></a>完成阅读后，切换回 Markdown 模式</h2><p>Annotator 最重要的功能就是能够直接在 pdf 文件上进行高亮和批注。等完成阅读后，点击右上角的三个点，点击 Open as Markdown 之后，再点击右上角切换成 “ 阅读视图 “，就可以看到你的高亮和批注啦。</p><p><img src="/../../img/blog/d5b67d5b541ce075e1b03442f392fc1c_MD5.png" alt="图片"></p><h2 id="进一步深加工你的批注"><a href="#进一步深加工你的批注" class="headerlink" title="进一步深加工你的批注"></a>进一步深加工你的批注</h2><p>Annotator 会帮你自动整理你在阅读过程中所批注和高亮的内容。</p><p>当你得到一篇你的笔记之后，你就可以进一步整理你的这些碎片笔记了，让这些碎片笔记真正为你所吸收，成为一篇读书报告或者书评。</p><p><img src="/../../img/blog/c758a95b637468bb9b45489f8c9c4db0_MD5.png" alt="图片"></p><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><ul><li><a href="https://pkmer.cn/Pkmer-Docs/10-obsidian/obsidian%E7%A4%BE%E5%8C%BA%E6%8F%92%E4%BB%B6/typewriter-mode/">Obsidian 插件：Typewriter Mode 更完美的打字机模式 (pkmer.cn)</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 本地 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Obsidian </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker镜像使用</title>
      <link href="/posts/%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7/Mysql/docker%E9%95%9C%E5%83%8F%E4%BD%BF%E7%94%A8.html"/>
      <url>/posts/%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7/Mysql/docker%E9%95%9C%E5%83%8F%E4%BD%BF%E7%94%A8.html</url>
      
        <content type="html"><![CDATA[<h1 id="下载-MySQL-镜像"><a href="#下载-MySQL-镜像" class="headerlink" title="下载 MySQL 镜像"></a>下载 MySQL 镜像</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull mysql</span><br></pre></td></tr></table></figure><h1 id="创建挂载目录"><a href="#创建挂载目录" class="headerlink" title="创建挂载目录"></a>创建挂载目录</h1><p>创建 data 目录用来挂载数据库文件，创建 conf 目录用来挂载配置文件</p><h1 id="第一次启动-MySQL"><a href="#第一次启动-MySQL" class="headerlink" title="第一次启动 MySQL"></a>第一次启动 MySQL</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 3306:3306 --name mysql -v D:/Docker/MySQL/conf:/etc/mysql/conf.d -v D:/Docker/MySQL/datadir:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 -d mysql:latest</span><br></pre></td></tr></table></figure><p>解释下这条命令的参数</p><p><strong>-a stdin:</strong> 指定标准输入输出内容类型，可选 STDIN&#x2F;STDOUT&#x2F;STDERR 三项；</p><p><strong>-d:</strong> 后台运行容器，并返回容器 ID；</p><p><strong>-i:</strong> 以交互模式运行容器，通常与 -t 同时使用；</p><p><strong>-P:</strong> 随机端口映射，容器内部端口<strong>随机</strong>映射到主机的端口</p><p><strong>-p:</strong> 指定端口映射，格式为：<strong>主机 (宿主) 端口: 容器端口</strong></p><p><strong>-t:</strong> 为容器重新分配一个伪输入终端，通常与 -i 同时使用；</p><p><strong>–name&#x3D;”nginx-lb”:</strong> 为容器指定一个名称；</p><p><strong>–dns 8.8.8.8:</strong> 指定容器使用的 DNS 服务器，默认和宿主一致；</p><p><strong>–dns-search example.com:</strong> 指定容器 DNS 搜索域名，默认和宿主一致；</p><p><strong>-h “mars”:</strong> 指定容器的 hostname；</p><p><strong>-e username&#x3D;”ritchie”:</strong> 设置环境变量；</p><p><strong>–env-file&#x3D;[]:</strong> 从指定文件读入环境变量；</p><p><strong>–cpuset&#x3D;”0-2” or –cpuset&#x3D;”0,1,2”:</strong> 绑定容器到指定 CPU 运行；</p><p>**-m :**设置容器使用内存最大值;</p><p><strong>–net&#x3D;”bridge”:</strong> 指定容器的网络连接类型，支持 bridge&#x2F;host&#x2F;none&#x2F;container: 四种类型；</p><p><strong>–link&#x3D;[]:</strong> 添加链接到另一个容器；</p><p><strong>–expose&#x3D;[]:</strong> 开放一个端口或一组端口；</p><p><strong>–volume , -v 本地目录：容器目录:</strong> 绑定一个卷,将容器目录挂载到本地目录</p><h1 id="启动-Mysqldocker-容器"><a href="#启动-Mysqldocker-容器" class="headerlink" title="启动 Mysqldocker 容器"></a>启动 Mysqldocker 容器</h1><p>利用 docker ps 命令可以查看当前运行的容器，docker ps -a 查看所有容器（包括停止的容器）</p><p>可以命令 停止和启动 docker 容器</p><p>停止容器：docker stop [CONTAINER ID]</p><p>启动 容器：docker start [CONTAINER ID]</p><p>也可以在 windows 的 docker 桌面版里启动</p><p><img src="/../../../img/blog/ba3f764c1b1ddb1c3b0dacc7c3b3fb0a_MD5.jpg"></p><h2 id="进入容器"><a href="#进入容器" class="headerlink" title="进入容器"></a>进入容器</h2><p>命令 docker exec -it [NAMES] bash，这里 names 可以用那么也可以使用容器 ID 即 Container ID</p><p><img src="/../../../img/blog/2013019ac6572b7bde84da1285a612b4_MD5.jpg"></p><h2 id="进入数据库"><a href="#进入数据库" class="headerlink" title="进入数据库"></a>进入数据库</h2><p>使用 mysql -uroot -p123456 进入数据库</p><p>使用 show databases; 查看数据库</p><p><img src="/../../../img/blog/20b9dd25df9db1f71ffdf25b9ed9f1bf_MD5.webp"></p><p>use mysql 进入名为 mysql 的数据库，show tables 可以查看当前数据库有哪些表</p><h2 id="使用-SQL"><a href="#使用-SQL" class="headerlink" title="使用 SQL"></a>使用 SQL</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source /etc/mysql/conf.d/kaoqin.sql</span><br></pre></td></tr></table></figure><h2 id="创建账户"><a href="#创建账户" class="headerlink" title="创建账户"></a>创建账户</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># 创建用户并开启远程登录</span><br><span class="line"></span><br><span class="line">CREATE USER &#x27; 你的账号 &#x27;@&#x27;%&#x27; IDENTIFIED BY &#x27; 你的密码 &#x27;;</span><br><span class="line"></span><br><span class="line"># 创建数据库并设置字符集</span><br><span class="line"></span><br><span class="line">CREATE DATABASE `库名` CHARACTER SET &#x27;utf8mb4&#x27;;</span><br><span class="line"></span><br><span class="line"># 给账号授权数据库</span><br><span class="line"></span><br><span class="line">GRANT ALL PRIVILEGES ON 库名.* TO &#x27; 你的账号 &#x27;@&#x27;%&#x27;;</span><br><span class="line"></span><br><span class="line"># 刷新权限</span><br><span class="line"></span><br><span class="line">flush privileges;</span><br></pre></td></tr></table></figure><h2 id="为了方便以后远程连接，需要下面操作"><a href="#为了方便以后远程连接，需要下面操作" class="headerlink" title="为了方便以后远程连接，需要下面操作"></a>为了方便以后远程连接，需要下面操作</h2><p>需要修改 user 表中的 user 为 root 变为 %。这里没有修改成功，因为一开始就是 %</p><p>exit 关掉，利用 service mysqld restart 重新启动 mysql 服务。</p><p><img src="/../../../img/blog/5ae34a419de42bc94ab05f5550bf6e3d_MD5.webp"></p><h2 id="如何远程连接-Docker-的-Mysql-容器"><a href="#如何远程连接-Docker-的-Mysql-容器" class="headerlink" title="如何远程连接 Docker 的 Mysql 容器"></a>如何远程连接 Docker 的 Mysql 容器</h2><p>首先查看 dockers 镜像 ip，在终端输如 ifconfig，如果出现 bash: ifconfig: command not found，则需要安装一些东西 sudo apt-get install net-tools，现在就可以访问 ifconfig</p><p>现在还不能连接成功，给 root 用户分配权限</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter user &#x27;root&#x27;@&#x27;%&#x27; identified with mysql_native_password by &#x27;123456&#x27;;</span><br></pre></td></tr></table></figure><p>刷新权限</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flush privileges;</span><br></pre></td></tr></table></figure><h1 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h1><p>新装了 mysql8.0 后再用 navicat 链接就会报 2059 的错误。</p><p>上网查了发现是 8.0 之后 mysql 更改了密码的加密规则，只要在命令窗口把加密方法改回去即可。</p><p>首先使用以下命令进入 MySQL 的 docker 容器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it MYSQL8.0 bash</span><br></pre></td></tr></table></figure><p>然后登录 MySQL</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -uroot -p123456</span><br></pre></td></tr></table></figure><p>然后运行以下 SQL 即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">alter user &#x27;root&#x27;@&#x27;%&#x27; identified by &#x27;123456&#x27; password expire never;</span><br><span class="line">alter user &#x27;root&#x27;@&#x27;%&#x27; identified with mysql_native_password by &#x27;123456&#x27;;</span><br><span class="line">flush privileges;</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://blog.csdn.net/u014282578/article/details/127920419">写最好的Docker安装最新版MySQL8（mysql-8.0.31）教程（参考Docker Hub和MySQL官方文档）_docker 安装mysql8_大白有点菜的博客-CSDN博客</a></p>]]></content>
      
      
      <categories>
          
          <category> 编程工具 </category>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机/编程工具/docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IDEA创建maven项目卡在resolving dependencies</title>
      <link href="/posts/%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7/IDEA/IDEA%E5%88%9B%E5%BB%BAmaven%E9%A1%B9%E7%9B%AE%E5%8D%A1%E5%9C%A8resolving%20dependencies.html"/>
      <url>/posts/%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7/IDEA/IDEA%E5%88%9B%E5%BB%BAmaven%E9%A1%B9%E7%9B%AE%E5%8D%A1%E5%9C%A8resolving%20dependencies.html</url>
      
        <content type="html"><![CDATA[<p>记得在使用 IDEA 创建 maven 项目的时候，有时候会一直卡在 resolving dependencies…问题上，从而导致创建项目过慢，这是由于在下载 jar 包的时候由于可能没有设置镜像是从远程进行下载导致过慢，也有可能是网络的原因。这时候我们如果是在开始创建 maven 项目的时候在 Properties 的属性面板中添加一项：archetypeCatalog &#x3D; internal 即可。配置如下</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">archetypeCatalog</span><br><span class="line"><span class="keyword">internal</span></span><br></pre></td></tr></table></figure><p><img src="/../../../img/blog/45bfcd7e428008c2f2401bd26948e965_MD5.webp" alt="在这里插入图片描述"></p><p>如果是在项目已经创建过后，在 pom 文件中添加其他的依赖的时候，也卡在了 resolving dependencies…问题上，则我们可以在 settings 中的 maven 进行设置，路径和配置如下：</p><p><img src="/../../../img/blog/65c8f2f732a5129388710b9f129d4c42_MD5.webp" alt="在这里插入图片描述"></p><p>即在 vm options 添加参数</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">-DarchetypeCatalog</span>=internal</span><br></pre></td></tr></table></figure><p>-DarchetypeCatalog 参数是用来指定 archetype-catalog.xml 文件从哪里获取的。可以选择的值为：remote，internal ，local 等，如果不进行设置的话则默认使用 remote，而由于远程的中央仓库的 archetype 太多， 导致从远程网络加载所以非常慢，这也是之前卡在这里的原因。</p><p>settings 设置的是当前项目的配置，如果设置全局的设置，则在 other settings 进行上述设置，则对其他项目也生效。</p><p>通过上述设置即可解决 IDEA 创建 maven 项目过慢，一直卡在 resolving dependencies…的问题。</p><h1 id="打开-Settings"><a href="#打开-Settings" class="headerlink" title="打开 Settings"></a>打开 Settings</h1><p>修改 maven Importing 的 jvm 参数, 默认为 700 多, 直接修改成</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xms1024m -Xmx2048m</span><br></pre></td></tr></table></figure><p>（博主的话：猜测这个貌似是 maven 下载速度的带宽限制，我直接搞成了 -Xmx4096m，然后就看到进度条一直处在飞奔的状态。。。）</p><p>Resolving Maven dependencies 立刻就消失了。</p><p><img src="/../../../img/blog/483947dcd3400e975b7618d564129533_MD5.webp"></p>]]></content>
      
      
      <categories>
          
          <category> 编程工具 </category>
          
          <category> IDEA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机/编程工具/IDEA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>本地软件配置1</title>
      <link href="/posts/%E6%9C%AC%E5%9C%B0/%E6%9C%AC%E5%9C%B0%E8%BD%AF%E4%BB%B6%E9%85%8D%E7%BD%AE1.html"/>
      <url>/posts/%E6%9C%AC%E5%9C%B0/%E6%9C%AC%E5%9C%B0%E8%BD%AF%E4%BB%B6%E9%85%8D%E7%BD%AE1.html</url>
      
        <content type="html"><![CDATA[<h1 id="Scoop"><a href="#Scoop" class="headerlink" title="Scoop"></a>Scoop</h1><h2 id="将-Scoop-安装到自定义目录-命令行方式-设置环境变量）"><a href="#将-Scoop-安装到自定义目录-命令行方式-设置环境变量）" class="headerlink" title="将 Scoop 安装到自定义目录 (命令行方式)(设置环境变量）"></a>将 Scoop 安装到自定义目录 (命令行方式)(设置环境变量）</h2><p><code>$env:SCOOP=&#39;D:\Applications\Scoop&#39; </code><br><code>[Environment]::SetEnvironmentVariable(&#39;SCOOP&#39;, $env:SCOOP, &#39;User&#39;)</code></p><h2 id="将-Scoop-配置为将全局程序安装到自定义目录-SCOOP-GLOBAL-命令行方式"><a href="#将-Scoop-配置为将全局程序安装到自定义目录-SCOOP-GLOBAL-命令行方式" class="headerlink" title="将 Scoop 配置为将全局程序安装到自定义目录 SCOOP_GLOBAL(命令行方式)"></a>将 Scoop 配置为将全局程序安装到自定义目录 SCOOP_GLOBAL(命令行方式)</h2><p><code>$env:SCOOP_GLOBAL=&#39;F:\GlobalScoopApps&#39;</code><br><code>[Environment]::SetEnvironmentVariable(&#39;SCOOP_GLOBAL&#39;, $env:SCOOP_GLOBAL, &#39;Machine&#39;)</code></p><h2 id="安装并镜像加速"><a href="#安装并镜像加速" class="headerlink" title="安装并镜像加速"></a>安装并镜像加速</h2><p><a href="https://gitee.com/glsnames/scoop-installer#31-%E4%BB%A3%E7%90%86%E5%8F%AF%E9%80%89">https://gitee.com/glsnames/scoop-installer#31-%E4%BB%A3%E7%90%86%E5%8F%AF%E9%80%89</a></p><h1 id="Zotero-本体"><a href="#Zotero-本体" class="headerlink" title="Zotero 本体"></a>Zotero 本体</h1><h2 id="添加文献"><a href="#添加文献" class="headerlink" title="添加文献"></a>添加文献</h2><p>Zotero 添加文献主要有通过浏览器插件添加和手动添加两种方式。</p><h3 id="通过浏览器插件添加"><a href="#通过浏览器插件添加" class="headerlink" title="通过浏览器插件添加"></a>通过浏览器插件添加</h3><p><strong>注意，通过这种方式添加需要保证 Zotero 客户端在运行状态。</strong></p><p>安装好浏览器插件后，浏览器的插件栏会多出一个 Zotero 图标（空白页面下），如下图红框。</p><p><img src="/../../img/blog/a7b1dc70a97fea74d55355358a30481f_MD5.png"></p><p>随手打开一篇 arXiv 上的文章，你会发现这个图标变成了一张纸的样子，这意味着 Zotero 插件检测到了一篇文献。点一下它，将出现下图中的提示框，Zotero 说，我帮你把这个文献保存在 “My Library” 啦，除了它自身的信息之外，还有一个 “Comment”，一个全文 PDF 文件，以及一个网页快照（Snapshot）。</p><p><img src="/../../img/blog/c88365fe0ef3757e374debb85a3b0ca7_MD5.webp"></p><p>打开 Zotero，这篇文献已经出现在 “My Library” 中了，连同下载的所有附件。如果附件没有出现的话，你需要稍等片刻，因为 PDF 的下载可能需要一些时间。</p><p><img src="/../../img/blog/fe794eca77aafb142ab878cec2bba311_MD5.webp"></p><p>现在我们打开一个 Google Scholar 搜索结果页面，你会发现这个图标变成了一个 “ 文件夹 “，因为 Zotero 在这个页面找到了多篇文献。点击文件夹图标，在弹出的窗口可以选择一篇或多篇文献加入文献库。</p><p><img src="/../../img/blog/c89c69700f395d2782ded7fc738119ad_MD5.webp"></p><p>Amazing！打开 Zotero，刚才选择的文献全部被加进来了！</p><p><img src="/../../img/blog/a5c0c4c00dca176e891ff02ec5899b4c_MD5.webp"></p><p>即使在找不到文献的页面，Zotero 也可以保存网页的快照（Snapshot）以供离线查看。这是个非常实用的功能，一些大佬的技术博客、公众号推送、发出来可能很快就不会存在的文章，都可以通过这种方式用 Zotero 统一管理，简直不能太方便。下面的图中我用这种方式保存了一篇 GCN 教程：</p><p><img src="/../../img/blog/1eb6941df924c45f2e340bb62e4f3658_MD5.webp"></p><p><img src="/../../img/blog/1355e4a52bd280d759a1b38c63ea9a50_MD5.webp"></p><p>在知道有这个功能之后，我做的第一件事是保存了自己投过所有文章的 review，以在骄傲自满的时候给自己沉重打击。</p><h3 id="手动添加"><a href="#手动添加" class="headerlink" title="手动添加"></a>手动添加</h3><p>手动添加最常用的情况是直接导入一个本地的 PDF 文件。方法是直接把 PDF 文件拖进 Zotero 界面，像下面这样。</p><p><img src="/../../img/blog/793e17c80299296602bf227fef8d3372_MD5.webp"></p><p>Zotero 会自动识别 PDF 中的各种元数据，自动填充条目信息：</p><p><img src="/../../img/blog/75ed132fe774c2ad46c453a8067837c4_MD5.webp"></p><p>并不是每一个 PDF 文件都能够识别得很准确，比如这篇 Conference Paper 就被识别成了 Book Section，作者的顺序也不对。使用这种方法导入通常需要手动再进行一些修改。</p><p>当然，对于任何一个条目，除了修改基本信息之外，我们也可以手动为它添加各种附件。比如我们通过浏览器添加了一篇没有全文 PDF 的文献，我们可以通过这种方法为其加入自己下载的 PDF。方法是右击条目，选择 “Add attachment “。</p><p><img src="/../../img/blog/a90501bb644b1f5f63fb6da352e9056b_MD5.webp"></p><p>这里 “ Attach Stored Copy of File” 和 “Attach Link to File” 的区别是，前者会把这个文件复制一份丢进文献库，而后者只会把这个附件指向原文件（类似超链接）。</p><p>Zotero 也支持直接通过 ISBN、DOI、PMID 或 arXiv ID 来添加文献。点击工具栏的 “ 魔棒 “ 图标，输入一个 ISBN 编码：</p><p><img src="/../../img/blog/ec0dd8456a92fa425c8166366fe9fcc8_MD5.webp"></p><p>Zotero 会去网上找这个编码对应的元数据，把它加进文献库：</p><p><img src="/../../img/blog/de0611287f9f751f6db6c1a8e6c3ef63_MD5.webp"></p><p>最后，我们也可以纯手动添加条目，自己填写所有数据域、添加附件。点击工具栏的加号按钮，选择一个合适的类型即可。</p><p><img src="/../../img/blog/e4ec2eb01ac6f1582fba28048951f92a_MD5.webp"></p><h2 id="管理文献"><a href="#管理文献" class="headerlink" title="管理文献"></a>管理文献</h2><p>在文献管理上，Zotero 有文件夹（collection）、标签（tag）和便捷搜索（saved search）三种方式。</p><h3 id="文件夹（collection）管理"><a href="#文件夹（collection）管理" class="headerlink" title="文件夹（collection）管理"></a>文件夹（collection）管理</h3><p>在 Zotero 客户端左边栏的 “My Library” 上右键选择 “New Collection”（或者点击最左上角的按钮），新建一个文件夹：</p><p><img src="/../../img/blog/0dcfc09d372d33a9fbee8672e0b9edf9_MD5.webp"></p><p>Zotero 里的文件夹和操作系统里是一样的，我们可以把文献在文件夹之间拖来拖去，还可以在文件夹下新建子文件夹，建立层级的树状结构：</p><p><img src="/../../img/blog/58090b35374130309b53bbe9f53aa67f_MD5.webp"></p><p>如果只是使用 collection，其实和你不用 Zotero、在电脑上建一层一层的文件夹进行管理没有很大区别。我一般会用 collection 进行数据来源层级的区分（比如论文、公众号、网页等），再使用标签（tag）机制进行进一步的细粒度管理。</p><h3 id="标签（tag）管理"><a href="#标签（tag）管理" class="headerlink" title="标签（tag）管理"></a>标签（tag）管理</h3><p>我们可以对文献库中的文献添加一个或多个自定义的标签（tag）：</p><p><img src="/../../img/blog/dd23d27bb9ad6b32730c691f0bea71f7_MD5.webp"></p><p>也可以在用浏览器插件添加文献时顺手添加：</p><p><img src="/../../img/blog/405113edde415dde36da15ff528c3fdb_MD5.webp"></p><p>Zotero 支持最多为 9 个 tag 分别指定不同的颜色，做法是在界面左下角的 tag 面板中，右击一个 tag，选择 “ Assign Color”。</p><p><img src="/../../img/blog/f711e46e54b6fdf9f6976c71697f9cc2_MD5.webp"></p><p>如果一个文献被打上了带颜色的标签，这个颜色的色块也会被显示在文献标题中，一目了然，区别起来很方便！</p><p><img src="/../../img/blog/08e774bf004a3430c71d89c9ba43c718_MD5.webp"></p><p>现在，我们可以通过点击 tag 面板中的标签来实现对于文献的筛选了！</p><p><img src="/../../img/blog/5414718a5d4ade06a752b54f3f8a4b14_MD5.jpg" alt="动图封面"></p><h3 id="便捷搜索（saved-search）"><a href="#便捷搜索（saved-search）" class="headerlink" title="便捷搜索（saved search）"></a>便捷搜索（saved search）</h3><p>我们有时候需要对文献库进行一些搜索，针对关键词、标签，或者二者都有。但有些常用的搜索条件，我们不希望每次都重新输入，这时候便捷搜索功能（saved search）就是一个强大的工具。</p><p>右击 “My Library”，选择 “New Saved Search”。</p><p><img src="/../../img/blog/320e4a44517bb5ecf34bd824fbd0a576_MD5.webp"></p><p>在弹出的窗口中，输入检索条件，点击 “OK”。比如这里我做了一个 ICCV 2019 文章的搜索，限定会议名称包含 “IEEE International Conference on Computer Vision “，日期是 “2019”。当然这需要文献的元数据准确。</p><p><img src="/../../img/blog/0985d58709fd1a74c91260ef2a05c178_MD5.webp"></p><p>点击 “OK”，我们会发现出现了这样带齿轮的紫色文件夹，这就是便捷搜索生成的结果。文件夹中包含了当前文献库中符合此条件的所有文献，如果新增添的文献符合搜索条件的话，也会自动出现在这里。</p><p><img src="/../../img/blog/8bb2b462ed7c5131c14342fee6d70ef8_MD5.webp"></p><p>在工具栏点击搜索按钮，在弹出的高级搜索对话框中，也可以保存便捷搜索：</p><p><img src="/../../img/blog/69878e72e688127af92fc27bd3798f60_MD5.webp"></p><h2 id="笔记系统"><a href="#笔记系统" class="headerlink" title="笔记系统"></a>笔记系统</h2><p>Zotero 的笔记系统比较简单。由于 Zotero 没有内置 PDF 阅读器，所以 PDF 内部的高亮、标注等功能依赖用户的 PDF 阅读器。但 Zotero 允许我们给文献添加多篇笔记（note），在任意一篇文献的 “Notes” 选项卡中点击 “Add” 来添加笔记。</p><p><img src="/../../img/blog/d51bc1c8b0f5e7c216abd333ec9e5b1c_MD5.webp"></p><p>我们可以在出现的富文本编辑器中写简单的笔记。注意左边，文献的附件中出现了一条新的笔记。笔记也可以打标签，或是和文献一起被同步至云空间。</p><p><img src="/../../img/blog/f84ed344b50a4affd17a59c1f6e4481c_MD5.webp"></p><p>值得一提的是，你还可以在工具栏中，添加独立的笔记条目（standalone note），该条目不依赖于任何文献。这意味着，Zotero 还可以当做一个笔记本&#x2F;备忘录来用 [呲牙]。通用性多强啊！</p><p><img src="/../../img/blog/42c879055d7e65feb7045e25197896d7_MD5.webp"></p><h2 id="文献导出"><a href="#文献导出" class="headerlink" title="文献导出"></a>文献导出</h2><p>选中一篇或多篇文献，右击菜单中有三种导出方式： <strong>Export Items</strong>、<strong>Create Bibliography from Items</strong> 和 <strong>Generate Report from Items</strong>。</p><p><img src="/../../img/blog/38f04b3ff627f835ace93701d688cf1a_MD5.webp"></p><p>其中：</p><ul><li><strong>Export Items</strong> 可以将文献导出成不同的格式，包括 BibTex、 Bookmarks 、CSV、Endnote XML 等，也同时可以导出附件。我一般用来和他人分享文章，也可以用来在不同文献管理软件之间做数据迁移。</li><li><strong>Create Bibliography from Items</strong> 就是我们在写论文时生成参考文献最常用的选项了。弹出的对话框中可以选择不同的参考文献格式和导出的形式（默认是复制到剪贴板）。</li></ul><p><img src="/../../img/blog/1bcba8c35ec817bf114d845eef76fee9_MD5.webp"></p><ul><li><strong>Generate Report from Items</strong> 可以为这些文献生成一个固定格式的 HTML report，里面有每篇文献的元数据。感觉没啥用，官方说可以用来 “Reviewing Abstracts “、”Teaching” 以及 “ Organizing Notes into Outlines “。</li></ul><p>这里有一个小技巧——最便捷生成参考文献的方式，是直接把选中的文献拖动至文本编辑器中；或者按 Cmd+ Shift +C，再粘贴到文本编辑框中。这种方式输出的参考文献格式可以在设置的 Export 选项卡里更改，我改成了 BibTex。下面的 GIF 展示了这种 “Quick Copy” 的特性，实在是方便得过分。</p><p><img src="/../../img/blog/30d92b09fddfbe3c46cf3ad69aefbdeb_MD5.jpg" alt="动图封面"></p><p>Zotero 还提供了针对 Word、LibreOffice 的插件，以及对 Google Docs 的支持，如果你用以上工具写作，看看 <a href="https://link.zhihu.com/?target=https://www.zotero.org/support/word_processor_integration">官方的介绍</a> 吧。</p><h1 id="NSSM—封装-windows-服务工具"><a href="#NSSM—封装-windows-服务工具" class="headerlink" title="NSSM—封装 windows 服务工具"></a>NSSM—封装 windows 服务工具</h1><p><strong>NSSM 是一个服务封装程序，它可以将普通 exe 程序或 bat 文件封装成服务，使之像 windows 服务一样运行</strong>。同类型的工具还有微软自己的 srvany，不过 nssm 更加简单易用，并且功能强大。它的特点如下：</p><p><strong>1.支持普通 exe 程序（控制台程序或者带界面的 Windows 程序都可以）或 bat 文件</strong></p><p><strong>2.安装简单又方便</strong></p><p><strong>3.可以重定向输出（并且支持 Rotation）</strong></p><p><strong>4.可以自动守护封装了的服务，程序挂掉了后可以自动重启</strong></p><p><strong>5.可以自定义环境变量</strong></p><p><strong>6.可以自定义启动参数</strong></p><p>从以上可以得知，NSSM 每个功能都很实用，可以大大简化开发流程，降低了开发难度，使用和调试起来也非常方便，特别不需要考虑开发一个服务实现服务守护功能，以确保稳定可靠。</p><p>**NSSM 的官网下载地址：<a href="https://link.zhihu.com/?target=http://nssm.cc/download">http://nssm.cc/download</a>**，如下图：</p><p><img src="/../../img/blog/8cd0d9ab5f8e26606e0c474d5f06cacb_MD5.webp"></p><p>NSSM 的官网下载地址</p><p><strong>NSSM 常用命令，</strong>如下：</p><p><strong>1.安装服务：nssm install 服务名称</strong></p><p><strong>2.删除服务：nssm remove 服务名称</strong></p><p><strong>3.删除服务确定：nssm remove 服务名称 confirm</strong></p><p><strong>4.修改服务（显示界面修改）：nssm edit 服务名称</strong></p><p><strong>5.启动服务：nssm start 服务名称</strong></p><p><strong>6.停止服务：nssm stop 服务名名称</strong></p><p><strong>7.停止服务：nssm stop 服务名称</strong></p><p><strong>NSSM 使用步骤</strong>，如下：</p><p><strong>1.下载 NSSM</strong></p><p><strong>2.根据 windows 平台，将 32&#x2F;64 位 nssm.exe 文件解压至任意文件夹</strong></p><p><strong>3.cmd 定位至 nssm.exe 所在目录，如你操作系统是 32bit，请对应 32 位的 nssm.exe 文件，如你操作系统是 64bit，请对应 64 位的 nssm.exe</strong></p><p><strong>4.输入 nssm install {服务名称}，即注册 Windows 服务的名称。</strong></p><p><img src="/../../img/blog/817502c361bb8affe362565acb72665b_MD5.webp"></p><p>对应的 nssm.exe</p><p><strong>注册服务弹出如下 NSSM 界面</strong>，如下图：</p><p><img src="/../../img/blog/995ccd62bbd6febec71419597ff0c125_MD5.webp"></p><p>注册服务</p><p>设置说明，如下：</p><p><strong>1.Application Path: 选择系统安装的 exe 或 bat。</strong></p><p><strong>2.Startup directory: 选择 exe 或 bat 项目的根目录。</strong></p><p><strong>3.Arguments: 输入启动参数。</strong></p><p>上述步骤操作完成，即可点击 Install service 来注册服务。我们在系统的服务中即可找到刚刚注册的服务。</p><p><img src="/../../img/blog/e2d9007b90d24b64941a9491919659b8_MD5.webp"></p><p>安装服务</p><p><img src="/../../img/blog/0d10b71e5697d21cdf87fe32fa8a219d_MD5.webp"></p><p>安装成功</p><p><img src="/../../img/blog/e3be526bf010091371d60c21a5204060_MD5.webp"></p><p>新安装的 windows 服务</p><p>在系统服务中找到刚刚注册的服务，右键属性 - 恢复即可设置此服务挂掉重启等内容。<br><strong>需要注意一点，安装完服务后，需要启动服务，否则没有生效</strong>。</p><h1 id="PotPlayer"><a href="#PotPlayer" class="headerlink" title="PotPlayer"></a>PotPlayer</h1><p><a href="https://zhuanlan.zhihu.com/p/504190202">超详细PotPlayer教程：下载安装与优化设置 保姆级教程 - 知乎 (zhihu.com)</a><br><a href="https://www.appinn.com/potplayer-webdav-alist/">PotPlayer 直接播放网盘视频：连接 Alist，接入阿里云盘、百度&#x2F;夸克网盘等 - 小众软件 (appinn.com)</a></p><h1 id="zerotrust"><a href="#zerotrust" class="headerlink" title="zerotrust"></a>zerotrust</h1><h2 id="tunnel"><a href="#tunnel" class="headerlink" title="tunnel"></a>tunnel</h2><ul><li><a href="https://sspai.com/post/79278#!">CloudFlare Tunnel 免费内网穿透的简明教程 - 少数派 (sspai.com)</a></li><li><a href="https://blog.borber.top/tech/cf-tunnel-proxy-ssh/">cloudflare tunnel 代理 ssh | BORBER</a></li><li><a href="https://zhuanlan.zhihu.com/p/621870045">使用cloudflare tunnel免费内网穿透，实现网站的外网访问和远程桌面 - 知乎 (zhihu.com)</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 本地 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>docker安装和使用</title>
      <link href="/posts/%E7%B3%BB%E7%BB%9F/Docker/docker%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8.html"/>
      <url>/posts/%E7%B3%BB%E7%BB%9F/Docker/docker%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8.html</url>
      
        <content type="html"><![CDATA[<h1 id="Docker-Desktop"><a href="#Docker-Desktop" class="headerlink" title="Docker Desktop"></a>Docker Desktop</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>平时要使用 Docker 不想安装虚拟机，也不想买服务器时推荐安装官方提供的「Docker Desktop」</p><p>1、官网下载安装包： https:&#x2F;<img src="/../../../img/blog/48f51444c4d1b5363ab558441fffe3e1_MD5.png" alt="图片">441fffe3e1_MD5.png)</p><hr><p>2、修改默认安装位置</p><p>默认是安装在 C 盘中的并且无法修改，后续下载一些镜像时也会存放在 C 盘，我这里通过「mklink 创建软链接」的方式，将文件映射到我的 D 盘中，先在 D 盘创建好如下四个目录结构：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mkdir D:\Docker  </span><br><span class="line">mkdir D:\Docker\Local  </span><br><span class="line">mkdir D:\Docker\Roaming\Docker  </span><br><span class="line">mkdir &quot;D:\Docke![图片](../../../img/blog/6c73026be38cb3e6c6767df7cae248fe_MD5.png)be38cb3e6c6767df7cae248fe_MD5.png)然后以管理员身份打开 cmd，在打开的 cmd 窗口中依次执行下面四个 `mklink` 命令</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>mklink &#x2F;j “C:\Program Files\Docker” “D:\Docker”<br>mklink &#x2F;j “C:\Users\ICEFJL\AppData\Local\Docker” “D:\Docker\Local”<br>mklink &#x2F;j “C:\Users\ICEFJL\AppData\Roaming\Docker” “D:\Docker\Roaming\Docker”<br>mklink &#x2F;j “C:\Users\ICEFJL\AppData\Roaming\Docker Desktop” “D:\Docker\Roaming\Docker Desktop”</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">3、安装**「Docker Deskt![图片](../../../img/blog/f032a04751de9c7da78e303776aac9ce_MD5.png)blog/f032a04751de9c7da78e303776![图片](../../../img/blog/6aa10763fea03299263663fbe4460bbc_MD5.png)g/blog/6aa10763fea03299263663fbe4460bbc_MD5.png) Accept 后出现以下弹窗：Docker Desktop 需要更新的 WSL 内核版本。通过运行 &quot;wsl --update&quot; 更新 WSL 内核，或按照以下位置的说明进行操作 https://docs.microsoft.com/windows/ws![图片](../../../img/blog/568cf9761d743c2b2ceb0ff96a7e9eee_MD5.png)/img/blog/568cf9761d743c2b2ceb0ff96a7e9eee_MD5.png)</span><br><span class="line"></span><br><span class="line">## 更改镜像下载源</span><br><span class="line"></span><br><span class="line">![图片](../../../img/blog/d823d802503de776664e32fb0f187ec7_MD5.png)/../../img/blog/d823d802503de776664e32fb0f187ec7_MD5.png)复制以下代码覆盖掉要更改部分，重启 Docker Desktop 即可，**「registry-mirrors」**配的都是国内的一些镜像源</span><br><span class="line"></span><br><span class="line">```json</span><br><span class="line">&#123;</span><br><span class="line">  &quot;builder&quot;: &#123;</span><br><span class="line">    &quot;gc&quot;: &#123;</span><br><span class="line">      &quot;defaultKeepStorage&quot;: &quot;20GB&quot;,</span><br><span class="line">      &quot;enabled&quot;: true</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;experimental&quot;: false,</span><br><span class="line">  &quot;features&quot;: &#123;</span><br><span class="line">    &quot;buildkit&quot;: true</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;registry-mirrors&quot; : [</span><br><span class="line">    &quot;https://registry.docker-cn.com&quot;,</span><br><span class="line">    &quot;https://docker.mirrors.ustc.edu.cn&quot;,</span><br><span class="line">    &quot;http![图片](../../../img/blog/32d5b77b0cd97dfac76c81cb51e332f0_MD5.png)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/../../../../img/blog/32d5b77b0cd97dfac76c81cb51e332f0_MD5.png" alt="图片"></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://mp.weixin.qq.com/s/ErDeO9e1aaOIRMkfnfXU7Q">Windows中也可以安装使用Docker (qq.com)</a></p><h1 id="Docker-学习"><a href="#Docker-学习" class="headerlink" title="Docker 学习"></a>Docker 学习</h1><p><a href="https://yeasy.gitbook.io/docker_practice/">前言 - Docker — 从入门到实践 (gitbook.io)</a></p><h1 id="Docker-安装"><a href="#Docker-安装" class="headerlink" title="Docker 安装"></a>Docker 安装</h1><p><a href="https://www.runoob.com/docker/ubuntu-docker-install.html">Ubuntu Docker 安装 | 菜鸟教程 (runoob.com)</a><br>linux&#x2F;ubuntu 下的安装命令 (使用阿里云镜像)：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update &amp;&amp; sudo apt-get install -y apt-transport-https ca-certificates curl software-properties-common &amp;&amp; curl -fsSL https:``//download``.[docker.com](http://docker.com/)``/linux/ubuntu/gpg | sudo apt-key add - &amp;&amp; sudo add-apt-repository <span class="string">&quot;deb [arch=amd64] [http://mirrors.aliyun.com/docker-ce/linux/ubuntu](http://mirrors.aliyun.com/docker-ce/linux/ubuntu) <span class="subst">$(lsb_release -cs)</span> stable&quot;</span> &amp;&amp; sudo apt-get update &amp;&amp; sudo apt-get install -y docker-ce</span><br></pre></td></tr></table></figure><p>一条命令就可以搞定安装，不过安装可能需要一些时间，等着就行。</p><p>在使用过程中，当需要查找某个镜像的时候，我们可以去 docker 中央仓库：<a href="https://hub.docker.com/">https://hub.docker.com/</a>  查看，从中我们可以看到该名称镜像历史的 release 的版本，我们可以根据需求选择自己需要的版本。</p><h1 id="Docker-常用管理命令"><a href="#Docker-常用管理命令" class="headerlink" title="Docker 常用管理命令"></a>Docker 常用管理命令</h1><p><a href="https://www.runoob.com/docker/docker-command-manual.html">Docker 命令大全 | 菜鸟教程 (runoob.com)</a><br>service docker start # 启动 docker 服务器</p><p>(1) 拉取某个镜像</p><p><code>docker pull xxxx</code></p><p>(2) 查看镜像与删除镜像</p><p>查看所有镜像：<code>docker images</code></p><p>删除镜像 ：<code>docker rmi xxxx</code></p><p>注意：删除镜像前必须先停用、删除该镜像产生的实例</p><p>(3) 查看与删除实例</p><p>查看所有实例：<code>docker ps -a</code></p><p>查看 activate 实例：<code>docker ps</code></p><p>删除实例：<code>docker rm xxx</code></p><p>(4) 根据镜像创造 docker 实例,这里以 nginx 为例</p><p><code>docker run --name nginx -p 80:80 -v /root/docker_conf/nginx/nginx.conf:/etc/nginx/nginx.conf -d docker.io/nginx</code></p><p>其中: -name 是镜像的名称,  -p 是端口映射, -v 是绑定一个卷, 我们可以把自己的文件目录映射到镜像内部目录, 冒号前面为自己的实际机器, : 后面是对应镜像的目录。</p><p>(5) 当 docker 启动失败的时候 debug 原因：</p><p><code>docker logs xxID</code></p><p>(6) 进入实例</p><p>根据上面的命令创建的实例之后，如果成功的话会默认启动实例，我们可以使用下列命令进入到该实例内部：</p><p><code>docker exec -it nginx bash</code></p><p><code>docker run -it --rm ubuntu /bin/bash</code>    运行存在的镜像，并以交互的方式进入容器，运行完删除容器</p><p>(7) 复制文件到实例内部系统</p><p><code>docker cp my.cnf mysql5.7:/etc/mysql/my.cnf</code></p><p>把宿主机文件拷到容器里面<br><code>docker cp 要拷贝的文件路径 容器名: 要拷贝到容器里面对应的路径</code></p><p>容器里面拷文件到主机<br><code>docker cp 容器名: 要拷贝的文件在容器中的路径 要拷贝到宿主机器的响应路径</code></p><p>(8)  实例内系统安装软件</p><p>实例内也是一个操作系统，我们可以安装需要使用的程序：</p><p><code>apt update</code></p><p>例如安装 vim 命令 :  <code>apt install vim</code></p><p>(9) 停止,启动,重新启动 docker 实例</p><p><code>docker start/stop/restart xxx</code></p><p>(10)  卸载 docker</p><p><code>yum remove docker-ce</code></p><p>删除镜像、容器、配置文件等内容：</p><p><code>rm -rf /var/lib/docker</code></p><h2 id="Docker-资源管理命令"><a href="#Docker-资源管理命令" class="headerlink" title="Docker 资源管理命令"></a>Docker 资源管理命令</h2><p>docker 镜像在很多时候会耗占比较多的内存和 cpu, 甚至某个镜像被用来挖矿的情况下, cpu 会达到 100%(都是血与泪的实践经历啊)， 所以我们可以使用下面的命令来限制性设置某个实例的内存与 cpu 占用量。</p><p>(1) docker 各个镜像资源使用情况查看 (包括 cpu 和内存)：</p><p><code>docker stats</code></p><p>(2)  限制 docker 内存</p><p><code>docker update -m 20M --memory-reservation 20M --memory-swap 20M nginx</code></p><p>（3）限制 docker cpu</p><p><code>docker update --cpu-period=100000 --cpu-quota=20000 nginx</code></p><p>在每 100 毫秒的时间里，运行进程使用的 CPU 时间最多为 20 毫秒，这里仅仅考虑百分比。</p><h1 id="Docker-常用软件管理"><a href="#Docker-常用软件管理" class="headerlink" title="Docker 常用软件管理"></a>Docker 常用软件管理</h1><h2 id="Docker-部署私有的笔记服务-Wiznote"><a href="#Docker-部署私有的笔记服务-Wiznote" class="headerlink" title="Docker 部署私有的笔记服务 Wiznote"></a>Docker 部署私有的笔记服务 Wiznote</h2><p>作为一个对写代码有追求的程序员，有一个自己用起来顺手的笔记服务是必不可少的，作者经过大量的筛选，目前主要在使用的就是 wiznote 这个软件，个人用户使用 5 个账号内免费，并且个人功能上的需求完全可以满足，使用 docker 部署也非常简单便利。</p><p>(1) 部署过程如下：</p><p><code>docker run --name wiz --restart=always -it -d -v /root/docker_conf/wiz_wiki_dat:/wiz/storage -v /etc/localtime:/etc/localtime -p 9191:80 -p 9269:9269/udp wiznote/wizserve</code></p><p>然后我们访问 <code>http://ip:9191</code> 网址即可以访问我们自己的笔记后端服务了。</p><p>初始账号：<code>admin@wiz.cn</code>,  密码：<code>123456，</code> 输入后记得自行进行修改啊，否则可能导致被他人登陆。</p><h2 id="Docker-部署-Mysql"><a href="#Docker-部署-Mysql" class="headerlink" title="Docker 部署 Mysql"></a>Docker 部署 Mysql</h2><p>（1）docker 部署 mysql</p><p>参考 wiki: <a href="https://blog.csdn.net/weixin_43888891/article/details/122518719">https://blog.csdn.net/weixin_43888891/article/details/122518719</a></p><p><code>docker pull mysql:5.7   docker run -itd --name mysql5.7 --restart=always -p 3306:3306 -e MYSQL_ROOT_PASSWORD=you_mysql_pwd docker.io/mysql:5.7    进入docker 内部：docker exec -it mysql5.7 bash   </code></p><p>(2) 配置数据库可以远程访问</p><p><code>docker exec -it mysql5.7 bash   grant all on *.* to root@&#39;%&#39; identified by &#39;you_mysql_pwd&#39; with grant option;      </code></p><p>(3) 优化 docker MySQL 配置</p><p>更新 my.cnf 文件</p><p><code>[mysqld]      max_connect_errors = 1000      lower_case_table_names = 1      performance_schema_max_table_instances = 200      table_definition_cache = 100      table_open_cache = 100      innodb_buffer_pool_size=2M      performance_schema=off   </code></p><p>更新 docker.cnf  文件</p><p><code>skip-host-cache   skip-name-resolve</code> </p><p>（4）覆盖 docker 内部文件配置</p><p><code>docker cp docker.cnf  mysql5.7:/etc/mysql/conf.d/docker.cnf   docker cp my.cnf  mysql5.7:/etc/mysql/my.cnf   </code></p><p>(5)  限制 docker MYSQL 内存和 cpu 使用</p><p><code>docker update -m 800M --memory-reservation 800M --memory-swap 800M mysql5.7   docker update  --cpu-period=100000 --cpu-quota=20000 mysql5.7</code></p><h2 id="Docker-部署-Redis"><a href="#Docker-部署-Redis" class="headerlink" title="Docker 部署 Redis"></a>Docker 部署 Redis</h2><p><a href="https://blog.csdn.net/yaoyuncn/article/details/103916573">使用docker desktop for windows安装redis:latest并挂载配置文件及持久化数据至windows的文件夹下</a></p><p>(1) docker 使用 redis</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name redis -p 6379:6379 -v /root/docker_conf/redis/redis.conf:/etc/redis/redis.conf -d redis redis-server /etc/redis/redis.conf</span><br></pre></td></tr></table></figure><p>我们可以把 redis 常用的配置文件放在 &#x2F;root&#x2F;docker_conf&#x2F;redis&#x2F;redis.conf 这个路径下。</p><p>(2) 外面访问容器里的 redis 服务</p><p><code>docker exec -it redis redis-cli</code></p><p>(3) 限制 redis 内存访问</p><p><code>docker update -m 50M --memory-reservation 50M --memory-swap 50M redis</code></p><p>然后我们就可以通过 ip: 6379 端口访问我们的 redis 服务了。</p><h2 id="Docker-部署-Nginx"><a href="#Docker-部署-Nginx" class="headerlink" title="Docker 部署 Nginx"></a>Docker 部署 Nginx</h2><p>(1) docker 使用 nginx</p><p><code>docker pull nginx</code></p><p>&#x2F;&#x2F; 本机卷映射 nginx 卷</p><p><code>docker run --name nginx -p 80:80 -v /root/docker_conf/nginx/nginx.conf:/etc/nginx/nginx.conf -d docker.io/nginx</code></p><p>(2) 限制 docker 使用内存</p><p><code>docker update -m 50M --memory-reservation 50M --memory-swap 50M nginx</code></p><p>注意，使用 docker 之后，映射的服务 IP 应该改成外部 IP，在使用 127.0.0.1 会报错。</p><p>（3）配置 nginx conf</p><p><code>/root/docker_conf/nginx下nginx.conf</code></p><p>这样我们修改本机器上的&#x2F;root&#x2F;docker_conf&#x2F;nginx&#x2F;nginx.conf  路径下的配置文件，就可以直接影响 docker nginx 服务的配置了。</p><p>然后我们就可以通过 <a href="http://ip/">http://ip:80</a>  端口访问我们的 nginx  服务了。</p><h2 id="Docker-部署-Gitea"><a href="#Docker-部署-Gitea" class="headerlink" title="Docker 部署 Gitea"></a>Docker 部署 Gitea</h2><p>在很多时候我们会需要部署我们自己的 git 版本管理仓库，可以使用 gitea 这个开源版本库，非常好用，使用 docker 部署也非常简单。</p><p>(1) 拉取 gitea 仓库</p><p><code>docker pull gitea/gitea</code></p><p>(2)  启动 gitea 实例与服务</p><p><code>docker run -d --privileged=true --restart=always --name=gitea -p 20022:22 -p 3000:3000 -v /root/docker_conf/gitea:/data gitea/gitea:latest</code></p><p>在下面我们就可以使用 <code>http://ip:3000</code> 去访问我们的 git 服务了。</p><h1 id="Docker-镜像文件保存与加载"><a href="#Docker-镜像文件保存与加载" class="headerlink" title="Docker 镜像文件保存与加载"></a>Docker 镜像文件保存与加载</h1><p>(1) 保存 docker 镜像文件到本地：</p><p><code>docker save nginx &gt;./nginx.tar</code></p><p>(2)  在另一台主机加载本地文件到镜像 ：</p><p><code>docker load &lt; nginx.tar</code></p><p>然后看 docker images ，就能看到该镜像 ，但是名字和标签都是 none</p><p>（3）执行完上述语句后，查看本地镜像，会看到新加载的镜像名字和标签都是 none，利用该镜像的 id 对名字和标签重新命名即可：</p><p><code>指令：docker tag 镜像id 镜像名:标签      docker tag 172825a55619 confluence6.12_cracked:0.1   </code></p><p>(4) 启动镜像</p><p><code>docker run -it --name nginx 172825a55619 /bin/bash</code></p><h1 id="Docker-镜像文件的提交与上传到中央仓库"><a href="#Docker-镜像文件的提交与上传到中央仓库" class="headerlink" title="Docker 镜像文件的提交与上传到中央仓库"></a>Docker 镜像文件的提交与上传到中央仓库</h1><p>很多时候，我们会需要在已有的镜像上进行一些自定义修改，然后重新打包上传自己的镜像供别人使用，我们可以使用下面的流程来上传自己新打包的镜像到中央仓库。</p><p>(5.1)  官网账号注册</p><p>首先我们先到 docker 官网注册一个账号，这样我们才能将制作好的镜像上传到 docker 仓库，</p><p>打开 <code>https://hub.docker.com/</code></p><p>(5.2) 提交自己要上传的镜像</p><p><code>docker commit Container_name yourdockerhub/nginx:latest</code></p><p>注意：commit 对包名命名有要求，Container_name 容器名称,yourdockerhub 改成自己的账号，否则无法上传</p><p>(5.3)  登录到远程 docker 仓库 (输入自己注册的账号和密码)</p><p><code>docker login</code></p><p>(5.4)  上传至 docker 云端</p><p><code>docker push yourdockerhub/nginx:latest</code><br>注意: 这里 push 对包名命名有要求，yourdockerhub 改成自己的账号，否则无法上传 上传成功了就可以在中央仓库你的账号下搜到你刚上传的镜像了。</p>]]></content>
      
      
      <categories>
          
          <category> 系统 </category>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机/编程工具/docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vscode</title>
      <link href="/posts/%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7/Vim/Vscode.html"/>
      <url>/posts/%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7/Vim/Vscode.html</url>
      
        <content type="html"><![CDATA[<h1 id="输入法切换"><a href="#输入法切换" class="headerlink" title="输入法切换"></a>输入法切换</h1><p>设置 NORMAL 模式下的输入法为英文， 方便进行 vim 指令操作。</p><ul><li>Windows scoop 安装</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scoop bucket add im-select https://github.com/daipeihust/im-select</span><br><span class="line">scoop install im-select</span><br></pre></td></tr></table></figure><ul><li>需要在系统设置中添加中英文语言包，需要下载中文（简体，中国）和英语（美国），im-select<img src="/../../../img/blog/4f7dd400131ed1102d1d590cdab024cd_MD5.webp"></li><li>勾选 <img src="/../../../img/blog/b3ac789a137121fa6d03e9004ecda674_MD5.webp">a6d03e9004ecda674_MD5.webp)</li><li>随后在 im-select.exe 所在文件夹打开 shell 窗口，执行.\im-select.exe 之后会返回当前输入语言的句柄值，我的电脑中文使用搜狗输入法，执行.\im-select.exe 后其返回值为 2052，切换到英文输入法后再次执<img src="/../../../img/blog/39498a4d9a902f8d90bdc30eae4ddbfb_MD5.webp">02f8d90bdc30eae4ddbfb_MD5.webp)</li><li>随后执行.\im-select.exe 1033 以及.\im-select.exe 2052 测试输入语言可以正常切换，说明<img src="/../../../img/blog/e32d15d7fbc9c3746d4a21b2d42641ff_MD5.webp">fbc9c3746d4a21b2d42641ff_MD5.webp)<br>然后再到 settings.json 中加入以下配置项即可完成输入法在 INSERT 模式以及 NORMAL 模式下的自动切换。</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自动切换输入法</span></span><br><span class="line">   <span class="attr">&quot;vim.autoSwitchInputMethod.enable&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">   <span class="attr">&quot;vim.autoSwitchInputMethod.defaultIM&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1033&quot;</span><span class="punctuation">,</span>  <span class="comment">// 这里输入你刚刚获得的英文输入法名称</span></span><br><span class="line">   <span class="attr">&quot;vim.autoSwitchInputMethod.obtainIMCmd&quot;</span><span class="punctuation">:</span> <span class="string">&quot;C:/Users/User/scoop/apps/im-select/current/im-select.exe&quot;</span><span class="punctuation">,</span></span><br><span class="line">   <span class="attr">&quot;vim.autoSwitchInputMethod.switchIMCmd&quot;</span><span class="punctuation">:</span> <span class="string">&quot;C:/Users/User/scoop/apps/im-select/current/im-select.exe &#123;im&#125;&quot;</span></span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://hangx-ma.github.io/2023/03/14/vsvim-keyborad-setting.html#22-%E7%83%AD%E9%94%AE%E9%85%8D%E7%BD%AE%E5%8C%BA%E5%9F%9F%E8%AF%B4%E6%98%8E">VSCodeVim 配置指南 - 一只豆腐 (hangx-ma.github.io)</a><br><a href="https://www.barbarianmeetscoding.com/boost-your-coding-fu-with-vscode-and-vim">Boost Your Coding Fu With VSCode and Vim - The Book | Barbarian Meets Coding</a><br><a href="https://coolshell.cn/articles/5426.html">简明 Vim 练级攻略 | 酷 壳 - CoolShell</a></p>]]></content>
      
      
      <categories>
          
          <category> 编程工具 </category>
          
          <category> Vim </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vim </tag>
            
            <tag> vscode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu解决方案</title>
      <link href="/posts/%E7%B3%BB%E7%BB%9F/Linux/Ubuntu%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88.html"/>
      <url>/posts/%E7%B3%BB%E7%BB%9F/Linux/Ubuntu%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88.html</url>
      
        <content type="html"><![CDATA[<h1 id="Ubuntu-修改终端上显示的用户名和主机名"><a href="#Ubuntu-修改终端上显示的用户名和主机名" class="headerlink" title="Ubuntu 修改终端上显示的用户名和主机名"></a>Ubuntu 修改终端上显示的用户名和主机名</h1><p><a href="https://blog.nowcoder.net/n/9719c38265a44e23a0c7b4b9f0225b72?from=nowcoder_improve">Ubuntu修改终端上显示的用户名和主机名（详细步骤）_牛客博客 (nowcoder.net)</a></p><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p><a href="https://zhuanlan.zhihu.com/p/540712989">Linux使用 apt-get 查询并安装指定版本的软件 - 知乎 (zhihu.com)</a></p><h1 id="列出手动安装的软件包"><a href="#列出手动安装的软件包" class="headerlink" title="列出手动安装的软件包"></a>列出手动安装的软件包</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-mark showmanual</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 系统 </category>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Go语言环境配置</title>
      <link href="/posts/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Go%E8%AF%AD%E8%A8%80%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE.html"/>
      <url>/posts/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Go%E8%AF%AD%E8%A8%80%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE.html</url>
      
        <content type="html"><![CDATA[<h1 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h1><h2 id="使用包管理器"><a href="#使用包管理器" class="headerlink" title="使用包管理器"></a>使用包管理器</h2><ul><li><p><strong>Ubuntu&#x2F;Debian</strong></p>  <figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt install golang</span><br></pre></td></tr></table></figure></li><li><p><strong>Fedora</strong></p>  <figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo dnf install golang</span><br></pre></td></tr></table></figure></li><li><p><strong>CentOS&#x2F;RHEL</strong></p>  <figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install golang</span><br></pre></td></tr></table></figure></li></ul><h2 id="使用-tarball"><a href="#使用-tarball" class="headerlink" title="使用 tarball"></a>使用 tarball</h2><p>下载安装包</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget -c https://storage.googleapis.com/golang/go1.8.3.linux-amd64.tar.gz</span><br></pre></td></tr></table></figure><p>解压至 &#x2F;usr&#x2F;local 目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo tar -C /usr/local -xzf go1.8.3.linux-amd64.tar.gz</span><br></pre></td></tr></table></figure><p>修改环境变量</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/profile</span><br></pre></td></tr></table></figure><p>在文件后面增加</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export GOPATH=$HOME/gopath</span><br><span class="line">export GOROOT=/usr/local/go</span><br><span class="line">export PATH=$PATH:$GOROOT/bin:$GOPATH/bin</span><br></pre></td></tr></table></figure><p>保存并退出，并执行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source ~/.profile</span><br></pre></td></tr></table></figure><p>重启系统，查看是否安装成功</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go version</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机/编程语言/go </tag>
            
            <tag> 计算机/编程语言/语言环境配置 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WSL配置</title>
      <link href="/posts/%E7%B3%BB%E7%BB%9F/%E8%99%9A%E6%8B%9F%E6%9C%BA/WSL%E9%85%8D%E7%BD%AE.html"/>
      <url>/posts/%E7%B3%BB%E7%BB%9F/%E8%99%9A%E6%8B%9F%E6%9C%BA/WSL%E9%85%8D%E7%BD%AE.html</url>
      
        <content type="html"><![CDATA[<h1 id="Wsl-搬迁"><a href="#Wsl-搬迁" class="headerlink" title="Wsl 搬迁"></a>Wsl 搬迁</h1><p>如果我们是通过 Windows Store 进行安装的，就会默认安装到 C 盘。在使用过程中，WSL 占用空间会越来越大，很容易让 C 盘爆满，所以我们需要将其迁移到其他非 C 盘的地方。</p><h2 id="终止正在运行的-Wsl"><a href="#终止正在运行的-Wsl" class="headerlink" title="终止正在运行的 Wsl"></a>终止正在运行的 Wsl</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wsl --shutdown</span><br></pre></td></tr></table></figure><h2 id="将需要迁移的-Linux，进行导出"><a href="#将需要迁移的-Linux，进行导出" class="headerlink" title="将需要迁移的 Linux，进行导出"></a>将需要迁移的 Linux，进行导出</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wsl --export Ubuntu-18.04 D:\wsl\export</span><br></pre></td></tr></table></figure><h2 id="导出完成之后，就需要将原有的分发进行卸载"><a href="#导出完成之后，就需要将原有的分发进行卸载" class="headerlink" title="导出完成之后，就需要将原有的分发进行卸载"></a>导出完成之后，就需要将原有的分发进行卸载</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wsl --unregister Ubuntu-18.04</span><br></pre></td></tr></table></figure><h2 id="然后将导出的文件放到需要保存的地方，进行导入即可"><a href="#然后将导出的文件放到需要保存的地方，进行导入即可" class="headerlink" title="然后将导出的文件放到需要保存的地方，进行导入即可"></a>然后将导出的文件放到需要保存的地方，进行导入即可</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wsl --import Ubuntu-18.04 D:\wsl D:\wsl\export --version 2</span><br></pre></td></tr></table></figure><p>注意：如果导入后终端查找不到 wsl，可以重启系统后再打开终端。</p><p>这时打开终端，进的是 root 系统，还需要：</p><h2 id="设置默认登陆用户为安装时用户名"><a href="#设置默认登陆用户为安装时用户名" class="headerlink" title="设置默认登陆用户为安装时用户名"></a>设置默认登陆用户为安装时用户名</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">myUsername=caloewen</span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;[user]\ndefault=<span class="variable">$myUsername</span>&quot;</span> &gt;&gt; /etc/wsl.conf</span><br></pre></td></tr></table></figure><p>重启终端</p><h1 id="WSL2-优化"><a href="#WSL2-优化" class="headerlink" title="WSL2 优化"></a>WSL2 优化</h1><h2 id="压缩"><a href="#压缩" class="headerlink" title="压缩"></a>压缩</h2><p>随着使用时间的延长，WSL2 占用的硬盘空间会越来越多，这个时候就需要对其文件进行压缩。方法如下</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">wsl <span class="literal">--shutdown</span></span><br><span class="line">diskpart</span><br><span class="line"><span class="comment"># open window Diskpart</span></span><br><span class="line"><span class="built_in">select</span> vdisk file=<span class="string">&quot;C:\Users\Ci\AppData\Local\Packages\CanonicalGroupLimited.Ubuntu20.04onWindows_79rhkp1fndgsc\LocalState\ext4.vhdx&quot;</span></span><br><span class="line"><span class="comment"># select vdisk file=&quot;C:\Users\Ci\AppData\Local\Packages\KaliLinux.54290C8133FEE_ey8k8hqnwqnmg\LocalState\ext4.vhdx&quot;</span></span><br><span class="line">attach vdisk readonly</span><br><span class="line">compact vdisk</span><br><span class="line">detach vdisk</span><br></pre></td></tr></table></figure><h2 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h2><p>当然，WSL2 也会带来内存占用的问题，可以打开 <code>$home/.wslconfig</code>，进行如下设置</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="type">wsl2</span>]</span><br><span class="line">memory=<span class="number">4</span>GB</span><br><span class="line">swap=<span class="number">0</span></span><br></pre></td></tr></table></figure><h1 id="Wsl-2-设置静态-DNS-服务地址及-Linux-和-Windows-主机网络互相访问设置"><a href="#Wsl-2-设置静态-DNS-服务地址及-Linux-和-Windows-主机网络互相访问设置" class="headerlink" title="Wsl 2 设置静态 DNS 服务地址及 Linux 和 Windows 主机网络互相访问设置"></a>Wsl 2 设置静态 DNS 服务地址及 Linux 和 Windows 主机网络互相访问设置</h1><p>DNS 解析<br>wsl 2 使用的 DNS 解析服务器设置在文件：&#x2F;etc&#x2F;resolv.conf 内设置，这是一个 link 文件，真正的文件路径是：&#x2F;run&#x2F;resolvconf&#x2F;resolv.conf，这个文件是每次 wsl 启动时自动生成的，内容如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># This file was automatically generated by WSL. To stop automatic generation of this file, add the following entry to /etc/wsl.conf:</span></span><br><span class="line"><span class="comment"># [network]</span></span><br><span class="line"><span class="comment"># generateResolvConf = false</span></span><br><span class="line">nameserver 172.24.144.1</span><br></pre></td></tr></table></figure><p>nameserver 后面的就是指定的 DNS 服务器地址。我发现有时候分配的服务器地址是无效的，如：127.0.0.53，使用 ping 来测试发现提示无法解析地址。需要设置一个固定的 DNS 地址，方法如下：</p><p>新建文件：&#x2F;etc&#x2F;wsl.conf，内容如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[network]</span><br><span class="line">generateResolvConf = <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>以上配置好就不会自动创建 &#x2F;run&#x2F;resolvconf&#x2F;resolv.conf 文件了。</p><p>退出 wsl，关机然后重新启动：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">exit</span></span><br><span class="line">wsl --shutdown</span><br><span class="line">wsl</span><br></pre></td></tr></table></figure><p>删除 link 文件：&#x2F;etc&#x2F;resolv.conf:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">rm</span> /etc/resolv.conf</span><br></pre></td></tr></table></figure><p>然后新建 &#x2F;etc&#x2F;resolv.conf 文件，内容如下，可自定义 nameserver 地址：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nameserver 114.114.114.114</span><br></pre></td></tr></table></figure><p>再次退出 wsl，关机然后重新启动<br>查看 &#x2F;etc&#x2F;resolv.conf 文件是否是之前自定义的地址：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /etc/resolv.conf</span><br></pre></td></tr></table></figure><p>测试网络服务：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping niekun.net</span><br></pre></td></tr></table></figure><p>如果你想对将要安装的 deb 软件包使用 dpkg 命令，在这里是如何完成它：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo dpkg -i path_to_deb_file</span><br></pre></td></tr></table></figure><h1 id="记录-Windows11-安装-WSL2-配置环境时遇到的坑，以及一些常用命令（持续更新）"><a href="#记录-Windows11-安装-WSL2-配置环境时遇到的坑，以及一些常用命令（持续更新）" class="headerlink" title="记录 Windows11 安装 WSL2 配置环境时遇到的坑，以及一些常用命令（持续更新）"></a>记录 Windows11 安装 WSL2 配置环境时遇到的坑，以及一些常用命令（持续更新）</h1><p><a href="https://blog.csdn.net/luyuyingyingying/article/details/123110417">https://blog.csdn.net/luyuyingyingying/article/details/123110417</a></p><h1 id="WSL-systemd"><a href="#WSL-systemd" class="headerlink" title="WSL_systemd"></a>WSL_systemd</h1><p>安装好新版 wsl 后，通过以下命令来配置 wsl 启用 systemd:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;[boot]\nsystemd=true&quot;</span> | sudo <span class="built_in">tee</span> -a /etc/wsl.conf</span><br></pre></td></tr></table></figure><p>配置后需要通过 <code>wsl --shutdown</code> 命令关闭 wsl，来进行 wsl 的完整重启。</p><h2 id="如何判断-Systemd-是否启用成功"><a href="#如何判断-Systemd-是否启用成功" class="headerlink" title="如何判断 Systemd 是否启用成功"></a>如何判断 Systemd 是否启用成功</h2><p>判断 wsl 是否已启用 systemd，可通过以下命令查看：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps --no-headers -o <span class="built_in">comm</span> 1</span><br></pre></td></tr></table></figure><p>如果命令返回的是 <code>init</code> 说明 systemd 未启用，如果是 <code>systemd</code> 那么你的 systemd 已启用成功了。</p><h2 id="查看已启用的-Systemd-Service"><a href="#查看已启用的-Systemd-Service" class="headerlink" title="查看已启用的 Systemd Service"></a>查看已启用的 Systemd Service</h2><p>通过 systemctl 的 list-units、list-unit-files 命令，都可以很好的查看目前的 systemd 状态，命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl list-units --<span class="built_in">type</span>=service</span><br><span class="line">systemctl list-unit-files --<span class="built_in">type</span>=service --state=enabled</span><br></pre></td></tr></table></figure><h2 id="解决-Exec-Exec-Format-Error"><a href="#解决-Exec-Exec-Format-Error" class="headerlink" title="解决 Exec: Exec Format Error"></a>解决 Exec: Exec Format Error</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo sh -c &#x27;echo :WSLInterop:M::MZ::/init:PF &gt; /usr/lib/binfmt.d/WSLInterop.conf&#x27;</span><br></pre></td></tr></table></figure><p>After <code>wsl --shutdown</code> and logging back in, now next to systemd, <code>explorer.exe</code> and the like are finally working again!<br><a href="https://github.com/microsoft/WSL/issues/8843">[WSL2][systemd][interop] Unable to Execute Windows Binary when systemd enabled · Issue #8843 · microsoft&#x2F;WSL (github.com)</a></p><h2 id="启用-Systemd-支持后无法从-Wsl2-运行-Exe"><a href="#启用-Systemd-支持后无法从-Wsl2-运行-Exe" class="headerlink" title="启用 Systemd 支持后无法从 Wsl2 运行 Exe"></a>启用 Systemd 支持后无法从 Wsl2 运行 Exe</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo update-binfmts --disable cli</span><br></pre></td></tr></table></figure><h1 id="Kali"><a href="#Kali" class="headerlink" title="Kali"></a>Kali</h1><h2 id="升级"><a href="#升级" class="headerlink" title="升级"></a>升级</h2><p>安装完成后，在 Kali Linux 下，输入如下命令，安装工具集</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update &amp;&amp; sudo apt upgrade</span><br><span class="line">sudo apt install -y kali-linux-default</span><br></pre></td></tr></table></figure><h2 id="GUI"><a href="#GUI" class="headerlink" title="GUI"></a>GUI</h2><p>当然为了更好的体验 Kali，我们可以安装官方推荐的 GUI —— Win-KeX。输入如下命令，进行安装。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install -y kali-win-kex</span><br><span class="line">sudo mount -o remount,rw /tmp/.X11-unix</span><br></pre></td></tr></table></figure><p>安装完毕后，可使用如下命令启动</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动</span></span><br><span class="line"><span class="built_in">cd</span> ~</span><br><span class="line">kex</span><br><span class="line"><span class="comment"># 关闭</span></span><br><span class="line">kex stop</span><br><span class="line"><span class="comment"># 窗口模式</span></span><br><span class="line">kex --win -s</span><br></pre></td></tr></table></figure><p><a href="https://www.kali.org/docs/wsl/win-kex/#install-kali-linux-in-wsl2">Win-KeX | Kali Linux Documentation</a></p><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><p><a href="https://blog.csdn.net/qq_26107827/article/details/129282799">解决：wsl 系统无法访问此文件-CSDN博客</a></p>]]></content>
      
      
      <categories>
          
          <category> 系统 </category>
          
          <category> 虚拟机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> wsl </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VMware解决方案</title>
      <link href="/posts/%E7%B3%BB%E7%BB%9F/%E8%99%9A%E6%8B%9F%E6%9C%BA/VMware%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88.html"/>
      <url>/posts/%E7%B3%BB%E7%BB%9F/%E8%99%9A%E6%8B%9F%E6%9C%BA/VMware%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88.html</url>
      
        <content type="html"><![CDATA[<h1 id="虚拟机-Deepin-网线未连接"><a href="#虚拟机-Deepin-网线未连接" class="headerlink" title="虚拟机 Deepin 网线未连接"></a>虚拟机 Deepin 网线未连接</h1><p>不小心将虚拟机 <a href="https://so.csdn.net/so/search?q=ubuntu&spm=1001.2101.3001.7020">ubuntu</a>&#x2F;deepin 强制关机后，重启之后系统显示网卡未连接。<br>解决办法：<br>编辑文件&#x2F;etc&#x2F;network&#x2F;interfaces:<br>sudo vi &#x2F;etc&#x2F;network&#x2F;interfaces，在文件里加上：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">auto ens33</span><br><span class="line">iface ens33 inet dhcp</span><br></pre></td></tr></table></figure><p>最后执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo /etc/init.d/networking restart</span><br></pre></td></tr></table></figure><h1 id="vmware-虚拟机网卡不启动时的-service-NetworkManager-修复"><a href="#vmware-虚拟机网卡不启动时的-service-NetworkManager-修复" class="headerlink" title="vmware 虚拟机网卡不启动时的 service NetworkManager 修复"></a>vmware 虚拟机网卡不启动时的 service NetworkManager 修复</h1><h2 id="检查-Windows-下的-Vmware-虚拟机网络相关服务是否开启"><a href="#检查-Windows-下的-Vmware-虚拟机网络相关服务是否开启" class="headerlink" title="检查 Windows 下的 Vmware 虚拟机网络相关服务是否开启"></a>检查 Windows 下的 Vmware 虚拟机网络相关服务是否开启</h2><p><img src="/../../../img/blog/0dd2e698444a07e3d24ae66ce90bed4d_MD5.png" alt="image.png"></p><h2 id="2-检查虚拟接网络配置设置是否正确"><a href="#2-检查虚拟接网络配置设置是否正确" class="headerlink" title="2. 检查虚拟接网络配置设置是否正确"></a>2. 检查虚拟接网络配置设置是否正确</h2><p>检查 vmware workstation 的网络配置是否符合主机的虚拟网卡配置，若不确定就点击还原默认设置<br><img src="/../../../img/blog/8f86b52d506cbb4260790e6f77103348_MD5.png" alt="image.png"></p><h2 id="3-检查虚拟机-Ubuntu-系统右上角的网络连接是否存在"><a href="#3-检查虚拟机-Ubuntu-系统右上角的网络连接是否存在" class="headerlink" title="3. 检查虚拟机 Ubuntu 系统右上角的网络连接是否存在"></a>3. 检查虚拟机 Ubuntu 系统右上角的网络连接是否存在</h2><p>若不存在，网络就可能连不上</p><h2 id="4-修复"><a href="#4-修复" class="headerlink" title="4. 修复"></a>4. 修复</h2><p>（1）删除 NetworkManager 缓存文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">service NetworkManager stop</span><br><span class="line">sudo <span class="built_in">rm</span> /var/lib/NetworkManager/NetworkManager.state</span><br><span class="line">service NetworkManager start</span><br></pre></td></tr></table></figure><p>（2）修改&#x2F;etc&#x2F;NetworkManager&#x2F;NetworkManager.conf</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo gedit /etc/NetworkManager/NetworkManager.conf</span><br><span class="line"><span class="comment">##找到managed=false修改为：managed=true</span></span><br></pre></td></tr></table></figure><p>（3）重启 NetworkManager</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo service network-manager restart</span><br></pre></td></tr></table></figure><p>就可以看到系统右上角出现了网络图标，重启虚拟机，搞定！</p><h1 id="Ubuntu22-04-在-VMware-17-无法实现拖放复制操作解决办法"><a href="#Ubuntu22-04-在-VMware-17-无法实现拖放复制操作解决办法" class="headerlink" title="Ubuntu22.04 在 VMware 17 无法实现拖放复制操作解决办法"></a>Ubuntu22.04 在 VMware 17 无法实现拖放复制操作解决办法</h1><p><a href="https://blog.csdn.net/ZRongZH/article/details/129237476">Ubuntu22.04 在 VMware 17 无法实现拖放复制操作解决办法_ubuntu无法拖拽文件-CSDN博客</a></p><h1 id="ubuntu-开启-125-、150-、175-缩放比例"><a href="#ubuntu-开启-125-、150-、175-缩放比例" class="headerlink" title="ubuntu 开启 125%、150%、175% 缩放比例"></a>ubuntu 开启 125%、150%、175% 缩放比例</h1><p>点击导航栏最右边的自由缩放，打开全屏后退出全屏<br>可参考 <a href="https://zhuanlan.zhihu.com/p/588666878">Ubuntu自由调整显示比例 - 知乎 (zhihu.com)</a> 对虚拟机不一定有用</p><h1 id="虚拟机不能上网，ifconfig-后只有-lo，没有-ens33-等信息"><a href="#虚拟机不能上网，ifconfig-后只有-lo，没有-ens33-等信息" class="headerlink" title="虚拟机不能上网，ifconfig 后只有 lo，没有 ens33 等信息"></a>虚拟机不能上网，ifconfig 后只有 lo，没有 ens33 等信息</h1><h2 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h2><p><img src="/../../../img/blog/27a9772ac09683210d7a53269a5cb50a_MD5.png" alt="在这里插入图片描述"><br>ifconfig 后只有一个 lo，好像其他网卡驱动都没有启动一样。</p><h2 id="尝试解决"><a href="#尝试解决" class="headerlink" title="尝试解决"></a>尝试解决</h2><p>输入 ifconfig -a</p><p><img src="/../../../img/blog/95a40c634df65f08a92e738ff9b9a2cc_MD5.png" alt="在这里插入图片描述"></p><p>发现了需要的网卡驱动，但是却没有 ip 地址啥的。</p><p>尝试一下几条条指令：</p><p>ifconfig ens33 up</p><p>sudo dhclient ens33</p><p>sudo ifconfig ens33（这条指令测试好了之后我的 OK 了）</p><p>sudo systemctl restart network-manager.service &#x2F;&#x2F;重启网卡</p><p>如果问题解决了，会是这种：<br><img src="/../../../img/blog/2b10fed180895ab2931e726a8e6f4134_MD5.png" alt="在这里插入图片描述"></p><p>随后再输入 ifconfig 指令<br><img src="/../../../img/blog/e80fddd0477a103b11f731eb3505d6d8_MD5.png" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> 系统 </category>
          
          <category> 虚拟机 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>butterfly主题配置</title>
      <link href="/posts/%E7%BD%91%E7%BB%9C/%E5%8D%9A%E5%AE%A2%E9%85%8D%E7%BD%AE/butterfly%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE.html"/>
      <url>/posts/%E7%BD%91%E7%BB%9C/%E5%8D%9A%E5%AE%A2%E9%85%8D%E7%BD%AE/butterfly%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE.html</url>
      
        <content type="html"><![CDATA[<p><a href="https://butterfly.js.org/posts/21cfbf15/">文档地址</a><br><a href="https://fontawesome.com/icons?d=gallery">Find Icons with the Perfect Look &amp; Feel | Font Awesome</a><br>将 <code>butterfly/_config.yml</code> 文件复制，重命名为 <code>_config.butterfly.yml</code> 放在 hexo 根目录下，在这个文件里做修改<br>命令：hexo clean &amp;&amp; hexo g &amp;&amp; hexo d 上传主题，验证是否修改成功。</p><h1 id="主题素材"><a href="#主题素材" class="headerlink" title="主题素材"></a>主题素材</h1><h2 id="本地图片"><a href="#本地图片" class="headerlink" title="本地图片"></a>本地图片</h2><p>在根目录的 source 文件夹下创建 img 文件夹，包含 web 和 blog 两个文件夹，网站图片使用 <code>/img/web/xx.jpg</code>,博客图片使用 <code>![](img/blog/xx.jpg)</code>,并把 butterfly 主题文件夹下的 img 文件夹剪切到 <code>/img/web</code> 文件夹下</p><h2 id="FontAwesome-图标本地加载"><a href="#FontAwesome-图标本地加载" class="headerlink" title="FontAwesome 图标本地加载"></a>FontAwesome 图标本地加载</h2><p>由于 all.min.css 下载 woff 文件较慢所以改为本地加载<br>首先注释掉 themes\butterfly\plugins.yml 中的以下代码</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#fontawesomeV6:</span></span><br><span class="line"><span class="comment">#   name: &#x27;@fortawesome/fontawesome-free&#x27;</span></span><br><span class="line"><span class="comment">#   file: css/all.min.css</span></span><br><span class="line"><span class="comment">#   other_name: font-awesome</span></span><br><span class="line"><span class="comment">#   version: 6.3.0</span></span><br></pre></td></tr></table></figure><p>再从 <a href="https://github.com/FortAwesome/Font-Awesome/tree/6.x">这个网站</a> 下载 css&#x2F;all.min.css 和 webfonts 文件夹<br>下载好后将 all.min.css 拷贝到 themes\butterfly\source\css 目录中,将 webfonts 文件夹拷贝到 themes\butterfly\source 目录中<br>最后引入 css</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">inject:</span></span><br><span class="line">  <span class="attr">head:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&lt;link</span> <span class="string">rel=&quot;stylesheet&quot;</span> <span class="string">href=&quot;/css/all.min.css&quot;&gt;</span></span><br><span class="line">  <span class="attr">bottom:</span></span><br><span class="line">    <span class="comment"># - &lt;script src=&quot;xxxx&quot;&gt;&lt;/script&gt;</span></span><br></pre></td></tr></table></figure><p>使用阿里图标与此类似 <a href="https://www.cnblogs.com/MoYu-zc/p/14399186.html">Hexo-使用阿里iconfont图标 - MoYu-zc - 博客园 (cnblogs.com)</a></p><h2 id="解决-cdn-jsdelivr-net-国内无法加载"><a href="#解决-cdn-jsdelivr-net-国内无法加载" class="headerlink" title="解决 cdn.jsdelivr.net 国内无法加载"></a>解决 cdn.jsdelivr.net 国内无法加载</h2><p>使用 <code>cdn.jsdelivr.net</code> 未受污染的子域：</p><ul><li><code>fastly.jsdelivr.net</code>，由 Fastly 提供 本站使用</li><li><code>gcore.jsdelivr.net</code>，由 G-Core 提供</li><li><code>testingcf.jsdelivr.net</code>，由 CloudFlare 提供<br>将博客主题的文件中 jsDelivr 链接里的 <code>cdn</code> 替换为子域名即可</li></ul><blockquote><p>比如 butterfly 主题中将 <code>themes\butterfly\layout\includes\head\preconnect.pug</code> 和 <code>themes\butterfly\scripts\events\cdn.js</code> 中的 <code>cdn.jsdelivr.net</code> 替换为 <code>fastly.jsdelivr.net</code></p></blockquote><h2 id="查看网页加载的大小和时间"><a href="#查看网页加载的大小和时间" class="headerlink" title="查看网页加载的大小和时间"></a>查看网页加载的大小和时间</h2><ol><li><p>右键点击网页，选择 “ 检查 “，(直接按 ctrl+shift+I 也可以）。</p></li><li><p>出来的界面上，点击 “Network”，按 Ctrl+R，就可以看到每个资源的大小和加载时间</p></li><li><p>进一步分析：点击特定请求，可以查看更详细的信息，如请求头、响应头、传输大小等。通过分析这些信息，你可以确定加载时间较长的资源，并找出导致问题的原因。</p></li></ol><h2 id="外挂-Css"><a href="#外挂-Css" class="headerlink" title="外挂 Css"></a>外挂 Css</h2><p>在 themes\butterfly\source\css 目录中添加 my.css,添加需要的 css</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 滚动条 */</span></span><br><span class="line">::-webkit-scrollbar &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">14px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">14px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">::-webkit-scrollbar-track &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="built_in">rgba</span>(<span class="number">73</span>, <span class="number">177</span>, <span class="number">245</span>, <span class="number">0.2</span>);</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">2em</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">::-webkit-scrollbar-thumb &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#49b1f5</span>;</span><br><span class="line">    <span class="attribute">background-image</span>: <span class="built_in">-webkit-linear-gradient</span>(<span class="number">45deg</span>,</span><br><span class="line">            <span class="built_in">rgba</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>, <span class="number">0.4</span>) <span class="number">25%</span>,</span><br><span class="line">            transparent <span class="number">25%</span>,</span><br><span class="line">            transparent <span class="number">50%</span>,</span><br><span class="line">            <span class="built_in">rgba</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>, <span class="number">0.4</span>) <span class="number">50%</span>,</span><br><span class="line">            <span class="built_in">rgba</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>, <span class="number">0.4</span>) <span class="number">75%</span>,</span><br><span class="line">            transparent <span class="number">75%</span>,</span><br><span class="line">            transparent);</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">2em</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">::-webkit-scrollbar-corner &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: transparent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">::-moz-selection &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#fff</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#49b1f5</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* a标签默认颜色 */</span></span><br><span class="line"><span class="selector-id">#article-container</span> <span class="selector-tag">a</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#00c4b6</span>;</span><br><span class="line">    <span class="attribute">text-decoration</span>: none;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 鼠标悬停时的颜色 */</span></span><br><span class="line"><span class="comment">/* #article-container a:hover &#123;</span></span><br><span class="line"><span class="comment">    color: #e58a8a;</span></span><br><span class="line"><span class="comment">&#125; */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*a标签颜色*/</span></span><br><span class="line"><span class="selector-tag">a</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#00c4b6</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后引入 css</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">inject:</span></span><br><span class="line">  <span class="attr">head:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&lt;link</span> <span class="string">rel=&quot;stylesheet&quot;</span> <span class="string">href=&quot;/css/my.css&quot;&gt;</span></span><br><span class="line">  <span class="attr">bottom:</span></span><br><span class="line">    <span class="comment"># - &lt;script src=&quot;xxxx&quot;&gt;&lt;/script&gt;</span></span><br></pre></td></tr></table></figure><h2 id="分割线图标更换"><a href="#分割线图标更换" class="headerlink" title="分割线图标更换"></a>分割线图标更换</h2><p>本次修改基于 Butterfly 主题 3.0.0 ！<br>将图标更换为 “ 太空飞船 “。<br>修改 butterfly 主题配置文件 <code>_data</code>–<code>_config.yml</code> ：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">hr_icon:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">icon:</span> <span class="string">&#x27;\f197&#x27;</span> <span class="comment"># the unicode value of Font Awesome icon</span></span><br><span class="line">  <span class="attr">icon-top:</span> <span class="string">-10px</span></span><br></pre></td></tr></table></figure><p><code>icon-top</code> 常用数值：</p><p>-20px：图标位于分割线上方<br>-10px：图标位于分割线中间<br>0px：图标位于分割线下方</p><h1 id="本地搜索"><a href="#本地搜索" class="headerlink" title="本地搜索"></a>本地搜索</h1><p>安装 hexo-generator-searchdb 搜索插件</p><p>修改配置文件：</p><p>找到 local_search 将 enable 修改为 true</p><h2 id="加速方案"><a href="#加速方案" class="headerlink" title="加速方案"></a>加速方案</h2><h3 id="减少索引内容"><a href="#减少索引内容" class="headerlink" title="减少索引内容"></a>减少索引内容</h3><ul><li>可以设置搜索内容，若仅搜索标题 （搜索内容 content 设置为 false） 则会加载快到飞起<br><img src="/../../../../img/blog/butterfly%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE-2.png"></li></ul><h3 id="外链加速"><a href="#外链加速" class="headerlink" title="外链加速"></a>外链加速</h3><p>打开主题下的 local-search.js 文件 (不同主题的位置会不同, 但是一般都在 source&#x2F;js 这种文件夹里) , 找到如下字段</p><p><code>url: GLOBAL_CONFIG.root + path</code> 改成 <code>url: 外链</code><br>外链推荐使用 Jsdelivr 的 cdn (引用 Github 的资源, 不需要手动更新, 速度也挺快)</p><h1 id="评论"><a href="#评论" class="headerlink" title="评论"></a>评论</h1><h2 id="使用-Valine-添加评论功能"><a href="#使用-Valine-添加评论功能" class="headerlink" title="使用 Valine 添加评论功能"></a>使用 Valine 添加评论功能</h2><ol><li><p>注册账号并进入：<a href="https://leancloud.cn/dashboard/login.html#/signin">LeanCloud</a></p></li><li><p>创建开发版应用：</p></li><li><p>创建后点击设置进入应用：</p></li><li><p>复制 AppID、AppKey</p></li><li><p>修改主题配置文件<br>找到 valine，分别将复制的 id 和 key 填入,开启评论需要在 comments-use 中填写你需要的评论。</p></li></ol><h2 id="Giscus-评论系统设置"><a href="#Giscus-评论系统设置" class="headerlink" title="Giscus 评论系统设置"></a>Giscus 评论系统设置</h2><h3 id="安装-Giscus"><a href="#安装-Giscus" class="headerlink" title="安装 Giscus"></a>安装 Giscus</h3><p>点击这个链接安装：**<a href="https://github.com/apps/giscus">GitHub Apps - giscus</a>**</p><h3 id="配置仓库-Discuss-部分"><a href="#配置仓库-Discuss-部分" class="headerlink" title="配置仓库 Discuss 部分"></a>配置仓库 Discuss 部分</h3><p>首先打开仓库的 setting，将 Discussions 部分打上对号，然后建立一个 Announcements 的分类</p><h3 id="进入-Giscus-配置"><a href="#进入-Giscus-配置" class="headerlink" title="进入 Giscus 配置"></a>进入 Giscus 配置</h3><p>链接在这：**<a href="https://link.zhihu.com/?target=https://giscus.app/zh-CN">giscus</a>**</p><p>配置完仓库和 discussion 分类后，可以在启动 giscus 下边复制几个东西</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">repo:</span><br><span class="line">repo_id:</span><br><span class="line">category_id:</span><br></pre></td></tr></table></figure><p>还可根据自己的需要在 option 中添加对应的选项，按照 yaml 格式填入</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">data-strict:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">data-lang:</span> <span class="string">zh-CN</span></span><br><span class="line"><span class="attr">data-input-position:</span> <span class="string">top</span></span><br><span class="line"><span class="attr">data-loading:</span> <span class="string">lazy</span></span><br></pre></td></tr></table></figure><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>在 Hexo 中，评论功能默认在所有页面都开启，如果部分页面我们不需要评论功能，例如分类、标记页面。我们可以在在站点根目录下 <code>/source/页面名称/index.md</code> 中通过 <code>comments</code> 属性设置 <code>true</code> 或 <code>false</code> 控制该页面或者是文章的评论功能是否打开</p><h1 id="收录谷歌、百度"><a href="#收录谷歌、百度" class="headerlink" title="收录谷歌、百度"></a>收录谷歌、百度</h1><p>1、 查看收录情况：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">地址栏输入：site:xingjiahui.top</span><br></pre></td></tr></table></figure><p>2、验证、提交网站：<a href="https://www.ancii.com/avcwpl4d6/">JingLisen</a></p><h1 id="PWA"><a href="#PWA" class="headerlink" title="PWA"></a>PWA</h1><p><a href="https://www.xiaowu95.wang/posts/80027c66/">记录hexo整合pwa的使用 | 小五的个人杂货铺 (xiaowu95.wang)</a><br><a href="https://butterfly.js.org/posts/ceeb73f/#PWA">Butterfly 安裝文檔(四) 主題配置-2 | Butterfly</a></p><h1 id="SEO"><a href="#SEO" class="headerlink" title="SEO"></a>SEO</h1><p>百度主动提交链接</p><p>1、首先，在 Hexo 根目录下，安装本插件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-baidu-url-submit --save</span><br></pre></td></tr></table></figure><p>2、然后在根目录下，把以下内容配置到 _config.yml 文件中:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> </span><br><span class="line">    <span class="attr">gitee:</span> <span class="string">https://gitee.com/youthlql/youthlql.git</span></span><br><span class="line">    <span class="attr">github:</span> <span class="string">https://github.com/youthlql/youthlql.github.io.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> <span class="attr">type:</span> <span class="string">baidu_url_submitter</span></span><br><span class="line"><span class="comment"># 百度主动推送</span></span><br><span class="line"><span class="attr">baidu_url_submit:</span></span><br><span class="line">  <span class="attr">count:</span> <span class="number">100</span> <span class="comment">## 提交最新的一个链接</span></span><br><span class="line">  <span class="attr">host:</span>  <span class="comment">## 在百度站长平台中注册的域名</span></span><br><span class="line">  <span class="attr">token:</span>  <span class="comment">## 请注意这是您的秘钥， 所以请不要把博客源代码发布在公众仓库里!</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">baidu_urls.txt</span> <span class="comment">## 文本文档的地址， 新链接会保存在此文本文档里</span></span><br></pre></td></tr></table></figure><p>我把 deploy 配置也贴出来是因为有两个 type，注意用 - 区分</p><p>百度其它的 seo 到他的官网看文档就行</p><h1 id="查看网页-RSS"><a href="#查看网页-RSS" class="headerlink" title="查看网页 RSS"></a>查看网页 RSS</h1><p>本次修改基于 Butterfly 主题 3.0.0 ！</p><p>实现：增加社交图标 RSS，点击可查看网页 RSS。</p><p>1.下载插件 hexo-generator-feed</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-feed --save</span><br></pre></td></tr></table></figure><p>2.在 hexo 的主配置文件 _config.yml 中任意位置添加以下代码：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">feed:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">atom</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">atom.xml</span></span><br><span class="line">  <span class="attr">limit:</span> <span class="number">20</span></span><br><span class="line">  <span class="attr">hub:</span></span><br><span class="line">  <span class="attr">content:</span></span><br><span class="line">  <span class="attr">content_limit:</span> <span class="number">140</span></span><br><span class="line">  <span class="attr">content_limit_delim:</span> <span class="string">&#x27; &#x27;</span></span><br><span class="line">  <span class="attr">order_by:</span> <span class="string">-date</span></span><br><span class="line">  <span class="attr">icon:</span> <span class="string">icon.png</span></span><br><span class="line">  <span class="attr">autodiscovery:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">template:</span></span><br></pre></td></tr></table></figure><p>3.修改 butterfly 主题配置文件 _config.yml ，添加 RSS 的图标：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">social:</span></span><br><span class="line">  <span class="attr">fa fa-rss:</span> <span class="string">/atom.xml</span> <span class="string">||</span> <span class="string">RSS链接</span></span><br></pre></td></tr></table></figure><h1 id="社交信息设置"><a href="#社交信息设置" class="headerlink" title="社交信息设置"></a>社交信息设置</h1><p>在 <code>\source\_data</code> 中的 <code>butterfly.yml</code> 修改 <code>social</code>：</p><p>(可以选择使用 <code>fa fa-xxx</code> 图标，也可以选择使用 <code>阿里iconfont</code> 图标)</p><p>此处要注意：</p><p>​ 很多人不知道自己上方填的网址怎么找</p><p>​ <code>RSS</code> 上面有教程，<code>Giuhub</code>、<code>Github</code>、<code>CSDN</code>、<code>bilibili</code> 直接 <code>个人主页</code> 网址就可以</p><p>​ <code>QQ</code>：下方 xxxxxxx 填上对应的 <code>qq号码</code> 即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tencent://AddContact/?fromId=45&amp;fromSubId=1&amp;subcmd=all&amp;uin=xxxxxxx&amp;website=www.oicqzone.com</span><br></pre></td></tr></table></figure><h1 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h1><p>有时浏览器会缓存旧的链接或搜索结果，无法加载更新后的结果，可使用使用 Ctrl + F5 强制刷新页面，或清除缓存并刷新页面，如缓存图片和文件。</p>]]></content>
      
      
      <categories>
          
          <category> 网络 </category>
          
          <category> 博客配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++课程设计</title>
      <link href="/posts/%E5%AD%A6%E6%A0%A1%E8%AF%BE%E7%A8%8B/C++%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1.html"/>
      <url>/posts/%E5%AD%A6%E6%A0%A1%E8%AF%BE%E7%A8%8B/C++%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1.html</url>
      
        <content type="html"><![CDATA[<h1 id="程序设计课程设计报告—学生信息管理系统"><a href="#程序设计课程设计报告—学生信息管理系统" class="headerlink" title="程序设计课程设计报告—学生信息管理系统"></a>程序设计课程设计报告—学生信息管理系统</h1><h1 id="目-录"><a href="#目-录" class="headerlink" title="目 录"></a>目 录</h1><ol><li><p>需求分析</p></li><li><p>架构设计</p></li><li><p>模块设计</p></li><li><p>类和函数的说明</p></li><li><p>比较有特色的算法</p></li><li><p>存在的不足及对策</p></li><li><p>使用说明</p></li><li><p>程序源代码</p></li></ol><h1 id="一、需求分析"><a href="#一、需求分析" class="headerlink" title="一、需求分析"></a>一、需求分析</h1><p>      学生信息管理系统，能够实现计算机化的学生信息管理，能够提供实现基本的学生信息管理功能，方便管理员进行学生信息管理。</p><p>      本项目面向学生管理员，管理员需使用账号密码登录，其拥有学生基本信息管理和学生成绩管理两大功能。</p><h2 id="二、架构设计"><a href="#二、架构设计" class="headerlink" title="二、架构设计"></a>二、架构设计</h2><h3 id="（一）管理员登录主系统"><a href="#（一）管理员登录主系统" class="headerlink" title="（一）管理员登录主系统"></a>（一）管理员登录主系统</h3><p>       管理员可以登陆账号以管理学生信息，每个账号中都保存着相应的数据，管理员可以操控管理这些数据，可以修改自己的密码，退出登录或退出程序时自动将内存中的数据清空。</p><p><img src="/../../img/blog/965da85c7dfebc6e8becc6a9d9b9873b_MD5.png" alt="image_48Mse1CdsA.png"></p><h3 id="（二）学生基本信息管理系统"><a href="#（二）学生基本信息管理系统" class="headerlink" title="（二）学生基本信息管理系统"></a>（二）学生基本信息管理系统</h3><p>①<strong>添加</strong>：管理员将信息依次录入。</p><p>②<strong>删除</strong>：按学号对一个学生的信息进行删除，还可以选择一键删除。</p><p>③<strong>修改</strong>：按学号修改相应的信息。</p><p>④<strong>查询</strong>：根据你键入的学生姓名或学号，显示其详细信息。</p><p>⑤<strong>浏览</strong>：管理员可以浏览当前所存储的全部学生信息。</p><p>⑥<strong>保存</strong>：管理员退出程序前或者退出登陆前，将数据自动储存到本地文件。</p><p><img src="/../../img/blog/1ceeca2ae4ce2a5e57ff8ab541d15538_MD5.png" alt="image_LH3SQ4mlAi.png"></p><h3 id="（三）学生成绩管理系统"><a href="#（三）学生成绩管理系统" class="headerlink" title="（三）学生成绩管理系统"></a>（三）学生成绩管理系统</h3><p>①<strong>添加</strong>：管理员将信息依次录入。</p><p>②<strong>删除</strong>：按学号对一个学生的信息进行删除，还可以选择一键删除。</p><p>③<strong>修改</strong>：按学号选择修改相应的信息。</p><p>④<strong>查询</strong>：根据你键入的学生姓名或学号，显示其详细信息。</p><p>⑤<strong>浏览</strong>：</p><p>A) <strong>浏览总平均成绩</strong>：管理员可以看到以总平均成绩从高到低的学生所有成绩信息。</p><p>B) <strong>浏览单科成绩</strong>：管理员可以选择具体的单科，并且可以看到以该单科成绩从高到低的学生单科成绩信息。</p><p>C) <strong>浏览成绩报告分析</strong>：管理员可以看到各科以及总平均成绩中 60 分以下和 90 分以上人数占比和信息，还有 60 分以上人数占比。</p><p>⑥<strong>保存</strong>：管理员退出程序前或者退出登陆前，将数据自动储存到本地文件。</p><p><img src="/../../img/blog/86124ef8a28606c2189cedeaf8b7647c_MD5.png" alt="image_PLsdkWmHyq.png"></p><h2 id="三、模块设计"><a href="#三、模块设计" class="headerlink" title="三、模块设计"></a>三、模块设计</h2><h3 id="1-添加模块"><a href="#1-添加模块" class="headerlink" title="1.添加模块"></a>1.添加模块</h3><p>学生基本信息管理系统：管理员按照学号、姓名、联系方式以及宿舍号的顺序依次录入，插入到 AVL 树中。</p><p>学生成绩管理系统：管理员按照学号、姓名、高数成绩、大学英语成绩以及 C++ 成绩的顺序依次录入，插入到多重链表中。</p><h3 id="2-删除模块"><a href="#2-删除模块" class="headerlink" title="2.删除模块"></a>2.删除模块</h3><p>管理员输入要删除学生的学号，然后调用删除函数，删除该名学生的信息，或者一键删除，清空 AVL 树或多重链表中的数据。</p><h3 id="3-修改模块"><a href="#3-修改模块" class="headerlink" title="3.修改模块"></a>3.修改模块</h3><p>管理员输入要修改学生的学号，然后管理员可以选择修改相应的信息。</p><h3 id="4-查询模块"><a href="#4-查询模块" class="headerlink" title="4.查询模块"></a>4.查询模块</h3><p>首先由管理员输入要查找的学生姓名或学号，然后系统用查找函数查找，然后系统就调用输出函数，输出所查找的学生信息。</p><h3 id="5-浏览模块"><a href="#5-浏览模块" class="headerlink" title="5.浏览模块"></a>5.浏览模块</h3><p>学生基本信息管理系统：显示当前所存储的全部学生基本信息。</p><p>学生成绩管理系统：管理员可以选择浏览以总成绩排名顺序分布的内容；可以浏览以单科成绩排名顺序分布的内容；亦可以浏览总体成绩报告分析。对于每一种需求，系统显示相应的数据。</p><h3 id="6-保存模块"><a href="#6-保存模块" class="headerlink" title="6.保存模块"></a>6.保存模块</h3><p>学生基本信息管理系统：将 AVL 树中的数据储存到 “ 用户名 “+”_ IF.txt” 中。</p><p>学生成绩管理系统：将多重链表中的数据储存到 “ 用户名 “+”_GD.txt” 中。</p><h3 id="7-管理员模块"><a href="#7-管理员模块" class="headerlink" title="7.管理员模块"></a>7.管理员模块</h3><p>管理员键入帐号密码，系统会从本地文件检索账号密码，如果管理员选择创建账号，那么系统会将账号密码保存至本地文件中，以便下次登陆时检索，并且系统会以管理员账号名创建额外两个文件，分别用以存储学生基本信息和学生成绩信息。</p><p>登陆成功后，系统从本地文件中获取数据，管理员可以对这些数据进行操作，在管理员退出时，系统将数据存入相应的文件之中，并且遍历 AVL 树和链表，清空数据。</p><p>管理员修改密码时，系统查阅本地文件，并修改数据。</p><h2 id="四、类和函数的说明"><a href="#四、类和函数的说明" class="headerlink" title="四、类和函数的说明"></a>四、类和函数的说明</h2><h3 id="1-menu1-的声明"><a href="#1-menu1-的声明" class="headerlink" title="1.menu1 的声明"></a>1.menu1 的声明</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">menu1</span> &#123;</span></span><br><span class="line">private:</span><br><span class="line">  <span class="built_in">string</span> sn;  <span class="comment">//学号 student number</span></span><br><span class="line">  <span class="built_in">string</span> name;  <span class="comment">//姓名</span></span><br><span class="line">  <span class="built_in">string</span> chat; <span class="comment">//联系方式</span></span><br><span class="line">  <span class="built_in">string</span> dor; <span class="comment">//宿舍号</span></span><br><span class="line">  <span class="type">int</span> height;     <span class="comment">//平衡树的高度</span></span><br><span class="line">  menu1* left;</span><br><span class="line">  menu1* right;</span><br><span class="line">public:</span><br><span class="line">  menu1(<span class="built_in">string</span> a, <span class="built_in">string</span> b, <span class="built_in">string</span> c, <span class="built_in">string</span> d, <span class="type">int</span> h=<span class="number">0</span>, menu1* L=nullptr,menu1* r=nullptr):</span><br><span class="line">    sn(a),name(b),chat(c),dor(d),height(h),left(L),right(r) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> <span class="title function_">high</span><span class="params">( menu1* p)</span>;<span class="comment">//返回高度</span></span><br><span class="line"></span><br><span class="line">  menu1* <span class="title function_">singleft</span><span class="params">( menu1* k2)</span>;<span class="comment">//左单旋</span></span><br><span class="line"></span><br><span class="line">  menu1* <span class="title function_">singright</span><span class="params">( menu1* k2)</span>;<span class="comment">//右单旋</span></span><br><span class="line"></span><br><span class="line">  menu1* <span class="title function_">doubleleft</span><span class="params">( menu1* k3)</span>;<span class="comment">//LR</span></span><br><span class="line"></span><br><span class="line">  menu1* <span class="title function_">doubleright</span><span class="params">( menu1* k3)</span>;<span class="comment">//RL</span></span><br><span class="line"></span><br><span class="line">  <span class="type">void</span> <span class="title function_">Record_1</span><span class="params">( menu1 *&amp; ph, <span class="built_in">string</span>&amp; a, <span class="built_in">string</span>&amp; b, <span class="built_in">string</span>&amp; c, <span class="built_in">string</span>&amp; d)</span>;<span class="comment">//记录系统一的用户数据，存储到文件中</span></span><br><span class="line"></span><br><span class="line">  <span class="type">void</span> <span class="title function_">Seeit_1</span><span class="params">( menu1 *&amp; head)</span>;<span class="comment">//查看所有数据函数</span></span><br><span class="line"></span><br><span class="line">  menu1* <span class="title function_">Read1</span><span class="params">( menu1 *&amp; head)</span>;   <span class="comment">//从文件中读取数据</span></span><br><span class="line"></span><br><span class="line">  menu1* <span class="title function_">Delete_1</span><span class="params">( menu1* p, <span class="built_in">string</span>&amp; x)</span>;<span class="comment">//删除实现</span></span><br><span class="line"></span><br><span class="line">  menu1* <span class="title function_">Find_1</span><span class="params">( menu1 *&amp; head, <span class="type">int</span> sp)</span>;<span class="comment">//查询函数</span></span><br><span class="line"></span><br><span class="line">  <span class="type">void</span> <span class="title function_">Change_1</span><span class="params">( menu1 *&amp; head)</span>;<span class="comment">//修改数据</span></span><br><span class="line"></span><br><span class="line">  <span class="type">void</span> <span class="title function_">EnterDelete_1</span><span class="params">( menu1 *&amp; head)</span>;<span class="comment">//进入删除，一个接口</span></span><br><span class="line"></span><br><span class="line">  <span class="type">void</span> <span class="title function_">FreeAll_1</span><span class="params">(<span class="type">void</span>)</span>;<span class="comment">//释放内存函数</span></span><br><span class="line"></span><br><span class="line">  <span class="type">void</span> <span class="title function_">Store1</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="2-menu2-的声明"><a href="#2-menu2-的声明" class="headerlink" title="2.menu2 的声明"></a>2.menu2 的声明</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">menu2</span>&#123;</span>  </span><br><span class="line">private:</span><br><span class="line">    <span class="built_in">string</span> sn2;    <span class="comment">//学号</span></span><br><span class="line">    <span class="built_in">string</span> name2;    <span class="comment">//姓名</span></span><br><span class="line">    <span class="type">static</span> <span class="built_in">string</span> g[<span class="number">4</span>];</span><br><span class="line">    <span class="type">float</span> grade[<span class="number">4</span>];       <span class="comment">//总成绩的平均数,高数,英语,C++</span></span><br><span class="line">    menu2* Next; <span class="comment">//链表下一节点</span></span><br><span class="line">    menu2* Previous; <span class="comment">//上一节点</span></span><br><span class="line">public:</span><br><span class="line">    <span class="type">void</span> <span class="title function_">FreeAll_2</span><span class="params">(<span class="type">void</span>)</span>;    <span class="comment">//释放内存，退出时用到</span></span><br><span class="line"></span><br><span class="line">    menu2* <span class="title function_">Record_2</span><span class="params">(menu2*&amp; head, <span class="built_in">string</span>&amp; a, <span class="built_in">string</span>&amp; b, <span class="type">float</span> G[<span class="number">4</span>], <span class="type">int</span> change)</span>;<span class="comment">//写入文件</span></span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> <span class="title function_">Record_2_isnert</span><span class="params">(menu2 *&amp; head, menu2* p, menu2* pr, menu2* ph, <span class="type">float</span> x, <span class="type">float</span> gr, <span class="built_in">string</span>&amp; a)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> <span class="title function_">Seeit_2</span><span class="params">(menu2*&amp; head)</span>; <span class="comment">//查看信息</span></span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> <span class="title function_">SeeThesingle_2</span><span class="params">(menu2*&amp; head, <span class="type">int</span> choice)</span>;   <span class="comment">//查看单科成绩</span></span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> <span class="title function_">SeeThesingle_2_print</span><span class="params">(menu2 *&amp; head, <span class="built_in">string</span> g, <span class="type">int</span> index)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> <span class="title function_">Delete_2</span><span class="params">(menu2 *&amp; head, <span class="built_in">string</span>&amp; s)</span>;   <span class="comment">//删除</span></span><br><span class="line"></span><br><span class="line">    menu2* <span class="title function_">Find_2</span><span class="params">(menu2*&amp; head, <span class="type">int</span> change, <span class="built_in">string</span>&amp; c)</span>;  <span class="comment">//查找</span></span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> <span class="title function_">EnterSee2</span><span class="params">(menu2* headx[<span class="number">4</span>])</span>; <span class="comment">//查看接口函数</span></span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> <span class="title function_">Change_2</span><span class="params">(menu2 *&amp; head, <span class="type">int</span> choice, <span class="built_in">string</span>&amp; sn, <span class="built_in">string</span>&amp; s, <span class="type">float</span> grade)</span>;<span class="comment">//修改数据函数</span></span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> <span class="title function_">CordReport_2</span><span class="params">(menu2* headx[<span class="number">4</span>])</span>;  <span class="comment">//成绩分析报告</span></span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> <span class="title function_">CordReport_2_print</span><span class="params">(menu2* p, <span class="built_in">string</span>&amp; g, <span class="type">int</span> index)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> <span class="title function_">Store2</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="3-Users-的声明"><a href="#3-Users-的声明" class="headerlink" title="3.Users 的声明"></a>3.Users 的声明</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Users</span>&#123;</span>   </span><br><span class="line">private:</span><br><span class="line">     <span class="built_in">string</span> accounts, password;</span><br><span class="line">     Users* next;</span><br><span class="line">public:</span><br><span class="line">    <span class="type">int</span> <span class="title function_">Enter</span><span class="params">(Users* user)</span>;<span class="comment">//登陆函数</span></span><br><span class="line"></span><br><span class="line">    Users* <span class="title function_">Readuser</span><span class="params">(Users* user)</span>;<span class="comment">//读取账户信息函数</span></span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> <span class="title function_">ChangePass</span><span class="params">(Users* user)</span>;<span class="comment">//修改密码函数</span></span><br><span class="line"></span><br><span class="line">    Users* <span class="title function_">Register</span><span class="params">(Users* user)</span>;<span class="comment">//注册函数</span></span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> <span class="title function_">StoreUser</span><span class="params">(Users* user)</span>;<span class="comment">//存储用户账户函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="4-输入函数声明"><a href="#4-输入函数声明" class="headerlink" title="4.输入函数声明"></a>4.输入函数声明</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> <span class="title function_">inputlnt</span><span class="params">(<span class="type">void</span>)</span>; <span class="comment">//这个函数是我们输入数字的函数</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">inputString</span><span class="params">(<span class="built_in">string</span>&amp; buffer)</span>; <span class="comment">//这个函数就是输入字符串，同样我们可以检测是否溢出</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> <span class="title function_">enterspring</span><span class="params">(<span class="type">int</span> c)</span>; <span class="comment">//接口，c是选择，可以实现输入密码的时候以****形式输入</span></span><br></pre></td></tr></table></figure><h3 id="5-显示函数声明"><a href="#5-显示函数声明" class="headerlink" title="5.显示函数声明"></a>5.显示函数声明</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ShowMap0</span><span class="params">(<span class="type">void</span>)</span>; <span class="comment">//登录注册菜单</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ShowMap1</span><span class="params">(<span class="type">void</span>)</span>; <span class="comment">//主系统菜单</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ShowMap2</span><span class="params">(<span class="type">void</span>)</span>; <span class="comment">//系统一菜单</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ShowMap3</span><span class="params">(<span class="type">void</span>)</span>; <span class="comment">//系统二菜单</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ShowSeeit_1</span><span class="params">(<span class="type">void</span>)</span>; <span class="comment">//菜单一信息</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">heart</span><span class="params">()</span>; <span class="comment">//登录爱心显示</span></span><br></pre></td></tr></table></figure><h2 id="五、比较有特色的算法"><a href="#五、比较有特色的算法" class="headerlink" title="五、比较有特色的算法"></a>五、比较有特色的算法</h2><h3 id="1-管理员登录主系统"><a href="#1-管理员登录主系统" class="headerlink" title="1.管理员登录主系统"></a>1.管理员登录主系统</h3><p><img src="/../../img/blog/6b8f96f22126e56233278cda474c2cb3_MD5.png" alt="image_2-oqxglqv3.png"></p><p>采用心形算法，输出心形，优化界面。</p><p>登录使用检索本地文件以核对账户密码完成登录，对于数据文件采用用户名加后缀的形式作为对应文件名。</p><h3 id="2-学生基本信息管理系统"><a href="#2-学生基本信息管理系统" class="headerlink" title="2.学生基本信息管理系统"></a>2.学生基本信息管理系统</h3><p>鉴于对学号的顺序排序，选择采用一颗 AVL 树以保存数据，能够相对的提高程序的性能。</p><p>使用 AVL 树的几个基本旋转以实现插入。</p><p>对于每一个删除操作，均需调整 AVL 树的平衡，由于删除操作开销较大，我们可以选取左右子树较高的树中的最右或最左树以替代要删除的数据，这样可以明显减少时间平均复杂度。</p><h3 id="3-学生成绩管理系统"><a href="#3-学生成绩管理系统" class="headerlink" title="3.学生成绩管理系统"></a>3.学生成绩管理系统</h3><p>鉴于需要对总成绩以及各科成绩查询，寻常的排序需要花费大量的时间，十分不值，并且代码极其冗长，因此我们采用多重链表对数据进行操作，使用多个表头对应每一种成绩。这样做的缺点是查找和插入效率可能不如 AVL 树，但对于多根节点 AVL 树而言，删除一个数据所需要付出的代价是昂贵的，所以我们选择链表实现。</p><h2 id="六、存在的不足及对策"><a href="#六、存在的不足及对策" class="headerlink" title="六、存在的不足及对策"></a>六、存在的不足及对策</h2><p>1.不足：不知道如何进行开发程序</p><p>对策：先建造一个原型，列出想要实现的功能，逐步细化调整，再将功能一个一个实现，最终整合在一起</p><p>2.不足：想要实现好的效果，却不知从何下手</p><p>对策：有些问题已被前人解决过，可以通过借鉴实现，有的问题需要学习其他知识或工具，如数据可以储存在数据库中，UI 界面的优化等，则当前阶段只需要做到自己能做到的最好就行。</p><h2 id="七、使用说明"><a href="#七、使用说明" class="headerlink" title="七、使用说明"></a>七、使用说明</h2><p>程序编译运行平台：Windows 和 Vs2022</p><p>打开文件夹 “x64”→打开文件夹 “Debug”→打开 exe 文件运行</p><p>原本无账户，则需先注册</p><p>输入字符串长度不得超过 18</p><p><img src="/../../img/blog/e2b262fccb741b7dddded98736f6f74d_MD5.png" alt="QQ截图20220520194350_tmm2d3QPTu.png"></p><h2 id="八、程序源代码"><a href="#八、程序源代码" class="headerlink" title="八、程序源代码"></a>八、程序源代码</h2><h3 id="1-Core1-h"><a href="#1-Core1-h" class="headerlink" title="1.Core1.h"></a>1.Core1.h</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> CORE1_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CORE1_H</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">menu1</span> &#123;</span></span><br><span class="line">private:</span><br><span class="line">  <span class="built_in">string</span> sn;  <span class="comment">//学号 student number</span></span><br><span class="line">  <span class="built_in">string</span> name;  <span class="comment">//姓名</span></span><br><span class="line">  <span class="built_in">string</span> chat; <span class="comment">//联系方式</span></span><br><span class="line">  <span class="built_in">string</span> dor; <span class="comment">//宿舍号</span></span><br><span class="line">  <span class="type">int</span> height;     <span class="comment">//平衡树的高度</span></span><br><span class="line">  menu1* left;</span><br><span class="line">  menu1* right;</span><br><span class="line">public:</span><br><span class="line">  menu1(<span class="built_in">string</span> a, <span class="built_in">string</span> b, <span class="built_in">string</span> c, <span class="built_in">string</span> d, <span class="type">int</span> h=<span class="number">0</span>, menu1* L=nullptr,menu1* r=nullptr):</span><br><span class="line">    sn(a),name(b),chat(c),dor(d),height(h),left(L),right(r) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> <span class="title function_">high</span><span class="params">( menu1* p)</span>;<span class="comment">//返回高度</span></span><br><span class="line"></span><br><span class="line">  menu1* <span class="title function_">singleft</span><span class="params">( menu1* k2)</span>;<span class="comment">//左单旋</span></span><br><span class="line"></span><br><span class="line">  menu1* <span class="title function_">singright</span><span class="params">( menu1* k2)</span>;<span class="comment">//右单旋</span></span><br><span class="line"></span><br><span class="line">  menu1* <span class="title function_">doubleleft</span><span class="params">( menu1* k3)</span>;<span class="comment">//LR</span></span><br><span class="line"></span><br><span class="line">  menu1* <span class="title function_">doubleright</span><span class="params">( menu1* k3)</span>;<span class="comment">//RL</span></span><br><span class="line"></span><br><span class="line">  <span class="type">void</span> <span class="title function_">Record_1</span><span class="params">( menu1*&amp; ph, <span class="built_in">string</span>&amp; a, <span class="built_in">string</span>&amp; b, <span class="built_in">string</span>&amp; c, <span class="built_in">string</span>&amp; d)</span>;<span class="comment">//记录系统一的用户数据，存储到文件中</span></span><br><span class="line"></span><br><span class="line">  <span class="type">void</span> <span class="title function_">Seeit_1</span><span class="params">( menu1*&amp; head)</span>;<span class="comment">//查看所有数据函数</span></span><br><span class="line"></span><br><span class="line">  menu1* <span class="title function_">Read1</span><span class="params">( menu1*&amp; head)</span>;   <span class="comment">//从文件中读取数据</span></span><br><span class="line"></span><br><span class="line">  menu1* <span class="title function_">Delete_1</span><span class="params">( menu1* p, <span class="built_in">string</span>&amp; x)</span>;<span class="comment">//删除实现</span></span><br><span class="line"></span><br><span class="line">  menu1* <span class="title function_">Find_1</span><span class="params">( menu1*&amp; head, <span class="type">int</span> sp)</span>;<span class="comment">//查询函数</span></span><br><span class="line"></span><br><span class="line">  <span class="type">void</span> <span class="title function_">Change_1</span><span class="params">( menu1 *&amp; head)</span>;<span class="comment">//修改数据</span></span><br><span class="line"></span><br><span class="line">  <span class="type">void</span> <span class="title function_">EnterDelete_1</span><span class="params">( menu1 *&amp; head)</span>;<span class="comment">//进入删除，一个接口</span></span><br><span class="line"></span><br><span class="line">  <span class="type">void</span> <span class="title function_">FreeAll_1</span><span class="params">(<span class="type">void</span>)</span>;<span class="comment">//释放内存函数</span></span><br><span class="line"></span><br><span class="line">  <span class="type">void</span> <span class="title function_">Store1</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><h3 id="2-Core2-h"><a href="#2-Core2-h" class="headerlink" title="2.Core2.h"></a>2.Core2.h</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> CORE2_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CORE2_H</span></span><br><span class="line"><span class="comment">/*这个头文件里存储着与系统二相关的核心操作*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">menu2</span>&#123;</span>  </span><br><span class="line">private:</span><br><span class="line">    <span class="built_in">string</span> sn2;    <span class="comment">//学号</span></span><br><span class="line">    <span class="built_in">string</span> name2;    <span class="comment">//姓名</span></span><br><span class="line">    <span class="type">static</span> <span class="built_in">string</span> g[<span class="number">4</span>];</span><br><span class="line">    <span class="type">float</span> grade[<span class="number">4</span>];       <span class="comment">//总成绩的平均数,高数,英语,C++</span></span><br><span class="line">    menu2* Next; <span class="comment">//链表下一节点</span></span><br><span class="line">    menu2* Previous; <span class="comment">//上一节点</span></span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> <span class="title function_">FreeAll_2</span><span class="params">(<span class="type">void</span>)</span>;    <span class="comment">//释放内存，退出时用到</span></span><br><span class="line"></span><br><span class="line">    menu2* <span class="title function_">Record_2</span><span class="params">(menu2*&amp; head, <span class="built_in">string</span>&amp; a, <span class="built_in">string</span>&amp; b, <span class="type">float</span> G[<span class="number">4</span>], <span class="type">int</span> change)</span>;<span class="comment">//写入文件</span></span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> <span class="title function_">Record_2_isnert</span><span class="params">(menu2 *&amp; head, menu2* p, menu2* pr, menu2* ph, <span class="type">float</span> x, <span class="type">int</span> ch, <span class="built_in">string</span>&amp; a)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> <span class="title function_">Seeit_2</span><span class="params">(menu2 *&amp; head)</span>; <span class="comment">//查看信息</span></span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> <span class="title function_">SeeThesingle_2</span><span class="params">(menu2 *&amp; head, <span class="type">int</span> choice)</span>;   <span class="comment">//查看单科成绩</span></span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> <span class="title function_">SeeThesingle_2_print</span><span class="params">(menu2*&amp; head, <span class="built_in">string</span> g, <span class="type">int</span> index)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> <span class="title function_">Delete_2</span><span class="params">(menu2*&amp; head, <span class="built_in">string</span>&amp; s)</span>;   <span class="comment">//删除</span></span><br><span class="line"></span><br><span class="line">    menu2* <span class="title function_">Find_2</span><span class="params">(menu2 *&amp; head, <span class="type">int</span> change, <span class="built_in">string</span>&amp; c)</span>;  <span class="comment">//查找</span></span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> <span class="title function_">EnterSee2</span><span class="params">(menu2* headx[<span class="number">4</span>])</span>; <span class="comment">//查看接口函数</span></span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> <span class="title function_">Change_2</span><span class="params">(menu2*&amp; head, <span class="type">int</span> choice, <span class="built_in">string</span>&amp; sn, <span class="built_in">string</span>&amp; s, <span class="type">float</span> grade)</span>;<span class="comment">//修改数据函数</span></span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> <span class="title function_">CordReport_2</span><span class="params">(menu2* headx[<span class="number">4</span>])</span>;  <span class="comment">//成绩分析报告</span></span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> <span class="title function_">CordReport_2_print</span><span class="params">(menu2* p, <span class="built_in">string</span>&amp; g, <span class="type">int</span> index)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> <span class="title function_">Store2</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><h3 id="3-Everything-h"><a href="#3-Everything-h" class="headerlink" title="3.Everything.h"></a>3.Everything.h</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> EVERTTHING_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EVERTTHING_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;conio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ShowMap.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;FileO.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Core1.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Core2.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Input.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//全局变量，用以记录用户存放数据的文件名</span></span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">string</span> filebuffer1, filebuffer2;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><h3 id="4-FileO-h"><a href="#4-FileO-h" class="headerlink" title="4.FileO.h"></a>4.FileO.h</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> FILEO_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FILEO_H</span></span><br><span class="line"><span class="comment">/*这个头文件里保存着大部分与文件读写有关的函数*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*账号-密码类*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Users</span>&#123;</span>   </span><br><span class="line">private:</span><br><span class="line">     <span class="built_in">string</span> accounts, password;</span><br><span class="line">     Users* next;</span><br><span class="line">public:</span><br><span class="line">    <span class="type">int</span> <span class="title function_">Enter</span><span class="params">(Users* user)</span>;<span class="comment">//登陆函数</span></span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> <span class="title function_">Readuser</span><span class="params">(Users* user)</span>;<span class="comment">//读取账户信息函数</span></span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> <span class="title function_">ChangePass</span><span class="params">(Users* user)</span>;<span class="comment">//修改密码函数</span></span><br><span class="line"></span><br><span class="line">    Users* <span class="title function_">Register</span><span class="params">(Users* user)</span>;<span class="comment">//注册函数</span></span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> <span class="title function_">StoreUser</span><span class="params">(Users* user)</span>;<span class="comment">//存储用户账户函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// FILEO_H</span></span></span><br></pre></td></tr></table></figure><h3 id="5-Input-h"><a href="#5-Input-h" class="headerlink" title="5.Input.h"></a>5.Input.h</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> INPUT_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INPUT_H</span></span><br><span class="line"><span class="type">float</span> <span class="title function_">inputlnt</span><span class="params">(<span class="type">void</span>)</span>; <span class="comment">//这个函数是我们输入数字的函数</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">inputString</span><span class="params">(<span class="built_in">string</span>&amp; buffer)</span>; <span class="comment">//这个函数就是输入字符串，同样我们可以检测是否溢出</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> <span class="title function_">enterspring</span><span class="params">(<span class="type">int</span> c)</span>; <span class="comment">//接口，c是选择，可以实现输入密码的时候以****形式输入</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><h3 id="6-ShowMap-h"><a href="#6-ShowMap-h" class="headerlink" title="6.ShowMap.h"></a>6.ShowMap.h</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SHOWMAP_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SHOWMAP_H</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ShowMap0</span><span class="params">(<span class="type">void</span>)</span>; <span class="comment">//登录注册菜单</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ShowMap1</span><span class="params">(<span class="type">void</span>)</span>; <span class="comment">//主系统菜单</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ShowMap2</span><span class="params">(<span class="type">void</span>)</span>; <span class="comment">//系统1菜单</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ShowMap3</span><span class="params">(<span class="type">void</span>)</span>; <span class="comment">//系统二菜单</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ShowSeeit_1</span><span class="params">(<span class="type">void</span>)</span>; <span class="comment">//菜单一信息</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">heart</span><span class="params">()</span>; <span class="comment">//登录爱心显示</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// SHOWMAP_H</span></span></span><br></pre></td></tr></table></figure><h3 id="7-Core1-cpp"><a href="#7-Core1-cpp" class="headerlink" title="7.Core1.cpp"></a>7.Core1.cpp</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Everything.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*用以计算高度的函数*/</span></span><br><span class="line"> <span class="type">int</span> <span class="title function_">menu1::high</span><span class="params">(menu1* p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (p == nullptr)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> p-&gt;height;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/*LL型旋转 */</span></span><br><span class="line">  menu1* <span class="title function_">menu1::singleft</span><span class="params">( menu1* k2)</span>  <span class="comment">//左单旋  LL</span></span><br><span class="line"> &#123;</span><br><span class="line">     menu1* k1 = k2-&gt;left;</span><br><span class="line">     k2-&gt;left = k1-&gt;right;</span><br><span class="line">     k1-&gt;right = k2;</span><br><span class="line">     k1-&gt;height = max(high(k1-&gt;left), high(k1-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">     k2-&gt;height = max(high(k2-&gt;left), high(k2-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">     <span class="keyword">return</span> k1;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/*RR型旋转*/</span></span><br><span class="line">  menu1* <span class="title function_">menu1::singright</span><span class="params">( menu1* k2)</span>  <span class="comment">//右单旋 RR</span></span><br><span class="line"> &#123;</span><br><span class="line">     menu1* k1 = k2-&gt;right;</span><br><span class="line">     k2-&gt;right = k1-&gt;left;</span><br><span class="line">     k1-&gt;left = k2;</span><br><span class="line">     k1-&gt;height = max(high(k1-&gt;left), high(k1-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">     k2-&gt;height = max(high(k2-&gt;left), high(k2-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">     <span class="keyword">return</span> k1;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">  menu1* <span class="title function_">menu1::doubleleft</span><span class="params">( menu1* k3)</span>   <span class="comment">//左双旋 LR 核心操作 LRL(左孩子右单旋，本身左单旋)</span></span><br><span class="line"> &#123;</span><br><span class="line">     k3-&gt;left = singright(k3-&gt;left);</span><br><span class="line">     <span class="keyword">return</span> singleft(k3);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">  menu1* <span class="title function_">menu1::doubleright</span><span class="params">( menu1* k3)</span>  <span class="comment">//右双旋 RL 核心操作 RLR</span></span><br><span class="line"> &#123;</span><br><span class="line">     k3-&gt;right = singleft(k3-&gt;right);</span><br><span class="line">     <span class="keyword">return</span> singright(k3);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*用以记录系统一数据的函数，并未保存至文件中，采用递归实现(学号是有序的) */</span></span><br><span class="line"><span class="comment">/*主要的思想就是平衡树的插入操作 */</span></span><br><span class="line"><span class="comment">/*a,b,c,d即结构体中的信息，都是按顺序来的 */</span></span><br><span class="line">   <span class="type">void</span> <span class="title function_">menu1::Record_1</span><span class="params">( menu1 *&amp; ph, <span class="built_in">string</span>&amp; a, <span class="built_in">string</span>&amp; b, <span class="built_in">string</span>&amp; c, <span class="built_in">string</span>&amp; d)</span></span><br><span class="line">  &#123;</span><br><span class="line">      <span class="keyword">if</span> (ph == nullptr)</span><br><span class="line">      &#123;</span><br><span class="line">          ph = new menu1(a,b,c,d);</span><br><span class="line">          <span class="keyword">if</span> (ph == nullptr)</span><br><span class="line">          &#123;</span><br><span class="line">              MessageBox(nullptr, TEXT(<span class="string">&quot;程序异常崩溃&quot;</span>), TEXT(<span class="string">&quot;sorry!&quot;</span>), <span class="number">0</span>);</span><br><span class="line">              <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">          &#125;</span><br><span class="line">            </span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (a.compare(ph-&gt;sn) &lt; <span class="number">0</span>)</span><br><span class="line">      &#123;</span><br><span class="line">          Record_1(ph-&gt;left, a, b, c, d);</span><br><span class="line">          <span class="keyword">if</span> (high(ph-&gt;left) - high(ph-&gt;right) == <span class="number">2</span>)</span><br><span class="line">          &#123;</span><br><span class="line">              <span class="keyword">if</span> (a.compare(ph-&gt;left-&gt;sn) &lt; <span class="number">0</span>)</span><br><span class="line">                  ph = singleft(ph);</span><br><span class="line">              <span class="keyword">else</span></span><br><span class="line">                  ph = doubleleft(ph);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (a.compare(ph-&gt;sn) &gt; <span class="number">0</span>)</span><br><span class="line">      &#123;     </span><br><span class="line">          Record_1(ph-&gt;right, a, b, c, d);</span><br><span class="line">          <span class="keyword">if</span> (high(ph-&gt;right) - high(ph-&gt;left) == <span class="number">2</span>)</span><br><span class="line">          &#123;</span><br><span class="line">              <span class="keyword">if</span> (a.compare(ph-&gt;right-&gt;sn) &gt; <span class="number">0</span>)</span><br><span class="line">                  ph = singright(ph);</span><br><span class="line">              <span class="keyword">else</span></span><br><span class="line">                  ph = doubleright(ph);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (a.compare(ph-&gt;sn) == <span class="number">0</span>)<span class="comment">//检索学号重复</span></span><br><span class="line">      &#123;</span><br><span class="line">          <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;您输入的学号有重复!请您检查并重新操作 &quot;</span>;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      ph-&gt;height = max(high(ph-&gt;left), high(ph-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/*查看信息，中序遍历递归 */</span></span><br><span class="line">    <span class="type">void</span> <span class="title function_">menu1::Seeit_1</span><span class="params">( menu1 *&amp; head)</span></span><br><span class="line">   &#123;</span><br><span class="line">       menu1* p = head;</span><br><span class="line">       <span class="keyword">if</span> (p)</span><br><span class="line">       &#123;</span><br><span class="line">           Seeit_1(p-&gt;left);</span><br><span class="line">           <span class="built_in">printf</span>(<span class="string">&quot;\t\t     %-19s%-22s%-27s%-16s\n&quot;</span>, p-&gt;sn.c_str(), p-&gt;name.c_str(), p-&gt;chat.c_str(), p-&gt;dor.c_str());</span><br><span class="line">           Seeit_1(p-&gt;right);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*删除节点函数，递归实现*/</span></span><br><span class="line"><span class="comment">/*主要的思想为平衡树删除节点的操作*/</span></span><br><span class="line">     menu1* <span class="title function_">menu1::Delete_1</span><span class="params">( menu1* p, <span class="built_in">string</span>&amp; x)</span>&#123;</span><br><span class="line">        menu1* ph;</span><br><span class="line">        <span class="keyword">if</span> (!p)</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;该学生不存在!\n&quot;</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (x.compare(p-&gt;sn) &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            p-&gt;left = Delete_1(p-&gt;left, x);</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">abs</span>(high(p-&gt;left) - high(p-&gt;right)) == <span class="number">2</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (high(p-&gt;left-&gt;left) &gt; high(p-&gt;left-&gt;right))</span><br><span class="line">                    p = singleft(p);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    p = doubleleft(p);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (x.compare(p-&gt;sn) &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            p-&gt;right = Delete_1(p-&gt;right, x);</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">abs</span>(high(p-&gt;left) - high(p-&gt;right)) == <span class="number">2</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (high(p-&gt;right-&gt;left) &lt; high(p-&gt;right-&gt;right))</span><br><span class="line">                    p = singright(p);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    p = doubleright(p);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p-&gt;left &amp;&amp; p-&gt;right)<span class="comment">/*可以找到较高的子树中符合的节点替代，这样可以减少旋转的开销*/</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (high(p-&gt;left) &gt;= high(p-&gt;right))</span><br><span class="line">            &#123;</span><br><span class="line">                ph = p-&gt;left;</span><br><span class="line">                <span class="keyword">while</span> (ph-&gt;right)<span class="comment">//左子树中最大节点替代</span></span><br><span class="line">                    ph = ph-&gt;right;</span><br><span class="line">                p-&gt;sn = ph-&gt;sn;</span><br><span class="line">                p-&gt;name = ph-&gt;name;</span><br><span class="line">                p-&gt;dor = ph-&gt;dor;</span><br><span class="line">                p-&gt;chat = ph-&gt;chat;</span><br><span class="line">                p-&gt;left = Delete_1(p-&gt;left, ph-&gt;sn);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                ph = p-&gt;right;</span><br><span class="line">                <span class="keyword">while</span> (ph-&gt;left)<span class="comment">//右子树中最下节点替代</span></span><br><span class="line">                    ph = ph-&gt;left;</span><br><span class="line">                p-&gt;sn = ph-&gt;sn;</span><br><span class="line">                p-&gt;name = ph-&gt;name;</span><br><span class="line">                p-&gt;dor = ph-&gt;dor;</span><br><span class="line">                p-&gt;chat = ph-&gt;chat;</span><br><span class="line">                p-&gt;right = Delete_1(p-&gt;right, ph-&gt;sn);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            menu1* ph = p;</span><br><span class="line">            <span class="keyword">if</span> (p-&gt;left == nullptr)</span><br><span class="line">                p = p-&gt;right;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p-&gt;right == nullptr)</span><br><span class="line">                p = p-&gt;left;</span><br><span class="line">            delete ph;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">/*查询函数 */</span></span><br><span class="line">      menu1* <span class="title function_">menu1::Find_1</span><span class="params">( menu1*&amp; head, <span class="type">int</span> sp)</span><span class="comment">//sp用以表示选择，即以何种方式查询</span></span><br><span class="line">     &#123;</span><br><span class="line">         <span class="built_in">string</span> s;</span><br><span class="line">         menu1* p = head,*  <span class="built_in">queue</span>[<span class="number">1000</span>];</span><br><span class="line">         <span class="type">int</span> hea = <span class="number">0</span>, tail = <span class="number">0</span>;</span><br><span class="line">         <span class="built_in">queue</span>[tail++] = head;</span><br><span class="line">         <span class="keyword">if</span> (p == nullptr)</span><br><span class="line">         &#123;</span><br><span class="line">             <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;暂无数据\n&quot;</span>;</span><br><span class="line">             <span class="keyword">return</span> p;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">switch</span> (sp)</span><br><span class="line">         &#123;</span><br><span class="line">         <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">             <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;请输入该生的学号  &quot;</span>;</span><br><span class="line">             inputString(s);</span><br><span class="line">             system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">             <span class="keyword">while</span> (s.compare(p-&gt;sn) != <span class="number">0</span>)</span><br><span class="line">             &#123;</span><br><span class="line">                 <span class="keyword">if</span> (s.compare(p-&gt;sn) &lt; <span class="number">0</span>)</span><br><span class="line">                     p = p-&gt;left;</span><br><span class="line">                 <span class="keyword">else</span> <span class="keyword">if</span> (s.compare(p-&gt;sn) &gt; <span class="number">0</span>)</span><br><span class="line">                     p = p-&gt;right;</span><br><span class="line">                 <span class="keyword">if</span> (p == nullptr)</span><br><span class="line">                 &#123;</span><br><span class="line">                     <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;对不起，该生不存在\n&quot;</span>;</span><br><span class="line">                     <span class="keyword">return</span> p;</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;\t----------------------******************学生信息查看*********************--------------------\n&quot;</span>;</span><br><span class="line">             <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;\t-------------学号---------------姓名------------------联系方式-------------------宿舍号-----\n\n&quot;</span>;</span><br><span class="line">             <span class="built_in">printf</span>(<span class="string">&quot;\t\t     %-19s%-22s%-27s%-16s\n&quot;</span>, p-&gt;sn.c_str(), p-&gt;name.c_str(), p-&gt;chat.c_str(), p-&gt;dor.c_str());</span><br><span class="line">             <span class="keyword">return</span> p;</span><br><span class="line">         <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">             <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;请输入该生的姓名  &quot;</span>;</span><br><span class="line">             inputString(s);</span><br><span class="line">             system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">             <span class="keyword">while</span> (hea &lt; tail &amp;&amp; s.compare(<span class="built_in">queue</span>[hea]-&gt;name) != <span class="number">0</span>)</span><br><span class="line">             &#123;</span><br><span class="line">                 <span class="keyword">if</span> (<span class="built_in">queue</span>[hea]-&gt;left)</span><br><span class="line">                     <span class="built_in">queue</span>[tail++] = <span class="built_in">queue</span>[hea]-&gt;left;</span><br><span class="line">                 <span class="keyword">if</span> (<span class="built_in">queue</span>[hea]-&gt;right)</span><br><span class="line">                     <span class="built_in">queue</span>[tail++] = <span class="built_in">queue</span>[hea]-&gt;right;</span><br><span class="line">                 hea++;</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">if</span> (hea == tail)</span><br><span class="line">             &#123;</span><br><span class="line"></span><br><span class="line">                 <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;对不起，该生不存在\n&quot;</span>;</span><br><span class="line">                 <span class="keyword">return</span> nullptr;</span><br><span class="line"></span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">else</span> p = <span class="built_in">queue</span>[hea];</span><br><span class="line">             <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;\t----------------------******************学生信息查看******************** *--------------------\n&quot;</span>;</span><br><span class="line">             <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;\t-------------学号---------------姓名------------------联系方式-------------------宿舍号-----\n&quot;</span>;</span><br><span class="line">             <span class="built_in">printf</span>(<span class="string">&quot;\t\t     %-19s%-22s%-27s%-16s\n&quot;</span>, p-&gt;sn.c_str(), p-&gt;name.c_str(), p-&gt;chat.c_str(), p-&gt;dor.c_str());</span><br><span class="line">             <span class="keyword">return</span> p;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/*修改数据函数 */</span></span><br><span class="line">      <span class="type">void</span> <span class="title function_">menu1::Change_1</span><span class="params">(menu1 *&amp; head)</span></span><br><span class="line">      &#123;</span><br><span class="line">          <span class="built_in">string</span> sn1;</span><br><span class="line">          <span class="type">int</span> ck;</span><br><span class="line">          <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;您需要输入您想要修改的学生的学号\n&quot;</span>;</span><br><span class="line">          menu1* p = Find_1(head, <span class="number">4</span>);</span><br><span class="line">          <span class="keyword">if</span> (p == nullptr)</span><br><span class="line">          &#123;</span><br><span class="line">              system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">          &#123;</span><br><span class="line">              <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;您可以输入 1 以修改学号，输入 2 以修改姓名，输入 3 以修改联系方式，输入 4 以修改宿舍号，输入 0 以退出本次操作\n&quot;</span>;</span><br><span class="line">              <span class="built_in">cin</span> &gt;&gt; ck;</span><br><span class="line">              <span class="keyword">switch</span> (ck)</span><br><span class="line">              &#123;</span><br><span class="line">              <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                  <span class="keyword">return</span>;</span><br><span class="line">              <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                  <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;请输入新学号 &quot;</span>;</span><br><span class="line">                  inputString(p-&gt;sn);</span><br><span class="line">                  <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;操作成功，请继续操作\n&quot;</span>;</span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">              <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                  <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;请输入新姓名 &quot;</span>;</span><br><span class="line">                  inputString(p-&gt;name);</span><br><span class="line">                  <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;操作成功，请继续操作\n&quot;</span>;</span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">              <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                  <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;请输入新联系方式 &quot;</span>;</span><br><span class="line">                  inputString(p-&gt;chat);</span><br><span class="line">                  <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;操作成功，请继续操作\n&quot;</span>;</span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">              <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">                  <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;请输入新宿舍号 &quot;</span>;</span><br><span class="line">                  inputString(p-&gt;dor);</span><br><span class="line">                  <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;操作成功，请继续操作\n&quot;</span>;</span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">              <span class="keyword">default</span>:</span><br><span class="line">                  <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;输入的数字有误，请重新输入\n&quot;</span>;</span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/*删除函数的接口，进入删除菜单 */</span></span><br><span class="line">       <span class="type">void</span> <span class="title function_">menu1::EnterDelete_1</span><span class="params">( menu1 *&amp; head)</span></span><br><span class="line">      &#123;</span><br><span class="line">          <span class="type">int</span> c;</span><br><span class="line">          <span class="built_in">string</span> sn1;</span><br><span class="line">          <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">          &#123;</span><br><span class="line">              ShowSeeit_1();</span><br><span class="line">              Seeit_1(head);</span><br><span class="line">              <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;您可以输入 1 以删除，2 以全部删除，0 以返回菜单\n&quot;</span>;</span><br><span class="line">              <span class="built_in">cin</span> &gt;&gt; c;</span><br><span class="line">              <span class="keyword">switch</span> (c)</span><br><span class="line">              &#123;</span><br><span class="line">              <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                  <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;请输入您想要删除学生的学号 &quot;</span>;</span><br><span class="line">                  inputString(sn1);</span><br><span class="line">                  head = Delete_1(head, sn1);</span><br><span class="line">                  <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;本次操作结束，请输入任意键继续... &quot;</span>;</span><br><span class="line">                  <span class="built_in">cin</span>.ignore();</span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">              <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                  head-&gt;FreeAll_1();</span><br><span class="line">                  head = nullptr;</span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">              <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                  <span class="keyword">return</span>;</span><br><span class="line">              <span class="keyword">default</span>:</span><br><span class="line">                  <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;输入有误，请重新输入\n&quot;</span>;</span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/*Free */</span></span><br><span class="line">       <span class="type">void</span> <span class="title function_">menu1::FreeAll_1</span><span class="params">()</span></span><br><span class="line">       &#123;    </span><br><span class="line">           menu1* head = this;</span><br><span class="line">           <span class="keyword">if</span> (head &amp;&amp; head-&gt;left)</span><br><span class="line">               head-&gt;left-&gt;FreeAll_1();</span><br><span class="line">           <span class="keyword">if</span> (head)</span><br><span class="line">           &#123;</span><br><span class="line">               delete head;</span><br><span class="line">               head = nullptr;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (head &amp;&amp; head-&gt;right)</span><br><span class="line">               head-&gt;right-&gt;FreeAll_1();</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><h3 id="8-Core2-cpp"><a href="#8-Core2-cpp" class="headerlink" title="8.Core2.cpp"></a>8.Core2.cpp</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Everything.h&quot;</span></span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> flag;<span class="comment">//申明全局变量的使用</span></span><br><span class="line"><span class="built_in">string</span> menu2::g[<span class="number">4</span>] = &#123; <span class="string">&quot;平均&quot;</span>,<span class="string">&quot;高数&quot;</span>,<span class="string">&quot;英语&quot;</span>,<span class="string">&quot;C++&quot;</span> &#125;;</span><br><span class="line"><span class="comment">/*用于记录数据，ch用以表示选择，1个函数分别处理多个表头 */</span></span><br><span class="line"> menu2* <span class="title function_">menu2::Record_2</span><span class="params">( menu2*&amp; head, <span class="built_in">string</span>&amp; a, <span class="built_in">string</span>&amp; b, <span class="type">float</span> G[<span class="number">4</span>], <span class="type">int</span> ch)</span></span><br><span class="line">&#123;</span><br><span class="line">     menu2* p = head,*  pr=nullptr,*  ph=nullptr;<span class="comment">//双向链表</span></span><br><span class="line">     G[<span class="number">0</span>] = (G[<span class="number">1</span>] + G[<span class="number">2</span>] + G[<span class="number">3</span>]) / <span class="number">3.0</span>;</span><br><span class="line">    <span class="keyword">while</span> (p)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (a.compare(p-&gt;sn2) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            MessageBox(nullptr, TEXT(<span class="string">&quot;学号存在重复，请检查输入...&quot;</span>), TEXT(<span class="string">&quot;!&quot;</span>), <span class="number">0</span>);</span><br><span class="line">            flag = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        p = p-&gt;Next;</span><br><span class="line">    &#125;<span class="comment">//检索学号重复</span></span><br><span class="line">    p = head;</span><br><span class="line">    ph = new menu2;</span><br><span class="line">    <span class="keyword">if</span> (ph == nullptr)</span><br><span class="line">    &#123;</span><br><span class="line">        MessageBox(nullptr, TEXT(<span class="string">&quot;程序异常崩溃&quot;</span>), TEXT(<span class="string">&quot;Sorry!&quot;</span>), <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p == nullptr)</span><br><span class="line">    &#123;</span><br><span class="line">        head = ph;</span><br><span class="line">        ph-&gt;Previous = nullptr;</span><br><span class="line">        ph-&gt;Next = nullptr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> head-&gt;Record_2_isnert(head, p, pr, ph, G[ch], ch, a);</span><br><span class="line">    ph-&gt;sn2 = a;</span><br><span class="line">    ph-&gt;name2 = b;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        ph-&gt;grade[i] = G[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">menu2::Record_2_isnert</span><span class="params">(menu2*&amp; head, menu2* p, menu2* pr, menu2* ph, <span class="type">float</span> x, <span class="type">int</span> ch, <span class="built_in">string</span>&amp; a)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (x &gt; p-&gt;grade[ch] || (x == p-&gt;grade[ch] &amp;&amp; a.compare(p-&gt;sn2) &lt;= <span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        head = ph;</span><br><span class="line">        ph-&gt;Previous = nullptr;</span><br><span class="line">        ph-&gt;Next = p;</span><br><span class="line">        p-&gt;Previous = ph;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (p &amp;&amp; x &lt; p-&gt;grade[ch])</span><br><span class="line">        &#123;</span><br><span class="line">            pr = p;</span><br><span class="line">            p = p-&gt;Next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (p &amp;&amp; x == p-&gt;grade[ch] &amp;&amp; a.compare(p-&gt;sn2) &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            pr = p;</span><br><span class="line">            p = p-&gt;Next;</span><br><span class="line">        &#125;</span><br><span class="line">        ph-&gt;Previous = pr;</span><br><span class="line">        <span class="keyword">if</span> (p == nullptr)</span><br><span class="line">        &#123;</span><br><span class="line">            pr-&gt;Next = ph;</span><br><span class="line">            ph-&gt;Next = nullptr;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            ph-&gt;Next = p;</span><br><span class="line">            pr-&gt;Next = ph;</span><br><span class="line">            p-&gt;Previous = ph;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*查看所有数据函数 */</span></span><br><span class="line"> <span class="type">void</span> <span class="title function_">menu2::Seeit_2</span><span class="params">( menu2 *&amp; head)</span></span><br><span class="line">&#123;</span><br><span class="line">    system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">    menu2* p = head;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;\n\n\n\n\t----------------------******************学生成绩查看******************** *--------------------\n\n\n&quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;\t学号----------姓名----------高数成绩--------英语成绩--------C++程序设计成绩--------总成绩(平均成绩)\n\n&quot;</span>;</span><br><span class="line">    <span class="keyword">while</span> (p)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\t%-14s%-15s%-15.1f%-18.1f%-23.1f%-15.1f\n&quot;</span>, p-&gt;sn2.c_str(), p-&gt;name2.c_str(), p-&gt;grade[<span class="number">1</span>], p-&gt;grade[<span class="number">2</span>], p-&gt;grade[<span class="number">3</span>], p-&gt;grade[<span class="number">0</span>]);</span><br><span class="line">        p = p-&gt;Next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*删除节点函数 */</span></span><br><span class="line"><span class="comment">//flag用以标记删除失败情况，避免多次删除</span></span><br><span class="line"><span class="comment">//主要要考虑前节点与后节点的存在情况</span></span><br><span class="line"> <span class="type">void</span> <span class="title function_">menu2::Delete_2</span><span class="params">( menu2 *&amp; head, <span class="built_in">string</span>&amp; s)</span></span><br><span class="line">&#123;</span><br><span class="line">     menu2* p = head;</span><br><span class="line">    <span class="keyword">if</span> (!p)</span><br><span class="line">    &#123;</span><br><span class="line">        flag = <span class="number">1</span>;<span class="comment">//没有这个学生</span></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;暂无数据!\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (s.compare(p-&gt;sn2) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        p = p-&gt;Next;</span><br><span class="line">        <span class="keyword">if</span> (!p)</span><br><span class="line">        &#123;</span><br><span class="line">            flag = <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;该生数据不存在，请重试！\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;Previous == nullptr &amp;&amp; p-&gt;Next == nullptr)</span><br><span class="line">    &#123;</span><br><span class="line">        delete p;</span><br><span class="line">        p = nullptr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!p-&gt;Previous)</span><br><span class="line">    &#123;</span><br><span class="line">        head = p-&gt;Next;</span><br><span class="line">        p-&gt;Next-&gt;Previous = nullptr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!p-&gt;Next)</span><br><span class="line">        p-&gt;Previous-&gt;Next = nullptr;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        p-&gt;Previous-&gt;Next = p-&gt;Next;</span><br><span class="line">        p-&gt;Next-&gt;Previous = p-&gt;Previous;</span><br><span class="line">    &#125;</span><br><span class="line">    delete p;</span><br><span class="line">    p = nullptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*遍历查询*/</span></span><br><span class="line"> menu2* <span class="title function_">menu2::Find_2</span><span class="params">( menu2 *&amp; head, <span class="type">int</span> change, <span class="built_in">string</span>&amp; c)</span><span class="comment">//C用以表示姓名或者学号，取决于change是否为6还是4</span></span><br><span class="line">&#123;</span><br><span class="line">    system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">    menu2* p = head;</span><br><span class="line">    <span class="keyword">if</span> (change == <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (p)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (c.compare(p-&gt;sn2) == <span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">else</span> p = p-&gt;Next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (p)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (c.compare(p-&gt;name2) == <span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">else</span> p = p-&gt;Next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\n\n\n\n\t----------------------******************学生成绩查看******************** *--------------------\n\n\n&quot;</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\t学号----------姓名----------高数成绩--------英语成绩--------C++程序设计成绩--------总成绩(平均成绩)\n\n&quot;</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\t%-14s%-15s%-15.1f%-18.1f%-23.1f%-15.1f&quot;</span>, p-&gt;sn2.c_str(), p-&gt;name2.c_str(), p-&gt;grade[<span class="number">1</span>], p-&gt;grade[<span class="number">2</span>], p-&gt;grade[<span class="number">3</span>], p-&gt;grade[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;该学生不存在\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*查看单科成绩 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">menu2::SeeThesingle_2</span><span class="params">( menu2 *&amp; headofit, <span class="type">int</span> ch)</span></span><br><span class="line">&#123;</span><br><span class="line">    menu2* head = headofit;</span><br><span class="line">    SeeThesingle_2_print(head, g[ch], ch);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;\n\n操作成功，您可以继续操作！\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">menu2::SeeThesingle_2_print</span><span class="params">(menu2 *&amp; head, <span class="built_in">string</span> g, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\n\n\n\n\t----------------------******************学生&quot;</span> &lt;&lt; g &lt;&lt; <span class="string">&quot;成绩查看*********************  --------------------\n\n\n&quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\t\t\t\t\t学号----------姓名----------&quot;</span> &lt;&lt; g &lt;&lt; <span class="string">&quot;成绩\n\n&quot;</span>;</span><br><span class="line">    <span class="keyword">while</span> (head)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\t\t\t\t\t%-14s%-15s%-15.1f\n&quot;</span>, head-&gt;sn2.c_str(), head-&gt;name2.c_str(), head-&gt;grade[index]);</span><br><span class="line">        head = head-&gt;Next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*进入查看单科成绩接口 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">menu2::EnterSee2</span><span class="params">(menu2* headx[<span class="number">4</span>])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> c;</span><br><span class="line">    system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;您可以输入数字 1 以查看学生高数成绩，2 以查看学生的英语成绩，3 以查看C++成绩,0 以返回菜单\n&quot;</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        fflush(<span class="built_in">stdin</span>);</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; c;</span><br><span class="line">        <span class="keyword">if</span> (!c) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (c &lt; <span class="number">4</span> &amp;&amp; c &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            SeeThesingle_2(headx[c], c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;输入有误，请重新输入\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*修改数据，sn学号，s姓名，grade取决于choice分别表示不同的需要修改的成绩 */</span></span><br><span class="line"> <span class="type">void</span> <span class="title function_">menu2::Change_2</span><span class="params">( menu2 *&amp; head, <span class="type">int</span> choice, <span class="built_in">string</span>&amp; sn, <span class="built_in">string</span>&amp; s, <span class="type">float</span> grade)</span></span><br><span class="line">&#123;</span><br><span class="line">    menu2* p = head;</span><br><span class="line">    <span class="type">float</span> f;</span><br><span class="line">    <span class="keyword">while</span> (p &amp;&amp; sn.compare(p-&gt;sn2)!=<span class="number">0</span>)<span class="comment">//找到对应的学生</span></span><br><span class="line">        p = p-&gt;Next;</span><br><span class="line">    <span class="keyword">if</span> (!p) <span class="keyword">return</span> ;<span class="comment">//没有什么也不做</span></span><br><span class="line">    <span class="keyword">switch</span> (choice)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        p-&gt;sn2 = s;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        p-&gt;name2 = s;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        f = (grade + p-&gt;grade[<span class="number">2</span>] + p-&gt;grade[<span class="number">3</span>]) / <span class="number">3.0</span>;</span><br><span class="line">        p-&gt;grade[<span class="number">1</span>] = grade;</span><br><span class="line">        p-&gt;grade[<span class="number">0</span>] = f;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">        f = (grade + p-&gt;grade[<span class="number">1</span>] + p-&gt;grade[<span class="number">3</span>]) / <span class="number">3.0</span>;</span><br><span class="line">        p-&gt;grade[<span class="number">2</span>] = grade;</span><br><span class="line">        p-&gt;grade[<span class="number">0</span>] = f;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">        f = (grade + p-&gt;grade[<span class="number">2</span>] + p-&gt;grade[<span class="number">1</span>]) / <span class="number">3.0</span>;</span><br><span class="line">        p-&gt;grade[<span class="number">3</span>] = grade;</span><br><span class="line">        p-&gt;grade[<span class="number">0</span>] = f;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*成绩报告函数*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">menu2::CordReport_2</span><span class="params">( menu2* headx[<span class="number">4</span>])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">        <span class="type">int</span> ch;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;----------------------******************输入4以返回菜单，输入5以刷新页面******************** *--------------------\n&quot;</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\t*您可以输入 0 以查看平均成绩报告，1 以查看高数成绩报告，2 以查看英语成绩报告，3 以查看C++成绩报告* \n&quot;</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            fflush(<span class="built_in">stdin</span>);</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; ch;</span><br><span class="line">            <span class="keyword">if</span> (ch == <span class="number">4</span>)<span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ch == <span class="number">5</span>)<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ch &lt; <span class="number">4</span> &amp;&amp; ch &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                CordReport_2_print(headx[ch], g[ch], ch);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;您的输入有误，请重新输入！\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">menu2::CordReport_2_print</span><span class="params">(menu2* p, <span class="built_in">string</span>&amp; g,<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="type">float</span> num1 = <span class="number">0</span>, num2 = <span class="number">0</span>, num3 = <span class="number">0</span>;<span class="comment">//满绩、及格、挂科占比</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\t\t\t\t *&quot;</span> &lt;&lt; g &lt;&lt; <span class="string">&quot;成绩报告*  \n\n\t\t\t\t&quot;</span> &lt;&lt; g &lt;&lt; <span class="string">&quot;成绩在90分及以上的人分别是:\n&quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\t\t\t\t学号----------姓名-----------成绩\n&quot;</span>;</span><br><span class="line">    <span class="keyword">while</span> (p &amp;&amp; p-&gt;grade[index] &gt;= <span class="number">90</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n\t\t\t\t%-15s%-15s%.1f&quot;</span>, p-&gt;sn2.c_str(), p-&gt;name2.c_str(), p-&gt;grade[index]);</span><br><span class="line">        num1++;</span><br><span class="line">        num2++;</span><br><span class="line">        p = p-&gt;Next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (num1 == <span class="number">0</span>)  <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\t\t\t\t您的班没有满分人士！&quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\n\n\t\t\t\t&quot;</span> &lt;&lt; g &lt;&lt; <span class="string">&quot;成绩在60分以下的人分别是:\n&quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\t\t\t\t学号----------姓名-----------成绩\n&quot;</span>;</span><br><span class="line">    <span class="keyword">while</span> (p)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;grade[index] &lt; <span class="number">60</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n\t\t\t\t%-15s%-15s%.1f&quot;</span>, p-&gt;sn2.c_str(), p-&gt;name2.c_str(), p-&gt;grade[index]);</span><br><span class="line">            num3++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> num2++;</span><br><span class="line">        p = p-&gt;Next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (num3 == <span class="number">0</span>)<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\t\t\t\t您的班没有挂科人士！&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (num2 + num3 != <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n\n\t\t\t\t总体分布:\n\t\t\t\t60分以下共有%.0f人，占比%.1f%%。\n\n\t\t\t\t60分以上共有%.0f人，占比%.1f%%。\n\n\t\t\t\t其中90分以上共有%.0f人,占比%.1f%%。\n\n&quot;</span>, num3, (<span class="type">float</span>)num3 / (num2 + num3)*  <span class="number">100.0</span>, num2, (<span class="type">float</span>)num2 / (num2 + num3)*  <span class="number">100.0</span>, num1, (<span class="type">float</span>)num1 / (num2 + num3)*  <span class="number">100.0</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\n\n\t\t\t暂无数据！&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">menu2::FreeAll_2</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    menu2* p,* h = this;</span><br><span class="line">    <span class="keyword">while</span> (h)</span><br><span class="line">    &#123;</span><br><span class="line">        p = h;</span><br><span class="line">        h = h-&gt;Next;</span><br><span class="line">        delete p;</span><br><span class="line">        p = nullptr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-FileO-cpp"><a href="#9-FileO-cpp" class="headerlink" title="9.FileO.cpp"></a>9.FileO.cpp</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Everything.h&quot;</span></span></span><br><span class="line"><span class="comment">/*存储基本信息函数接口 */</span></span><br><span class="line"> <span class="type">void</span> <span class="title function_">menu1::Store1</span><span class="params">( )</span></span><br><span class="line">&#123;</span><br><span class="line">    menu1* head = this;</span><br><span class="line">    fstream file1;</span><br><span class="line">    file1.open(filebuffer1, ios::out );</span><br><span class="line">    menu1* <span class="built_in">queue</span>[<span class="number">1000</span>];</span><br><span class="line">    <span class="type">int</span> first = <span class="number">0</span>, tail = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">queue</span>[tail++] = head;<span class="comment">//队列</span></span><br><span class="line">    <span class="keyword">if</span> (!file1) <span class="keyword">return</span> ;</span><br><span class="line">    file1 &lt;&lt; <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (!head) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">while</span> (first &lt; tail)<span class="comment">//BFS遍历树存储每个节点</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">queue</span>[first]-&gt;left)  <span class="built_in">queue</span>[tail++] = <span class="built_in">queue</span>[first]-&gt;left;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">queue</span>[first]-&gt;right) <span class="built_in">queue</span>[tail++] = <span class="built_in">queue</span>[first]-&gt;right;</span><br><span class="line">        file1 &lt;&lt; <span class="built_in">queue</span>[first]-&gt;sn&lt;&lt;<span class="string">&quot; &quot;</span> &lt;&lt; <span class="built_in">queue</span>[first]-&gt;name &lt;&lt;<span class="string">&quot; &quot;</span> &lt;&lt; <span class="built_in">queue</span>[first]-&gt;chat&lt;&lt;<span class="string">&quot; &quot;</span> &lt;&lt; <span class="built_in">queue</span>[first]-&gt;dor&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        first++;</span><br><span class="line">    &#125;</span><br><span class="line">    file1.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*从文件中读取信息数据函数接口 */</span></span><br><span class="line"> menu1* <span class="title function_">menu1::Read1</span><span class="params">( menu1 *&amp; head)</span></span><br><span class="line"> &#123;</span><br><span class="line">    <span class="built_in">string</span> a, b, c, d;<span class="comment">//顺序表示学号姓名联系宿舍</span></span><br><span class="line">    fstream file1;</span><br><span class="line">    file1.open(filebuffer1, ios::in | ios::out );</span><br><span class="line">    <span class="keyword">if</span> (!file1)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!file1.eof())</span><br><span class="line">    &#123;</span><br><span class="line">        file1&gt;&gt;a&gt;&gt; b&gt;&gt; c&gt;&gt; d;</span><br><span class="line">        <span class="keyword">if</span> (file1.fail())</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        Record_1(head, a, b, c, d);</span><br><span class="line">    &#125;</span><br><span class="line">    file1.close();</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*存储成绩信息函数接口*/</span></span><br><span class="line"> <span class="type">void</span> <span class="title function_">menu2::Store2</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    fstream file2;</span><br><span class="line">    file2.open(filebuffer2, ios::out);</span><br><span class="line">    menu2* p = this;</span><br><span class="line">    <span class="keyword">if</span> (!file2) <span class="keyword">return</span>;</span><br><span class="line">    file2 &lt;&lt; <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (!p) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">while</span> (p)</span><br><span class="line">    &#123;</span><br><span class="line">        file2&lt;&lt; p-&gt;sn2&lt;&lt;<span class="string">&quot; &quot;</span> &lt;&lt; p-&gt;name2 &lt;&lt;<span class="string">&quot; &quot;</span> &lt;&lt; p-&gt;grade[<span class="number">1</span>] &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; p-&gt;grade[<span class="number">2</span>] &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; p-&gt;grade[<span class="number">3</span>]&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        p = p-&gt;Next;</span><br><span class="line">    &#125;</span><br><span class="line">    file2.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*注册函数接口菜单 */</span></span><br><span class="line"> Users* <span class="title function_">Users::Register</span><span class="params">( Users* user)</span></span><br><span class="line">&#123;</span><br><span class="line">    Users* u = user, * ur = user,*  uh;</span><br><span class="line">    <span class="built_in">string</span> pass, act;</span><br><span class="line">    fstream f1, f2;</span><br><span class="line">    <span class="built_in">string</span> fs1, fs2;</span><br><span class="line">    <span class="type">int</span> ch;</span><br><span class="line">TOP _:</span><br><span class="line"></span><br><span class="line">    system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt;<span class="string">&quot;        --------------------******************注册账号******************** *--------------------------\n\n\n&quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt;<span class="string">&quot;                             您可以输入 1 以进入注册，输入其他任意数以返回...\n\n&quot;</span>;</span><br><span class="line">    fflush(<span class="built_in">stdin</span>);</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; ch;</span><br><span class="line">    <span class="keyword">if</span> (ch == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;请输入您的账号 &quot;</span>;</span><br><span class="line">        act = enterspring(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">while</span> (u)<span class="comment">//检查账号是否已经存在</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (act.compare(u-&gt;accounts) == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                MessageBox(nullptr, TEXT(<span class="string">&quot;账号已经存在...&quot;</span>), TEXT(<span class="string">&quot;!&quot;</span>), <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">return</span> user;</span><br><span class="line">            &#125;</span><br><span class="line">            ur = u;</span><br><span class="line">            u = u-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        uh = new Users;<span class="comment">//新账号信息</span></span><br><span class="line">        <span class="keyword">if</span> (uh == nullptr) <span class="keyword">return</span> user;<span class="comment">//异常错误</span></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;请输入您的密码 &quot;</span>;</span><br><span class="line">        pass = enterspring(<span class="number">2</span>);</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;请再次输入您的密码 &quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (pass.compare(enterspring(<span class="number">2</span>)) != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;两次输入密码不一致，请重新输入.\n按任意键继续...&quot;</span>;</span><br><span class="line">            <span class="built_in">cin</span>.ignore();</span><br><span class="line">            <span class="keyword">goto</span> TOP _;</span><br><span class="line">        &#125;</span><br><span class="line">        uh-&gt;accounts = act;</span><br><span class="line">        uh-&gt;password = pass;</span><br><span class="line">        uh-&gt;next = nullptr;</span><br><span class="line">        <span class="keyword">if</span> (user == nullptr)   user = uh;</span><br><span class="line">        <span class="keyword">else</span>    ur-&gt;next = uh;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> user;</span><br><span class="line">    fs1 = act;</span><br><span class="line">    fs2 = act;</span><br><span class="line">    fs1 += <span class="string">&quot;_IF.txt&quot;</span>;<span class="comment">//添加指定后缀</span></span><br><span class="line">    fs2 += <span class="string">&quot;_GD.txt&quot;</span>;</span><br><span class="line">    f1.open(fs1, ios::app);</span><br><span class="line">    f2.open(fs2, ios::app);</span><br><span class="line">    f1.close();</span><br><span class="line">    f2.close();</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;注册成功，即将返回登陆页面！...&quot;</span>;</span><br><span class="line">    Sleep(<span class="number">200</span>);</span><br><span class="line">    <span class="keyword">return</span> user;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*登陆函数接口菜单*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Users::Enter</span><span class="params">( Users* user)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">string</span> act;</span><br><span class="line">    <span class="type">int</span> ch, gh;</span><br><span class="line">TOP _:</span><br><span class="line">    system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;    ------------------------******************登陆系统******************** *------------------------\n\n\n&quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;                             您可以输入 1 以进入登陆，其他任意键以返回...\n\n&quot;</span>;</span><br><span class="line">    fflush(<span class="built_in">stdin</span>);</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; ch;</span><br><span class="line">    <span class="keyword">if</span> (ch == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;\n请输入您的账号 &quot;</span>;</span><br><span class="line">        act = enterspring(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (user == nullptr)</span><br><span class="line">        &#123;</span><br><span class="line">            MessageBox(nullptr, TEXT(<span class="string">&quot;账号信息不存在...&quot;</span>), TEXT(<span class="string">&quot;!&quot;</span>), <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">         Users* p = user;</span><br><span class="line">        <span class="keyword">while</span> (p &amp;&amp; act.compare(p-&gt;accounts) != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (p == nullptr)</span><br><span class="line">        &#123;</span><br><span class="line">            MessageBox(nullptr, TEXT(<span class="string">&quot;账号信息不存在...&quot;</span>), TEXT(<span class="string">&quot;!&quot;</span>), <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;\n请输入您的密码 &quot;</span>;</span><br><span class="line">        <span class="keyword">while</span> (p-&gt;password.compare(enterspring(<span class="number">2</span>)) != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;密码错误,您可以输入 1 以继续输入密码，0 以刷新页面重新登陆 \n&quot;</span>;</span><br><span class="line">            fflush(<span class="built_in">stdin</span>);</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; gh;</span><br><span class="line">            <span class="keyword">if</span> (gh == <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;\n请输入您的密码 &quot;</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (gh == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">goto</span> TOP _;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/*用以创建存放用户数据两个文件的名称*/</span></span><br><span class="line">    filebuffer1=act;</span><br><span class="line">    filebuffer2=act;</span><br><span class="line">    filebuffer1+= <span class="string">&quot;_IF.txt&quot;</span>;<span class="comment">//添加指定后缀</span></span><br><span class="line">    filebuffer2+= <span class="string">&quot;_GD.txt&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*读取用户账户信息*/</span></span><br><span class="line"> <span class="type">void</span> <span class="title function_">Users::Readuser</span><span class="params">( Users* user)</span></span><br><span class="line">&#123;</span><br><span class="line">    Users* ph, * pc = user;</span><br><span class="line">    fstream p;</span><br><span class="line">    p.open(<span class="string">&quot;Users.txt&quot;</span>, ios::in|ios::out);</span><br><span class="line">    <span class="keyword">if</span> (!p)<span class="keyword">return</span> ;</span><br><span class="line">    <span class="built_in">string</span> act,pass;</span><br><span class="line">    <span class="keyword">while</span> (!p.eof())</span><br><span class="line">    &#123;</span><br><span class="line">        p&gt;&gt; act&gt;&gt; pass;</span><br><span class="line">        <span class="keyword">if</span> (!p.fail())</span><br><span class="line">        &#123;</span><br><span class="line">            ph = new Users;</span><br><span class="line">            ph-&gt;accounts= act;</span><br><span class="line">            ph-&gt;password= pass;</span><br><span class="line">            ph-&gt;next = nullptr;</span><br><span class="line">            <span class="keyword">if</span> (user == nullptr)</span><br><span class="line">            &#123;</span><br><span class="line">                user = ph;</span><br><span class="line">                pc = user;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                pc-&gt;next = ph;</span><br><span class="line">                pc = pc-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    p.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*存储用户账户信息函数实现 */</span></span><br><span class="line"><span class="type">void</span>  <span class="title function_">Users::StoreUser</span><span class="params">( Users* user)</span></span><br><span class="line">&#123;</span><br><span class="line">     Users* p1;</span><br><span class="line">     fstream p;</span><br><span class="line">     p.open(<span class="string">&quot;Users.txt&quot;</span>, ios::out);</span><br><span class="line">    <span class="keyword">if</span> (!p)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;保存用户信息失败...&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    p &lt;&lt; <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">while</span> (user)</span><br><span class="line">    &#123;</span><br><span class="line">        p1 = user;</span><br><span class="line">        p&lt;&lt;user-&gt;accounts&lt;&lt;<span class="string">&quot; &quot;</span> &lt;&lt; user-&gt;password&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        user = user-&gt;next;</span><br><span class="line">        delete p1;</span><br><span class="line">    &#125;</span><br><span class="line">    p.close();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*修改用户账号密码函数 */</span></span><br><span class="line"> <span class="type">void</span> <span class="title function_">Users::ChangePass</span><span class="params">( Users* user)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">string</span> act, pass, pass1;</span><br><span class="line">    <span class="type">int</span> ch;</span><br><span class="line">    <span class="type">int</span> len = filebuffer1.size(), i;</span><br><span class="line">     Users* p = user;</span><br><span class="line">    <span class="comment">/*检索当前账户名 */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (filebuffer1[i] == <span class="string">&#x27; _&#x27;</span>)<span class="keyword">break</span>;</span><br><span class="line">        act+= filebuffer1[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (p &amp;&amp; act.compare(p-&gt;accounts) != <span class="number">0</span>)<span class="comment">//账户一定是存在的</span></span><br><span class="line">    &#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">TOP_:</span><br><span class="line">    system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;   --------------------******************修改密码*********************------------------------\n\n\n&quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;                        您可以输入 1 以开始修改操作，0 以返回...\n&quot;</span>;</span><br><span class="line">    fflush(<span class="built_in">stdin</span>);</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; ch;</span><br><span class="line">    <span class="keyword">if</span> (ch == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;\n请输入原密码  &quot;</span>;</span><br><span class="line">        <span class="keyword">while</span> (p &amp;&amp; enterspring(<span class="number">2</span>).compare(p-&gt;password) != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> gh;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;密码错误,您可以输入 1 以继续输入密码，0 以刷新页面 &quot;</span>;</span><br><span class="line">            fflush(<span class="built_in">stdin</span>);</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; gh;</span><br><span class="line">            <span class="keyword">if</span> (gh == <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;\n请输入您的原密码 &quot;</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (gh == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">goto</span> TOP_;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;请输入您的新密码 &quot;</span>;</span><br><span class="line">        pass1 = enterspring(<span class="number">2</span>);</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;请再次输入您的密码 &quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (pass1.compare(enterspring(<span class="number">2</span>)) != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;两次输入密码不一致，请重新输入.\n按任意键继续...&quot;</span>;</span><br><span class="line">            <span class="built_in">cin</span>.ignore();</span><br><span class="line">            <span class="keyword">goto</span> TOP _;</span><br><span class="line">        &#125;</span><br><span class="line">        p-&gt;password = pass1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ch == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;修改密码成功！请按任意键返回...&quot;</span>;</span><br><span class="line">    <span class="built_in">cin</span>.ignore();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="10-Input-cpp"><a href="#10-Input-cpp" class="headerlink" title="10.Input.cpp"></a>10.Input.cpp</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Everything.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">float</span> <span class="title function_">inputlnt</span><span class="params">()</span></span><br><span class="line">&#123;   </span><br><span class="line">    <span class="type">float</span> rax;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; rax;</span><br><span class="line">        <span class="keyword">if</span> (rax &lt; <span class="number">0</span> || rax &gt; <span class="number">100</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            MessageBox(nullptr, TEXT(<span class="string">&quot;您输入的数字范围有误，请重新输入&quot;</span>), TEXT(<span class="string">&quot;输入错误&quot;</span>), <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    fflush(<span class="built_in">stdin</span>);</span><br><span class="line">    <span class="keyword">return</span> rax;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">inputString</span><span class="params">(<span class="built_in">string</span>&amp; buffer)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; buffer;</span><br><span class="line">        <span class="keyword">if</span> (buffer.size() == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            MessageBox(nullptr, TEXT(<span class="string">&quot;您还未输入！&quot;</span>), TEXT(<span class="string">&quot;!&quot;</span>), <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (buffer.size() &gt; <span class="number">17</span>) &#123;</span><br><span class="line">            MessageBox(nullptr, TEXT(<span class="string">&quot;您输入字符串字数超过上限，请重新输入。。。&quot;</span>), TEXT(<span class="string">&quot;overbuffer!&quot;</span>), <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    fflush(<span class="built_in">stdin</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">string</span> <span class="title function_">enterspring</span><span class="params">(<span class="type">int</span> c)</span><span class="comment">//c是一则视为账号输入，二视为密码输入，输出用*</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> ch;</span><br><span class="line">    <span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">string</span> buf;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (ch = _getch(), ch != <span class="string">&#x27;\r&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (k &gt; <span class="number">17</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                MessageBox(nullptr, TEXT(<span class="string">&quot;您输入字符串字数已达上限，无法继续输入。。。&quot;</span>), TEXT(<span class="string">&quot;overbuffer!&quot;</span>), <span class="number">0</span>);</span><br><span class="line">                fflush(<span class="built_in">stdin</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (ch == <span class="string">&#x27;\b&#x27;</span> &amp;&amp; k &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                k--;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\b \b&quot;</span>;</span><br><span class="line">                buf.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((ch &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;z&#x27;</span>) || (ch &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;Z&#x27;</span>) || (ch &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                buf += ch;</span><br><span class="line">                k++;</span><br><span class="line">                <span class="keyword">if</span> (c == <span class="number">2</span>)</span><br><span class="line">                    <span class="built_in">putchar</span>(<span class="string">&#x27;*&#x27;</span>);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="built_in">putchar</span>(ch);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                MessageBox(nullptr, TEXT(<span class="string">&quot;您输入的字符有误，请重新输入&quot;</span>), TEXT(<span class="string">&quot;输入错误&quot;</span>), <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">1</span> &amp;&amp; k == <span class="number">0</span>) MessageBox(nullptr, TEXT(<span class="string">&quot;您还未输入...&quot;</span>), TEXT(<span class="string">&quot;!&quot;</span>), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="number">2</span> &amp;&amp; k &lt; <span class="number">6</span>) MessageBox(nullptr, TEXT(<span class="string">&quot;您的密码太短了...&quot;</span>), TEXT(<span class="string">&quot;!&quot;</span>), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> buf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="11-main-cpp"><a href="#11-main-cpp" class="headerlink" title="11.main.cpp"></a>11.main.cpp</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Everything.h&quot;</span></span></span><br><span class="line"><span class="type">int</span> flag;<span class="comment">//用于系统二的多重表重复性与存在性验证,0代表正确的操作，1代表错误的操作</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//全局变量，用以记录用户存放数据的文件名</span></span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">string</span> filebuffer1=<span class="string">&quot;&quot;</span>, filebuffer2=<span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*用于退出程序或者退出登陆的接口函数*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Exit</span><span class="params">( Users* h,  menu1* h1,  menu2* h2,  menu2* h3,  menu2* h4,  menu2* h5)</span></span><br><span class="line">&#123;</span><br><span class="line">    h1-&gt;Store1();</span><br><span class="line">    h2-&gt;Store2();</span><br><span class="line">    h-&gt;StoreUser(h);</span><br><span class="line"></span><br><span class="line">    h1-&gt;FreeAll_1();</span><br><span class="line">    h2-&gt;FreeAll_2();</span><br><span class="line">    h3-&gt;FreeAll_2();</span><br><span class="line">    h4-&gt;FreeAll_2();</span><br><span class="line">    h5-&gt;FreeAll_2();</span><br><span class="line">    filebuffer1=<span class="string">&quot;&quot;</span>;</span><br><span class="line">    filebuffer2=<span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    SetConsoleTitle(<span class="string">&quot;学生管理系统&quot;</span>);</span><br><span class="line"></span><br><span class="line">    heart();</span><br><span class="line">    <span class="comment">/*需要用到的定义*/</span></span><br><span class="line">     menu1* head = nullptr; <span class="comment">//这个是系统1的，只有一个头</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*下面是系统二的,headx[0]是平均成绩,headx[1]是高数头，headx[2]英语,headx[3]C++ */</span></span><br><span class="line">     menu2* headx[<span class="number">4</span>] = &#123; nullptr,nullptr,nullptr,nullptr &#125;;<span class="comment">//分别为平均成绩主头指针和各科头指针</span></span><br><span class="line"></span><br><span class="line">     Users* user = nullptr;<span class="comment">//用户信息</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*1，2表示系统1、2需要用到的变量，命名可以看看头文件中的类 */</span></span><br><span class="line">    <span class="built_in">string</span> Sn2, Name2, temp, name1, sn1, chat1, dor1;</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> Grade[<span class="number">4</span>]=&#123;<span class="number">0</span>&#125;;<span class="comment">//系统二的成绩变量</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> c, ch;<span class="comment">//临时需要用的</span></span><br><span class="line"></span><br><span class="line">Menu0:<span class="comment">//登录注册菜单</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//首先读取用户账号密码</span></span><br><span class="line">        user-&gt;Readuser(user);</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ShowMap0();</span><br><span class="line">            fflush(<span class="built_in">stdin</span>);</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; ch;</span><br><span class="line">            <span class="keyword">switch</span> (ch)</span><br><span class="line">            &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">if</span> (user-&gt;Enter(user)) <span class="comment">//如果登入成功则读取信息</span></span><br><span class="line">                &#123;</span><br><span class="line">                    head = head-&gt;Read1(head);</span><br><span class="line">                    fstream file2;</span><br><span class="line">                    file2.open(filebuffer2, ios::in|ios::out|ios::binary);</span><br><span class="line">                    <span class="keyword">if</span> (!file2)      </span><br><span class="line">                        <span class="keyword">goto</span> Menu1;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">while</span> (!file2.eof())</span><br><span class="line">                    &#123;</span><br><span class="line">                        file2&gt;&gt; Sn2&gt;&gt; Name2&gt;&gt; Grade[<span class="number">1</span>]&gt;&gt; Grade[<span class="number">2</span>]&gt;&gt; Grade[<span class="number">3</span>];</span><br><span class="line">                        <span class="keyword">if</span> (file2.fail())</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">                            headx[i]-&gt;Record_2(headx[i], Sn2, Name2, Grade, i);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    file2.close();</span><br><span class="line">                    <span class="keyword">goto</span> Menu1;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                user = user-&gt;Register(user);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;\t\t\t\t\tBye!期待您的下次使用\n\n\n&quot;</span>;</span><br><span class="line">                MessageBox(nullptr, TEXT(<span class="string">&quot;感谢您使用本程序&quot;</span>), TEXT(<span class="string">&quot;Bye!&quot;</span>), <span class="number">0</span>);</span><br><span class="line">                Exit(user, head, headx[<span class="number">0</span>], headx[<span class="number">1</span>], headx[<span class="number">2</span>], headx[<span class="number">3</span>]);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                MessageBox(nullptr, TEXT(<span class="string">&quot;输入有误，请重新输入...&quot;</span>), TEXT(<span class="string">&quot;!&quot;</span>), <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">Menu1:<span class="comment">//主页面菜单</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">        &#123;   </span><br><span class="line">            ShowMap1();</span><br><span class="line">            fflush(<span class="built_in">stdin</span>);</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;ch;</span><br><span class="line">            <span class="keyword">switch</span> (ch)</span><br><span class="line">            &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">goto</span> Menu2;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                <span class="keyword">goto</span> Menu3;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                user-&gt;ChangePass(user);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">                Exit(user, head, headx[<span class="number">0</span>], headx[<span class="number">1</span>], headx[<span class="number">2</span>], headx[<span class="number">3</span>]);</span><br><span class="line">                user = nullptr;</span><br><span class="line">                head = nullptr;</span><br><span class="line">                headx[<span class="number">0</span>] = headx[<span class="number">1</span>] = headx[<span class="number">2</span>] = headx[<span class="number">3</span>] = nullptr;</span><br><span class="line">                <span class="keyword">goto</span> Menu0;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">                system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;\t\t\t\t\tBye!期待您的下次使用\n\n\n&quot;</span>;</span><br><span class="line">                MessageBox(nullptr, TEXT(<span class="string">&quot;感谢您使用本程序&quot;</span>), TEXT(<span class="string">&quot;Bye!&quot;</span>), <span class="number">0</span>);</span><br><span class="line">                Exit(user, head, headx[<span class="number">0</span>], headx[<span class="number">1</span>], headx[<span class="number">2</span>], headx[<span class="number">3</span>]);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;输入有误，请重新输入\n&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">Menu2:<span class="comment">//子系统1的菜单</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">        &#123;   </span><br><span class="line">            ShowMap2();</span><br><span class="line">            fflush(<span class="built_in">stdin</span>);</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;ch;</span><br><span class="line">            <span class="keyword">switch</span> (ch)</span><br><span class="line">            &#123;</span><br><span class="line">                sn1 = <span class="string">&quot;&quot;</span>;</span><br><span class="line">                name1 = <span class="string">&quot;&quot;</span>;</span><br><span class="line">                chat1 = <span class="string">&quot;&quot;</span>;</span><br><span class="line">                dor1=<span class="string">&quot;&quot;</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;请输入学生的学号      &quot;</span>;</span><br><span class="line">                inputString(sn1);</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;请输入学生的姓名      &quot;</span>;</span><br><span class="line">                inputString(name1);</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;请输入学生的联系电话  &quot;</span>;</span><br><span class="line">                inputString(chat1);</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;请输入学生的宿舍号    &quot;</span>;</span><br><span class="line">                inputString(dor1);</span><br><span class="line">                head-&gt;Record_1(head, sn1, name1, chat1, dor1);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                head-&gt;EnterDelete_1(head);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                ShowSeeit_1();</span><br><span class="line">                head-&gt;Seeit_1(head);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">                head-&gt;Find_1(head, ch);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">                ShowSeeit_1();</span><br><span class="line">                head-&gt;Seeit_1(head);</span><br><span class="line">                head-&gt;Change_1(head);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">                head-&gt;Find_1(head, ch);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">                <span class="keyword">goto</span> Menu1;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\t\t\t\t\tBye!期待您的下次使用\n\n\n&quot;</span>;</span><br><span class="line">                MessageBox(nullptr, TEXT(<span class="string">&quot;感谢您使用本程序&quot;</span>), TEXT(<span class="string">&quot;Bye!&quot;</span>), <span class="number">0</span>);</span><br><span class="line">                Exit(user, head, headx[<span class="number">0</span>], headx[<span class="number">1</span>], headx[<span class="number">2</span>], headx[<span class="number">3</span>]);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;输入有误，请重新输入\n&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">Menu3:<span class="comment">//子系统二菜单，对着程序显示的具体功能理解，有一些函数利用了接口的性质</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">        &#123;   </span><br><span class="line">            ShowMap3();</span><br><span class="line">            Sn2 = <span class="string">&quot;&quot;</span>;</span><br><span class="line">            Name2 = <span class="string">&quot;&quot;</span>;</span><br><span class="line">            fflush(<span class="built_in">stdin</span>);</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; ch;</span><br><span class="line">            <span class="keyword">switch</span> (ch)</span><br><span class="line">            &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;请输入待录入学生的学号 &quot;</span>;</span><br><span class="line">                inputString(Sn2);</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;请输入该生的姓名  &quot;</span>;</span><br><span class="line">                inputString(Name2);</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;请录入该生的高等数学成绩  &quot;</span>;</span><br><span class="line">                Grade[<span class="number">1</span>] = inputlnt();</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;请录入该生的大学英语成绩  &quot;</span>;</span><br><span class="line">                Grade[<span class="number">2</span>] = inputlnt();</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;请录入该生的C++程序设计成绩(将为您自动计算三科平均成绩)  &quot;</span>;</span><br><span class="line">                Grade[<span class="number">3</span>] = inputlnt();</span><br><span class="line">                flag = <span class="number">0</span>; <span class="comment">//这里0代表没有学号重复，是正确的操作</span></span><br><span class="line">                headx[<span class="number">0</span>]-&gt;Record_2(headx[<span class="number">0</span>], Sn2, Name2, Grade, <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">if</span> (!flag)<span class="comment">//如果记录中没有检测到学生重复的话，就记录这个学生</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">/*参数0\1\2\3是具体的功能，记录不同的成绩*/</span></span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">                        headx[i]-&gt;Record_2(headx[i], Sn2, Name2, Grade, i);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    headx[<span class="number">0</span>]-&gt;Seeit_2(headx[<span class="number">0</span>]);</span><br><span class="line">                    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;您可以输入 1 以进行删除，2 以全部删除，0 以返回菜单\n&quot;</span>;</span><br><span class="line">                    <span class="built_in">cin</span>&gt;&gt;c;</span><br><span class="line">                    <span class="keyword">if</span> (c == <span class="number">1</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;请输入您想要删除学生数据的学生学号  &quot;</span>;</span><br><span class="line">                        inputString(Sn2);</span><br><span class="line">                        flag = <span class="number">0</span>;<span class="comment">//这里0代表学生存在，1代表学生不存在</span></span><br><span class="line">                        headx[<span class="number">0</span>]-&gt;Delete_2(headx[<span class="number">0</span>], Sn2);</span><br><span class="line">                        <span class="keyword">if</span> (!flag)<span class="comment">//如果存在就删除</span></span><br><span class="line">                        &#123;   </span><br><span class="line">                            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">                                headx[i]-&gt;Delete_2(headx[i], Sn2);</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;操作成功！ &quot;</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="number">2</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">                            headx[i]-&gt;FreeAll_2();</span><br><span class="line">                            headx[i] = nullptr;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                headx[<span class="number">0</span>]-&gt;Seeit_2(headx[<span class="number">0</span>]);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;请输入您要查看学生的学号 &quot;</span>;</span><br><span class="line">                inputString(Sn2);</span><br><span class="line">                headx[<span class="number">0</span>]-&gt;Find_2(headx[<span class="number">0</span>], <span class="number">4</span>, Sn2);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">                headx[<span class="number">0</span>]-&gt;Seeit_2(headx[<span class="number">0</span>]);</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;\n请输入您要修改学生的学号 &quot;</span>;</span><br><span class="line">                inputString(Sn2);</span><br><span class="line">                <span class="keyword">while</span> (headx[<span class="number">0</span>]-&gt;Find_2(headx[<span class="number">0</span>], <span class="number">4</span>, Sn2))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;\n您可以输入 1 以更改学号，2 以更改姓名，3 以更改高数成绩，4 以更改英语成绩，5 以更改C++成绩，0 以结束操作 \n&quot;</span>;</span><br><span class="line">                    <span class="built_in">cin</span>&gt;&gt;c;</span><br><span class="line">                    <span class="keyword">if</span> (!c) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (c &lt; <span class="number">3</span>) &#123;</span><br><span class="line">                        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请输入新学号/姓名！&quot;</span>;</span><br><span class="line">                        inputString(temp);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请输入新成绩！&quot;</span>;</span><br><span class="line">                        Grade[<span class="number">0</span>] = inputlnt();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">                        headx[i]-&gt;Change_2(headx[i], c, Sn2, temp, Grade[<span class="number">0</span>]);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (c == <span class="number">1</span>)Sn2 = temp;</span><br><span class="line">                &#125;</span><br><span class="line">                fflush(<span class="built_in">stdin</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;请输入您要查看学生的姓名 &quot;</span>;</span><br><span class="line">                inputString(Name2);</span><br><span class="line">                headx[<span class="number">0</span>]-&gt;Find_2(headx[<span class="number">0</span>], <span class="number">6</span>, Name2);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">                headx[<span class="number">0</span>]-&gt;EnterSee2(headx);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">                headx[<span class="number">0</span>]-&gt;CordReport_2(headx);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">9</span>:</span><br><span class="line">                <span class="keyword">goto</span> Menu1;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\t\t\t\t\tBye!期待您的下次使用\n\n\n&quot;</span>;</span><br><span class="line">                MessageBox(nullptr, TEXT(<span class="string">&quot;感谢您使用本程序&quot;</span>), TEXT(<span class="string">&quot;Bye!&quot;</span>), <span class="number">0</span>);</span><br><span class="line">                Exit(user, head, headx[<span class="number">0</span>], headx[<span class="number">1</span>], headx[<span class="number">2</span>], headx[<span class="number">3</span>]);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;输入有误，请重新输入\n&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="12-ShowMap-cpp"><a href="#12-ShowMap-cpp" class="headerlink" title="12.ShowMap.cpp"></a>12.ShowMap.cpp</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Everything.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ShowMap0</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;color 74&quot;</span>);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;\t     -------------------******************学生管理系统******************** *--------------------\n\n\n&quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot; --------------------******************账号只允许由1-18位英文与数字组成******************* **------------------------\n&quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;\n --------------------******************密码只允许由6-18位英文与数字组成******************** *------------------------\n&quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;\n\n\n\n\n&quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;\t\t                   (@^o^@) 欢迎使用学生信息管理系统   (⌒:⌒)\n&quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;\t\t                   (~):(~)                            (~)v(~) \n&quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;\t\t*****************************************                   \n&quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;\t\t******                                                                         \n&quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;\t\t**********                                                                     \n&quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;\t\t*****                               菜   单*****                               \n&quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;\t\t********                                                                       \n&quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;\t\t****                                1：登录****                                \n&quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;\t\t********                                                                       \n&quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;\t\t****                                2：注册****                                \n&quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;\t\t********                                                                     \n&quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;\t\t****                                0：退出****                                \n&quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;\t\t********                                                                       \n&quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;\t\t***********************************************                                \n&quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;\n\t\t                                请输入您的操作--&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">ShowMap1</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;color 06&quot;</span>);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;\n\n\n\n\n&quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;\t  -------------------******************学生管理系统*********************--------------------\n\n&quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;\n\t\t\t\t\t    * [1] 学生信息管理\n&quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;\n\t\t\t\t\t*     [2] 学生成绩管理\n&quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;\n\t\t\t\t\t*     [3] 修改密码\n&quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;\n\t\t\t\t\t*     [4] 退出登陆\n&quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;\n\t\t\t\t\t*     [5] 退出程序\n&quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;\n\n\n\n&quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;\t  -------------------*******************欢迎使用********************** **--------------------\n&quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;请您输入菜单上的按键--&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">ShowMap2</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;color 0E&quot;</span>);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;\n\n\n\n\n&quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;\t  -------------------******************学生信息管理******************** *--------------------\n\n\n&quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;\t\t\t*      [1] 添加学生信息*              [2] 删除学生信息\n\n&quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;\t\t\t*      [3] 查看学生信息*              [4] 以学号查询学生信息\n\n&quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;\t\t\t*      [5] 修改学生信息*              [6] 以姓名查询学生信息\n\n&quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;\t\t\t*      [7] 回到上一级*                [0] 退出程序\n\n&quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;\n\n\n\n&quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;\t  -------------------*******************欢迎使用********************** **--------------------\n&quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;请您输入菜单上的按键--&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">ShowMap3</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;color 0E&quot;</span>);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;\n\n\n\n\n&quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;\t  -------------------******************学生成绩管理******************** *--------------------\n\n\n&quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;\t\t\t*      [1]  录入学生成绩*              [2] 删除学生成绩\n\n&quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;\t\t\t*      [3]  查看学生成绩*              [4] 以学号查询学生成绩\n\n&quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;\t\t\t*      [5]  修改学生成绩*              [6] 以姓名查询学生成绩\n\n&quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;\t\t\t*      [7]  单科成绩排名*              [8] 学生成绩报告\n\n&quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;\t\t\t*      [9]  返回上一级*                [0] 退出程序\n\n&quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;\n\n\n\n&quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;\t  -------------------*******************欢迎使用********************** **--------------------\n&quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;请您输入菜单上的按键--&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ShowSeeit_1</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;\n\n\n\n\t----------------------******************学生信息查看******************** *--------------------\n\n\n&quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;\t-------------学号---------------姓名------------------联系方式-------------------宿舍号-----\n\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">heart</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    system(<span class="string">&quot;color 74&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">float</span> y = <span class="number">1.5f</span>; y &gt; <span class="number">-1.5f</span>; y -= <span class="number">0.1f</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;\t\t\t&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">float</span> x = <span class="number">-1.5f</span>; x &lt; <span class="number">1.5f</span>; x += <span class="number">0.05f</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">float</span> a = x*  x + y*  y - <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">putchar</span>(a*  a*  a - x*  x*  y*  y*  y &lt;= <span class="number">0.0f</span> ? <span class="string">&#x27;*&#x27;</span> : <span class="string">&#x27; &#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;\t\t\t       &quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;欢&quot;</span>;</span><br><span class="line">    Sleep(<span class="number">200</span>);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot; 迎&quot;</span>;</span><br><span class="line">    Sleep(<span class="number">200</span>);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot; 使&quot;</span>;</span><br><span class="line">    Sleep(<span class="number">200</span>);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot; 用&quot;</span>;</span><br><span class="line">    Sleep(<span class="number">200</span>);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot; 学&quot;</span>;</span><br><span class="line">    Sleep(<span class="number">200</span>);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot; 生&quot;</span>;</span><br><span class="line">    Sleep(<span class="number">200</span>);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot; 管&quot;</span>;</span><br><span class="line">    Sleep(<span class="number">200</span>);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot; 理&quot;</span>;</span><br><span class="line">    Sleep(<span class="number">200</span>);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot; 系&quot;</span>;</span><br><span class="line">    Sleep(<span class="number">200</span>);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot; 统！&quot;</span>;</span><br><span class="line">    Sleep(<span class="number">200</span>);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot; (请按任意键进入...)&quot;</span>;</span><br><span class="line">    <span class="built_in">cin</span>.ignore();</span><br><span class="line">    system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学校课程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>职业生涯规划书</title>
      <link href="/posts/%E5%AD%A6%E6%A0%A1%E8%AF%BE%E7%A8%8B/%E8%81%8C%E4%B8%9A%E7%94%9F%E6%B6%AF%E8%A7%84%E5%88%92%E4%B9%A6.html"/>
      <url>/posts/%E5%AD%A6%E6%A0%A1%E8%AF%BE%E7%A8%8B/%E8%81%8C%E4%B8%9A%E7%94%9F%E6%B6%AF%E8%A7%84%E5%88%92%E4%B9%A6.html</url>
      
        <content type="html"><![CDATA[<h1 id="一、自我分析"><a href="#一、自我分析" class="headerlink" title="一、自我分析"></a>一、自我分析</h1><h2 id="（一）职业兴趣—喜欢干什么"><a href="#（一）职业兴趣—喜欢干什么" class="headerlink" title="（一）职业兴趣—喜欢干什么"></a>（一）职业兴趣—喜欢干什么</h2><p>喜欢处理数据，文字等，喜欢软件的设计，编码，调试，测试等工作。</p><h2 id="（二）职业价值观—最看重什么"><a href="#（二）职业价值观—最看重什么" class="headerlink" title="（二）职业价值观—最看重什么"></a>（二）职业价值观—最看重什么</h2><ol><li><p>独立思考，了解事物怎样运行和作用</p></li><li><p>以自己的方式做事，或快或慢随自己所愿</p></li><li><p>报酬高，能拥有自己想要的事物</p></li><li><p>在怡人的环境里工作</p></li><li><p>在一个公平并能与之融洽相处的管理者手下工作</p></li></ol><h2 id="（三）职业能力—能够干什么"><a href="#（三）职业能力—能够干什么" class="headerlink" title="（三）职业能力—能够干什么"></a>（三）职业能力—能够干什么</h2><p>做事认真，踏实，学习能力强，具有一定的创造力和承压能力，专业基础扎实。</p><h2 id="（四）性格特征—适合干什么"><a href="#（四）性格特征—适合干什么" class="headerlink" title="（四）性格特征—适合干什么"></a>（四）性格特征—适合干什么</h2><p>做事深思熟虑，沉着冷静，善于自控，不善交际。</p><h2 id="（五）自我分析小结"><a href="#（五）自我分析小结" class="headerlink" title="（五）自我分析小结"></a>（五）自我分析小结</h2><p>我是一个内倾的人，喜欢软件方面的工作。对于自己发展方向,最大的希望就是成为有用之才,实现自己的人生价值和自己的梦想,同时喜欢创新,做事认真、投入,有很大的责任心。通过上面的分析,我对自己有了深刻的认识,在看到自己优点的同时还发现自己有许多的不足之处,我会取别人之长来弥补自己的不足之处。</p><h1 id="二、职业分析"><a href="#二、职业分析" class="headerlink" title="二、职业分析"></a>二、职业分析</h1><h2 id="家庭环境分析"><a href="#家庭环境分析" class="headerlink" title="家庭环境分析"></a>家庭环境分析</h2><p>父母对我的期望也是比较高的，父亲学历中学，他认为知识对于我将来的发展起到很大的作用，希望我能一直学习下去。家里条件一般，致使我从小养成了独立的习惯。</p><h2 id="学校环境分析"><a href="#学校环境分析" class="headerlink" title="学校环境分析"></a>学校环境分析</h2><p>软件工程我感觉学院的师资都还可以，老师都挺尽心尽责，学生大部分都挺好学的。课程量也不少，要求比较严格，考试周压力也挺大。该学的课程基本都安排了，只是自己还记不记得的问题。</p><h2 id="社会环境分析"><a href="#社会环境分析" class="headerlink" title="社会环境分析"></a>社会环境分析</h2><p>近几年国内就业的压力逐步加重，可能是历史上最巨大的。就业竞争激烈，我们应该有危机意识，认真学习理论知识，提高业务技能，为以后的工作发展打好坚实的基础。</p><h2 id="职业环境分析"><a href="#职业环境分析" class="headerlink" title="职业环境分析"></a>职业环境分析</h2><h3 id="行业分析"><a href="#行业分析" class="headerlink" title="行业分析"></a>行业分析</h3><p>伴随着互联网的发展，IT 人才的短缺现象将会越来越严重。在我国，IC 人才、网络存储人才、电子商务人才、信息安全人才、游戏技术人才严重短缺；在软件人才层次结构上，水平高的系统分析员和有行业背景的项目策划人员偏少，同时软件蓝领也比较缺乏。随着 IT 业越来越火，各大高校计算机专业报名的人数也越来越多。而近年来，随着毕业生人数激增，就业率与供求比例明显走低。</p><h3 id="职业分析"><a href="#职业分析" class="headerlink" title="职业分析"></a>职业分析</h3><p>软件工程师，目前有如下特点：<br>1.工作起点高，发展空间大。<br>2.企业缺口大，工作待遇高，环境好。<br>3.工作稳定，不用频繁跳槽。<br>4.复合型人才，工程师们需要掌握更多的编程语言。</p><h3 id="企业分析"><a href="#企业分析" class="headerlink" title="企业分析"></a>企业分析</h3><p>互联网企业，从事国内互联网公司开发岗位工作的同学收入相对其他行业和专业要高出很多的，当然国内互联网大厂的工作压力还是非常大的，入职之后在不加班的情况下也要工作到晚上八九点。<br>各大外企，对于实力较强的同学也可以考虑 Google，Microsoft 等外企的 IT 岗位，相比于国内的血汗厂，外企在国内 996 的情况要相对少很多，虽然工资相比于国内互联网公司要低一些，但是性价比较高。想进入 955 的外企，不仅要专业技术水平高，英语也要好。<br>各大国企、银行、公务员、事业单位计算机相关岗位，从事体制内的工作，虽然挣得少，但是生活质量是相对较高的。</p><h3 id="地域分析"><a href="#地域分析" class="headerlink" title="地域分析"></a>地域分析</h3><p>从就业区域的情况来看，不出意外，排名前四名分别为北、深、上、广四大一线城市，而省会城市杭州、成都、南京、武汉、西安也在前十排名中，而前十名的榜单中只有苏州为非省会城市。</p><h2 id="职业分析小结"><a href="#职业分析小结" class="headerlink" title="职业分析小结"></a>职业分析小结</h2><p>就业率发展平稳，但薪酬水平有所下降。随着高校研究生和本科学生的扩招，特别是计算机专业毕业人数的急剧增加，以及受到经济因素的影响，计算机专业毕业生的就业不如从前那样火爆，就业的整体质量存在明显下降。平均起步收入较高。同其他专业相比，计算机专业在就业刚开始的时候的收入算高的。就业面广，计算机领域涉及到东西很多，各行各业都会涉及到计算机专业的就业岗位，可以结合自己的兴趣和实际情况，来选择合适自己的职位。</p><h1 id="三、职业定位"><a href="#三、职业定位" class="headerlink" title="三、职业定位"></a>三、职业定位</h1><table><thead><tr><th>内部环境因素</th><th></th><th>优势因素 (S)</th><th>弱势因素 (W)</th><th></th></tr></thead><tbody><tr><td></td><td>做事比较认真、踏实，有浓厚的学习兴趣和必须的实力，尤其在计算机方面有着浓厚的兴趣。</td><td>性格较内向，并不善于与人交往和沟通。工作、学习有些保守，冒险精神不够，没有结合长远目标，并且创新本事有待提高。</td><td></td><td></td></tr><tr><td>外部环境因素</td><td></td><td>机会因素 (O)</td><td>威胁因素 (T)</td><td></td></tr><tr><td></td><td>IT 行业迅猛发展，就业工作岗位也比比皆是。在最近几年内 IT 在职场排行榜中仍旧处于所有行业中的 “ 老大 “。</td><td>当今比我优秀的人才很多，而机会不必须是均等的，这时就不单单是知识的比拼，更是对个人发现机会、展示自我并把握机会本事的考验。</td><td></td><td></td></tr><tr><td>职业目标</td><td>软件开发工程师</td><td></td><td></td><td></td></tr><tr><td>职业发展策略</td><td>希望进入长三角地区、最好是外企类型的组织</td><td></td><td></td><td></td></tr><tr><td>职业发展路径</td><td>走专家路线</td><td></td><td></td><td></td></tr><tr><td>具体路径</td><td>软件工程师——高级软件工程师——架构师</td><td></td><td></td><td></td></tr></tbody></table><h2 id="计划实施"><a href="#计划实施" class="headerlink" title="计划实施"></a>计划实施</h2><table><thead><tr><th>名称</th><th>短期计划</th></tr></thead><tbody><tr><td>时间跨度</td><td>2022&#x2F;7——2023&#x2F;7</td></tr><tr><td>总目标</td><td>找到暑期实习</td></tr><tr><td>分目标</td><td>学习 Java,计算机基础，掌握基本算法和数据结构</td></tr><tr><td>计划内容</td><td>上课认真听讲，课余学习其他内容，刷题</td></tr></tbody></table><table><thead><tr><th>名称</th><th>中期计划</th></tr></thead><tbody><tr><td>时间跨度</td><td>2023&#x2F;7——2025&#x2F;7</td></tr><tr><td>总目标</td><td>找到理想的工作</td></tr><tr><td>分目标</td><td>准备好面试所需的经历，经验，技能</td></tr><tr><td>计划内容</td><td>做项目，找实习，学专业知识，刷面试题</td></tr></tbody></table><table><thead><tr><th>名称</th><th>长期计划</th></tr></thead><tbody><tr><td>时间跨度</td><td>2025——2030</td></tr><tr><td>总目标</td><td>成为架构师</td></tr><tr><td>分目标</td><td>提高自己的能力</td></tr><tr><td>计划内容</td><td>不断开阔自己眼界，提高自己的管理，沟通能力</td></tr></tbody></table><h1 id="评估调整"><a href="#评估调整" class="headerlink" title="评估调整"></a>评估调整</h1><h2 id="1、评估的内容"><a href="#1、评估的内容" class="headerlink" title="1、评估的内容"></a>1、评估的内容</h2><h3 id="职业目标评估"><a href="#职业目标评估" class="headerlink" title="职业目标评估"></a>职业目标评估</h3><p>对于自己制定的目标规划,可能会是一个失败的计划,但是只要去努力,无论失败还是成功,都将是一次巨大的收获,在今后的工作中,会不断完整自己的规划,将规划完善到最佳,将工作做到最佳,将人生规划到最佳。</p><h3 id="职业路径评估"><a href="#职业路径评估" class="headerlink" title="职业路径评估"></a>职业路径评估</h3><p>坚持自己的整体职业规划路径,中途中的一些小毛病可以适当的调整。如果规划发展方向有问题,可以选择更好的规划方向,但是规划中整体大局不变。</p><h3 id="实施策略评估"><a href="#实施策略评估" class="headerlink" title="实施策略评估"></a>实施策略评估</h3><p>如果出现一些变故,或者家庭需要,会去考虑改变行的策略,会在生活和工作中寻找一个平衡点。</p><h3 id="其它因素评估"><a href="#其它因素评估" class="headerlink" title="其它因素评估"></a>其它因素评估</h3><p>假如遇到什么事,我会根据实际情况去及时的调整及评估。</p><h2 id="2、评估的时间"><a href="#2、评估的时间" class="headerlink" title="2、评估的时间"></a>2、评估的时间</h2><p>一般情况下，我定期去评估和规划，当出现特殊情况时，我会随时评估并进行相应的调整。</p>]]></content>
      
      
      <categories>
          
          <category> 学校课程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>软件开发方法</title>
      <link href="/posts/%E5%AD%A6%E6%A0%A1%E8%AF%BE%E7%A8%8B/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E6%96%B9%E6%B3%95.html"/>
      <url>/posts/%E5%AD%A6%E6%A0%A1%E8%AF%BE%E7%A8%8B/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E6%96%B9%E6%B3%95.html</url>
      
        <content type="html"><![CDATA[<h1 id="一、-选题内容"><a href="#一、-选题内容" class="headerlink" title="一、 选题内容"></a>一、 选题内容</h1><p>在线购物系统</p><h1 id="二、-需求分析"><a href="#二、-需求分析" class="headerlink" title="二、 需求分析"></a>二、 需求分析</h1><p>在线购物系统所包含的基本功能为：<br>商家注册登录后可将新上架的商品信息通过系统发布到网上或对已有商品进行管理。<br>用户通过系统浏览商品，查看商品详细信息，或者直接搜索对应商品，还可对所属订单进行管理。<br>顾客注册登录之后，选择商品可加入购物车或下单购买，通过第三方支付平台支付，发货过程还需经过物流，还可进行售后服务。</p><h1 id="三、-系统设计"><a href="#三、-系统设计" class="headerlink" title="三、 系统设计"></a>三、 系统设计</h1><p><img src="/../../img/blog/254561b7f5b7cbdf0fa706baac7f16a1_MD5.jpg"></p><h1 id="四、-实验内容整合"><a href="#四、-实验内容整合" class="headerlink" title="四、 实验内容整合"></a>四、 实验内容整合</h1><h2 id="用况图"><a href="#用况图" class="headerlink" title="用况图"></a>用况图</h2><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>1、确定系统边界<br>首先，在线购物系统的外部活动者有用户，商家和顾客，这些都不属于系统本身，是系统的外部环境。<br>其次，在线购物系统需要涉及到第三方支付平台与物流运输，他们也是系统的外部环境。<br>第三，在线购物系统需要运行在操作系统上，运行过程中可能要进行生成文件,获取时间等操作，这涉及到操作系统的 API，所以操作系统对于在线购物系统来说也是外部环境。<br>第四，在线购物系统的使用需要涉及到手机或者电脑等设备，这些设备对于系统来说也是外部环境。<br>2、识别参与者<br>在线购物系统需要用户，顾客和商家的直接使用，所以他们是参与者。<br>在线购物系统的使用过程中会涉及第三方支付平台与物流运输，所以他们也是参与者。<br>外部系统方面有操作系统，而设备方面则需要考虑电脑、手机等智能设备。<br>3、捕获用况<br>从用户方面考虑，用户需要通过登陆注册的操作成为商家或者是顾客。通过修改信息，订单管理，订单查阅，修改订单来向系统读写信息。而顾客需要在此系统的主要任务是购物，他需要搜索浏览商品，管理购物车，以及购买商品，支付等操作。商家的主要任务则是管理自己商店的商品，将商品打包派送，修改货架信息。<br>从系统功能的角度看，在线购物系统需完成顾客购买商品，商家对于顾客的售后服务，如咨询与退换货<br>从场景的角度来看，在线购物系统需要涉及到物流来对商品进行派送运输，需要第三方支付平台来令用户完成支付，同时根据场景模拟，支付还可分为立即支付与货到付款等方式。<br>4、建立用况图<br>根据上述涉及到的参与者和捕获的用况来建立用况图，分析参与者与参与者，参与者与用况，用况与用况之间的关系。例如用户是顾客与商家的泛化，而用户与登陆注册，修改信息等用况是关联关系。订单管理与订单查询是包含关系，立即支付、货到付款与支付是继承关系，购买商品与购物车管理是扩展关系。<br>5、检查与调整<br>检查每个参与者是否都至少有一个用况关联，考虑了参与者与参与者是否有继承，考虑了用况的细化分解与用况之间关系的确立。</p><h3 id="模型图"><a href="#模型图" class="headerlink" title="模型图"></a>模型图</h3><p><img src="/../../img/blog/4b43099a7b937fdd9fec26db69f20386_MD5.jpg"></p><h3 id="用况描述"><a href="#用况描述" class="headerlink" title="用况描述"></a>用况描述</h3><h4 id="用况一"><a href="#用况一" class="headerlink" title="用况一"></a>用况一</h4><p>用况名：订单管理<br>简述：” 订单管理 “ 主要为用户，即顾客或商家提供订单的查询和更改<br>参与者：用户，顾客，商家<br>包含：包含订单查询和修改订单两个用况<br>扩展：无<br>继承：无<br>前置条件：用户登录成功<br>细节：</p><ol><li><p>在主界面，用户选择订单管理，进入界面</p></li><li><p>在订单管理界面，用户进行查询订单或直接选择订单</p></li><li><p>对于选中订单，用户可以进行修改或删除</p></li><li><p>修改完成后点击确认后结束</p></li></ol><p>后置条件：对于要修改的订单，修改信息必须填写完整<br>例外：</p><ul><li>用户点击确认时修改信息不完全</li></ul><p>（1）系统提示信息：修改信息未填写完全<br>（2）用户确认信息<br>（3）返回细节第 3 步<br>限制：对于顾客而言，可修改或删除的订单应是待付款订单<br>注释：无</p><h4 id="用况二"><a href="#用况二" class="headerlink" title="用况二"></a>用况二</h4><p>用况名：购买商品<br>简述：” 购买商品 “ 为商家顾客提供购买所需商品的提交订单和支付功能<br>参与者：顾客<br>包含：包含提交订单和支付两个用况<br>扩展：扩展它的用况有购物车管理<br>继承：无<br>前置条件：顾客登录成功<br>细节：<br>①基本流程</p><ol><li><p>客户在购物车或商品界面选择要确定购买的商品以及数量，点击提交订单</p></li><li><p>客户在订单页面填写收货地址等信息</p></li><li><p>选择支付方式，完成支付</p></li><li><p>系统提示交易成功</p></li></ol><p>②可选流程</p><ol><li><p>选择优惠方式（红包&#x2F;积分）</p></li><li><p>购买运费险</p></li></ol><p>后置条件：生成订单并变为待发货状态<br>例外：</p><ul><li>某商品数量不足或有购买数量限制<br>（1）系统提示信息：该商品剩余数量&#x2F;该商品限购数量<br>（2）顾客确认消息<br>（3）返回基本流程第 1 步</li><li>所选择的的第三方支付系统资金不足<br>（1）系统提示信息：账户资金不足，请重新选择支付方式<br>（2）顾客确认信息<br>（3）返回基本流程第 3 步</li></ul><p>限制：下单数量不得超过上限<br>注释：无</p><h4 id="用况三"><a href="#用况三" class="headerlink" title="用况三"></a>用况三</h4><p>用况名：商品派送<br>简述：商家通过商品派送将顾客所购买的商品打包出货<br>参与者：商家，物流<br>包含：被商品管理所包含<br>扩展：无<br>继承：无<br>前置条件：商家登录成功<br>细节：</p><ol><li><p>待顾客下单后，发货状态会改为待发货，商家会确认顾客的订单信息，如顾客的收货地址与联系方式是否正确，顾客是否有备注要求，收款是否到达后台账户。</p></li><li><p>如订单有误，商家可以修改或取消订单，如无误，商家则分配订单到物流配送部门进行备货，出货的处理。</p></li><li><p>同时，商家还会根据线下配送情况修改网上订单的配送状态进行标识，如待发货，待收货等。</p></li></ol><p>后置条件：发货成功<br>例外：</p><ul><li><p>某商品存在物流限制无法送达顾客收货地点时<br>（1）商家提示顾客物流受限无法送达<br>（2）顾客选择退货处理</p></li><li><p>顾客订单超过设定处理时间</p><pre><code>  （1）系统提示信息：顾客订单超过预定处理时间（2）商家确认信息（3）商家处理订单</code></pre></li></ul><p>限制：用户订单信息必须真实有效<br>注释：无</p><h4 id="用况四"><a href="#用况四" class="headerlink" title="用况四"></a>用况四</h4><p>用况名：修改上架商品<br>简述：商家想调整销售策略时，可以使用修改上架商品操作<br>参与者：商家<br>包含：被商品管理所包含<br>扩展：无<br>继承：无<br>前置条件：商家登录成功<br>细节：</p><ol><li><p>商家进入商品管理界面</p></li><li><p>商家根据最近的销售情况结合外部环境及政策来对上架商品的价格进行调整，也可查看上架商品的库存量，对热销商品进行补货，对滞销商品进行降价或者活动促销等操作。</p></li><li><p>如若有新品，商家也可点击添加商品，填写完商品的信息，点击确定，即可上架商品。</p></li></ol><p>后置条件：上架商品种类或信息改变<br>例外：</p><ul><li>上架新品时商品信息填写不完整<br>（1）系统提示信息：商品信息未填写完整<br>（2）商家确认消息<br>（3）返回商品信息填写界面</li><li>修改后的商品信息存在违规内容<br>（1）系统提示信息：商品内容违规请整改<br>（2）商家确认信息<br>（3）商家重新更改商品信息</li></ul><p>限制：无<br>注释：无</p><h4 id="用况五"><a href="#用况五" class="headerlink" title="用况五"></a>用况五</h4><p>用况名：支付<br>简述：顾客使用第三方支付平台进行支付来购买商品<br>参与者：顾客，第三方支付平台<br>包含：被购买商品所包含<br>扩展：无<br>继承：一般用况为支付，特殊用况为立即支付和货到付款<br>前置条件：顾客登录成功<br>细节：</p><ol><li><p>顾客选择支付方式</p></li><li><p>选择立即支付，顾客输入支付所需的信息并支付</p></li><li><p>选择货到付款，顾客收到商品，检查确认后签收付款</p></li><li><p>系统提示支付成功</p></li></ol><p>后置条件：账户扣款成功<br>例外：</p><ul><li>所选择的的第三方支付系统资金不足<br>（1）系统提示信息：账户资金不足，请重新选择支付方式<br>（2）顾客确认信息<br>（3）顾客重新选择支付方式</li></ul><p>限制：需实名认证后才可支付<br>注释：无</p><h2 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h2><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><h4 id="1）识别对象与类"><a href="#1）识别对象与类" class="headerlink" title="1）识别对象与类"></a>1）识别对象与类</h4><p>从系统边界、问题域、系统责任、名词代词和名词短语等角度出发，可以识别出的对象有游客、注册用户、商家、店铺、物流、商品、操作系统、电脑、手机、客服、交易订单、支付手段、购物车、订阅商铺等多种对象。<br>通过审查与筛选，从舍去无用对象，精简对象以及推迟到 OOD 考虑的对象等角度出发，发现如操作系统、电脑、手机等对象可以舍去，而商家和店铺则能够进行合并。<br>抽象出类并进行调整，将对象依据属性和操作进行分类，并对分好的类进行调整，如商家和顾客虽拥有共同部分，如用户名、账号、密码等，但两类属性与操作并不相同，则考虑建立一个用户类形成继承关系。</p><h4 id="2）类的属性与操作"><a href="#2）类的属性与操作" class="headerlink" title="2）类的属性与操作"></a>2）类的属性与操作</h4><p>识别出类的属性与操作、并对其进行审查与调整，如明确该属性或操作是否是否提供真正对系统有用信息、该属性是否描述的是这个类的特征，一个操作是否只完成一项明确定义的、相对完整而单一的功能。</p><h4 id="3）确定类之间的关系"><a href="#3）确定类之间的关系" class="headerlink" title="3）确定类之间的关系"></a>3）确定类之间的关系</h4><h5 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h5><p>审查类的属性与操作不难发现用户类中如存在支付，管理商品等操作并不适合用户类的全部对象，管理商品应属于商家，而支付则属于顾客。因此因在用户类下建立两个特殊类：商家与顾客，来形成继承</p><h5 id="关联"><a href="#关联" class="headerlink" title="关联"></a>关联</h5><p>通过类的静态联系可以看出，如用户与商品，商家与客服售后，顾客与订单等类中都存在关联关系</p><h5 id="聚合与组合"><a href="#聚合与组合" class="headerlink" title="聚合与组合"></a>聚合与组合</h5><p>顾客与订阅店铺、购物车构成一个整体，且订阅店铺、购物车不能独立于顾客存在，因此为组合关系</p><h5 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h5><p>商家对商品进行更新的同时，如果顾客订阅该店铺，顾客订阅店铺中的内容也会发生变化，因此两者存在依赖关系</p><h3 id="模型图-1"><a href="#模型图-1" class="headerlink" title="模型图"></a>模型图</h3><p><img src="/../../img/blog/fef1521c0bd0e1c7e51a248dd2ec24d8_MD5.jpg"></p><h1 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h1><p>软件开发方法这门课使我初步了解了面向对象的概念和它的基本思想，基本原则，并且基本掌握了 UML 语言的用法。通过实验，我对于如何建立需求模型——用况图，如何建立基本模型——类图有了更多的理解。<br>在建立需求模型中，我通过确定系统边界，通过交互识别参与者，捕获用况等方法建模得到了在线购物系统的用况图，并以此加深了对系统功能相互关系的理解，明白了外部事物如何使用系统以及系统所提供的功能，从而能更好地设计系统功能，使系统责任更加全面具体。<br>在建立基本模型中，我明白了对象和类与参与者的不同，并通过识别系统中的对象与类，确定了类的属性和操作以及类之间的关系后构建起在线购物系统的类图，在此过程中对于类的抽象和他们之间的各种关系有了更加深刻的理解，能够在实际问题中更好地通过编程构建类。<br>虽然最后因为种种原因这门课的内容并没有上完全，但它面向对象分析的思想和方法都对我有了一定的帮助，让我能够快速地分析出系统的功能以及结构，从而让编程变得更加轻松。</p>]]></content>
      
      
      <categories>
          
          <category> 学校课程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>MySQL忘记密码的修改密码方法</title>
      <link href="/posts/%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7/Mysql/MySQL%E5%BF%98%E8%AE%B0%E5%AF%86%E7%A0%81%E7%9A%84%E4%BF%AE%E6%94%B9%E5%AF%86%E7%A0%81%E6%96%B9%E6%B3%95.html"/>
      <url>/posts/%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7/Mysql/MySQL%E5%BF%98%E8%AE%B0%E5%AF%86%E7%A0%81%E7%9A%84%E4%BF%AE%E6%94%B9%E5%AF%86%E7%A0%81%E6%96%B9%E6%B3%95.html</url>
      
        <content type="html"><![CDATA[<h1 id="第一步：关闭-Mysql-服务"><a href="#第一步：关闭-Mysql-服务" class="headerlink" title="第一步：关闭 Mysql 服务"></a>第一步：关闭 Mysql 服务</h1><p>首先先停止 mysql 服务。可通过 net stop mysql,<img src="/../../../img/blog/3d1208dd95dda690b90f32e1fcf9f6bb_MD5.png" alt="image.png">9f6bb_MD5.png)</p><h1 id="第二步：跳过-Mysql-密码验证"><a href="#第二步：跳过-Mysql-密码验证" class="headerlink" title="第二步：跳过 Mysql 密码验证"></a>第二步：跳过 Mysql 密码验证</h1><p>进入命令提示符（管理员登陆）操作，进入 mysql 目录中 bin 文件夹下，使用 mysqld -console –skip-grant-tables –share<img src="/../../../img/blog/44e642cb9bc6960e6dd0d0b304e91a4d_MD5.png" alt="image.png">b304e91a4d_MD5.png)<br>输入执行后没有反馈，新开一个管理员窗口重新执行。（这是第二个窗口）<br>进入目录后，确保自己已经关闭了 Mysq<img src="/../../../img/blog/9634323dbbca0d39b1dbd8b8e53f6daa_MD5.png" alt="image.png">bd8b8e53f6daa_MD5.png)<br>关闭 Mysql 服务之后，继续在 D:\mysql-8.0.19-winx64\bin 目录下进行操作：<br>输入 mysqld -console –skip-grant<img src="/../../../img/blog/a4fc001803694ae84a7f9b1ec529da44_MD5.png" alt="image.png">4a7f9b1ec529da44_MD5.png)</p><h1 id="第三步：无密码方式进入-Mysql"><a href="#第三步：无密码方式进入-Mysql" class="headerlink" title="第三步：无密码方式进入 Mysql"></a>第三步：无密码方式进入 Mysql</h1><p>在上述步骤之后，再打开一个管理员模式运行的 cmd.exe （这是第三个窗口）<br>进入 mysql 下的 bin 目录后，直接登录 mysql<br>不需要通过 net start mysql 打开 mysql 服务<br>在命令行中输入以下代码</p><pre><code>cd D:\mysql-8.0.19-winx64\bin(此处输入自己电脑上的安装目录)mysql -u root -p![image.png](../../../img/blog/6e953ef22d472b9e51e4d80a83c19984_MD5.png)e953ef22d472b9e51e4d80a83c19984_MD5.png)# 第四步：将登陆密码设置为空输入代码，将密码设置为空（**此时还不能直接修改密码，必须先设置为空，否则会报错**）```basicuse mysql; (使用mysql数据表)update user set authentication_string=&#39;&#39; wh![image.png](../../../img/blog/c3cc01a12044ba39eba3a59f19a75554_MD5.png)./img/blog/c3cc01a12044ba39eba3a59f19a75554_MD5.png)# 第五步：更改自己的登陆密码## 1.关闭前两个 Cmd 窗口 (一定要关闭！)；## 2.在第三个窗口中输入代码；```basicnet stop mysql(关闭mysql服务,虽然会显示没有开启服务，但是以防万一)net start mysql(再打开mysql服务)cd D:\mysql-8.0.19-winx64\bin  (此处输入自己电脑上的安装目录)mysql -u root -p(此处会显示输入密码，直接回车就好了，第四步我们已经将他置为空了)ALTER USER![image.png](../../../img/blog/0bdf0d296cd61a0be8e9432b287e375c_MD5.png)e.png](../../../../img/blog/0bdf0d296cd61a0be8e9432b287e375c_MD5.png)## 3![image.png](../../../img/blog/42e7f6292604a68ac074ee231f80bb93_MD5.png)![image.png](../../../../img/blog/42e7f6292604a68ac074ee231f80bb93_MD5.png)</code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程工具 </category>
          
          <category> Mysql </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Github 代理加速或 CDN 加速</title>
      <link href="/posts/%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7/Git/Github%20%E4%BB%A3%E7%90%86%E5%8A%A0%E9%80%9F%E6%88%96%20CDN%20%E5%8A%A0%E9%80%9F.html"/>
      <url>/posts/%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7/Git/Github%20%E4%BB%A3%E7%90%86%E5%8A%A0%E9%80%9F%E6%88%96%20CDN%20%E5%8A%A0%E9%80%9F.html</url>
      
        <content type="html"><![CDATA[<h1 id="WSL-使用-Proxy-连接-Github"><a href="#WSL-使用-Proxy-连接-Github" class="headerlink" title="WSL 使用 Proxy 连接 Github"></a>WSL 使用 Proxy 连接 Github</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> hostip=127.0.0.1 </span><br><span class="line"><span class="built_in">export</span> hostport=10808 // 取决于win的proxy工具设置的端口号</span><br><span class="line"><span class="built_in">export</span> HTTPS_PROXY=<span class="string">&quot;socks5://<span class="variable">$&#123;hostip&#125;</span>:<span class="variable">$&#123;hostport&#125;</span>&quot;</span>;</span><br><span class="line"><span class="built_in">export</span> HTTP_PROXY=<span class="string">&quot;socks5://<span class="variable">$&#123;hostip&#125;</span>:<span class="variable">$&#123;hostport&#125;</span>&quot;</span>;</span><br><span class="line"><span class="built_in">export</span> ALL_PROXY=<span class="string">&quot;socks5://<span class="variable">$&#123;hostip&#125;</span>:<span class="variable">$&#123;hostport&#125;</span>&quot;</span>;</span><br></pre></td></tr></table></figure><p>下面的命令只针对 github.com，在国内还可能会用到 gitee.com，所以不能将所有的 git 站点都添加上代理。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置代理</span></span><br><span class="line">git config --global http.https://github.com.proxy socks5://127.0.0.1:1086</span><br><span class="line"><span class="comment"># 取消代理</span></span><br><span class="line">git config --global --<span class="built_in">unset</span> http.https://github.com.proxy</span><br></pre></td></tr></table></figure><p>如果没有代理也不要急，有专门的 cdn 加速：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git config --global url.<span class="string">&quot;https://github.com.cnpmjs.org&quot;</span>.insteadOf <span class="string">&quot;https://github.com&quot;</span></span><br><span class="line">git config --global url.<span class="string">&quot;https://ghproxy.com&quot;</span>.insteadOf <span class="string">&quot;https://github.com&quot;</span> </span><br><span class="line">git config --global url.<span class="string">&quot;https://hub.fastgit.xyz/&quot;</span>.insteadOf <span class="string">&quot;https://github.com/&quot;</span></span><br></pre></td></tr></table></figure><p>因为没有官方 CDN，上面都是用爱发电，没准哪天就挂了。</p><h1 id="在-Terminal-中通过代理访问-GitHub"><a href="#在-Terminal-中通过代理访问-GitHub" class="headerlink" title="在 Terminal 中通过代理访问 GitHub"></a>在 Terminal 中通过代理访问 GitHub</h1><h2 id="通过代理访问-GitHub"><a href="#通过代理访问-GitHub" class="headerlink" title="通过代理访问 GitHub"></a>通过代理访问 GitHub</h2><p>从国内访问 GitHub 速度慢是一个困扰大家很久的问题，使用代理可以提高网页浏览和下载 ZIP 文件的速度。但是在 Terminal 中，git 工具在访问 <a href="https://github.com/">github.com</a> 时，是不会经过代理的，这就导致了执行 <code>clone</code>、<code>pull</code>、<code>push</code> 等命令时，传输速度只有可怜的 10KiB&#x2F;s。</p><blockquote><p>如果使用代理之后网页加载速度还是很慢，有可能是没有打开代理的 <strong>全局模式（Global Mode）</strong>。因为 GitHub 在国内没有被封锁，只是被限速了，所以有的代理会 “ 智能 “ 地忽略对 <a href="https://github.com/">github.com</a> 的访问请求。</p></blockquote><p>论坛上常见解决方法是更改 <code>/etc/hosts</code> 文件，但这个方法成功率不是很高，而且因为 IP 地址变动的问题，每次都要重新配置。还有一个方法是通过 <a href="https://gitee.com/">gitee.com</a> 来中转仓库，但是这只适合用于一次性的克隆，如果要经常获取别人的提交，这种方法就过于繁琐了。<br>下面我就来讲解一下怎么让 git 工具通过代理访问 <a href="https://github.com/">github.com</a>。</p><hr><h1 id="第一步：配置代理"><a href="#第一步：配置代理" class="headerlink" title="第一步：配置代理"></a>第一步：配置代理</h1><p>从代理客户端设置中找到 <strong>允许其他设备连接本机代理</strong> 选项，并输入一个代理端口：<br><img src="/../../../img/blog/6e9499d89107234ed9447832bfb16949_MD5.png"><br><strong>注意：</strong></p><ul><li>每个代理的设置界面可能不一样，但是应该都有这些选项。</li><li>0～1023 端口为系统端口，所以这里选择 1024～65535 之间的端口。</li><li>如果有 SOCKS5 协议，也可以选择一个端口使用。</li></ul><h1 id="第二步：配置-Git-工具"><a href="#第二步：配置-Git-工具" class="headerlink" title="第二步：配置 Git 工具"></a>第二步：配置 Git 工具</h1><h2 id="设置-Git-局部代理"><a href="#设置-Git-局部代理" class="headerlink" title="设置 Git 局部代理"></a>设置 Git 局部代理</h2><p>如果你想在本地已有的仓库中，让 <code>pull</code> 或者 <code>push</code> 命令经过代理，就需要将 git 工具的代理设置为上一步中输入的端口（我的端口是 41091）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> path/to/your/repo/</span><br><span class="line">$ git config http.proxy http://127.0.0.1:41091</span><br><span class="line">$ git config https.proxy https://127.0.0.1:41091</span><br><span class="line">$ git config --list <span class="comment"># 查看设置结果</span></span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><ul><li>这里使用的是 git 工具的 <strong>局部代理</strong>（没有 <code>--global</code> 标示），所以仅该目录下的 git 命令会经过代理。</li><li>127.0.0.1 是 localhost 的 IP 地址，如果你的代理不在同一个计算机上，就需要输入对应的 IP 地址。</li><li>如果上一步选择了 SOCKS5 协议，使用以下命令：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config http.proxy socks5://127.0.0.1:1090</span><br><span class="line">$ git config https.proxy socks5://127.0.0.1:1090</span><br></pre></td></tr></table></figure><ul><li>如果想要停用代理，输入以下命令：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --unset http.proxy</span><br><span class="line">$ git config --unset https.proxy</span><br></pre></td></tr></table></figure><h2 id="设置-Git-全局代理"><a href="#设置-Git-全局代理" class="headerlink" title="设置 Git 全局代理"></a>设置 Git 全局代理</h2><p>如果你想让 <code>clone</code> 命令经过代理，首先需要设置 git 工具的 <strong>全局代理</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global http.proxy http://127.0.0.1:41091</span><br><span class="line">$ git config --global https.proxy https://127.0.0.1:41091</span><br></pre></td></tr></table></figure><p>在 <code>clone</code> 完成之后，记得停用全局代理，否则之后所有的 git 命令都会经过代理：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global --unset http.proxy</span><br><span class="line">$ git config --global --unset https.proxy</span><br></pre></td></tr></table></figure><p>如果想要在克隆的文件夹中打开局部代理，可以参照第一种情况。</p><h1 id="第三步：访问-GitHub"><a href="#第三步：访问-GitHub" class="headerlink" title="第三步：访问 GitHub"></a>第三步：访问 GitHub</h1><p>现在就可以用代理的最高限速访问 <a href="https://github.com/">github.com</a> 啦！我在测试中，<code>git pull</code> 的平均速度可以达到 10MiB&#x2F;s。<br><img src="/../../../img/blog/497b63211b4cbaa8156e9558551f67d7_MD5.png"></p><hr><h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><p>如果有的小伙伴不想在 Terminal 里设置 git 工具，还可以使用 <strong>GitHub Desktop</strong> （<a href="https://desktop.github.com/">点这里下载</a>）来管理本地的 GitHub 仓库。只要打开代理，不需要任何设置，GitHub Desktop 就会自动经过代理访问 GitHub 的服务器。</p><h1 id="下载单个-Github-文件夹（实际下载整个文件夹，速度还行）"><a href="#下载单个-Github-文件夹（实际下载整个文件夹，速度还行）" class="headerlink" title="下载单个 Github 文件夹（实际下载整个文件夹，速度还行）"></a>下载单个 Github 文件夹（实际下载整个文件夹，速度还行）</h1><p>刚写了个库 <a href="https://link.zhihu.com/?target=https://github.com/ykfe/dclone">dclone</a>,看了一眼应该是 github 上最简单的实现其他的库实现都写的特别复杂，可以让你只下载单个文件夹提升你的下载速度。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ npm i -g dclone</span><br><span class="line">$ dclone <span class="attr">https</span>:<span class="comment">//github.com/ykfe/egg-react-ssr/tree/dev/example/ssr-with-loadable</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程工具 </category>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机/编程工具/git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Cpp环境搭建</title>
      <link href="/posts/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Cpp%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA.html"/>
      <url>/posts/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Cpp%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA.html</url>
      
        <content type="html"><![CDATA[<h1 id="Window"><a href="#Window" class="headerlink" title="Window"></a>Window</h1><p>这套环境是 VSCode+MinGW（MSYS2）&#x2F;Msvc+Clangd+Xmake</p><h1 id="msvc"><a href="#msvc" class="headerlink" title="msvc"></a>msvc</h1><p><a href="https://visualstudio.microsoft.com/zh-hans/visual-cpp-build-tools/">Microsoft C++ 生成工具 - Visual Studio</a></p><h2 id="MinGW"><a href="#MinGW" class="headerlink" title="MinGW"></a>MinGW</h2><p>首先使用 scoop 安装 msys2（在 main bucket 中就有）：<br><code>scoop install msys2 </code><br>msys2 镜像源替换<br><a href="https://mirrors.ustc.edu.cn/help/msys2.html">https://mirrors.ustc.edu.cn/help/msys2.html</a><br>终端中输入 <code>msys2</code> 进入环境，下载 minGW：<br><code>pacman -S mingw-w64-x86_64-toolchain </code><br>下面会提示选择哪些工具，如果不是硬盘空间实在有限的话，直接回车默认安装全部即可。<br>随后找到 minGW 的 bin 目录（这里推荐一手 Listary，直接搜索 <code>g++.exe</code> 打开文件目录即可，非常方便），添加环境变量（环境变量一般重启才生效），此时 GCC 编译器就算是安装成功了。</p><h2 id="Clangd"><a href="#Clangd" class="headerlink" title="Clangd"></a>Clangd</h2><p>在 vscode 扩展商店中搜索 clangd 下载，完成后右下角会弹窗提醒你安装 clangd server，点击 Install 即可直接安装，这一点非常便捷。</p><h3 id="自身配置"><a href="#自身配置" class="headerlink" title="自身配置"></a>自身配置</h3><p><a href="https://clangd.llvm.org/config">Configuration (llvm.org)</a><br><a href="https://github.com/clangd/clangd/discussions/1170">为什么 windows 上的 clangd 找不到标准头文件</a><br><a href="https://github.com/clangd/clangd/discussions/1510">clangd 找不到 iostream 和其他标准库</a><br><a href="https://github.com/clangd/clangd/discussions/1573">msvc with clangd · clangd&#x2F;clangd · Discussion #1573 (github.com)</a><br><code>&lt;driver&gt; -E -v -x c++ -</code> 查看是否支持 clangd 用于尝试从驱动程序中提取内置包含的相同标志</p><ol><li><p>在工程目录下新建一个<strong>文件</strong>，名为 <code>.clangd</code>，或者编辑 <code>%LocalAppData%\clangd\config.yaml</code>, 通常为 <code>C:\Users\Bob\AppData\Local\clangd\config.yaml</code></p></li><li><p>在文件中添加</p></li></ol><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">CompileFlags:</span></span><br><span class="line">  <span class="attr">Add:</span> [<span class="string">&quot;-IC:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.34.31933\\include&quot;</span>]<span class="comment">#添加头文件</span></span><br><span class="line"><span class="attr">Diagnostics:</span></span><br><span class="line">  <span class="attr">UnusedIncludes:</span> <span class="string">Strict</span></span><br><span class="line">  <span class="attr">ClangTidy:</span></span><br><span class="line">    <span class="attr">Add:</span></span><br><span class="line">      [</span><br><span class="line">        <span class="string">performance-*</span>,</span><br><span class="line">        <span class="string">bugprone-*</span>,</span><br><span class="line">        <span class="string">portability-*</span>,</span><br><span class="line">        <span class="string">modernize-*</span>,</span><br><span class="line">      ]</span><br><span class="line">    <span class="attr">Remove:</span> <span class="string">modernize-use-trailing-return-type</span></span><br><span class="line">    <span class="attr">CheckOptions:</span></span><br><span class="line">      <span class="attr">WarnOnFloatingPointNarrowingConversion:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><h3 id="Mingw"><a href="#Mingw" class="headerlink" title="Mingw"></a>Mingw</h3><p>clangd 默认直接绑定了 VS 路径下的 MSVC 库，如果需要修改为 MinGW 则要改动 target。<br>配置如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**********</span></span><br><span class="line"><span class="comment">* Clangd *</span></span><br><span class="line"><span class="comment">**********/</span></span><br><span class="line"><span class="comment">// Clangd 运行参数(在终端/命令行输入 clangd --help-list-hidden 可查看更多)</span></span><br><span class="line"><span class="attr">&quot;clangd.arguments&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">  <span class="comment">//设置clangd server的驱动库路径，这里我设置了mingw的路径，但似乎没有效果（clangd仍然链接到了MSVC当中）</span></span><br><span class="line">  <span class="string">&quot;--query-driver=D:\\Scoop\\apps\\msys2\\current\\mingw64\\bin\\x86_64-w64-mingw32-g++.exe&quot;</span><span class="punctuation">,</span></span><br><span class="line">   </span><br><span class="line"><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line"><span class="comment">// clangd所在路径</span></span><br><span class="line"><span class="attr">&quot;clangd.path&quot;</span><span class="punctuation">:</span> <span class="string">&quot;D:\\Scoop\\apps\\llvm\\current\\bin\\clangd.exe&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="comment">// 默认编译器选项：在 clangd 没能找到 compile_flags.json 文件时采用</span></span><br><span class="line"><span class="comment">// 缺陷是不能如读取到 compile_flags.json 时一样直接索引同一项目的不同文件，因为没有它 clangd 仅能保守地分析</span></span><br><span class="line"><span class="comment">//系统头文件、当前文件、当前文件`#include`的文件</span></span><br><span class="line"><span class="comment">// compile_flags.json 可通过 CMake 等工具生成</span></span><br><span class="line"><span class="attr">&quot;clangd.fallbackFlags&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">  <span class="comment">//包含头文件</span></span><br><span class="line">  <span class="string">&quot;-ID:\\Scoop\\apps\\msys2\\current\\mingw64\\include\\c++\\12.2.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="string">&quot;-ID:\\Scoop\\apps\\msys2\\current\\mingw64\\include&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="string">&quot;-ID:\\Scoop\\apps\\msys2\\current\\mingw64\\include\\c++\\12.2.0\\x86_64-w64-mingw32&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="string">&quot;-I$&#123;workspaceFolder&#125;/src/includes&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="comment">//设置链接目标，这里改成了GNU，即对应MinGW</span></span><br><span class="line">  <span class="string">&quot;--target=x86_64-w64-windows-gnu&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">]</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure><p>逐一解释：</p><ul><li>header-insetion: 是否自动引入头文件，这里设置的是从不。</li><li>completion-style: 设置提示格式，这里设置的是展示所有细节。</li><li>query-driver：设置 clangd server 的驱动库路径，这里我设置了 mingw 的路径，但似乎没有效果（clangd 仍然链接到了 MSVC 当中）</li><li>std：设置 c++ 标准</li><li>-I：设置用户自定义的库路径</li><li>–target：设置链接目标，这里改成了 GNU，即对应 MinGW</li></ul><h3 id="Msvc"><a href="#Msvc" class="headerlink" title="Msvc"></a>Msvc</h3><p>msvc 编译器较快（推荐）</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**********</span></span><br><span class="line"><span class="comment"> * Clangd *</span></span><br><span class="line"><span class="comment"> **********/</span></span><br><span class="line"><span class="comment">// Clangd 运行参数(在终端/命令行输入 clangd --help-list-hidden 可查看更多)</span></span><br><span class="line"><span class="attr">&quot;clangd.arguments&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">  <span class="comment">//设置clangd server的驱动库路径</span></span><br><span class="line">  <span class="string">&quot;--query-driver=C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.34.31933\\bin\\HostX64\\x64\\cl.exe&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line"><span class="comment">// clangd所在路径</span></span><br><span class="line"><span class="attr">&quot;clangd.path&quot;</span><span class="punctuation">:</span> <span class="string">&quot;D:\\Scoop\\apps\\llvm\\current\\bin\\clangd.exe&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="comment">// 默认编译器选项：在 clangd 没能找到 compile_flags.json 文件时采用</span></span><br><span class="line"><span class="comment">// 缺陷是不能如读取到 compile_flags.json 时一样直接索引同一项目的不同文件，因为没有它 clangd 仅能保守地分析</span></span><br><span class="line"><span class="comment">//系统头文件、当前文件、当前文件`#include`的文件</span></span><br><span class="line"><span class="comment">// compile_flags.json 可通过 CMake 等工具生成</span></span><br><span class="line"><span class="attr">&quot;clangd.fallbackFlags&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">  <span class="comment">//包含头文件</span></span><br><span class="line">  <span class="string">&quot;-IC:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.34.31933\\include&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="string">&quot;-I$&#123;workspaceFolder&#125;/src/includes&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">]</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure><h2 id="Xmake"><a href="#Xmake" class="headerlink" title="Xmake"></a>Xmake</h2><p>设置工具链：<br><code>xmake f -p mingw --mingw=D:\Scoop\apps\msys2\current\mingw64  -c</code><br>贴一段 xmake 的配置代码：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">add_rules(<span class="string">&quot;mode.debug&quot;</span>, <span class="string">&quot;mode.release&quot;</span>)</span><br><span class="line">set_languages(<span class="string">&quot;c11&quot;</span>,<span class="string">&quot;cxx11&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">target(<span class="string">&quot;P2_6_1&quot;</span>)</span><br><span class="line">set_kind(<span class="string">&quot;binary&quot;</span>)</span><br><span class="line">add_files(<span class="string">&quot;src/chapter2/practice_2_6_1.cpp&quot;</span>)</span><br><span class="line">add_includedirs(<span class="string">&quot;src/includes&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><p>通过 <a href="https://github.com/xmake-io/xmake-vscode">xmake-vscode</a> 插件配合 vscode 来实现对 c&#x2F;c++ 项目的断点调试支持。<br>另外我们还需要依赖 vscode 的 C++ 插件才能进行调试支持</p><h1 id="使用-WSL-在-VScode-上用-LLVM-Clangd-LLDB-高效编程-C"><a href="#使用-WSL-在-VScode-上用-LLVM-Clangd-LLDB-高效编程-C" class="headerlink" title="使用 WSL 在 VScode 上用 LLVM + Clangd + LLDB 高效编程 C++"></a>使用 WSL 在 VScode 上用 LLVM + Clangd + LLDB 高效编程 C++</h1><h2 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h2><p>想要在 <a href="https://so.csdn.net/so/search?q=VScode&spm=1001.2101.3001.7020">VScode</a> 上使用 clang 编译 + LLDB 调试 + clangd 自动补全这一套工具链。</p><h2 id="安装工具链"><a href="#安装工具链" class="headerlink" title="安装工具链"></a>安装工具链</h2><p>当前工具链版本最新为 13，但是 20.04 版本的 Ubuntu 最新为 12，默认为 10。</p><h3 id="安装版本-10"><a href="#安装版本-10" class="headerlink" title="安装版本 10"></a>安装版本 10</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install clang clangd llvm liblldb-dev </span><br></pre></td></tr></table></figure><h3 id="安装版本-12"><a href="#安装版本-12" class="headerlink" title="安装版本 12"></a>安装版本 12</h3><p>我用的是最新 12 版本的<br> 使用 update-alternative 来设置 clang 默认使用 12 版本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install clang-12 clangd-12 llvm-12 liblldb-12-dev </span><br></pre></td></tr></table></figure><p><strong>可选：</strong><br> 如果你想后续均使用 12 版本，可以使用以下命令，默认将 clang 指向 12 版本。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo update-alternatives --install /usr/bin/clang clang /usr/bin/clang-12 100</span><br><span class="line">sudo update-alternatives --install /usr/bin/clangd clangd /usr/bin/clangd-12 100</span><br><span class="line">sudo update-alternatives --install /usr/bin/llvm-dis llvm-dis /usr/bin/llvm-dis-12 100</span><br></pre></td></tr></table></figure><h2 id="VScode-插件"><a href="#VScode-插件" class="headerlink" title="VScode 插件"></a>VScode 插件</h2><p>必装：</p><ol><li><p>clangd</p></li><li><p>CodeLLDB</p></li></ol><p>选装：</p><ol><li><p>Clang-Format</p></li><li><p>Clang-Tidy</p></li></ol><h3 id="CodeLLDB"><a href="#CodeLLDB" class="headerlink" title="CodeLLDB"></a>CodeLLDB</h3><p>这里安装后需要下载一个包，一般会超时。</p><ol><li>查看自己架构，一般是 X86_64</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">uname -m    </span><br><span class="line"># x86_64</span><br></pre></td></tr></table></figure><ol><li>自己下载对应架构的包，<a href="https://github.com/vadimcn/vscode-lldb/releases">下载链接</a><br> 比如这里是 x86_64 ，<img src="/../../img/blog/fcfef3558610976ad201fcc13231fb60_MD5.png">lldb&#x2F;releases&#x2F;download&#x2F;v1.6.10&#x2F;codelldb-x86_64-linux.vsix</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">1) 手动安装，选择刚刚下载到的安装包。图片参考 [博客](https://blog.csdn.net/Dimuky/article/details/109373334)</span><br><span class="line"> ![](../../../../img/blog/fcfef3558610976ad201fcc13231fb60_MD5.png)</span><br><span class="line"></span><br><span class="line">## 配置 VScode</span><br><span class="line"></span><br><span class="line">### settings.json</span><br><span class="line"></span><br><span class="line">按下 Ctrl+Shift+P，输入 setting(设置)，找到 WSL 的选项</span><br><span class="line">![](../../../../../public/img/blog/7f970935139f61c89700f15c8ec23c5e_MD5.png)</span><br><span class="line"> 粘贴以下配置：</span><br><span class="line"></span><br><span class="line">```json</span><br><span class="line">&#123;</span><br><span class="line">    &quot;clangd.arguments&quot;: [</span><br><span class="line">        &quot;--compile-commands-dir=$&#123;workspaceFolder&#125;/build&quot;,//指定配置文件compelie_commands.json所在目录，这里有三种方法生成</span><br><span class="line">        // 在后台自动分析文件（基于complie_commands)</span><br><span class="line">        &quot;--background-index&quot;,</span><br><span class="line">        // 同时开启的任务数量</span><br><span class="line">        &quot;-j=12&quot;,</span><br><span class="line">        // &quot;--folding-ranges&quot;</span><br><span class="line">        // 告诉clangd用那个clang进行编译，路径参考which clang++的路径</span><br><span class="line">        &quot;--query-driver=/usr/bin/clang++&quot;,</span><br><span class="line">        // clang-tidy功能</span><br><span class="line">        &quot;--clang-tidy&quot;,</span><br><span class="line">        &quot;--clang-tidy-checks=performance-*,bugprone-*&quot;,</span><br><span class="line">        // 全局补全（会自动补充头文件）</span><br><span class="line">        &quot;--all-scopes-completion&quot;,</span><br><span class="line">        // 更详细的补全内容</span><br><span class="line">        &quot;--completion-style=detailed&quot;,</span><br><span class="line">        &quot;--function-arg-placeholders&quot;,</span><br><span class="line">        // 补充头文件的形式</span><br><span class="line">        &quot;--header-insertion=iwyu&quot;,</span><br><span class="line">        // pch优化的位置</span><br><span class="line">        &quot;--pch-storage=memory&quot;,</span><br><span class="line">    ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="生成-Clangd-配置文件"><a href="#生成-Clangd-配置文件" class="headerlink" title="生成 Clangd 配置文件"></a>生成 Clangd 配置文件</h3><p>clangd 对每个项目都需要生成一个名为 compile_commands.json 的配置文件，参见 <a href="https://_clang.llvm.org_docs_jsoncompilationdatabase/">官方文档</a></p><h3 id="调试-1"><a href="#调试-1" class="headerlink" title="调试"></a>调试</h3><p>通过 <a href="https://github.com/xmake-io/xmake-vscode">xmake-vscode</a> 插件配合 vscode 来实现对 c&#x2F;c++ 项目的断点调试支持。<br>另外我们还需要依赖 vscode 的 C++ 插件才能进行调试支持</p><h1 id="其他配置"><a href="#其他配置" class="headerlink" title="其他配置"></a>其他配置</h1><h2 id="clang-format"><a href="#clang-format" class="headerlink" title="clang-format"></a>clang-format</h2><p>在项目的根目录下创建一个 <code>.clang-format</code> 文件，然后添加内容：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">BasedOnStyle:</span> <span class="string">Google</span></span><br><span class="line"><span class="attr">IndentWidth:</span> <span class="number">4</span></span><br><span class="line"><span class="attr">DerivePointerAlignment:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">PointerAlignment:</span> <span class="string">Left</span></span><br></pre></td></tr></table></figure><h3 id="官方文档"><a href="#官方文档" class="headerlink" title="官方文档"></a>官方文档</h3><p><a href="https://clang.llvm.org/docs/ClangFormatStyleOptions.html">Clang-Format Style Options — Clang 18.0.0git documentation (llvm.org)</a></p><h1 id="VSCode-的-C-配置：-clang-单文件编译和-clangd-检查-可用于-macOS"><a href="#VSCode-的-C-配置：-clang-单文件编译和-clangd-检查-可用于-macOS" class="headerlink" title="VSCode 的 C++ 配置： clang++ 单文件编译和 clangd 检查 (可用于 macOS)"></a>VSCode 的 C++ 配置： clang++ 单文件编译和 clangd 检查 (可用于 macOS)</h1><h2 id="使用-clang-x2F-lldb-进行单文件编译和调试"><a href="#使用-clang-x2F-lldb-进行单文件编译和调试" class="headerlink" title="使用 clang&#x2F;lldb 进行单文件编译和调试"></a>使用 clang&#x2F;lldb 进行单文件编译和调试</h2><ol><li><p>确保 <code>clang++</code> 已经正确安装（通过 <code>clang++ -v</code> 可以验证）</p><ul><li>对于 macOS，运行 <code>xcode-select --install</code> 可以安装好本文用到的所有包</li><li>对于 Linux，下载 llvm 包，大概率包含了本文用到的所有包</li></ul></li><li><p>vscode 已启用 CodeLLDB 插件（报错无法下载可以先按报错给的 url 用浏览器下载，然后手动安装）</p></li><li><p><strong>卸载微软提供的 C&#x2F;C++ 插件！！！也不要使用 Code Runner 插件。</strong></p></li><li><p>tasks.json，放入.vscode 文件夹中</p></li></ol><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span>  </span><br><span class="line">  <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2.0.0&quot;</span><span class="punctuation">,</span>  </span><br><span class="line">  <span class="attr">&quot;tasks&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span>  </span><br><span class="line">    <span class="punctuation">&#123;</span>  </span><br><span class="line">      <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;shell&quot;</span><span class="punctuation">,</span>  </span><br><span class="line">      <span class="attr">&quot;label&quot;</span><span class="punctuation">:</span> <span class="string">&quot;C/C++: clang++ build active file&quot;</span><span class="punctuation">,</span>  </span><br><span class="line">      <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/usr/bin/clang++&quot;</span><span class="punctuation">,</span> <span class="comment">// `which clang++` may help you find this path  </span></span><br><span class="line">      <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span>  </span><br><span class="line">        <span class="string">&quot;--std=c++17&quot;</span><span class="punctuation">,</span>  </span><br><span class="line">        <span class="string">&quot;-fcolor-diagnostics&quot;</span><span class="punctuation">,</span>  </span><br><span class="line">        <span class="string">&quot;-fansi-escape-codes&quot;</span><span class="punctuation">,</span>  </span><br><span class="line">        <span class="string">&quot;-g&quot;</span><span class="punctuation">,</span>  </span><br><span class="line">        <span class="string">&quot;$&#123;file&#125;&quot;</span><span class="punctuation">,</span>  </span><br><span class="line">        <span class="string">&quot;-o&quot;</span><span class="punctuation">,</span>  </span><br><span class="line">        <span class="string">&quot;$&#123;workspaceFolder&#125;/.build/$&#123;fileBasenameNoExtension&#125;&quot;</span>  </span><br><span class="line">        <span class="string">&quot;-fstandalone-debug&quot;</span><span class="punctuation">,</span> <span class="comment">// to enable viewing std::string etc. when using lldb on Windows or Linux   </span></span><br><span class="line">      <span class="punctuation">]</span><span class="punctuation">,</span>  </span><br><span class="line">      <span class="attr">&quot;options&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span>  </span><br><span class="line">        <span class="attr">&quot;cwd&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;fileDirname&#125;&quot;</span>  </span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span>  </span><br><span class="line">      <span class="attr">&quot;group&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span>  </span><br><span class="line">        <span class="attr">&quot;kind&quot;</span><span class="punctuation">:</span> <span class="string">&quot;build&quot;</span><span class="punctuation">,</span>  </span><br><span class="line">        <span class="attr">&quot;isDefault&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span>  </span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span>  </span><br><span class="line">      <span class="attr">&quot;detail&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Task generated by Debugger.&quot;</span>  </span><br><span class="line">    <span class="punctuation">&#125;</span>  </span><br><span class="line">  <span class="punctuation">]</span>  </span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><blockquote><p>   我的习惯是把所有的可执行文件放到 <code>./build/</code> 文件夹下，如果不这么做的话，改变 3、4 步中的文件路径，以及忽略第五步</p></blockquote><ol><li>launch.json，放入.vscode 文件夹中</li></ol><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span>  </span><br><span class="line">  <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0.2.0&quot;</span><span class="punctuation">,</span>  </span><br><span class="line">  <span class="attr">&quot;configurations&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span>  </span><br><span class="line">    <span class="punctuation">&#123;</span>  </span><br><span class="line">      <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;C/C++: clang++ build and debug active file customize&quot;</span><span class="punctuation">,</span>  </span><br><span class="line">      <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;lldb&quot;</span><span class="punctuation">,</span>  </span><br><span class="line">      <span class="attr">&quot;request&quot;</span><span class="punctuation">:</span> <span class="string">&quot;launch&quot;</span><span class="punctuation">,</span>  </span><br><span class="line">      <span class="attr">&quot;program&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;workspaceFolder&#125;/.build/$&#123;fileBasenameNoExtension&#125;&quot;</span><span class="punctuation">,</span>  </span><br><span class="line">      <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span>  </span><br><span class="line">      <span class="attr">&quot;cwd&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;workspaceFolder&#125;&quot;</span><span class="punctuation">,</span>  </span><br><span class="line">      <span class="attr">&quot;preLaunchTask&quot;</span><span class="punctuation">:</span> <span class="string">&quot;C/C++: clang++ build active file&quot;</span>  </span><br><span class="line">    <span class="punctuation">&#125;</span>  </span><br><span class="line">  <span class="punctuation">]</span>  </span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><ol><li><p>在文件夹里新建一个 .build 文件夹（ macOS &#x2F; Linux 必做）</p></li><li><p>按 F 5，就可以编译调试了</p></li></ol><h2 id="使用-clangd-自动补全、代码检查"><a href="#使用-clangd-自动补全、代码检查" class="headerlink" title="使用 clangd 自动补全、代码检查"></a>使用 clangd 自动补全、代码检查</h2><ol><li><p>确保已安装 clangd（应该和 clang++ 在一个包里的，通过 <code>clangd --version</code> 检查）</p></li><li><p>安装 VScode 插件 clangd</p></li><li><p>在工作区根目录下新建一个 <code>compile_flags.txt</code>，这是用来为 clangd 指定参数的，比如使用的标准或是标准库路径之类。内容就是编译选项，一行一个。这里只写了一个标准作为例子</p></li></ol><blockquote><p>一般来说 clangd 的参数是由 compile_commands.json 指定，由 CMake 等构建工具自动生成。但是由于在我的需求中对每一个文件都是相同的编译参数，所以可以手写 compile_flags.txt 统一管理。<br>具体查看 <a href="https://clang.llvm.org/docs/JSONCompilationDatabase.html#alternatives">JSON Compilation Database Format Specification</a></p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--std=c++17</span><br></pre></td></tr></table></figure><h2 id="关于-clang-format-文件"><a href="#关于-clang-format-文件" class="headerlink" title="关于 .clang-format 文件"></a>关于 .clang-format 文件</h2><p>我的习惯是直接放在 <code>~</code> 下（如果你的代码都放在你的~和其子文件夹里的话）<br>生成的话，官方文档的那个网页实在是太丑了，我直接选择去 CLion 里配好，然后导出为 .clang-format，既可视化又方便<br>贴一下我的.clang-format</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Generated from CLion C/C++ Code Style settings  </span></span><br><span class="line"><span class="attr">BasedOnStyle:</span> <span class="string">LLVM</span>  </span><br><span class="line"><span class="attr">AccessModifierOffset:</span> <span class="number">-4</span>  </span><br><span class="line"><span class="attr">AlignAfterOpenBracket:</span> <span class="string">Align</span>  </span><br><span class="line"><span class="attr">AlignConsecutiveAssignments:</span> <span class="string">None</span>  </span><br><span class="line"><span class="attr">AlignOperands:</span> <span class="string">Align</span>  </span><br><span class="line"><span class="attr">AllowAllArgumentsOnNextLine:</span> <span class="literal">false</span>  </span><br><span class="line"><span class="attr">AllowAllConstructorInitializersOnNextLine:</span> <span class="literal">false</span>  </span><br><span class="line"><span class="attr">AllowAllParametersOfDeclarationOnNextLine:</span> <span class="literal">false</span>  </span><br><span class="line"><span class="attr">AllowShortBlocksOnASingleLine:</span> <span class="string">Always</span>  </span><br><span class="line"><span class="attr">AllowShortCaseLabelsOnASingleLine:</span> <span class="literal">false</span>  </span><br><span class="line"><span class="attr">AllowShortFunctionsOnASingleLine:</span> <span class="string">All</span>  </span><br><span class="line"><span class="attr">AllowShortIfStatementsOnASingleLine:</span> <span class="string">Always</span>  </span><br><span class="line"><span class="attr">AllowShortLambdasOnASingleLine:</span> <span class="string">All</span>  </span><br><span class="line"><span class="attr">AllowShortLoopsOnASingleLine:</span> <span class="literal">true</span>  </span><br><span class="line"><span class="attr">AlwaysBreakAfterReturnType:</span> <span class="string">None</span>  </span><br><span class="line"><span class="attr">AlwaysBreakTemplateDeclarations:</span> <span class="literal">Yes</span>  </span><br><span class="line"><span class="attr">BreakBeforeBraces:</span> <span class="string">Custom</span>  </span><br><span class="line"><span class="attr">BraceWrapping:</span>  </span><br><span class="line">  <span class="attr">AfterCaseLabel:</span> <span class="literal">false</span>  </span><br><span class="line">  <span class="attr">AfterClass:</span> <span class="literal">false</span>  </span><br><span class="line">  <span class="attr">AfterControlStatement:</span> <span class="string">Never</span>  </span><br><span class="line">  <span class="attr">AfterEnum:</span> <span class="literal">false</span>  </span><br><span class="line">  <span class="attr">AfterFunction:</span> <span class="literal">false</span>  </span><br><span class="line">  <span class="attr">AfterNamespace:</span> <span class="literal">false</span>  </span><br><span class="line">  <span class="attr">AfterUnion:</span> <span class="literal">false</span>  </span><br><span class="line">  <span class="attr">BeforeCatch:</span> <span class="literal">false</span>  </span><br><span class="line">  <span class="attr">BeforeElse:</span> <span class="literal">false</span>  </span><br><span class="line">  <span class="attr">IndentBraces:</span> <span class="literal">false</span>  </span><br><span class="line">  <span class="attr">SplitEmptyFunction:</span> <span class="literal">false</span>  </span><br><span class="line">  <span class="attr">SplitEmptyRecord:</span> <span class="literal">true</span>  </span><br><span class="line"><span class="attr">BreakBeforeBinaryOperators:</span> <span class="string">None</span>  </span><br><span class="line"><span class="attr">BreakBeforeTernaryOperators:</span> <span class="literal">true</span>  </span><br><span class="line"><span class="attr">BreakConstructorInitializers:</span> <span class="string">BeforeColon</span>  </span><br><span class="line"><span class="attr">BreakInheritanceList:</span> <span class="string">BeforeColon</span>  </span><br><span class="line"><span class="attr">ColumnLimit:</span> <span class="number">0</span>  </span><br><span class="line"><span class="attr">CompactNamespaces:</span> <span class="literal">false</span>  </span><br><span class="line"><span class="attr">ContinuationIndentWidth:</span> <span class="number">8</span>  </span><br><span class="line"><span class="attr">IndentCaseLabels:</span> <span class="literal">true</span>  </span><br><span class="line"><span class="attr">IndentPPDirectives:</span> <span class="string">None</span>  </span><br><span class="line"><span class="attr">IndentWidth:</span> <span class="number">4</span>  </span><br><span class="line"><span class="attr">KeepEmptyLinesAtTheStartOfBlocks:</span> <span class="literal">true</span>  </span><br><span class="line"><span class="attr">MaxEmptyLinesToKeep:</span> <span class="number">2</span>  </span><br><span class="line"><span class="attr">NamespaceIndentation:</span> <span class="string">All</span>  </span><br><span class="line"><span class="attr">ObjCSpaceAfterProperty:</span> <span class="literal">false</span>  </span><br><span class="line"><span class="attr">ObjCSpaceBeforeProtocolList:</span> <span class="literal">true</span>  </span><br><span class="line"><span class="attr">PointerAlignment:</span> <span class="string">Right</span>  </span><br><span class="line"><span class="attr">ReflowComments:</span> <span class="literal">false</span>  </span><br><span class="line"><span class="attr">SpaceAfterCStyleCast:</span> <span class="literal">true</span>  </span><br><span class="line"><span class="attr">SpaceAfterLogicalNot:</span> <span class="literal">false</span>  </span><br><span class="line"><span class="attr">SpaceAfterTemplateKeyword:</span> <span class="literal">false</span>  </span><br><span class="line"><span class="attr">SpaceBeforeAssignmentOperators:</span> <span class="literal">true</span>  </span><br><span class="line"><span class="attr">SpaceBeforeCpp11BracedList:</span> <span class="literal">false</span>  </span><br><span class="line"><span class="attr">SpaceBeforeCtorInitializerColon:</span> <span class="literal">true</span>  </span><br><span class="line"><span class="attr">SpaceBeforeInheritanceColon:</span> <span class="literal">true</span>  </span><br><span class="line"><span class="attr">SpaceBeforeParens:</span> <span class="string">ControlStatements</span>  </span><br><span class="line"><span class="attr">SpaceBeforeRangeBasedForLoopColon:</span> <span class="literal">false</span>  </span><br><span class="line"><span class="attr">SpaceInEmptyParentheses:</span> <span class="literal">false</span>  </span><br><span class="line"><span class="attr">SpacesBeforeTrailingComments:</span> <span class="number">0</span>  </span><br><span class="line"><span class="attr">SpacesInAngles:</span> <span class="literal">false</span>  </span><br><span class="line"><span class="attr">SpacesInCStyleCastParentheses:</span> <span class="literal">false</span>  </span><br><span class="line"><span class="attr">SpacesInContainerLiterals:</span> <span class="literal">false</span>  </span><br><span class="line"><span class="attr">SpacesInParentheses:</span> <span class="literal">false</span>  </span><br><span class="line"><span class="attr">SpacesInSquareBrackets:</span> <span class="literal">false</span>  </span><br><span class="line"><span class="attr">TabWidth:</span> <span class="number">4</span>  </span><br><span class="line"><span class="attr">UseTab:</span> <span class="string">Never</span></span><br></pre></td></tr></table></figure><h2 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h2><p><a href="https://blog.yfi.moe/post/vscode-clang-clangd/">VSCode 的 C++ 配置： clang++ 单文件编译和 clangd 检查 (可用于 macOS) | Yunfi’s Blog (yfi.moe)</a></p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机/编程语言/语言环境配置 </tag>
            
            <tag> 计算机/编程语言/cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>shell配置</title>
      <link href="/posts/%E6%9C%AC%E5%9C%B0/shell%E9%85%8D%E7%BD%AE.html"/>
      <url>/posts/%E6%9C%AC%E5%9C%B0/shell%E9%85%8D%E7%BD%AE.html</url>
      
        <content type="html"><![CDATA[<h1 id="Nushell"><a href="#Nushell" class="headerlink" title="Nushell"></a>Nushell</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p><a href="https://www.nushell.sh/zh-CN/book/installation.html">安装 Nu | Nushell</a></p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p><a href="https://www.nushell.sh/zh-CN/book/configuration.html">配置 | Nushell</a></p><h3 id="Vscode-高亮插件"><a href="#Vscode-高亮插件" class="headerlink" title="Vscode 高亮插件"></a>Vscode 高亮插件</h3><p><a href="https://github.com/nushell/vscode-nushell-lang">GitHub - nushell&#x2F;vscode-nushell-lang: A Nushell grammar for Visual Studio Code with IDE support</a></p><h3 id="配置-nushell"><a href="#配置-nushell" class="headerlink" title="配置 nushell"></a>配置 nushell</h3><h4 id="不显示-banner"><a href="#不显示-banner" class="headerlink" title="不显示 banner"></a>不显示 <code>banner</code></h4><ol><li><p>运行 <code>$nu.config-path</code> 查看配置文件地址, 或你安装了 <code>neovim</code> 直接 <code>nvim $nu.config-path</code> 亦可</p></li><li><p>查找 <code>show_banner</code> 并修改为 <code>false</code></p></li></ol><h4 id="代理脚本"><a href="#代理脚本" class="headerlink" title="代理脚本"></a>代理脚本</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alias nuproxy = (let-env http_proxy = &quot;http://127.0.0.1:7890&quot; ; let-env https_proxy = &quot;http://127.0.0.1:7890&quot;)</span><br><span class="line">alias unproxy = (unlet-env http_proxy ; unlet-env https_proxy ; )</span><br></pre></td></tr></table></figure><h4 id="alias"><a href="#alias" class="headerlink" title="alias"></a>alias</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">alias l = (ls)</span><br><span class="line">alias ll = (ls -al)</span><br><span class="line">alias c = (clear)</span><br><span class="line">alias pwd = ($env.PWD)</span><br><span class="line">def b [file] &#123;bat -p $file&#125;</span><br><span class="line">def n [file] &#123;nvim $file&#125;</span><br></pre></td></tr></table></figure><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="丰富的数据类型"><a href="#丰富的数据类型" class="headerlink" title="丰富的数据类型"></a>丰富的数据类型</h3><p><img src="/../../img/blog/cbfc02cd7970a48c325a7eb715834c8d_MD5.jpeg"></p><h3 id="强大的-REPL-能力"><a href="#强大的-REPL-能力" class="headerlink" title="强大的 REPL 能力"></a>强大的 REPL 能力</h3><p>作为一个 shell，尤其是一个新的 shell，上手是否简单，使用是否 easy？这一点，nushell 也可圈可点（目前版本也还有一些不足，改进之后会更好）：</p><ul><li>help 命令几乎可以涵盖你绝大部分的搜索需求。由于 nushell 中所有的指令都是以 command 的形式提供，你可以使用 help -f keyword 来搜索相关的命令。例如：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">help</span> -f remove</span><br><span class="line"><span class="built_in">help</span> -f upper</span><br></pre></td></tr></table></figure><p>在学习 nushell 之前，先了解一下它的命令集，是很有帮助的，后续也方便快速的查找。尤其是 nushell 中与 filter 相关的一系列命令，它非常类似于 Java 8&#x2F;Scala 中的一些集合 λ 函数。</p><ul><li>还算不错的调试命令，例如：</li><li>view source</li><li>scope</li><li>debug&#x2F;inspect&#x2F;explore：显示变量的值</li><li>explain&#x2F;metadata&#x2F;describe: 查看变量的元信息</li></ul><h3 id="强大的-completion-能力"><a href="#强大的-completion-能力" class="headerlink" title="强大的 completion 能力"></a>强大的 completion 能力</h3><p>nushell 自身的命令具有强大的 completion 能力，而且，它还能把这个能力扩展到外部命令之上，而且，这种扩展的实现非常简单，你也可以对你常用的工具，包装一个 completion 的能力。参考：</p><p><a href="https://link.zhihu.com/?target=https://www.nushell.sh/book/custom_completions.html">Custom completions | Nushell​www.nushell.sh/book/custom_completions.html</a></p><p>比如我引入了 <a href="https://link.zhihu.com/?target=https://github.com/nushell/nu_scripts/blob/main/custom-completions/git/git-completions.nu">https://github.com/nushell/nu_scripts&#x2F;blob&#x2F;main&#x2F;custom-completions&#x2F;git&#x2F;git-completions.nu</a> 之后，我现在使用 git 命令行，基本上就无需搜索了，感觉效率比使用 GUI 工具要提高了不少。</p><h3 id="完备的语言能力，可以编写更简单、可读、鲁棒、强大的脚本"><a href="#完备的语言能力，可以编写更简单、可读、鲁棒、强大的脚本" class="headerlink" title="完备的语言能力，可以编写更简单、可读、鲁棒、强大的脚本"></a>完备的语言能力，可以编写更简单、可读、鲁棒、强大的脚本</h3><p>nushell 自身是一个编程语言，这一点倒不奇怪（bash、zsh 等也是这样的），不过，有一些特性让 nushell 相比其他的 shell 有更为强大的编程能力：</p><ul><li>nushell 针对 completion、argument process, command help 提供了语言级的支持，现在，你只需要定义一个简单的函数，它就有了 completion、argument process 的能力。非常的优美。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># run the mpp performance bench</span></span><br><span class="line">def-env main [ </span><br><span class="line"><span class="keyword">case</span>?: string@cases-list  <span class="comment"># run the given case (prefix match)</span></span><br><span class="line">--verbose <span class="comment"># show step results</span></span><br><span class="line">--list-details: bool   <span class="comment"># list all cases with sql</span></span><br><span class="line">--list-simple: bool <span class="comment"># list all cases&#x27;name</span></span><br><span class="line">] &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="variable">$list_details</span> &#123; <span class="built_in">return</span> <span class="variable">$cases</span> &#125; </span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> <span class="variable">$list_simple</span> &#123; <span class="built_in">return</span> (<span class="variable">$cases</span> | select <span class="keyword">case</span>) &#125;</span><br><span class="line"><span class="keyword">if</span> <span class="variable">$verbose</span> &#123;</span><br><span class="line"><span class="variable">$env</span>.verbose = <span class="variable">$verbose</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="variable">$case</span> == null) &#123;</span><br><span class="line"><span class="variable">$cases</span> | each &#123; |it| (compareSql <span class="variable">$it</span>.<span class="keyword">case</span> <span class="variable">$it</span>.sql) &#125; | reject sql</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="variable">$cases</span> | <span class="built_in">where</span> &#123; |it| <span class="variable">$it</span>.<span class="keyword">case</span> | str starts-with <span class="variable">$case</span> &#125;  | </span><br><span class="line">each &#123; |it| (compareSql <span class="variable">$it</span>.<span class="keyword">case</span> <span class="variable">$it</span>.sql) &#125; | reject sql</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个能力太让我开心了，几乎是零成本，就获得了显著的脚本的可用性提升。</p><p><img src="/../../img/blog/335025d13f92da375d850852241bab47_MD5.webp"></p><p><img src="/../../img/blog/e81ee709b0922b190e343cc3861f80da_MD5.webp"></p><ul><li>强类型。我更偏爱强类型的语言，代码有更强的鲁棒性。</li><li>简洁、友好的输出。结合使用 nushell 的 table，可以很简单的输出优美的报告。</li></ul><h1 id="Powershell-美化"><a href="#Powershell-美化" class="headerlink" title="Powershell 美化"></a>Powershell 美化</h1><h2 id="安装-NF-字体"><a href="#安装-NF-字体" class="headerlink" title="安装 NF 字体"></a>安装 NF 字体</h2><p>后面介绍的一些功能会有显示一些特殊字符的需求，所以这里我们要提前安装一些支持特殊字符的字体。而 <a href="https://link.zhihu.com/?target=https://github.com/ryanoasis/nerd-fonts">nerd-fonts</a> 这个项目，包含了众多适配过特殊字符的字体，可以放心使用。这里推荐 <code>Meslo-Nerd-Fonts</code>，可以在 scoop 中安装。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># scoop默认没有开启nerd-fonts分类，需要开启才能安装相关字体</span></span><br><span class="line">scoop bucket add nerd-fonts</span><br><span class="line"><span class="comment"># 安装字体时需要在管理员权限的终端中运行</span></span><br><span class="line">scoop install Meslo-NF-Mono</span><br></pre></td></tr></table></figure><h2 id="Windows-Terminal-终端-选项"><a href="#Windows-Terminal-终端-选项" class="headerlink" title="Windows Terminal (终端) 选项"></a>Windows Terminal (终端) 选项</h2><p>然后再来配置一下 Windows Terminal (终端) ，点击下拉菜单选择设置打开设置标签页，然后依次修改以下选项：</p><ul><li>启动 -&gt; 默认配置文件，改为 Powershell，如果你已经安装了 Powershell 7.2，这里应当可以自动搜索到。否则可能需要手动编辑配置文件。</li><li>启动 -&gt; 默认终端应用程序，改为 Windows Terminal (终端) 。</li><li>外观 -&gt; 在选项卡中显示亚力克效果，选择启用。</li><li>配色方案，这里可以根据自己喜好调整。</li><li>配置文件默认值 -&gt; 外观 -&gt; 字体，改为 <code>MesloLGS NF</code> 字体，字号按照自己屏幕大小选择，再开启亚力克效果，透明度选择 70% 左右。</li></ul><h2 id="对所有终端生效"><a href="#对所有终端生效" class="headerlink" title="对所有终端生效"></a>对所有终端生效</h2><p>在终端中配置只能在当前终端生效，为了让它能够在所有 Powershell 中永久生效，需要在配置文件中编辑。</p><p>在 Powershell 中运行以下命令，用 vscode 打开 Powershell 的配置文件，如果你没有 vscode，也可以改成 notepad 用记事本来编辑配置文件。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">code $PROFILE</span><br></pre></td></tr></table></figure><h2 id="安装-Oh-my-posh"><a href="#安装-Oh-my-posh" class="headerlink" title="安装 Oh-my-posh"></a>安装 Oh-my-posh</h2><p>oh-my-posh 是一个 Powershell 的主题项目，可以将 Powershell 美化成类似 ohmyzsh 的效果。安装 oh-my-posh 也很简单，运行下面的命令即可。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scoop install oh-my-posh</span><br></pre></td></tr></table></figure><p>这里有很多主题可供选择，<a href="https://link.zhihu.com/?target=https://ohmyposh.dev/docs/themes">https://ohmyposh.dev/docs/themes</a>。选择好后，在 Powershell 的配置文件中填入以下内容。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">oh-my-posh init pwsh --config &quot;$env:POSH_THEMES_PATH\powerlevel10k_rainbow.omp.json&quot; | Invoke-Expression</span><br></pre></td></tr></table></figure><h2 id="PSReadLine"><a href="#PSReadLine" class="headerlink" title="PSReadLine"></a>PSReadLine</h2><p>想让 Powershell 也拥有提示和补全功能？PSReadLine 可以帮你，这是一个可以增强终端体验的工具。</p><h3 id="安装-PSReadLine"><a href="#安装-PSReadLine" class="headerlink" title="安装 PSReadLine"></a>安装 PSReadLine</h3><p><a href="https://github.com/PowerShell/PSReadLine">PowerShell&#x2F;PSReadLine: A bash inspired readline implementation for PowerShell (github.com)</a><br>确保你使用的是 Powershell 7.2，然后运行下面的命令。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Install-Module PSReadLine -AllowPrerelease -Force</span><br><span class="line"># 或者你喜欢稳定版</span><br><span class="line">Install-Module PSReadLine -Scope CurrentUser</span><br></pre></td></tr></table></figure><h3 id="使用-PSReadLine"><a href="#使用-PSReadLine" class="headerlink" title="使用 PSReadLine"></a>使用 PSReadLine</h3><p>要使用 PSReadLine，同样需要在 <code>$PROFILE</code> 中添加一些配置，可以参考 <a href="https://link.zhihu.com/?target=https://docs.microsoft.com/zh-cn/powershell/module/psreadline/about/about_psreadline">官方文档</a></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Import-Module PSReadLine</span><br><span class="line"></span><br><span class="line">Set-PSReadLineOption -EditMode Emacs</span><br><span class="line"></span><br><span class="line">Set-PSReadLineOption -PredictionSource HistoryAndPlugin</span><br><span class="line"></span><br><span class="line">Set-PSReadLineOption -PredictionViewStyle ListView</span><br><span class="line"></span><br><span class="line">Set-PSReadLineOption -BellStyle None</span><br></pre></td></tr></table></figure><h1 id="zsh-配置"><a href="#zsh-配置" class="headerlink" title="zsh 配置"></a>zsh 配置</h1><h2 id="Zsh-安装"><a href="#Zsh-安装" class="headerlink" title="Zsh 安装"></a>Zsh 安装</h2><ul><li>查看自己系统是否存在 zsh</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /etc/shells</span><br></pre></td></tr></table></figure><ul><li>查看是否是使用的 zsh</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo $SHELL</span><br></pre></td></tr></table></figure><ul><li>ubuntu</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">apt-get update</span><br><span class="line"># ubuntu下载安装zsh</span><br><span class="line">apt install zsh -y</span><br><span class="line"># 切换</span><br><span class="line">chsh -s /bin/zsh</span><br><span class="line">reboot</span><br></pre></td></tr></table></figure><p>第一次进入 Zsh 会自动出现一个配置界面，这个界面可以根据需要自定义 Zsh。</p><p><img src="/../../img/blog/c773655c02f59e687eaea4359fb5a6ff_MD5.png"></p><p>在这里输入  <code>1</code>  就可以进入配置界面了。</p><p><img src="/../../img/blog/bc5c230efde8f4fd68396d10c8dfef9d_MD5.png"></p><p>配置界面中各个菜单代表的意思分别是：</p><ul><li><code>1</code>：设置命令历史记录相关的选项</li><li><code>2</code>：设置命令补全系统</li><li><code>3</code>：设置热建</li><li><code>4</code>：选择各种常见的选项，只需要选择 “On” 或者 “Off”</li><li><code>0</code>：退出，并使用空白（默认）配置</li><li><code>a</code>：终止设置并退出</li><li><code>q</code>：退出</li></ul><p>这里根据提示，然后按照你自己的喜好配置就可以了。配置好后，会在你的用户目录下生成  <code>.zshrc</code>  文件。然后我们要去这个文件中启用插件和主题。</p><h3 id="Ubuntu-安装插件"><a href="#Ubuntu-安装插件" class="headerlink" title="Ubuntu 安装插件"></a>Ubuntu 安装插件</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install zsh-autosuggestions zsh-syntax-highlighting autojump exa</span><br></pre></td></tr></table></figure><p><a href="https://github.com/wting/autojump">autojump</a> 实现目录间的快速跳转。<br>如果使用「autojump」，只需要输入</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ j 路径关键词</span><br></pre></td></tr></table></figure><p><img src="/../../img/blog/2710cb80bea91134d1f934f9ac51d6ae_MD5.png"></p><p>可以看到直接跳进该路径下了。</p><p>「autojump」会按照关键词使用频率做一个排序，有的时候有一些路径有相似的关键词时，使用「tab」可以查看排序，例如：</p><p><img src="/../../img/blog/4f336a6ce3326ab7784225b14a3ba6f4_MD5.png"></p><p>想访问哪一个，输入相应的数字即可。</p><ol><li><p>autojump 只能跳转到已经用 <code>cd</code> 进入过的目录，无法跳转到没有用 <code>cd</code> 进入过的目录。即使用 cd 进入过一个特定的目录才会被记录到 autojump 的数据库中，才可以使用 autojump 进行跳转。</p></li><li><p>自动跳转不支持 <code>-</code> 开头的目录。</p></li></ol><blockquote><p><a href="https://github.com/zsh-users/zsh-autosuggestions">zsh-autosuggestion</a><br> 基于历史记录，进行命令的推荐和补全。<br> <a href="https://github.com/zsh-users/zsh-syntax-highlighting">zsh-syntax-highlighting</a><br> 对输入的命令提供高亮显示和语法检查。<br> <a href="https://github.com/ogham/exa">exa</a><br> 用于替代原生的  <code>ls</code>，通过不同的颜色来更好地区分文件的类型及相关的元属性。</p></blockquote><h2 id="powerlevel-10-k-安装"><a href="#powerlevel-10-k-安装" class="headerlink" title="powerlevel 10 k 安装"></a>powerlevel 10 k 安装</h2><p>打开此链接 <a href="https://github.com/romkatv/powerlevel10k">github</a>，进入到库里面，按照安装步骤：</p><ol><li><p>安装字体：随便下载一个字体，我是下载了第一个，然后双击下载文件，最后我们开启 terminal，点击偏好设置，在字体那个地方点击更改，右上角搜索 Meslo 就能看到你安装的字体<br><img src="/../../img/blog/6c989af71948343f43ee1567004d0930_MD5.png" alt="在这里插入图片描述"></p></li><li><p>安装 powerlevel 10 k</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone --depth=1 https://gitee.com/romkatv/powerlevel10k.git ~/module/powerlevel10k</span><br></pre></td></tr></table></figure><p>你要是用着之后想换的话直接在命令行里加</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p10k configure</span><br></pre></td></tr></table></figure><h2 id="Zsh-Vi-mod"><a href="#Zsh-Vi-mod" class="headerlink" title="Zsh Vi mod"></a>Zsh Vi mod</h2><p><a href="https://github.com/jeffreytse/zsh-vi-mode#custom-escape-key">jeffreytse&#x2F;zsh-vi-mode: 💻 A better and friendly vi(vim) mode plugin for ZSH. (github.com)</a><br>使用 vi 模式编辑命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://gitee.com/mirrors_jeffreytse/zsh-vi-mode.git ~/module/zsh-vi-mode</span><br></pre></td></tr></table></figure><h2 id="zsh-completions"><a href="#zsh-completions" class="headerlink" title="zsh-completions"></a>zsh-completions</h2><p><a href="https://github.com/zsh-users/zsh-completions/tree/master">https://github.com/zsh-users/zsh-completions/tree/master</a></p><h2 id="Fzf-tab"><a href="#Fzf-tab" class="headerlink" title="Fzf-tab"></a>Fzf-tab</h2><p><a href="https://github.com/Aloxaf/fzf-tab">Aloxaf&#x2F;fzf-tab: Replace zsh’s default completion selection menu with fzf! (github.com)</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install fzf</span><br><span class="line">git clone https://gitee.com/mirrors_Aloxaf/fzf-tab.git ~/module/fzf-tab</span><br></pre></td></tr></table></figure><h2 id="x2F-zshrc"><a href="#x2F-zshrc" class="headerlink" title="~&#x2F;. zshrc"></a>~&#x2F;. zshrc</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">source /usr/share/zsh-autosuggestions/zsh-autosuggestions.zsh</span><br><span class="line">source /usr/share/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh</span><br><span class="line">source /usr/share/autojump/autojump.zsh</span><br><span class="line">source ~/module/zsh-vi-mode/zsh-vi-mode.plugin.zsh</span><br><span class="line">source ~/module/powerlevel10k/powerlevel10k.zsh-theme</span><br><span class="line">source ~/module/fzf-tab/fzf-tab.plugin.zsh</span><br><span class="line">source ~/module/zsh-completions/zsh-completions.plugin.zsh</span><br><span class="line">alias ls=&quot;exa&quot;</span><br></pre></td></tr></table></figure><h1 id="starship"><a href="#starship" class="headerlink" title="starship"></a>starship</h1><ul><li><a href="https://starship.rs/zh-CN/guide/#%F0%9F%9A%80-%E5%AE%89%E8%A3%85">Starship</a></li><li><a href="https://www.fournoas.com/posts/personalize-your-powershell-terminal-with-starship/">通过 Starship 个性化定制 PowerShell 终端 · 白汤四物 (fournoas.com)</a></li><li><a href="https://github.com/starship/starship/issues/5617">starship在wsl的zsh上无法正常运行</a></li></ul><h1 id="命令行常用工具"><a href="#命令行常用工具" class="headerlink" title="命令行常用工具"></a>命令行常用工具</h1><h2 id="替代品"><a href="#替代品" class="headerlink" title="替代品"></a>替代品</h2><ul><li><a href="https://www.ruanyifeng.com/blog/2022/01/cli-alternative-tools.html">命令行常用工具的替代品 - 阮一峰的网络日志 (ruanyifeng.com)</a></li><li><a href="https://github.com/ibraheemdev/modern-unix">ibraheemdev&#x2F;modern-unix: A collection of modern&#x2F;faster&#x2F;saner alternatives to common unix commands. (github.com)</a></li><li><a href="https://docs.brew.sh/Homebrew-on-Linux">Homebrew on Linux — Homebrew Documentation — Linux 上的 Homebrew — Homebrew 文档</a></li></ul><h2 id="UNIX-工具链"><a href="#UNIX-工具链" class="headerlink" title="UNIX 工具链"></a>UNIX 工具链</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scoop install busybox</span><br></pre></td></tr></table></figure><p>安装完成之后，来试用一下：</p><p><img src="/../../img/blog/1535f6e4f7b9a2d8a37206c1b8d4b382_MD5.jpg"></p><p>输出 ls 命令结果的前几行</p><p>删除 Powershell 中的 ls</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Remove-Alias ls</span><br></pre></td></tr></table></figure><p>这个包还提供了很多常用工具，基本可以满足日常需要，大家可以都试一下。</p><h2 id="Sudo"><a href="#Sudo" class="headerlink" title="Sudo"></a>Sudo</h2><p>Linux 最好用的命令是什么？sudo！一键切换管理员权限，Powershell 每次发现忘了开管理员，就得重开一个，很麻烦的有没有！</p><p>所以我们来给 Windows 装一个 sudo：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scoop search sudo</span><br></pre></td></tr></table></figure><p>然后就可以爽到飞起了。以后不管什么命令失败，都可以 sudo 试一试。</p><h2 id="Zoxide-快速跳转"><a href="#Zoxide-快速跳转" class="headerlink" title="Zoxide 快速跳转"></a>Zoxide 快速跳转</h2><p><a href="https://github.com/ajeetdsouza/zoxide">ajeetdsouza&#x2F;zoxide: A smarter cd command. Supports all major shells. (github.com)</a></p><h1 id="MobaXterm"><a href="#MobaXterm" class="headerlink" title="MobaXterm"></a>MobaXterm</h1><ul><li><a href="https://blog.csdn.net/mobaxterm445/article/details/127831465">mobaxterm设置中文_mobaxterm中文-CSDN博客</a></li><li><a href="https://blog.csdn.net/xuanying_china/article/details/120080644">MobaXterm详细使用教程_mobaxterm_personal-CSDN博客</a><br><strong>创建 SSH session</strong></li></ul><p>安装完毕之后界面长这个样。</p><p><img src="/../../img/blog/b8b8ab4b5b38f3290ca82b0aa6e7e54d_MD5.webp"></p><p>当然你们刚安装完成是不会有任何 session 的。下面来创建第一个 SSH session。</p><p>点击菜单栏 「sessions」 –&gt; 「new session」，即可弹出 「session setting」 对话框。由上面那一大串的连接方式我们就可以知道 Moba 的强大之处。</p><p><img src="/../../img/blog/b113eb34598cea732b80e55a3b5e8e5e_MD5.webp"></p><p>我们点选第一个 SSH 图标，并填入相关信息，就可以完成 session 创建了。</p><p>点击确定后，输入密码就可以连接上虚拟机了。而且边上虚拟机之后，它会自动通过 FTP 也连接到虚拟机，直接拖拽就可以进行文件复制了。</p><p><strong>快速连接 session</strong></p><p>创建一个 session 之后，就可以在左侧的 session 标签里留下它的信息，下次需要连接的时候直接双击即可。</p><p><img src="/../../img/blog/b8b8ab4b5b38f3290ca82b0aa6e7e54d_MD5.webp"><br><strong>几个有用的设置</strong></p><p><strong>隐藏菜单栏下的那排按钮</strong></p><p>菜单栏下的那排按钮感觉有点鸡肋，全部可以从菜单栏里找到，而且使用频率也不是非常高。况且，大部分屏幕是长方形的，上下空间有限，左右还比较富余一些，因此去掉它可以省下很大空间。</p><p><img src="/../../img/blog/1400e3ad7d9e0b805433c6cb8f7086e0_MD5.webp"></p><p>在菜单栏点击 「view」 –&gt; 「show menu bar」，即可隐藏此排按钮。</p><p><strong>右键粘贴</strong></p><p>在 Moba 及很多终端工具里，都有这样的功能：鼠标左键划选复制文件，右键粘贴文本。但在 Moba 中右键粘贴功能默认不打开，我们可以手动打开。</p><p>在菜单栏点击 「settings」 –&gt; 「Configuration」，在弹出的对话框中选择 「terminal」，再将 「paste using right-click」 打上对勾即可。</p><p><img src="/../../img/blog/c99899059e794daccbb8978e9d44d519_MD5.webp"></p><p><strong>关闭自动弹出 SFTP</strong></p><p>Moba 在连接上远程电脑之后，将自动打开左侧的 SFTP 侧边栏。有时我们并不需要 SFTP，同时主窗口是黑色的，SFTP 又是白色的，显得有点刺眼，因此可以将自动弹出 SFTP 功能关闭掉。</p><p>在菜单栏点击 「settings」 –&gt; 「Configuration」，在弹出的对话框中选择 「SSH」，再将 「automaticall switch to SSH-browser tab after login」 前面的对勾去掉即可。</p><p><img src="/../../img/blog/80a8627d9b6064f33c47ff0641db606e_MD5.webp"></p>]]></content>
      
      
      <categories>
          
          <category> 本地 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机/编程工具/shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo配置</title>
      <link href="/posts/%E7%BD%91%E7%BB%9C/%E5%8D%9A%E5%AE%A2%E9%85%8D%E7%BD%AE/Hexo%E9%85%8D%E7%BD%AE.html"/>
      <url>/posts/%E7%BD%91%E7%BB%9C/%E5%8D%9A%E5%AE%A2%E9%85%8D%E7%BD%AE/Hexo%E9%85%8D%E7%BD%AE.html</url>
      
        <content type="html"><![CDATA[<h1 id="Hexo-安装配置"><a href="#Hexo-安装配置" class="headerlink" title="Hexo 安装配置"></a>Hexo 安装配置</h1><h2 id="Node-Js-安装设置"><a href="#Node-Js-安装设置" class="headerlink" title="Node.Js 安装设置"></a>Node.Js 安装设置</h2><p>安装完成后，要查看我们是否安装成功，可以打开命令提示符（<code>Win + R</code>），输入 <code>cmd</code> 打开控制台，输入如下命令，如果出现对应版本号，说明安装成功了；</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">node -v</span><br><span class="line">npm -v</span><br></pre></td></tr></table></figure><h2 id="Hexo-安装"><a href="#Hexo-安装" class="headerlink" title="Hexo 安装"></a>Hexo 安装</h2><p>在你的硬盘上找个地儿，用来存放你的博客文件，比如我的就在 <code>D:personalFiles/github/blog</code>，这个文件夹你可以根据自己的喜好来设置。然后从命令台进入当前文件夹，接下来就是安装过程了；</p><p>首先安装 Hexo</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i hexo-cli -g</span><br></pre></td></tr></table></figure><p>新建一个文件夹用于存放你的博客，比如我的是 <code>blog</code>，然后进入该文件夹，并用如下命令进行初始化并安装必备组件；</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo init .</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure><p>然后输入如下命令，然后在浏览器中打开 <code>http://localhost:4000</code>；</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">新建博客</span></span><br><span class="line">hexo new &quot;博客名&quot;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">生成静态网页</span></span><br><span class="line">hexo g</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">打开本地服务器</span></span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure><h2 id="创建-Github-Pages-仓库"><a href="#创建-Github-Pages-仓库" class="headerlink" title="创建 Github Pages 仓库"></a>创建 Github Pages 仓库</h2><p>GitHub 主页右上角加号 -&gt; New repository：</p><ul><li>Repository name 中输入 <code>用户名.github.io</code>(<font color="#00b050">最好均为小写字母</font>)</li><li>勾选 “Initialize this repository with a README”</li><li>Description 选填</li></ul><p>填好后点击 Create repository 创建。<br>创建后默认自动启用 HTTPS，博客地址为：<code>https://用户名.github.io</code></p><h2 id="部署-Hexo-到-GitHub-Pages"><a href="#部署-Hexo-到-GitHub-Pages" class="headerlink" title="部署 Hexo 到 GitHub Pages"></a>部署 Hexo 到 GitHub Pages</h2><p>本地博客测试成功后，就是上传到 GitHub 进行部署，使其能够在网络上访问。</p><p>首先<strong>安装 hexo-deployer-git</strong>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p>然后修改 <code>_config.yml</code> 文件末尾的 Deployment 部分，修改成如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repository:</span> <span class="string">git@github.com:用户名/用户名.github.io.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">main</span></span><br></pre></td></tr></table></figure><p>完成后运行 <code>hexo d</code> 将网站上传部署到 GitHub Pages。</p><p>完成！这时访问我们的 GitHub 域名 <code>https://用户名.github.io</code> 就可以看到 Hexo 网站了。</p><h1 id="在-Obsidian-中执行-Shell-命令"><a href="#在-Obsidian-中执行-Shell-命令" class="headerlink" title="在 Obsidian 中执行 Shell 命令"></a>在 Obsidian 中执行 Shell 命令</h1><p>而 Shell commands 可以在 Obsidian 中设置好命令，并通过 Obsidian 的命令面板或快捷键快速运行。</p><p>在插件设置面板中添加命令：</p><p><img src="/../../../img/blog/48f3cbd2ed2ea9918c17f72ba4e3e2f1_MD5.webp"></p><p>运行博客：</p><ul><li>Shell commands 没有显示终端窗口的功能，所以需要我们启动 powershell 再传入命令</li><li>有了终端窗口我们才可以在窗口中按 Ctrl + C 关闭 Hexo 服务，否则它会一直占用端口</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">start powershell <span class="string">&#x27;-NoExit -Command start http://localhost:4000 ; cd Blog ; hexo s&#x27;</span></span><br></pre></td></tr></table></figure><p>打开站点和主题配置文件：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">start Blog/_config.yml</span><br><span class="line">start Blog/themes/butterfly4.3.1/_config.yml</span><br></pre></td></tr></table></figure><p>然后修改默认执行环境为 PowerShell 5：</p><p><img src="/../../../img/blog/a71dfad1e73f7d9f594fcc596e01b933_MD5.webp"></p><p>点这个按钮可以执行测试我们的命令：</p><p><img src="/../../../img/blog/a5f82f052ff8f87198c08d18cc7af9b9_MD5.webp"></p><p>如果你遇到了这个错误：<code>hexo:无法加载文件C:\Users\xxx\AppData\Roaming\npm\hexo.ps1，因为在此系统上禁止运行脚本。</code> 只需在 Windows 设置&gt;更新和安全&gt;开发者选项，找到 PowerShell，点下应用即可：</p><p><img src="/../../../img/blog/d23fe3ad93154ab94982bbe124d0e4c8_MD5.webp"></p><p>Ctrl+P 打开命令面板，输入 Shell commands 即可找到我们定义好的命令：</p><p><img src="/../../../img/blog/3462bd22140ba71844ee901f66488eae_MD5.webp"></p><p>可以为每个命令设置下别名，就是在命令面板显示的名字：</p><p><img src="/../../../img/blog/73564a2b5df297eafa35b27106300f77_MD5.png"></p><p><img src="/../../../img/blog/f44caffc478975f0b99d1d7569206153_MD5.webp"></p><p>在 Hotkeys 面板中为我们的命令设置好快捷键，就可以通过快捷键快速执行命令了：</p><p><img src="/../../../img/blog/43cdf9a774dbfec85ff37576057b5034_MD5.webp"></p><h1 id="Hexo-Obsidian-内部链接跳转"><a href="#Hexo-Obsidian-内部链接跳转" class="headerlink" title="Hexo+Obsidian 内部链接跳转"></a>Hexo+Obsidian 内部链接跳转</h1><ul><li>Obsidian 选择基于当前笔记的相对路径，关闭 WIKi 链接</li><li>Hexo 需要修改永久链接模式 <a href="https://hexo.io/zh-cn/docs/permalinks.html">永久链接（Permalinks）| Hexo</a>，修改 <code>_config.yml</code> 中的</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">permalink:</span> <span class="string">posts/:category/:post_title.html</span></span><br></pre></td></tr></table></figure><ul><li>不同级目录下的跳转</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[深度学习-图像视频文本标注工具](../../工具使用/深度学习-图像视频文本标注工具)</span><br></pre></td></tr></table></figure><p>需要去掉. md 后缀，采用以下 python 脚本自动全部去除, 脚本放在根目录</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义要查找的文件夹路径和要替换的链接格式</span></span><br><span class="line">folder_path = <span class="string">r&quot;.\source\_posts/&quot;</span></span><br><span class="line">link_pattern = <span class="string">r&quot;\[(.*?)\]\((.*?).md\)&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 遍历文件夹中的所有Markdown文件</span></span><br><span class="line"><span class="keyword">for</span> root, dirs, files <span class="keyword">in</span> os.walk(folder_path):</span><br><span class="line">    <span class="keyword">for</span> file <span class="keyword">in</span> files:</span><br><span class="line">        <span class="keyword">if</span> file.endswith(<span class="string">&quot;.md&quot;</span>):</span><br><span class="line">            file_path = os.path.join(root, file)</span><br><span class="line">            <span class="keyword">with</span> <span class="built_in">open</span>(file_path, <span class="string">&quot;r&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">                content = f.read()</span><br><span class="line">            <span class="comment"># 使用正则表达式查找并替换链接</span></span><br><span class="line">            new_content = re.sub(link_pattern, <span class="string">r&quot;[\1](\2)&quot;</span>, content)</span><br><span class="line">            <span class="keyword">with</span> <span class="built_in">open</span>(file_path, <span class="string">&quot;w&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">                f.write(new_content)</span><br></pre></td></tr></table></figure><p>借鉴 <a href="./Hexo%E6%8F%92%E4%BB%B6">Hexo插件</a> 中的钩子函数实现提交时自动更新</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">hexo generate &amp;&amp; python changemd.py &amp;&amp; git add .</span><br></pre></td></tr></table></figure><h1 id="hexo-插件"><a href="#hexo-插件" class="headerlink" title="hexo 插件"></a>hexo 插件</h1><h2 id="Hexo-auto-category-自动生成-Categories"><a href="#Hexo-auto-category-自动生成-Categories" class="headerlink" title="Hexo -auto-category 自动生成 Categories"></a>Hexo -auto-category 自动生成 Categories</h2><p>最常用的文件管理策略，就是利用文件系统目录结构 (树形结构 directory-tree)。<br>同样，为了便于管理大量的日志文件，采用目录结构是一种简便可行的方案。<code>hexo-auto-category</code> 根据日志文件 (Markdown) 所在文件目录自动分类，即自动生成 <code>markdown</code> 的 front-matter 中的 <code>categories</code> 变量。</p><p><strong>示例</strong></p><p>对于博客 <code>source/_post/web/framework/hexo.md</code>，该插件会自动生成以下 <code>categories</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">categories:  </span><br><span class="line">  - web  </span><br><span class="line">  - framework  </span><br></pre></td></tr></table></figure><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-auto-category --save</span><br></pre></td></tr></table></figure><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>在站点根目录下的 <code>_config.yml</code> 添加：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">auto_category:  </span><br><span class="line"> enable: true  </span><br><span class="line"> depth:  </span><br></pre></td></tr></table></figure><h3 id="编译-amp-部署"><a href="#编译-amp-部署" class="headerlink" title="编译 &amp; 部署"></a>编译 &amp; 部署</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo d  </span><br></pre></td></tr></table></figure><h3 id="高级配置"><a href="#高级配置" class="headerlink" title="高级配置"></a>高级配置</h3><p>如果只想生成第一级目录分类，可以设置 <code>depth</code> 属性，比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">auto_category:  </span><br><span class="line"> enable: true  </span><br><span class="line"> depth: 1</span><br></pre></td></tr></table></figure><h3 id="利用-Git-钩子函数触发更新"><a href="#利用-Git-钩子函数触发更新" class="headerlink" title="利用 Git 钩子函数触发更新"></a>利用 Git 钩子函数触发更新</h3><p>这个插件只有执行 <code>hexo generate</code> 时才会去读取文件夹并更新所有文章的 Front-matter 分类信息，所以我们可以利用 <a href="https://link.zhihu.com/?target=https://git-scm.com/book/zh/v2/%25E8%2587%25AA%25E5%25AE%259A%25E4%25B9%2589-Git-Git-%25E9%2592%25A9%25E5%25AD%2590%23_git_hooks">Git的钩子函数</a>，在 commit (提交) 的时候先执行下 <code>hexo generate</code>，这样就能实现自动更新了。</p><p>在 <code>.git/hooks</code> 目录下新建一个 <code>pre-commit</code> 文件</p><p><img src="/../../../img/blog/556caf664a0dcbfcadc114240db84416_MD5.webp"></p><p>可以先在该文件中写入 <code>echo hello world!</code>，然后在 git 终端下执行 <code>sh pre-commit</code> 或者 <code>./pre-commit</code> 测试钩子能不能正常执行，没问题后，将如下命令写到文件里：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">hexo generate &amp;&amp; git add .</span><br></pre></td></tr></table></figure><p> 之所以后面追加 <code>git add .</code>，是因为 generate (生成) 后，所有文章的 Front-matter 信息会更新，所以要将所有修改重新添加进来</p><h2 id="Hexo-neat-插件优化提升访问效率"><a href="#Hexo-neat-插件优化提升访问效率" class="headerlink" title="Hexo-neat 插件优化提升访问效率"></a>Hexo-neat 插件优化提升访问效率</h2><p><a href="https://cloud.tencent.com/developer/article/1946999">Hexo-neat插件优化提升访问效率-腾讯云开发者社区-腾讯云 (tencent.com)</a></p><h3 id="1、安装-Hexo-neat"><a href="#1、安装-Hexo-neat" class="headerlink" title="1、安装 Hexo-neat"></a>1、安装 Hexo-neat</h3><p>在站点根目录下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-neat --save</span><br></pre></td></tr></table></figure><h3 id="2、添加相关配置"><a href="#2、添加相关配置" class="headerlink" title="2、添加相关配置"></a>2、添加相关配置</h3><p>在站点配置文件 <code>_config.yml</code> 添加相关配置，直接添加到站点配置文件 <code>_config.yml</code> 的末尾就可以。可以安装自己的需求去自定义配置，不过有些注意事项</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># hexo-neat</span></span><br><span class="line"><span class="comment"># 博文压缩</span></span><br><span class="line"><span class="attr">neat_enable:</span> <span class="literal">true</span></span><br><span class="line"><span class="comment"># 压缩html（ejs，swig等也属于html格式片段）</span></span><br><span class="line"><span class="attr">neat_html:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">exclude:</span></span><br><span class="line"><span class="comment"># 压缩css  </span></span><br><span class="line"><span class="attr">neat_css:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">exclude:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;**/*.min.css&#x27;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;**/live2d-widget/waifu.css&#x27;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;jquery.fancybox.min.css&#x27;</span></span><br><span class="line"><span class="comment"># 压缩js</span></span><br><span class="line"><span class="attr">neat_js:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">mangle:</span> <span class="literal">true</span> <span class="comment">#打印日志</span></span><br><span class="line">  <span class="attr">output:</span></span><br><span class="line">  <span class="attr">compress:</span></span><br><span class="line">  <span class="attr">exclude:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;**/*.min.js&#x27;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;jquery.fancybox.min.js&#x27;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;**/index.js&#x27;</span>  </span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;**/live2d-widget/*.js&#x27;</span> </span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;**/live2d-widget/*.min.js&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="3、hexo-neat-插件注意事项"><a href="#3、hexo-neat-插件注意事项" class="headerlink" title="3、hexo-neat 插件注意事项"></a>3、hexo-neat 插件注意事项</h3><p>在使用 hexo-neat 插件时，可以在命令窗口中看到各个文件的压缩率，于是可以通过跳过一些文件让效率更高。<br><strong>1. 跳过压缩文件的正确配置方式</strong><br>如果按照官方插件的文档说明来配置 exclude，会发现完全不起作用。这是因为配置的文件路径不对，压缩时找不到你配置的文件，自然也就无法跳过了。于是需要给这些文件指定正确的路径，万能的配置方式如下：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">neat_css:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">exclude:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;**/*.min.css&#x27;</span></span><br></pre></td></tr></table></figure><ul><li>已经压缩过的 css 和 js 不用压缩：剔除 exclude（<code>*.min.css</code> 和 <code>* .min.js</code>）</li><li>特殊名字 xx. xx. min. js 的需要单独列出来（这里引用了 fancybox 图片弹窗效果，从压缩名单里单独剔除）</li><li>深目录的，需要单独列出来：（这里我引用了 live 2 d 看板娘的动画） 单用 <code>_*/_.min.js</code> 深目录跳过已压缩文件不行，这部分只好全部跳过压缩了</li></ul><p><strong>2. 压缩 html 时不要跳过 <code>.md</code> 文件和 <code>.swig</code> 文件</strong><br><code>.md</code> 文件就是 markdown 文件，如果跳过压缩 <code>.md</code> 文件，而又刚好在文章中使用到了 tab 标签，那么当 hexo 在生成静态页面时就会发生解析错误。这会导致使用到了 tab 标签的页面生成失败而无法访问。</p><p><code>.swig</code> 文件是模板引擎文件，也就是 hexo 可以通过这些文件来生成对应的页面。如果跳过这些文件，所有页面完全没有起到压缩的效果，页面源代码里依然存在着一大堆空白。<br><strong>3. 注意 md 中不要带特殊标签&lt;&gt;的颜表情&lt;(￣ˇ￣)&#x2F;、&lt;(ˉ^ˉ)&gt;等，因为压缩转换为 html 后会变成<br>&lt; (￣ˇ￣)&#x2F;，转义失败！！！</strong></p>]]></content>
      
      
      <categories>
          
          <category> 网络 </category>
          
          <category> 博客配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
